<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="WAL 在 DB::Open 时就会创建，用于持久化 MemTable 中尚未 Flush 的数据。具体写入 WAL 的格式可以参考 Write-Ahead-Log-File-Format 及其对应实现 DBImpl::WriteToWAL 函数，本文及后续几期主要关注 WAL&#x2F;MemTable 的生命周期管理。 r## PreprocessWrite在写 WAL&#x2F;MemTab">
<meta property="og:type" content="article">
<meta property="og:title" content="WAL、MemTable 的生命周期管理(1)">
<meta property="og:url" content="https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="WAL 在 DB::Open 时就会创建，用于持久化 MemTable 中尚未 Flush 的数据。具体写入 WAL 的格式可以参考 Write-Ahead-Log-File-Format 及其对应实现 DBImpl::WriteToWAL 函数，本文及后续几期主要关注 WAL&#x2F;MemTable 的生命周期管理。 r## PreprocessWrite在写 WAL&#x2F;MemTab">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-03-01T06:15:35.000Z">
<meta property="article:modified_time" content="2023-12-10T10:16:12.162Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="RocksDb">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>WAL、MemTable 的生命周期管理(1)</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2022/04/05/rocksdb/WritePath/WAL_2/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022/02/13/rocksdb/WritePath/write_thread_4/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&text=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&title=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&is_video=false&description=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=WAL、MemTable 的生命周期管理(1)&body=Check out this article: https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&title=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&title=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&title=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&title=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&name=WAL、MemTable 的生命周期管理(1)&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&t=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#SwitchMemTable"><span class="toc-number">1.</span> <span class="toc-text">SwitchMemTable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateWAL"><span class="toc-number">1.1.</span> <span class="toc-text">CreateWAL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConstructNewMemtable"><span class="toc-number">1.2.</span> <span class="toc-text">ConstructNewMemtable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ColumnFamily"><span class="toc-number">2.</span> <span class="toc-text">ColumnFamily</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GenerateFlushRequest"><span class="toc-number">2.1.</span> <span class="toc-text">GenerateFlushRequest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SchedulePendingFlush"><span class="toc-number">2.2.</span> <span class="toc-text">SchedulePendingFlush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MaybeScheduleFlushOrCompaction"><span class="toc-number">2.3.</span> <span class="toc-text">MaybeScheduleFlushOrCompaction</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BackgroundCallFlush"><span class="toc-number">3.</span> <span class="toc-text">BackgroundCallFlush</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BackgroundFlush"><span class="toc-number">3.1.</span> <span class="toc-text">BackgroundFlush</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        WAL、MemTable 的生命周期管理(1)
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-03-01T06:15:35.000Z" itemprop="datePublished">2022-03-01</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/RocksDb/" rel="tag">RocksDb</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>WAL 在 DB::Open 时就会创建，用于持久化 MemTable 中尚未 Flush 的数据。具体写入 WAL 的格式可以参考 <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Write-Ahead-Log-File-Format">Write-Ahead-Log-File-Format</a> 及其对应实现 DBImpl::WriteToWAL 函数，本文及后续几期主要关注 WAL&#x2F;MemTable 的生命周期管理。</p>
<p>r## PreprocessWrite<br>在写 WAL&#x2F;MemTable 之前，会先在 <code>DBImpl::PreprocessWrite</code> 函数中基于当前 RocksDB 的一些指标判断是否需要 Flush MemTable，创建新的 WAL&#x2F;MemTable 再接受本次写入：</p>
<ol>
<li>当前 WAL 的大小 <code>total_log_size_</code> 是否超过阈值 <code>DBOptions::max_total_wal_size</code></li>
<li>根据 write_buffer_manager_ 判断当前 MemTable 是否需要 Flush</li>
<li>flush_scheduler_.empty() 为 false，则说明上次某个 CF MemTable 写满了</li>
</ol>
<p>上述三种触发条件的处理方式，都需要先创建新的 WAL&#x2F;MemTable，然后生成 Flush 请求 flush_request，并且触发后台线程去消费该 flush_request。</p>
<ul>
<li>正常情况下，发起 Flush 请求后，不用等待后台 Flush 完成，新的 WAL&#x2F;MemTable 就可以继续接受后续读写请求，</li>
<li>但是如果写的压力过大，则会进一步限制，比如 DelayWrite，WriteStall，恢复正常后才会继续接受新的写入。</li>
</ul>
<p>上述三种的不同触发条件，不同在于如何选择 ColumnFamily。比如 条件（1）WAL 的大小超过阈值，则所有 ColumnFamilys 都需要进行更换 WAL&#x2F;MemTable；而条件（3）则只是需要某个具体的 CF MemTable 满了。因此只是 FlushReason 不同，处理过程都类似。</p>
<p>下面针对核心处理流程开始讲解。</p>
<h3 id="SwitchMemTable"><a href="#SwitchMemTable" class="headerlink" title="SwitchMemTable"></a>SwitchMemTable</h3><p>SwitchMemtable 函数是针对具体的 ColumnFamily 创建 WAL&#x2F;MemTable ，因此需要上层先筛选出需要切换 MemTable 的 CF，再传递给此函数。</p>
<p>由前文可知，进入 PreprocessWrite 函数时已经是单线程操作，而 SwitchMemtable 函数仍需要在 <code>DBImpl::_mutex</code> 的保护下才能调用，这是为了与后台 Flush 线程互斥。</p>
<p>根据 <code>log_empty_</code> 字段来判断是否需要创建新的 WAL，即当前 WAL 是否有数据写入，如果没有则不创建新的 WAL。主要是可能要为多个 CFs 创建新的 WAL&#x2F;MemTable，但是 WAL 是共享的，只需要第一次创建 WAL 即可，后续的 ColumnFamily 检测到 <code>log_empty_</code> 为空，则不再重复创建。</p>
<p>每个 WAL 都有一个对应的编号 <code>logfile_num</code>，由 <code>VersionSet::NewFileNumber</code> 函数来生成。</p>
<p><em>DBOptions::recycle_log_file_num</em> 决定是否复用生命周期已结束的 WALs，<code>log_recycle_files_</code> 字段用于保存生命周期已结束待删除的 WALs。此如果 <code>recycle_log_file_num &gt; 0</code> 则按照 FIFO 规则从 <code>log_recycle_files_</code> 取出生命周期最早结束的 WAL 的 logfile_number，因此可以 truncate 旧 WAL 文件再接受新数据。</p>
<p>在 RocksDB 中，数据存储目录在 <em>DBOptions::wal_dir</em>，其值就是 db_name，每个 WAL 文件名就是<code>wal_dir</code>+<code>logfile_number</code>+<code>.log</code>。因此，后文一般提及 log 都是指 WAL 文件。</p>
<p>比如：编译完 RocksDB，并执行 <em>build&#x2F;examples&#x2F;simple_example</em>，在 <em>&#x2F;tmp&#x2F;rocksdb_simple_example</em> 目录下会有如下以 log 为后缀的文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ll /tmp/rocksdb_simple_example</span><br><span class="line">total 1832</span><br><span class="line">-rw-r--r-- 1 root root  1045 Jul 10 08:27 000326.sst</span><br><span class="line">-rw-r--r-- 1 root root   999 Jul 24 14:17 000331.sst</span><br><span class="line">-rw-r--r-- 1 root root    68 Jul 24 14:18 000332.<span class="built_in">log</span></span><br><span class="line">-rw-r--r-- 1 root root   999 Jul 24 14:18 000336.sst</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p><code>log_recycle_files_</code> 等字段会收到 FlushJob 的影响，因此需要在 <code>DBImpl::mutex_</code> 的保护下调用。而 CreateWAL 只是影响局部变量 new_log，不需要 mutex_ 保护，同理构建新的 MemTable 对象 new_mem 也不需要 mutex_。</p>
<p>下面是创建 new_log 和 new_mem 的核心代码及其注释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::SwitchMemtable</span><span class="params">(ColumnFamilyData* cfd, WriteContext* context)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  log::Writer* new_log = <span class="literal">nullptr</span>;</span><br><span class="line">  MemTable* new_mem = <span class="literal">nullptr</span>;</span><br><span class="line">  IOStatus io_s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免多个 CFs 创建不同的 WAL</span></span><br><span class="line">  <span class="type">bool</span> creating_new_log = !log_empty_;</span><br><span class="line">  <span class="type">uint64_t</span> recycle_log_number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (creating_new_log &amp;&amp; immutable_db_options_.recycle_log_file_num &amp;&amp;</span><br><span class="line">      !log_recycle_files_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    recycle_log_number = log_recycle_files_.<span class="built_in">front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint64_t</span> new_log_number =</span><br><span class="line">      creating_new_log ? versions_-&gt;<span class="built_in">NewFileNumber</span>() : logfile_number_;</span><br><span class="line">  <span class="type">const</span> MutableCFOptions mutable_cf_options = *cfd-&gt;<span class="built_in">GetLatestMutableCFOptions</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为啥这个函数也需要保护 ???</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> preallocate_block_size =</span><br><span class="line">      <span class="built_in">GetWalPreallocateBlockSize</span>(mutable_cf_options.write_buffer_size);</span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 WAL</span></span><br><span class="line">  <span class="keyword">if</span> (creating_new_log) &#123;</span><br><span class="line">    io_s = <span class="built_in">CreateWAL</span>(new_log_number, recycle_log_number, preallocate_block_size,</span><br><span class="line">                     &amp;new_log);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// WAL 创建成功后，再创建 MemTable</span></span><br><span class="line"> <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    SequenceNumber seq = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">    new_mem = cfd-&gt;<span class="built_in">ConstructNewMemtable</span>(mutable_cf_options, seq);</span><br><span class="line">    context-&gt;superversion_context.<span class="built_in">NewSuperVersion</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用于 delete_range</span></span><br><span class="line">  cfd-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">ConstructFragmentedRangeTombstones</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// mutex_.Lock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="CreateWAL"><a href="#CreateWAL" class="headerlink" title="CreateWAL"></a>CreateWAL</h4><p>WAL 的创建也比较简单，如代码注释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOStatus <span class="title">DBImpl::CreateWAL</span><span class="params">(<span class="type">uint64_t</span> log_file_num, <span class="type">uint64_t</span> recycle_log_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">size_t</span> preallocate_block_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                           log::Writer** new_log)</span> </span>&#123;</span><br><span class="line">  IOStatus io_s;</span><br><span class="line">  std::unique_ptr&lt;FSWritableFile&gt; lfile;</span><br><span class="line"></span><br><span class="line">  DBOptions db_options =</span><br><span class="line">      <span class="built_in">BuildDBOptions</span>(immutable_db_options_, mutable_db_options_);</span><br><span class="line">  FileOptions opt_file_options =</span><br><span class="line">      fs_-&gt;<span class="built_in">OptimizeForLogWrite</span>(file_options_, db_options);</span><br><span class="line">  std::string wal_dir = immutable_db_options_.<span class="built_in">GetWalDir</span>();</span><br><span class="line">  std::string log_fname = <span class="built_in">LogFileName</span>(wal_dir, log_file_num);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 生成底层 wal 文件</span></span><br><span class="line">  <span class="keyword">if</span> (recycle_log_number) &#123;</span><br><span class="line">    std::string old_log_fname = <span class="built_in">LogFileName</span>(wal_dir, recycle_log_number);</span><br><span class="line">    io_s = fs_-&gt;<span class="built_in">ReuseWritableFile</span>(log_fname, old_log_fname, opt_file_options,</span><br><span class="line">                                  &amp;lfile, <span class="comment">/*dbg=*/</span><span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    io_s = <span class="built_in">NewWritableFile</span>(fs_.<span class="built_in">get</span>(), log_fname, &amp;lfile, opt_file_options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    lfile-&gt;<span class="built_in">SetWriteLifeTimeHint</span>(<span class="built_in">CalculateWALWriteHint</span>());</span><br><span class="line">    lfile-&gt;<span class="built_in">SetPreallocationBlockSize</span>(preallocate_block_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; listeners = immutable_db_options_.listeners;</span><br><span class="line">    FileTypeSet tmp_set = immutable_db_options_.checksum_handoff_file_types;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建写 wal 的 writer</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;WritableFileWriter&gt; <span class="title">file_writer</span><span class="params">(<span class="keyword">new</span> WritableFileWriter(</span></span></span><br><span class="line"><span class="params"><span class="function">        std::move(lfile), log_fname, opt_file_options,</span></span></span><br><span class="line"><span class="params"><span class="function">        immutable_db_options_.clock, io_tracer_, <span class="literal">nullptr</span> <span class="comment">/* stats */</span>, listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="literal">nullptr</span>, tmp_set.Contains(FileType::kWalFile),</span></span></span><br><span class="line"><span class="params"><span class="function">        tmp_set.Contains(FileType::kWalFile)))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 封装 log_writer</span></span><br><span class="line">    *new_log = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(std::<span class="built_in">move</span>(file_writer), log_file_num,</span><br><span class="line">                               immutable_db_options_.recycle_log_file_num &gt; <span class="number">0</span>,</span><br><span class="line">                               immutable_db_options_.manual_wal_flush,</span><br><span class="line">                               immutable_db_options_.wal_compression);</span><br><span class="line">    io_s = (*new_log)-&gt;<span class="built_in">AddCompressionTypeRecord</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> io_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ConstructNewMemtable"><a href="#ConstructNewMemtable" class="headerlink" title="ConstructNewMemtable"></a>ConstructNewMemtable</h4><p>WAL 创建成功后，由 MemTable 所属的 ColumnFamily 构建 MemTable。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MemTable* <span class="title">ColumnFamilyData::ConstructNewMemtable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options, SequenceNumber earliest_seq)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_, ioptions_, mutable_cf_options,</span><br><span class="line">                      write_buffer_manager_, earliest_seq, id_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ColumnFamily"><a href="#ColumnFamily" class="headerlink" title="ColumnFamily"></a>ColumnFamily</h3><p>上面 new_log, new_mem 成功创建完后，下面对 ColumnFamily 的 WAL&#x2F;MemTable 相关的元信息进行更新。</p>
<p>首先需要将当前 cur_log_writer 中已有的数据 flush 到操作系统中。实际上在 LogWriter::AddRecord 内部，每次写完都会进行一次 flush，将数据刷操作系统page cache 中，由操作系统决定何时将数据写入文件。flush 只能保证 RocksDB 进程中途挂了再重启数据不会丢，但是如果机器挂了数据还是有丢的可能，如果想要进一步保证安全就需要 sync 操作，将操作系统缓存层的数据同步到磁盘，很显然这个操作会拖慢写入速度。RocksDB 也配置了开启选项 <em>WriteOptions::sync: bool</em>，默认 false。</p>
<p><code>logs_</code>字段是个map，映射关系是{logfile_number_, log_writer}，记录了每一个log_writer及其对应的logfile_number，<code>alive_log_files_</code>记录是 logfile_number及其log_writer写入的数据量大小。由于 WAL 的生命周期和 ColumnFamily 有关，因此需要 <code>logs_</code> 和 <code>alive_log_files_</code> 来记录一个 RocksDB 实例中所有生命周期尚未结束的 WALs。</p>
<p>因此，当创建了新的 WAL ，需要在 log_write_mutex_ 的保护下添加新的记录。后续 FLushJob 完成了，也会相应删除生命周期结束的 WAL 记录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//... above code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面 Unlock, 现在恢复 Lock</span></span><br><span class="line">mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"><span class="keyword">if</span> (recycle_log_number != <span class="number">0</span>) &#123;</span><br><span class="line">  log_recycle_files_.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; creating_new_log) &#123;</span><br><span class="line">  <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;log_write_mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 1. Flush</span></span><br><span class="line">  <span class="keyword">if</span> (!logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    log::Writer* cur_log_writer = logs_.<span class="built_in">back</span>().writer;</span><br><span class="line">    io_s = cur_log_writer-&gt;<span class="built_in">WriteBuffer</span>();</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. Flush 成功后，更新 log 相关元信息</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    logfile_number_ = new_log_number;</span><br><span class="line">    log_empty_ = <span class="literal">true</span>;</span><br><span class="line">    log_dir_synced_ = <span class="literal">false</span>;</span><br><span class="line">    logs_.<span class="built_in">emplace_back</span>(logfile_number_, new_log);</span><br><span class="line">    alive_log_files_.<span class="built_in">push_back</span>(<span class="built_in">LogFileNumberSize</span>(logfile_number_));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前置工作已经完成，下面要开始更新 ColumnFaimly了。</p>
<p>由于传递给 SwitchMemTable 的 CF 并非都是因为自己的 MemTable 满了，可能是因为某个 CF0 把 WAL 写满了，导致所有的 MmeTable 都要切换，比如上述条件（1）。有些 CF1 可能仍然是空的，此时就需要更新 CF1 当前的 LogNumber。 这样就可以删除 CF1 之前指向的 WAL。</p>
<p>比如：CF0，CF1 当前都指向 log1，由于 CF0 一直写入数据，导致 log1 满了。此时需要创建新的 WAL 文件 log2。但是 CF1 一直没有写入数据，此时同步将 CF1 当前 log 指针 <code>log_number_</code> 指向 log2，使得指向 log1 的引用就是0，因此就可以在 MemTable 完成 Flush 完成后，将 log1 删除。</p>
<p>其余解释见代码，这部分代码简化如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...above code</span></span><br><span class="line"><span class="type">bool</span> empty_cf_updated = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!empty_cf_updated) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> cf : *versions_-&gt;<span class="built_in">GetColumnFamilySet</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cf-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (creating_new_log) &#123;</span><br><span class="line">        cf-&gt;<span class="built_in">SetLogNumber</span>(logfile_number_);</span><br><span class="line">      &#125;</span><br><span class="line">      cf-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">SetCreationSeq</span>(versions_-&gt;<span class="built_in">LastSequence</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CF 当前 Memtable 下一个活跃的 logfile_numer_，</span></span><br><span class="line"><span class="comment">// 选择需要 Flush 的 ImmutableMemTables 使用</span></span><br><span class="line">cfd-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">SetNextLogNumber</span>(logfile_number_);</span><br><span class="line"><span class="comment">// 将当前 Memtable 添加到 ImmutableMemTable 链表中，等待 Flush 删除。</span></span><br><span class="line">cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">Add</span>(cfd-&gt;<span class="built_in">mem</span>(), &amp;context-&gt;memtables_to_free_);</span><br><span class="line"><span class="comment">// 设置新的 MemTable</span></span><br><span class="line">new_mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">cfd-&gt;<span class="built_in">SetMemtable</span>(new_mem);</span><br><span class="line"><span class="comment">// 更新 superversion</span></span><br><span class="line"><span class="built_in">InstallSuperVersionAndScheduleWork</span>(cfd, &amp;context-&gt;superversion_context,</span><br><span class="line">                                   mutable_cf_options);</span><br></pre></td></tr></table></figure>

<h4 id="GenerateFlushRequest"><a href="#GenerateFlushRequest" class="headerlink" title="GenerateFlushRequest"></a>GenerateFlushRequest</h4><p>SwitchMemTable，完成了 WAL&#x2F;MemTable 的切换。紧接着就会尝试发起一次 flush 请求。Flush 的对象是从每个 CF 的 ImmutableMemtables 中提取的，因此 FlushRequest 需要保存每个 CF 的 max_memtable_id。</p>
<p>CF 中的每个 MemTable 都有一个单增的 <code>id_</code>，用于追踪 Flush。在使用 <code>ColumnFamilyData::SetMemtable</code> 函数添加到 CF 中时更新 <code>MemTable::id_</code> 字段。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::GenerateFlushRequest</span><span class="params">(<span class="type">const</span> autovector&lt;ColumnFamilyData*&gt;&amp; cfds,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  FlushReason flush_reason, FlushRequest* req)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(req != <span class="literal">nullptr</span>);</span><br><span class="line">  req-&gt;flush_reason = flush_reason;</span><br><span class="line">  req-&gt;cfd_to_max_mem_id_to_persist.<span class="built_in">reserve</span>(cfds.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> cfd : cfds) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == cfd) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// max_memtable_id 即最新加入 ImmutableMemtables 的 memtable 的 Id</span></span><br><span class="line">    <span class="type">uint64_t</span> max_memtable_id = cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">GetLatestMemTableID</span>();</span><br><span class="line">    req-&gt;cfd_to_max_mem_id_to_persist.<span class="built_in">emplace</span>(cfd, max_memtable_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="SchedulePendingFlush"><a href="#SchedulePendingFlush" class="headerlink" title="SchedulePendingFlush"></a>SchedulePendingFlush</h4><p> <code>flush_queue_</code> 用于保存MemTables的Flush请求，<code>SchedulePendingFlush</code> 将上述生成的flush请求压入flush_queue_，再调度后台任务线程从 flush_queue_中取出FlushRequest执行。</p>
<p>这里也有个设计，如果开启了 <em>DBOptions::atomic_flush</em> 则会让多个 CFs 的 Flush 请求放到一个线程去执行，这样就可以保证 Flush 的原子性。否则，每次只 flush。但是其默认值为 false，因为只要开启了 WAL，就能保证跨多个 CFs 的写操作是原子性的，即便 flush 操作挂了也还有 WAL 可以恢复。</p>
<p>部分代码如下。 </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::SchedulePendingFlush</span><span class="params">(<span class="type">const</span> FlushRequest&amp; flush_req)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">if</span> (flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!immutable_db_options_.atomic_flush) &#123;</span><br><span class="line">    <span class="comment">// only one</span></span><br><span class="line">    <span class="built_in">assert</span>(flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">size</span>() == <span class="number">1</span>);</span><br><span class="line">    ColumnFamilyData* cfd =</span><br><span class="line">        flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">begin</span>()-&gt;first;</span><br><span class="line">    <span class="keyword">if</span> (!cfd-&gt;<span class="built_in">queued_for_flush</span>() &amp;&amp; cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">IsFlushPending</span>()) &#123;</span><br><span class="line">      cfd-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">      cfd-&gt;<span class="built_in">set_queued_for_flush</span>(<span class="literal">true</span>);</span><br><span class="line">      ++unscheduled_flushes_;</span><br><span class="line">      flush_queue_.<span class="built_in">push_back</span>(flush_req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [cfd, _] : flush_req.cfd_to_max_mem_id_to_persist) &#123;</span><br><span class="line">      cfd-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ++unscheduled_flushes_;</span><br><span class="line">    flush_queue_.<span class="built_in">push_back</span>(flush_req);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MaybeScheduleFlushOrCompaction"><a href="#MaybeScheduleFlushOrCompaction" class="headerlink" title="MaybeScheduleFlushOrCompaction"></a>MaybeScheduleFlushOrCompaction</h4><p>RocksDB 的后台任务线程调度是主动触发的，并没有 loop 线程在阻塞等待 <code>flush_queue_</code> 加入新元素后就从 <code>flush_queue_</code> 提取请求去执行。</p>
<p>因此，在向 <code>flush_req</code> 加入有新请求后，需要主动通过 <code>MaybeScheduleFlushOrCompaction</code> 函数调度后台线程执行 <code>DBImpl::BackgroundCallFlush</code> 函数执行 FlushRequest 请求。</p>
<p>最大后台任务有 <code>bg_job_limits</code> 限制，<code>unscheduled_flushes_</code> 表征当前有多少待 flush 的请求，<code>bg_flush_scheduled_</code> 表征当前已经调度了多少 flush 请求，配合 <code>bg_job_limits</code> 参数限制后台 flush 任务。</p>
<p><code>DBImpl::BGWorkFlush</code> 函数用于执行 FlushRequest，<code>DBImpl::UnscheduleFlushCallback</code> 函数则是执行 FlushRequest 完的回调函数，用于释放 <code>FlushThreadArg</code> 对象。</p>
<p><code>MaybeScheduleFlushOrCompaction</code> 函数执行，是个分界点：</p>
<ul>
<li>提交完 Flush 请求后，如果没有触发 DelayWrite，WriteStall，就会接受新的读写请求了；</li>
<li>后台线程池接受到 <code>BGWorkFlush</code> 请求后，就开始执行 FlushReqeust</li>
</ul>
<p>这部分相关代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MaybeScheduleFlushOrCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="comment">//... precondition check</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bg_job_limits = <span class="built_in">GetBGJobLimits</span>();</span><br><span class="line">  <span class="type">bool</span> is_flush_pool_empty =</span><br><span class="line">      env_-&gt;<span class="built_in">GetBackgroundThreads</span>(Env::Priority::HIGH) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!is_flush_pool_empty &amp;&amp; unscheduled_flushes_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         bg_flush_scheduled_ &lt; bg_job_limits.max_flushes) &#123;</span><br><span class="line">    bg_flush_scheduled_++;</span><br><span class="line">    FlushThreadArg* fta = <span class="keyword">new</span> FlushThreadArg;</span><br><span class="line">    fta-&gt;db_ = <span class="keyword">this</span>;</span><br><span class="line">    fta-&gt;thread_pri_ = Env::Priority::HIGH;</span><br><span class="line">    env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWorkFlush, fta, Env::Priority::HIGH, <span class="keyword">this</span>,</span><br><span class="line">                   &amp;DBImpl::UnscheduleFlushCallback);</span><br><span class="line">    --unscheduled_flushes_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_flush_pool_empty) &#123;</span><br><span class="line">    <span class="keyword">while</span> (unscheduled_flushes_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           bg_flush_scheduled_ + bg_compaction_scheduled_ &lt;</span><br><span class="line">               bg_job_limits.max_flushes) &#123;</span><br><span class="line">      bg_flush_scheduled_++;</span><br><span class="line">      FlushThreadArg* fta = <span class="keyword">new</span> FlushThreadArg;</span><br><span class="line">      fta-&gt;db_ = <span class="keyword">this</span>;</span><br><span class="line">      fta-&gt;thread_pri_ = Env::Priority::LOW;</span><br><span class="line">      env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWorkFlush, fta, Env::Priority::LOW, <span class="keyword">this</span>,</span><br><span class="line">                     &amp;DBImpl::UnscheduleFlushCallback);</span><br><span class="line">      --unscheduled_flushes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//.. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BackgroundCallFlush"><a href="#BackgroundCallFlush" class="headerlink" title="BackgroundCallFlush"></a>BackgroundCallFlush</h3><p>DBImpl::BGWorkFlush 只是个 <code>BackgroundCallFlush</code> 的 wrapper。 进入 <code>BackgroundCallFlush</code> 函数后，需要获取 <code>DBImpl::mutex_</code> 来执行 <code>BackgroundFlush</code>，执行成功后。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::BackgroundCallFlush</span><span class="params">(Env::Priority thread_pri)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> made_progress = <span class="literal">false</span>;</span><br><span class="line">  <span class="function">JobContext <span class="title">job_context</span><span class="params">(next_job_id_.fetch_add(<span class="number">1</span>), <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 需要 DBImpl::mutex_</span></span><br><span class="line">    <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>; </span><br><span class="line">    num_running_flushes_++;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;std::list&lt;<span class="type">uint64_t</span>&gt;::iterator&gt;</span><br><span class="line">        <span class="built_in">pending_outputs_inserted_elem</span>(<span class="keyword">new</span> std::list&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">iterator</span>(</span><br><span class="line">            <span class="built_in">CaptureCurrentFileNumberInPendingOutputs</span>()));</span><br><span class="line">    FlushReason reason;</span><br><span class="line"></span><br><span class="line">    Status s = <span class="built_in">BackgroundFlush</span>(&amp;made_progress, &amp;job_context, &amp;log_buffer,</span><br><span class="line">                               &amp;reason, thread_pri);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(num_running_flushes_ &gt; <span class="number">0</span>);</span><br><span class="line">    num_running_flushes_--;</span><br><span class="line">    bg_flush_scheduled_--;</span><br><span class="line">    <span class="comment">// See if there&#x27;s more work to be done</span></span><br><span class="line">    <span class="built_in">MaybeScheduleFlushOrCompaction</span>();</span><br><span class="line">    atomic_flush_install_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">    bg_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BackgroundFlush"><a href="#BackgroundFlush" class="headerlink" title="BackgroundFlush"></a>BackgroundFlush</h4><p><code>PopFirstFromFlushQueue</code> 函数从 <code>flush_request_</code> 中取出待 Flush 的请求，过滤掉不符合条件的的CF，符合结果的存在 <code>bg_flush_args</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::BackgroundFlush</span><span class="params">(<span class="type">bool</span>* made_progress, JobContext* job_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                               LogBuffer* log_buffer, FlushReason* reason,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Env::Priority thread_pri)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  autovector&lt;BGFlushArg&gt; bg_flush_args;</span><br><span class="line">  std::vector&lt;SuperVersionContext&gt;&amp; superversion_contexts =</span><br><span class="line">      job_context-&gt;superversion_contexts;</span><br><span class="line">  autovector&lt;ColumnFamilyData*&gt; column_families_not_to_flush;</span><br><span class="line">  <span class="keyword">while</span> (!flush_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// This cfd is already referenced</span></span><br><span class="line">    <span class="keyword">auto</span> [flush_reason, cfd_to_max_mem_id_to_persist] =</span><br><span class="line">        <span class="built_in">PopFirstFromFlushQueue</span>();</span><br><span class="line">    superversion_contexts.<span class="built_in">clear</span>();</span><br><span class="line">    superversion_contexts.<span class="built_in">reserve</span>(cfd_to_max_mem_id_to_persist.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [cfd, max_mem_id] : cfd_to_max_mem_id_to_persist) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cfd-&gt;<span class="built_in">GetMempurgeUsed</span>()) &#123;</span><br><span class="line">        cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">FlushRequested</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cfd-&gt;<span class="built_in">IsDropped</span>() || !cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">IsFlushPending</span>()) &#123;</span><br><span class="line">        <span class="comment">// can&#x27;t flush this CF, try next one</span></span><br><span class="line">        column_families_not_to_flush.<span class="built_in">push_back</span>(cfd);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      superversion_contexts.<span class="built_in">emplace_back</span>(<span class="built_in">SuperVersionContext</span>(<span class="literal">true</span>));</span><br><span class="line">      bg_flush_args.<span class="built_in">emplace_back</span>(cfd, max_mem_id,</span><br><span class="line">                                 &amp;(superversion_contexts.<span class="built_in">back</span>()), flush_reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有待 Flush 的 CF</span></span><br><span class="line">    <span class="keyword">if</span> (!bg_flush_args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获得具有 Flush 条件的 <code>bg_flush_args</code>，下面就是真正的准备执行 FlushJob。<code>FlushJob</code> 由 <code>FlushMemTablesToOutputFiles</code> 函数执行，这个后续再讲。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (!bg_flush_args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span> bg_job_limits = <span class="built_in">GetBGJobLimits</span>();</span><br><span class="line">  status = <span class="built_in">FlushMemTablesToOutputFiles</span>(bg_flush_args, made_progress,</span><br><span class="line">                                       job_context, log_buffer, thread_pri);</span><br><span class="line">  *reason = bg_flush_args[<span class="number">0</span>].flush_reason_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; arg : bg_flush_args) &#123;</span><br><span class="line">    ColumnFamilyData* cfd = arg.cfd_;</span><br><span class="line">    <span class="keyword">if</span> (cfd-&gt;<span class="built_in">UnrefAndTryDelete</span>()) &#123;</span><br><span class="line">      arg.cfd_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> cfd : column_families_not_to_flush) &#123;</span><br><span class="line">  cfd-&gt;<span class="built_in">UnrefAndTryDelete</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#SwitchMemTable"><span class="toc-number">1.</span> <span class="toc-text">SwitchMemTable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CreateWAL"><span class="toc-number">1.1.</span> <span class="toc-text">CreateWAL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ConstructNewMemtable"><span class="toc-number">1.2.</span> <span class="toc-text">ConstructNewMemtable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ColumnFamily"><span class="toc-number">2.</span> <span class="toc-text">ColumnFamily</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#GenerateFlushRequest"><span class="toc-number">2.1.</span> <span class="toc-text">GenerateFlushRequest</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SchedulePendingFlush"><span class="toc-number">2.2.</span> <span class="toc-text">SchedulePendingFlush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MaybeScheduleFlushOrCompaction"><span class="toc-number">2.3.</span> <span class="toc-text">MaybeScheduleFlushOrCompaction</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BackgroundCallFlush"><span class="toc-number">3.</span> <span class="toc-text">BackgroundCallFlush</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BackgroundFlush"><span class="toc-number">3.1.</span> <span class="toc-text">BackgroundFlush</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&text=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&title=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&is_video=false&description=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=WAL、MemTable 的生命周期管理(1)&body=Check out this article: https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&title=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&title=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&title=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&title=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&name=WAL、MemTable 的生命周期管理(1)&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/&t=WAL、MemTable 的生命周期管理(1)"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2026
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
