<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="主要是描述下 Segment 的多线程读流程是如何实现的。 就是为了实现读取同一个segemnt SegmentReadTaskSegmentReadTask 表征的是读取一个 segment 不同 ranges 的任务。 1234567891011121314151617181920212223struct SegmentReadTask&amp;#123;    SegmentPtr segment;">
<meta property="og:type" content="article">
<meta property="og:title" content="tiflash: 多线程读取流程">
<meta property="og:url" content="https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="主要是描述下 Segment 的多线程读流程是如何实现的。 就是为了实现读取同一个segemnt SegmentReadTaskSegmentReadTask 表征的是读取一个 segment 不同 ranges 的任务。 1234567891011121314151617181920212223struct SegmentReadTask&amp;#123;    SegmentPtr segment;">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-11-05T02:00:01.000Z">
<meta property="article:modified_time" content="2023-09-02T04:48:14.000Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="tidb-v6.1">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>tiflash: 多线程读取流程</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2022/11/11/TiFlash/aggregate-1/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022/11/04/TiFlash/DelteMerge/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&text=tiflash: 多线程读取流程"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&title=tiflash: 多线程读取流程"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&is_video=false&description=tiflash: 多线程读取流程"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=tiflash: 多线程读取流程&body=Check out this article: https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&title=tiflash: 多线程读取流程"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&title=tiflash: 多线程读取流程"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&title=tiflash: 多线程读取流程"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&title=tiflash: 多线程读取流程"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&name=tiflash: 多线程读取流程&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&t=tiflash: 多线程读取流程"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SegmentReadTask"><span class="toc-number">1.</span> <span class="toc-text">SegmentReadTask</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SegmentReadTaskPool"><span class="toc-number">2.</span> <span class="toc-text">SegmentReadTaskPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SegmentReadTaskScheduler"><span class="toc-number">3.</span> <span class="toc-text">SegmentReadTaskScheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#add"><span class="toc-number">3.0.1.</span> <span class="toc-text">add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SegmentReadTaskPool-valid"><span class="toc-number">3.0.2.</span> <span class="toc-text">SegmentReadTaskPool::valid</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SegmentReadTaskScheduler-1"><span class="toc-number">3.1.</span> <span class="toc-text">SegmentReadTaskScheduler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#schedule"><span class="toc-number">3.2.</span> <span class="toc-text">schedule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleMergedTask"><span class="toc-number">3.3.</span> <span class="toc-text">scheduleMergedTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleSegmentUnlock"><span class="toc-number">3.4.</span> <span class="toc-text">scheduleSegmentUnlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleSegment"><span class="toc-number">3.5.</span> <span class="toc-text">scheduleSegment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SegmentReaderPoolManager"><span class="toc-number">4.</span> <span class="toc-text">SegmentReaderPoolManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SegmentReaderPool-addTask"><span class="toc-number">4.1.</span> <span class="toc-text">SegmentReaderPool::addTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SegmentReader-readSegments"><span class="toc-number">4.2.</span> <span class="toc-text">SegmentReader::readSegments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MergedTask-readOneBlock"><span class="toc-number">4.3.</span> <span class="toc-text">MergedTask::readOneBlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SegmentReadTaskPool-readOneBlock"><span class="toc-number">4.4.</span> <span class="toc-text">SegmentReadTaskPool::readOneBlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnorderedInputStream-readImpl"><span class="toc-number">4.5.</span> <span class="toc-text">UnorderedInputStream::readImpl</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        tiflash: 多线程读取流程
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-11-05T02:00:01.000Z" itemprop="datePublished">2022-11-05</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/tidb-v6-1/" rel="tag">tidb-v6.1</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>主要是描述下 Segment 的多线程读流程是如何实现的。</p>
<p>就是为了实现读取同一个segemnt</p>
<h2 id="SegmentReadTask"><a href="#SegmentReadTask" class="headerlink" title="SegmentReadTask"></a>SegmentReadTask</h2><p>SegmentReadTask 表征的是读取一个 segment 不同 ranges 的任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SegmentReadTask</span></span><br><span class="line">&#123;</span><br><span class="line">    SegmentPtr segment;</span><br><span class="line">    SegmentSnapshotPtr read_snapshot;</span><br><span class="line">    RowKeyRanges ranges;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegmentReadTask</span>(<span class="type">const</span> SegmentPtr &amp; segment_, <span class="comment">//</span></span><br><span class="line">                    <span class="type">const</span> SegmentSnapshotPtr &amp; read_snapshot_,</span><br><span class="line">                    <span class="type">const</span> RowKeyRanges &amp; ranges_);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SegmentReadTask</span><span class="params">(<span class="type">const</span> SegmentPtr &amp; segment_, <span class="type">const</span> SegmentSnapshotPtr &amp; read_snapshot_)</span></span>;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">SegmentReadTask</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">size_t</span>, <span class="type">size_t</span>&gt; <span class="title">getRowsAndBytes</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addRange</span><span class="params">(<span class="type">const</span> RowKeyRange &amp; range)</span> </span>&#123; ranges.<span class="built_in">push_back</span>(range); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeRanges</span><span class="params">()</span> </span>&#123; ranges = DM::<span class="built_in">tryMergeRanges</span>(std::<span class="built_in">move</span>(ranges), <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 tasks 划分为 &gt;= expected_size 个任务</span></span><br><span class="line">    <span class="function"><span class="type">static</span> SegmentReadTasks <span class="title">trySplitReadTasks</span><span class="params">(<span class="type">const</span> SegmentReadTasks &amp; tasks, <span class="type">size_t</span> expected_size)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="SegmentReadTaskPool"><a href="#SegmentReadTaskPool" class="headerlink" title="SegmentReadTaskPool"></a>SegmentReadTaskPool</h2><p>表征的是读取某个 <code>table_id</code> 的中的 segment，记录在 <code>tasks</code>.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentReadTaskPool</span> : <span class="keyword">private</span> boost::noncopyable</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> pool_id;</span><br><span class="line">    <span class="type">const</span> <span class="type">int64_t</span> table_id;</span><br><span class="line">    DMContextPtr dm_context;</span><br><span class="line">    ColumnDefines columns_to_read;</span><br><span class="line">    RSOperatorPtr filter;</span><br><span class="line">    <span class="type">const</span> <span class="type">uint64_t</span> max_version;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> expected_block_size;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> is_raw;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> do_range_filter_for_raw;</span><br><span class="line">    SegmentReadTasks tasks;</span><br><span class="line">    AfterSegmentRead after_segment_read;</span><br><span class="line">    <span class="comment">///...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>比如，在<code>DeltaMergeStore::read</code> 函数中相关代码片段:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 获得要读取的segment及其ranges</span></span><br><span class="line">SegmentReadTasks tasks = <span class="built_in">getReadTasksByRanges</span>(*dm_context,</span><br><span class="line">                                              sorted_ranges,</span><br><span class="line">                                              num_streams,</span><br><span class="line">                                              read_segments,</span><br><span class="line">                                              !enable_read_thread);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. read_task_pool 则表征此 table 所有要读的任务的信息</span></span><br><span class="line"><span class="keyword">auto</span> read_task_pool = std::<span class="built_in">make_shared</span>&lt;SegmentReadTaskPool&gt;(</span><br><span class="line">    physical_table_id,</span><br><span class="line">    dm_context,</span><br><span class="line">    columns_to_read,</span><br><span class="line">    filter,</span><br><span class="line">    max_version,</span><br><span class="line">    expected_block_size,</span><br><span class="line">    <span class="comment">/* is_raw = */</span> is_fast_mode,</span><br><span class="line">    <span class="comment">/* do_delete_mark_filter_for_raw = */</span> is_fast_mode,</span><br><span class="line">    std::<span class="built_in">move</span>(tasks),</span><br><span class="line">    after_segment_read);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将新的读取任务添加到调度器中</span></span><br><span class="line">SegmentReadTaskScheduler::<span class="built_in">instance</span>().<span class="built_in">add</span>(read_task_pool);</span><br></pre></td></tr></table></figure>

<h2 id="SegmentReadTaskScheduler"><a href="#SegmentReadTaskScheduler" class="headerlink" title="SegmentReadTaskScheduler"></a>SegmentReadTaskScheduler</h2><p>SegmentReadTaskPool 表征的一个 table 级别要读取的任务信息，下面就是如何调度这些读取任务。</p>
<p>下面来介绍调度器 <code>SegmentReadTaskScheduler</code>。 其中，</p>
<ul>
<li><code>read_pools</code>: 记录的所有的 SegmentReadTaskPool 数据</li>
<li><code>merging_segments</code>: 记录的是 DeltaMergeStore 中某个 Segment 出现在了哪些 SegmentReadTaskPool 中，方便后续收集不同 SegmentReadTaskPool 中出现的相同 Segment。</li>
<li><code>merged_task_pool</code>: 是个cache，用于存放上次读取但是尚未完成的读取任务</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentReadTaskScheduler</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::mutex mtx;</span><br><span class="line">    CircularScanList&lt;SegmentReadTaskPool&gt; read_pools;</span><br><span class="line">    <span class="comment">// table_id -&gt; &#123;seg_id -&gt; pool_ids, seg_id -&gt; pool_ids, ...&#125;</span></span><br><span class="line">    std::unordered_map&lt;<span class="type">int64_t</span>, std::unordered_map&lt;<span class="type">uint64_t</span>, std::vector&lt;<span class="type">uint64_t</span>&gt;&gt;&gt; merging_segments;</span><br><span class="line"></span><br><span class="line">    MergedTaskPool merged_task_pool;</span><br><span class="line"></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; stop;</span><br><span class="line">    std::thread sched_thread;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="add"><a href="#add" class="headerlink" title="add"></a>add</h4><p>该函数是用于添加新的读取任务</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SegmentReadTaskScheduler::add</span><span class="params">(<span class="type">const</span> SegmentReadTaskPoolPtr &amp; pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 添加读取任务本身</span></span><br><span class="line">    read_pools.<span class="built_in">add</span>(pool);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 记录读取任务的一些元数据信息</span></span><br><span class="line">    std::unordered_set&lt;<span class="type">uint64_t</span>&gt; seg_ids;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; task : pool-&gt;<span class="built_in">getTasks</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> seg_id = task-&gt;segment-&gt;<span class="built_in">segmentId</span>();</span><br><span class="line">        merging_segments[pool-&gt;<span class="built_in">tableId</span>()][seg_id].<span class="built_in">push_back</span>(pool-&gt;<span class="built_in">poolId</span>());</span><br><span class="line">        <span class="comment">// 读取同一个 segment 的不同 range, 要表征为一个 SegmentReadTask</span></span><br><span class="line">        <span class="keyword">if</span> (!seg_ids.<span class="built_in">insert</span>(seg_id).second)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> DB::<span class="built_in">Exception</span>(fmt::format(<span class="string">&quot;Not support split segment task. seg_ids &#123;&#125; =&gt; seg_id &#123;&#125; already exist.&quot;</span>, seg_ids, seg_id));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> [unexpired, expired] = read_pools.<span class="built_in">count</span>(pool-&gt;<span class="built_in">tableId</span>());</span><br><span class="line">    <span class="built_in">LOG_FMT_DEBUG</span>(log, <span class="string">&quot;add pool &#123;&#125; table &#123;&#125; block_slots &#123;&#125; segment count &#123;&#125; segments &#123;&#125; unexpired pool &#123;&#125; expired pool &#123;&#125;&quot;</span>, <span class="comment">//</span></span><br><span class="line">                  pool-&gt;<span class="built_in">poolId</span>(),</span><br><span class="line">                  pool-&gt;<span class="built_in">tableId</span>(),</span><br><span class="line">                  pool-&gt;<span class="built_in">getFreeBlockSlots</span>(),</span><br><span class="line">                  seg_ids.<span class="built_in">size</span>(),</span><br><span class="line">                  seg_ids,</span><br><span class="line">                  unexpired,</span><br><span class="line">                  expired);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释下  <code>read_pools.count(pool-&gt;tableId());</code> 的返回值</p>
<p>由于可能多处在读取同一个 table，即多处引用同一个 SegmentReadTaskPoolPtr 对象来读取同一个 DeltaMergeStore，当所有引用 SegmentReadTaskPoolPtr 来读取 DeltaMergeStore 的地方都完成了，则 SegmentReadTaskPoolPtr 则处于 invalid 状态，否则即处于 valid 状态。</p>
<p>返回值 [unexpired, expired] 分别表示 [valid, invalid] 两种状态的个数。</p>
<ul>
<li><code>unexpired</code>: 有几个 UnorderedInputStream 对象正在读取同一个 table</li>
</ul>
<h4 id="SegmentReadTaskPool-valid"><a href="#SegmentReadTaskPool-valid" class="headerlink" title="SegmentReadTaskPool::valid"></a>SegmentReadTaskPool::valid</h4><p><code>UnorderedInputStream</code> 放在最后来讲，可以先看看。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SegmentReadTaskPool::valid</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">exceptionHappened</span>() &amp;&amp; unordered_input_stream_ref_count.<span class="built_in">load</span>(std::memory_order_relaxed) &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">UnorderedInputStream</span> : <span class="keyword">public</span> IProfilingBlockInputStream</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> NAME = <span class="string">&quot;UnorderedInputStream&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">UnorderedInputStream</span>(</span><br><span class="line">        <span class="type">const</span> SegmentReadTaskPoolPtr &amp; task_pool_,</span><br><span class="line">        <span class="type">const</span> ColumnDefines &amp; columns_to_read_,</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> extra_table_id_index,</span><br><span class="line">        <span class="type">const</span> TableID physical_table_id,</span><br><span class="line">        <span class="type">const</span> String &amp; req_id)</span><br><span class="line">        : <span class="built_in">task_pool</span>(task_pool_)</span><br><span class="line">        , <span class="built_in">header</span>(<span class="built_in">toEmptyBlock</span>(columns_to_read_))</span><br><span class="line">        , <span class="built_in">extra_table_id_index</span>(extra_table_id_index)</span><br><span class="line">        , <span class="built_in">physical_table_id</span>(physical_table_id)</span><br><span class="line">        , <span class="built_in">log</span>(Logger::<span class="built_in">get</span>(NAME, req_id))</span><br><span class="line">        , <span class="built_in">ref_no</span>(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (extra_table_id_index != InvalidColumnID)</span><br><span class="line">        &#123;</span><br><span class="line">            ColumnDefine extra_table_id_col_define = <span class="built_in">getExtraTableIDColumnDefine</span>();</span><br><span class="line">            ColumnWithTypeAndName col&#123;extra_table_id_col_define.type-&gt;<span class="built_in">createColumn</span>(),</span><br><span class="line">                                      extra_table_id_col_define.type,</span><br><span class="line">                                      extra_table_id_col_define.name,</span><br><span class="line">                                      extra_table_id_col_define.id,</span><br><span class="line">                                      extra_table_id_col_define.default_value&#125;;</span><br><span class="line">            header.<span class="built_in">insert</span>(extra_table_id_index, col);</span><br><span class="line">        &#125;</span><br><span class="line">        ref_no = task_pool-&gt;<span class="built_in">increaseUnorderedInputStreamRefCount</span>();</span><br><span class="line">        <span class="built_in">LOG_FMT_DEBUG</span>(log, <span class="string">&quot;pool &#123;&#125; ref &#123;&#125; created&quot;</span>, task_pool-&gt;<span class="built_in">poolId</span>(), ref_no);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">UnorderedInputStream</span>() <span class="keyword">override</span></span><br><span class="line">    &#123;</span><br><span class="line">        task_pool-&gt;<span class="built_in">decreaseUnorderedInputStreamRefCount</span>();</span><br><span class="line">        <span class="built_in">LOG_FMT_DEBUG</span>(log, <span class="string">&quot;pool &#123;&#125; ref &#123;&#125; destroy&quot;</span>, task_pool-&gt;<span class="built_in">poolId</span>(), ref_no);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="SegmentReadTaskScheduler-1"><a href="#SegmentReadTaskScheduler-1" class="headerlink" title="SegmentReadTaskScheduler"></a>SegmentReadTaskScheduler</h3><p>SegmentReadTaskScheduler 在构造函数中启动读取任务的调度功能。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SegmentReadTaskScheduler::<span class="built_in">SegmentReadTaskScheduler</span>()</span><br><span class="line">: <span class="built_in">stop</span>(<span class="literal">false</span>) , <span class="built_in">log</span>(&amp;Poco::Logger::<span class="built_in">get</span>(<span class="string">&quot;SegmentReadTaskScheduler&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line">    sched_thread = std::<span class="built_in">thread</span>(&amp;SegmentReadTaskScheduler::schedThread, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SegmentReadTaskScheduler::schedThread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isStop</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有任务可执行，则 sleep</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">schedule</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">using</span> <span class="keyword">namespace</span> std::chrono_literals;</span><br><span class="line">            std::this_thread::<span class="built_in">sleep_for</span>(<span class="number">2</span>ms);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><p><code>schedule</code> 函数:</p>
<ul>
<li>将 read_pools 中读取相同 segment 的任务聚在一起</li>
<li>将 merged_task 算一个批次进行读取<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SegmentReadTaskScheduler::schedule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stopwatch sw;</span><br><span class="line">    <span class="keyword">auto</span> [merged_task, run_sche] = <span class="built_in">scheduleMergedTask</span>();</span><br><span class="line">    <span class="keyword">if</span> (merged_task != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FMT_DEBUG</span>(log, <span class="string">&quot;scheduleMergedTask seg_id &#123;&#125; pools &#123;&#125; =&gt; &#123;&#125; ms&quot;</span>,</span><br><span class="line">                      merged_task-&gt;<span class="built_in">getSegmentId</span>(),</span><br><span class="line">                      merged_task-&gt;<span class="built_in">getPoolIds</span>(),</span><br><span class="line">                      sw.<span class="built_in">elapsedMilliseconds</span>());</span><br><span class="line">        SegmentReaderPoolManager::<span class="built_in">instance</span>().<span class="built_in">addTask</span>(std::<span class="built_in">move</span>(merged_task));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> run_sche;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="scheduleMergedTask"><a href="#scheduleMergedTask" class="headerlink" title="scheduleMergedTask"></a>scheduleMergedTask</h3><p>执行流程如下:</p>
<ul>
<li><code>scheduleSegmentReadTaskPoolUnlock</code> 函数先选出一个处于 <code>valid</code> 状态的 SegmentReadTaskPool</li>
<li>从 <code>merged_task_pool</code> 查看是否之前已经读取过，但是上次读取没有完成, merged_task_pool 在此处是个 <code>cache</code></li>
<li>如果仍然没有，则调用 <code>scheduleSegmentUnlock</code> 函数选择一个 segment 来读取，</li>
<li>如果存在待读取的 segment, 则调用 <code>getPoolsUnlock</code> 函数，获取 <code>segment</code> 所存在的 SegmentReadTaskPool 对象 <code>pools</code></li>
<li>取出 <code>pools</code> 中的同一个<code>segement</code> 读取任务</li>
</ul>
<p>详细见代码注释。</p>
<p>顺带解释下，只有在第一个分支才会返回 <code>&#123;nullptr, false&#125;</code>，重点是 false,因为只有这个时候才能说明整个队列中没有可执行的读请求。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::pair&lt;MergedTaskPtr, <span class="type">bool</span>&gt; <span class="title">SegmentReadTaskScheduler::scheduleMergedTask</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mtx)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 是否存在 valid 状态 SegmentReadTaskPool 对象, 没有则说明读请求执行完毕</span></span><br><span class="line">    <span class="keyword">auto</span> pool = <span class="built_in">scheduleSegmentReadTaskPoolUnlock</span>();</span><br><span class="line">    <span class="keyword">if</span> (pool == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No SegmentReadTaskPool to schedule. Maybe no read request or</span></span><br><span class="line">        <span class="comment">// block queue of each SegmentReadTaskPool reaching the limit.</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. cache: 上次读取过此 pool 中的任务, 但是没有读取完</span></span><br><span class="line">    <span class="keyword">auto</span> merged_task = merged_task_pool.<span class="built_in">pop</span>(pool-&gt;<span class="built_in">poolId</span>());</span><br><span class="line">    <span class="keyword">if</span> (merged_task != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">GET_METRIC</span>(tiflash_storage_read_thread_counter, type_sche_from_cache).<span class="built_in">Increment</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;merged_task, <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 选择一个 segment 来读取</span></span><br><span class="line">    <span class="keyword">auto</span> segment = <span class="built_in">scheduleSegmentUnlock</span>(pool);</span><br><span class="line">    <span class="keyword">if</span> (!segment)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// The number of active segments reaches the limit.</span></span><br><span class="line">        <span class="built_in">GET_METRIC</span>(tiflash_storage_read_thread_counter, type_sche_no_segment).<span class="built_in">Increment</span>();</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 包含此 segemnt 的 pools</span></span><br><span class="line">    SegmentReadTaskPools pools = <span class="built_in">getPoolsUnlock</span>(segment-&gt;second);</span><br><span class="line">    <span class="keyword">if</span> (pools.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Maybe SegmentReadTaskPools are expired because of upper threads finish the request.</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="literal">nullptr</span>, <span class="literal">true</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 获取 pools 中包含同一个 segment_id(segment-&gt;first)的 SegmentReadTaskPool</span></span><br><span class="line">    std::vector&lt;MergedUnit&gt; units;</span><br><span class="line">    units.<span class="built_in">reserve</span>(pools.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; pool : pools)</span><br><span class="line">    &#123;</span><br><span class="line">        units.<span class="built_in">emplace_back</span>(pool, pool-&gt;<span class="built_in">getTask</span>(segment-&gt;first));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">GET_METRIC</span>(tiflash_storage_read_thread_counter, type_sche_new_task).<span class="built_in">Increment</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;std::<span class="built_in">make_shared</span>&lt;MergedTask&gt;(segment-&gt;first, std::<span class="built_in">move</span>(units)), <span class="literal">true</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scheduleSegmentUnlock"><a href="#scheduleSegmentUnlock" class="headerlink" title="scheduleSegmentUnlock"></a>scheduleSegmentUnlock</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">std::optional&lt;std::pair&lt;<span class="type">uint64_t</span>, std::vector&lt;<span class="type">uint64_t</span>&gt;&gt;&gt; </span><br><span class="line">SegmentReadTaskScheduler::<span class="built_in">scheduleSegmentUnlock</span>(<span class="type">const</span> SegmentReadTaskPoolPtr &amp; pool)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> [unexpired, expired] = read_pools.<span class="built_in">count</span>(pool-&gt;<span class="built_in">tableId</span>());</span><br><span class="line">    <span class="keyword">auto</span> expected_merge_seg_count = std::<span class="built_in">min</span>(unexpired, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">auto</span> itr = merging_segments.<span class="built_in">find</span>(pool-&gt;<span class="built_in">tableId</span>());</span><br><span class="line">    <span class="keyword">if</span> (itr == merging_segments.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// No segment of tableId left.</span></span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::optional&lt;std::pair&lt;<span class="type">uint64_t</span>, std::vector&lt;<span class="type">uint64_t</span>&gt;&gt;&gt; result;</span><br><span class="line">    <span class="keyword">auto</span> &amp; segments = itr-&gt;second; <span class="comment">// segment_id --&gt; pool_ids</span></span><br><span class="line">    <span class="keyword">auto</span> target = pool-&gt;<span class="built_in">scheduleSegment</span>(segments, expected_merge_seg_count);</span><br><span class="line">    <span class="keyword">if</span> (target != segments.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// &lt; 100 : 简单判断当前正在读取的压力不大</span></span><br><span class="line">        <span class="keyword">if</span> (MergedTask::<span class="built_in">getPassiveMergedSegments</span>() &lt; <span class="number">100</span> || target-&gt;second.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result = *target;</span><br><span class="line">            segments.<span class="built_in">erase</span>(target);</span><br><span class="line">            <span class="keyword">if</span> (segments.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                merging_segments.<span class="built_in">erase</span>(itr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前读取的任务较多，则只读取一个</span></span><br><span class="line">            result = std::pair&#123;target-&gt;first, std::<span class="built_in">vector</span>&lt;<span class="type">uint64_t</span>&gt;(<span class="number">1</span>, pool-&gt;<span class="built_in">poolId</span>())&#125;;</span><br><span class="line">            <span class="comment">// 下面从 segments[target-&gt;first] 中删除 pool-&gt;poolId()</span></span><br><span class="line">            <span class="keyword">auto</span> mutable_target = segments.<span class="built_in">find</span>(target-&gt;first);</span><br><span class="line">            <span class="keyword">auto</span> itr = std::<span class="built_in">find</span>(mutable_target-&gt;second.<span class="built_in">begin</span>(), mutable_target-&gt;second.<span class="built_in">end</span>(), pool-&gt;<span class="built_in">poolId</span>());</span><br><span class="line">            *itr = mutable_target-&gt;second.<span class="built_in">back</span>(); </span><br><span class="line">            mutable_target-&gt;second.<span class="built_in">resize</span>(mutable_target-&gt;second.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="scheduleSegment"><a href="#scheduleSegment" class="headerlink" title="scheduleSegment"></a>scheduleSegment</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Choose a segment to read.</span></span><br><span class="line"><span class="comment">// Returns &lt;segment_id, pool_ids&gt;.</span></span><br><span class="line">std::unordered_map&lt;<span class="type">uint64_t</span>, std::vector&lt;<span class="type">uint64_t</span>&gt;&gt;::<span class="function">const_iterator </span></span><br><span class="line"><span class="function"><span class="title">SegmentReadTaskPool::scheduleSegment</span><span class="params">(<span class="type">const</span> std::unordered_map&lt;<span class="type">uint64_t</span>, std::vector&lt;<span class="type">uint64_t</span>&gt;&gt; &amp; segments, <span class="type">uint64_t</span> expected_merge_count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> target = segments.<span class="built_in">end</span>();</span><br><span class="line">    <span class="function">std::lock_guard <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">getFreeActiveSegmentCountUnlock</span>() &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp; task : tasks)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> itr = segments.<span class="built_in">find</span>(task-&gt;segment-&gt;<span class="built_in">segmentId</span>());</span><br><span class="line">        <span class="keyword">if</span> (itr == segments.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> DB::<span class="built_in">Exception</span>(fmt::format(<span class="string">&quot;seg_id &#123;&#125; not found from merging segments&quot;</span>, task-&gt;segment-&gt;<span class="built_in">segmentId</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (std::<span class="built_in">find</span>(itr-&gt;second.<span class="built_in">begin</span>(), itr-&gt;second.<span class="built_in">end</span>(), <span class="built_in">poolId</span>()) == itr-&gt;second.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> DB::<span class="built_in">Exception</span>(fmt::format(<span class="string">&quot;pool &#123;&#125; not found from merging segment &#123;&#125;=&gt;&#123;&#125;&quot;</span>, <span class="built_in">poolId</span>(), itr-&gt;first, itr-&gt;second));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == segments.<span class="built_in">end</span>() || itr-&gt;second.<span class="built_in">size</span>() &gt; target-&gt;second.<span class="built_in">size</span>()) <span class="comment">// 优先选择的 segment:  被更多 pool 读取</span></span><br><span class="line">        &#123;</span><br><span class="line">            target = itr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个满足条件的</span></span><br><span class="line">        <span class="comment">// 读取此 task-&gt;segment 的 pool 个数 &gt;= expected_merge_count</span></span><br><span class="line">        <span class="keyword">if</span> (target-&gt;second.<span class="built_in">size</span>() &gt;= expected_merge_count)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SegmentReaderPoolManager"><a href="#SegmentReaderPoolManager" class="headerlink" title="SegmentReaderPoolManager"></a>SegmentReaderPoolManager</h2><p><code>SegmentReader</code> 用于真正的读取segment。<code>SegmentReaderPool</code> 是一组 <code>SegmentReader</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SegmentReaderPoolManager::addTask</span><span class="params">(MergedTaskPtr &amp;&amp; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> std::hash&lt;<span class="type">uint64_t</span>&gt; hash_func;</span><br><span class="line">    <span class="keyword">auto</span> idx = <span class="built_in">hash_func</span>(task-&gt;<span class="built_in">getSegmentId</span>()) % reader_pools.<span class="built_in">size</span>();</span><br><span class="line">    reader_pools[idx]-&gt;<span class="built_in">addTask</span>(std::<span class="built_in">move</span>(task));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SegmentReaderPool-addTask"><a href="#SegmentReaderPool-addTask" class="headerlink" title="SegmentReaderPool::addTask"></a>SegmentReaderPool::addTask</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SegmentReaderPool::addTask</span><span class="params">(MergedTaskPtr &amp;&amp; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!task_queue.<span class="built_in">push</span>(std::<span class="built_in">move</span>(task), <span class="literal">nullptr</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">Exception</span>(<span class="string">&quot;addTask fail&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="SegmentReader-readSegments"><a href="#SegmentReader-readSegments" class="headerlink" title="SegmentReader::readSegments"></a>SegmentReader::readSegments</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SegmentReader::readSegments</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MergedTaskPtr merged_task;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!task_queue.<span class="built_in">pop</span>(merged_task))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_FMT_INFO</span>(log, <span class="string">&quot;pop fail, stop &#123;&#125;&quot;</span>, <span class="built_in">isStop</span>());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">SCOPE_EXIT</span>(&#123;</span><br><span class="line">            <span class="keyword">if</span> (!merged_task-&gt;<span class="built_in">allStreamsFinished</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                SegmentReadTaskScheduler::<span class="built_in">instance</span>().<span class="built_in">pushMergedTask</span>(merged_task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> read_count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!merged_task-&gt;<span class="built_in">allStreamsFinished</span>() &amp;&amp; !<span class="built_in">isStop</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> c = merged_task-&gt;<span class="built_in">readBlock</span>();</span><br><span class="line">            read_count += c;</span><br><span class="line">            <span class="keyword">if</span> (c &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (read_count &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">LOG_FMT_DEBUG</span>(log, <span class="string">&quot;pool &#123;&#125; seg_id &#123;&#125; read_count &#123;&#125;&quot;</span>, merged_task-&gt;<span class="built_in">getPoolIds</span>(), merged_task-&gt;<span class="built_in">getSegmentId</span>(), read_count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (DB::Exception &amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FMT_ERROR</span>(log, <span class="string">&quot;ErrMsg: &#123;&#125; StackTrace &#123;&#125;&quot;</span>, e.<span class="built_in">message</span>(), e.<span class="built_in">getStackTrace</span>().<span class="built_in">toString</span>());</span><br><span class="line">        <span class="keyword">if</span> (merged_task != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            merged_task-&gt;<span class="built_in">setException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (std::exception &amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">LOG_FMT_ERROR</span>(log, <span class="string">&quot;ErrMsg: &#123;&#125;&quot;</span>, e.<span class="built_in">what</span>());</span><br><span class="line">        <span class="keyword">if</span> (merged_task != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            merged_task-&gt;<span class="built_in">setException</span>(DB::<span class="built_in">Exception</span>(e.<span class="built_in">what</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">tryLogCurrentException</span>(<span class="string">&quot;exception thrown in SegmentReader&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (merged_task != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            merged_task-&gt;<span class="built_in">setException</span>(DB::<span class="built_in">Exception</span>(<span class="string">&quot;unknown exception thrown in SegmentReader&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MergedTask-readOneBlock"><a href="#MergedTask-readOneBlock" class="headerlink" title="MergedTask::readOneBlock"></a>MergedTask::readOneBlock</h3><p>读取相同segment的数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MergedTask::readOneBlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> read_block_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (cur_idx = <span class="number">0</span>; cur_idx &lt; <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(units.<span class="built_in">size</span>()); cur_idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isStreamFinished</span>(cur_idx))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> &amp; [pool, task, stream] = units[cur_idx];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!pool-&gt;<span class="built_in">valid</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">setStreamFinished</span>(cur_idx);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;<span class="built_in">getFreeBlockSlots</span>() &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pool-&gt;<span class="built_in">readOneBlock</span>(stream, task-&gt;segment))</span><br><span class="line">        &#123;</span><br><span class="line">            read_block_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">setStreamFinished</span>(cur_idx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> read_block_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SegmentReadTaskPool-readOneBlock"><a href="#SegmentReadTaskPool-readOneBlock" class="headerlink" title="SegmentReadTaskPool::readOneBlock"></a>SegmentReadTaskPool::readOneBlock</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SegmentReadTaskPool::readOneBlock</span><span class="params">(BlockInputStreamPtr &amp; stream, <span class="type">const</span> SegmentPtr &amp; seg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">MemoryTrackerSetter <span class="title">setter</span><span class="params">(<span class="literal">true</span>, mem_tracker)</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> block = stream-&gt;<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span> (block)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">pushBlock</span>(std::<span class="built_in">move</span>(block));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">finishSegment</span>(seg);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UnorderedInputStream-readImpl"><a href="#UnorderedInputStream-readImpl" class="headerlink" title="UnorderedInputStream::readImpl"></a>UnorderedInputStream::readImpl</h3><p>上面的流程执行后执行了, UnorderedInputStream::read 执行读取的数据</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Block <span class="title">UnorderedInputStream::readImpl</span><span class="params">(FilterPtr &amp; <span class="comment">/*res_filter*/</span>, <span class="type">bool</span> <span class="comment">/*return_filter*/</span>)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (done)</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">FAIL_POINT_PAUSE</span>(FailPoints::pause_when_reading_from_dt_stream);</span><br><span class="line"></span><br><span class="line">        Block res;</span><br><span class="line">        task_pool-&gt;<span class="built_in">popBlock</span>(res);</span><br><span class="line">        <span class="keyword">if</span> (res)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (extra_table_id_index != InvalidColumnID)</span><br><span class="line">            &#123;</span><br><span class="line">                ColumnDefine extra_table_id_col_define = <span class="built_in">getExtraTableIDColumnDefine</span>();</span><br><span class="line">                ColumnWithTypeAndName col&#123;&#123;&#125;,</span><br><span class="line">                                          extra_table_id_col_define.type,</span><br><span class="line">                                          extra_table_id_col_define.name,</span><br><span class="line">                                          extra_table_id_col_define.id&#125;;</span><br><span class="line">                <span class="type">size_t</span> row_number = res.<span class="built_in">rows</span>();</span><br><span class="line">                col.column = col.type-&gt;<span class="built_in">createColumnConst</span>(row_number, <span class="built_in">Field</span>(physical_table_id));</span><br><span class="line">                res.<span class="built_in">insert</span>(extra_table_id_index, std::<span class="built_in">move</span>(col));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!res.<span class="built_in">rows</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                total_rows += res.<span class="built_in">rows</span>();</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            done = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SegmentReadTask"><span class="toc-number">1.</span> <span class="toc-text">SegmentReadTask</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SegmentReadTaskPool"><span class="toc-number">2.</span> <span class="toc-text">SegmentReadTaskPool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SegmentReadTaskScheduler"><span class="toc-number">3.</span> <span class="toc-text">SegmentReadTaskScheduler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#add"><span class="toc-number">3.0.1.</span> <span class="toc-text">add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SegmentReadTaskPool-valid"><span class="toc-number">3.0.2.</span> <span class="toc-text">SegmentReadTaskPool::valid</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SegmentReadTaskScheduler-1"><span class="toc-number">3.1.</span> <span class="toc-text">SegmentReadTaskScheduler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#schedule"><span class="toc-number">3.2.</span> <span class="toc-text">schedule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleMergedTask"><span class="toc-number">3.3.</span> <span class="toc-text">scheduleMergedTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleSegmentUnlock"><span class="toc-number">3.4.</span> <span class="toc-text">scheduleSegmentUnlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduleSegment"><span class="toc-number">3.5.</span> <span class="toc-text">scheduleSegment</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SegmentReaderPoolManager"><span class="toc-number">4.</span> <span class="toc-text">SegmentReaderPoolManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SegmentReaderPool-addTask"><span class="toc-number">4.1.</span> <span class="toc-text">SegmentReaderPool::addTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SegmentReader-readSegments"><span class="toc-number">4.2.</span> <span class="toc-text">SegmentReader::readSegments</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MergedTask-readOneBlock"><span class="toc-number">4.3.</span> <span class="toc-text">MergedTask::readOneBlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SegmentReadTaskPool-readOneBlock"><span class="toc-number">4.4.</span> <span class="toc-text">SegmentReadTaskPool::readOneBlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UnorderedInputStream-readImpl"><span class="toc-number">4.5.</span> <span class="toc-text">UnorderedInputStream::readImpl</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&text=tiflash: 多线程读取流程"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&title=tiflash: 多线程读取流程"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&is_video=false&description=tiflash: 多线程读取流程"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=tiflash: 多线程读取流程&body=Check out this article: https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&title=tiflash: 多线程读取流程"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&title=tiflash: 多线程读取流程"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&title=tiflash: 多线程读取流程"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&title=tiflash: 多线程读取流程"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&name=tiflash: 多线程读取流程&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/11/05/TiFlash/SegmentReadThread/&t=tiflash: 多线程读取流程"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2025
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
