<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="ExecuteStmtExecuteStmt 是执行一条 Stmt 的大致流程。 EnterNewTxn是用来准备事务相关的信息  RunInNewTxn tikvStore::Begin在 tikvStroe 内部结构如下：  KVStroe::Begin每个 client connection 对应着一个 session, 事务相关数据的放在了session中， 它包含了对 kv.Storag">
<meta property="og:type" content="article">
<meta property="og:title" content="tidb: 2PC transaction 写入 tikv 详解">
<meta property="og:url" content="https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="ExecuteStmtExecuteStmt 是执行一条 Stmt 的大致流程。 EnterNewTxn是用来准备事务相关的信息  RunInNewTxn tikvStore::Begin在 tikvStroe 内部结构如下：  KVStroe::Begin每个 client connection 对应着一个 session, 事务相关数据的放在了session中， 它包含了对 kv.Storag">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-1.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-2.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-3.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-4.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-5.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-6.png?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-7.png?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-8.png?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-9.png?raw=true">
<meta property="article:published_time" content="2022-09-01T02:00:01.000Z">
<meta property="article:modified_time" content="2023-09-03T01:46:36.669Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="tidb-v6.1">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-1.svg?raw=true">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>tidb: 2PC transaction 写入 tikv 详解</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2022/09/02/TiDB/tidb_transaction_2/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022/04/16/rocksdb/WritePath/WAL_3/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&text=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&title=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&is_video=false&description=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=tidb: 2PC transaction 写入 tikv 详解&body=Check out this article: https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&title=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&title=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&title=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&title=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&name=tidb: 2PC transaction 写入 tikv 详解&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&t=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ExecuteStmt"><span class="toc-number">1.</span> <span class="toc-text">ExecuteStmt</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EnterNewTxn"><span class="toc-number">1.1.</span> <span class="toc-text">EnterNewTxn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunInNewTxn"><span class="toc-number">1.2.</span> <span class="toc-text">RunInNewTxn</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tikvStore-Begin"><span class="toc-number">1.2.1.</span> <span class="toc-text">tikvStore::Begin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KVStroe-Begin"><span class="toc-number">1.2.2.</span> <span class="toc-text">KVStroe::Begin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DML"><span class="toc-number">2.</span> <span class="toc-text">DML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#COMMIT"><span class="toc-number">3.</span> <span class="toc-text">COMMIT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#twoPhaseCommitter"><span class="toc-number">3.1.</span> <span class="toc-text">twoPhaseCommitter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doActionOnMutations"><span class="toc-number">3.2.</span> <span class="toc-text">doActionOnMutations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#groupSortedMutationsByRegion"><span class="toc-number">3.2.1.</span> <span class="toc-text">groupSortedMutationsByRegion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#preSplitRegion"><span class="toc-number">3.2.2.</span> <span class="toc-text">preSplitRegion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#groupMutations"><span class="toc-number">3.2.3.</span> <span class="toc-text">groupMutations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doActionOnGroupMutations"><span class="toc-number">3.2.4.</span> <span class="toc-text">doActionOnGroupMutations</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#batched-appendBatchMutationsBySize"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">batched::appendBatchMutationsBySize</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#batched-setPrimary"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">batched::setPrimary</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doActionOnBatches"><span class="toc-number">3.3.</span> <span class="toc-text">doActionOnBatches</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">乐观事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#actionPrewrite"><span class="toc-number">4.1.</span> <span class="toc-text">actionPrewrite</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TiKV-Client"><span class="toc-number">4.1.1.</span> <span class="toc-text">TiKV-Client</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">悲观事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MvccTxn"><span class="toc-number">6.</span> <span class="toc-text">MvccTxn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#acquire-pessimistic-lock"><span class="toc-number">7.</span> <span class="toc-text">acquire_pessimistic_lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prewrite"><span class="toc-number">8.</span> <span class="toc-text">prewrite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PrewriteMutation-check-lock"><span class="toc-number">8.1.</span> <span class="toc-text">PrewriteMutation::check_lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrewriteMutation-write-lock"><span class="toc-number">8.2.</span> <span class="toc-text">PrewriteMutation::write_lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commit"><span class="toc-number">9.</span> <span class="toc-text">Commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Others"><span class="toc-number">10.</span> <span class="toc-text">Others</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        tidb: 2PC transaction 写入 tikv 详解
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-09-01T02:00:01.000Z" itemprop="datePublished">2022-09-01</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/tidb-v6-1/" rel="tag">tidb-v6.1</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="ExecuteStmt"><a href="#ExecuteStmt" class="headerlink" title="ExecuteStmt"></a>ExecuteStmt</h2><p>ExecuteStmt 是执行一条 Stmt 的大致流程。</p>
<h3 id="EnterNewTxn"><a href="#EnterNewTxn" class="headerlink" title="EnterNewTxn"></a>EnterNewTxn</h3><p>是用来准备事务相关的信息</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-1.svg?raw=true" alt="tidb-transaction-1"></p>
<h3 id="RunInNewTxn"><a href="#RunInNewTxn" class="headerlink" title="RunInNewTxn"></a>RunInNewTxn</h3><p><img src="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-2.svg?raw=true" alt="tidb-transaction-2"></p>
<h4 id="tikvStore-Begin"><a href="#tikvStore-Begin" class="headerlink" title="tikvStore::Begin"></a>tikvStore::Begin</h4><p>在 tikvStroe 内部结构如下：</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-3.svg?raw=true" alt="tidb-transaction-3"></p>
<h4 id="KVStroe-Begin"><a href="#KVStroe-Begin" class="headerlink" title="KVStroe::Begin"></a>KVStroe::Begin</h4><p>每个 client connection 对应着一个 session, 事务相关数据的放在了session中， 它包含了对 kv.Storage 和 KVTxn 接口的引用。<br>kv.Storage接口定义了 Begin&#x2F;BeginWithOption 接口，用来创建开始一个事务，主要实现者为KVStore。</p>
<p>KVStore::Begin 开始一个事务，如果此时 start_ts为nil，则会从PD 获取一个时间戳start_ts，并且作为事务的唯一标识txn_id，会由 KVSnapshot 对象保存事务开始的快照信息，方便后续和 TiKV 进行交互。其中 KVStore::Begin 内部的关系如下：</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-4.svg?raw=true" alt="tidb-transaction-4"></p>
<p>Begin之后，就基于Begin中创建的 snapshot 元数据信息从 TiKV 获取 snapshot，并基于该 snapshot 执行用户的 DML 操作，在 tikvTxn::Commit  之后开始将DDL的结果 mutations 使用 2PC 算法提交到 TiKV。</p>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><p>DML 操作都是基于 Next 执行框架完成，即在 Next 函数完成执行。 比如 InsertExec::Next  函数中完成将插入的数据封装成{key, value} 写入到 KVTxn的 MemDB 中。等到 Commit 时从 MemDB 中取出写入的数据，再进入 2PC 阶段向 TiKV 提交数据。</p>
<p>增删改的流程如下，在 Next 的执行框架中完成操作最终都是调用 Table 的 xxxRecord 接口，操作的结果缓存在 KVTxn.KVUnionStore.MemDB 中。</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-5.svg?raw=true" alt="tidb-transaction-5"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">        tablePrefix     = []<span class="type">byte</span>&#123;<span class="string">&#x27;t&#x27;</span>&#125;</span><br><span class="line">        recordPrefixSep = []<span class="type">byte</span>(<span class="string">&quot;_r&quot;</span>)</span><br><span class="line">        indexPrefixSep  = []<span class="type">byte</span>(<span class="string">&quot;_i&quot;</span>)</span><br><span class="line">        metaPrefix      = []<span class="type">byte</span>&#123;<span class="string">&#x27;m&#x27;</span>&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendTableRecordPrefix</span><span class="params">(buf []<span class="type">byte</span>, tableID <span class="type">int64</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">        buf = <span class="built_in">append</span>(buf, tablePrefix...)</span><br><span class="line">        buf = codec.EncodeInt(buf, tableID)</span><br><span class="line">        buf = <span class="built_in">append</span>(buf, recordPrefixSep...)</span><br><span class="line">        <span class="keyword">return</span> buf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// appendTableIndexPrefix appends table index prefix  &quot;t[tableID]_i&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendTableIndexPrefix</span><span class="params">(buf []<span class="type">byte</span>, tableID <span class="type">int64</span>)</span></span> []<span class="type">byte</span> &#123;</span><br><span class="line">        buf = <span class="built_in">append</span>(buf, tablePrefix...)</span><br><span class="line">        buf = codec.EncodeInt(buf, tableID)</span><br><span class="line">        buf = <span class="built_in">append</span>(buf, indexPrefixSep...)</span><br><span class="line">        <span class="keyword">return</span> buf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// GenTableRecordPrefix composes record prefix with tableID: &quot;t[tableID]_r&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenTableRecordPrefix</span><span class="params">(tableID <span class="type">int64</span>)</span></span> kv.Key &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(tablePrefix)+<span class="number">8</span>+<span class="built_in">len</span>(recordPrefixSep))</span><br><span class="line">        <span class="keyword">return</span> appendTableRecordPrefix(buf, tableID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GenTableIndexPrefix composes index prefix with tableID: &quot;t[tableID]_i&quot;.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GenTableIndexPrefix</span><span class="params">(tableID <span class="type">int64</span>)</span></span> kv.Key &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(tablePrefix)+<span class="number">8</span>+<span class="built_in">len</span>(indexPrefixSep))</span><br><span class="line">        <span class="keyword">return</span> appendTableIndexPrefix(buf, tableID)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initTableCommon</span><span class="params">(t *TableCommon, tblInfo *model.TableInfo, physicalTableID <span class="type">int64</span>, cols []*table.Column, allocs autoid.Allocators)</span></span> &#123;</span><br><span class="line">        t.tableID = tblInfo.ID</span><br><span class="line">        t.physicalTableID = physicalTableID</span><br><span class="line">        t.allocs = allocs</span><br><span class="line">        t.meta = tblInfo</span><br><span class="line">        t.Columns = cols</span><br><span class="line">        t.PublicColumns = t.Cols()</span><br><span class="line">        t.VisibleColumns = t.VisibleCols()</span><br><span class="line">        t.HiddenColumns = t.HiddenCols()</span><br><span class="line">        t.WritableColumns = t.WritableCols()</span><br><span class="line">        t.FullHiddenColsAndVisibleColumns = t.FullHiddenColsAndVisibleCols()</span><br><span class="line">        t.recordPrefix = tablecodec.GenTableRecordPrefix(physicalTableID)</span><br><span class="line">        t.indexPrefix = tablecodec.GenTableIndexPrefix(physicalTableID)</span><br><span class="line">        <span class="keyword">if</span> tblInfo.IsSequence() &#123;</span><br><span class="line">                t.sequence = &amp;sequenceCommon&#123;meta: tblInfo.Sequence&#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeRecordKey</span><span class="params">(recordPrefix kv.Key, h kv.Handle)</span></span> kv.Key &#123;</span><br><span class="line">        buf := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>, <span class="built_in">len</span>(recordPrefix)+h.Len())</span><br><span class="line">        buf = <span class="built_in">append</span>(buf, recordPrefix...)</span><br><span class="line">        buf = <span class="built_in">append</span>(buf, h.Encoded()...)</span><br><span class="line">        <span class="keyword">return</span> buf</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对键进行编码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *TableCommon)</span></span> RecordKey(h kv.Handle) kv.Key &#123;</span><br><span class="line">        <span class="keyword">return</span> tablecodec.EncodeRecordKey(t.recordPrefix, h)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="COMMIT"><a href="#COMMIT" class="headerlink" title="COMMIT"></a>COMMIT</h2><h3 id="twoPhaseCommitter"><a href="#twoPhaseCommitter" class="headerlink" title="twoPhaseCommitter"></a>twoPhaseCommitter</h3><ol>
<li>在 Commit 之前，数据会缓存在 KVUnionStore.MemDB 中</li>
<li>当执行用户的 COMMIT 时，在 KVTxn::Commit 函数中创建 twpPhaseCommitter，并调用 twoPhaseCommitter.initKeysAndMutations 函数遍历 KVUnionStore.MemDB 来初始化 memBuffMutations，作为后续的和 TiKV 交互的基础</li>
<li>在twoPhaseCommitter::execute 函数中，主要有五种操作：prewriteMutations、commitMutations、pessimisticLockMutations、pessimisticRollbackMutations 和 cleanupMutations。</li>
</ol>
<p>  他们输入都是 memBuffMutations ，然后都对 memBuffMutations 按照如下流程进行处理后再向 TiKV 发起请求：</p>
<ul>
<li>先基于 region 进行分组，将相同的 region 的数据分到一个 groupMutations</li>
<li>再基于 batch_size 阈值，对 groupMutations 划分为多个 batchMutations，</li>
<li>最终每个 batch 的数据经由各自的 action实现的 handleSingleBatch 函数向 TiKV 发送数据。有如下四个actions，对应着事务的不同过程：</li>
</ul>
  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(action actionPrewrite)</span></span> handleSingleBatch(c *twoPhaseCommitter, bo *retry.Backoffer, batch batchMutations) <span class="type">error</span>;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(action actionPessimisticLock)</span></span> handleSingleBatch(..);</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(action PessimisticRollback)</span></span> handleSingleBatch(...);</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(action Commit)</span></span> handleSingleBatch(..);</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(action Cleanup)</span></span> handleSingleBatch(..);</span><br></pre></td></tr></table></figure>
<p>  如果 memBuffMutations 只有一个 region 的数据，那么就可以直接使用 1 phase commit 进行优化。</p>
<p>下面是分组分批提交的细节</p>
<h3 id="doActionOnMutations"><a href="#doActionOnMutations" class="headerlink" title="doActionOnMutations"></a>doActionOnMutations</h3><h4 id="groupSortedMutationsByRegion"><a href="#groupSortedMutationsByRegion" class="headerlink" title="groupSortedMutationsByRegion"></a>groupSortedMutationsByRegion</h4><p>在 groupSortedMutationsByRegion，通过向 pd 查询每个 key所属的region，直接对已排序的 key 进行分组，划分到不同的group中。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// groupSortedMutationsByRegion separates keys into groups by their belonging Regions.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">groupSortedMutationsByRegion</span><span class="params">(c *locate.RegionCache, bo *retry.Backoffer, m CommitterMutations)</span></span> ([]groupedMutations, <span class="type">error</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> (</span><br><span class="line">    groups  []groupedMutations</span><br><span class="line">    lastLoc *locate.KeyLocation</span><br><span class="line">  )</span><br><span class="line">  lastUpperBound := <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m.Len(); i++ &#123;</span><br><span class="line">    <span class="keyword">if</span> lastLoc == <span class="literal">nil</span> || !lastLoc.Contains(m.GetKey(i)) &#123;</span><br><span class="line">      <span class="keyword">if</span> lastLoc != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 新生成一个 group</span></span><br><span class="line">        groups = <span class="built_in">append</span>(groups, groupedMutations &#123;</span><br><span class="line">          mutations: m.Slice(lastUpperBound, i), <span class="comment">// [lastUpperBound, i) 区间的 mutations 属于一个 group</span></span><br><span class="line">          region:    lastLoc.Region,             <span class="comment">// 这个区间的 mutations 所属的 region</span></span><br><span class="line">        &#125;)</span><br><span class="line">        lastUpperBound = i</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> err <span class="type">error</span></span><br><span class="line">      lastLoc, err = c.LocateKey(bo, m.GetKey(i)) <span class="comment">// 确定新的key所在的 region</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 最后一个分组</span></span><br><span class="line">  <span class="keyword">if</span> lastLoc != <span class="literal">nil</span> &#123;</span><br><span class="line">    groups = <span class="built_in">append</span>(groups, groupedMutations&#123;</span><br><span class="line">      region:    lastLoc.Region,</span><br><span class="line">      mutations: m.Slice(lastUpperBound, m.Len()),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> groups, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="preSplitRegion"><a href="#preSplitRegion" class="headerlink" title="preSplitRegion"></a>preSplitRegion</h4><p>如果一个 groupedMutations 的数据量过大，TiKV-client 会先向 TiKV-server 发起 split_region 请求这个 groupedMutations 对应的 region 分裂，并等待 region 分裂完成。这样避免对单个 region too much write workload, 避免了不必要的重试<br>如果确实分裂了，那么基于 groupSortedMutationsByRegion 函数得到的 region 信息就过时了，需要重新执行一次 groupSortedMutationsByRegion 函数，再执行写入操作。</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-6.png?raw=true" alt="tidb-transaction-6"></p>
<h4 id="groupMutations"><a href="#groupMutations" class="headerlink" title="groupMutations"></a>groupMutations</h4><p>整完整的 groupMutations 如下：</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-7.png?raw=true" alt="tidb-transaction-7"></p>
<h4 id="doActionOnGroupMutations"><a href="#doActionOnGroupMutations" class="headerlink" title="doActionOnGroupMutations"></a>doActionOnGroupMutations</h4><p>doActionOnGroupMutations 会对每个 group 的 mutations 做进一步的分批处理，最终将所有的 groupMutations 统一划分成多个 batchMutations，其中只有一个 Primary BatchMutations，其他的是 Secondary BatchMutations。写入的时先同步执行 Primary BatchMutations 中的数据，再异步执行 Secondary BatchMutations 中的数据。</p>
<p>batched 的定义如下</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> batched <span class="keyword">struct</span> &#123;</span><br><span class="line">  batches    []batchMutations <span class="comment">// 保存所有的数据</span></span><br><span class="line">  primaryIdx <span class="type">int</span>              <span class="comment">// 记录 Primary BatchMutations 所属 batch 的位置索引</span></span><br><span class="line">  primaryKey []<span class="type">byte</span>           <span class="comment">// 记录 Primary Key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="batched-appendBatchMutationsBySize"><a href="#batched-appendBatchMutationsBySize" class="headerlink" title="batched::appendBatchMutationsBySize"></a>batched::appendBatchMutationsBySize</h5><p>对 groupMutations 进行分批是由 appendBatchMutationsBySize 函数实现：</p>
<ul>
<li>对每个 groupMutations 进行划分成 batchMutations，每个 batchMutations  的大小限制在 16 * 1024 字节大小。</li>
<li>同时，在batch分组中，会寻找 groupMutations 中是否存在「主键」，如果存在则记录主键所属的 batch的在整个batches中的索引位置</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> batched <span class="keyword">struct</span> &#123;</span><br><span class="line">  batches    []batchMutations</span><br><span class="line">  primaryIdx <span class="type">int</span></span><br><span class="line">  primaryKey []<span class="type">byte</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *batched)</span></span> appendBatchMutationsBySize(region locate.RegionVerID, mutations CommitterMutations, sizeFn <span class="function"><span class="keyword">func</span><span class="params">(k, v []<span class="type">byte</span>)</span></span> <span class="type">int</span>, limit <span class="type">int</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> start, end <span class="type">int</span></span><br><span class="line">  <span class="comment">// 将 mutations 按照大小阈值 limit 进行划分</span></span><br><span class="line">  <span class="keyword">for</span> start = <span class="number">0</span>; start &lt; mutations.Len(); start = end &#123;</span><br><span class="line">    <span class="keyword">var</span> size <span class="type">int</span></span><br><span class="line">    <span class="keyword">for</span> end = start; end &lt; mutations.Len() &amp;&amp; size &lt; limit; end++ &#123;</span><br><span class="line">      <span class="keyword">var</span> k, v []<span class="type">byte</span></span><br><span class="line">      k = mutations.GetKey(end)</span><br><span class="line">      v = mutations.GetValue(end)</span><br><span class="line">      size += sizeFn(k, v)</span><br><span class="line">      <span class="keyword">if</span> b.primaryIdx &lt; <span class="number">0</span> &amp;&amp; bytes.Equal(k, b.primaryKey) &#123;</span><br><span class="line">        <span class="comment">// 更新 PrimaryIdx 为 PrimaryKey 在 batches 中所属 batch 的位置</span></span><br><span class="line">        b.primaryIdx = <span class="built_in">len</span>(b.batches) </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    b.batches = <span class="built_in">append</span>(b.batches, batchMutations&#123;</span><br><span class="line">      region:    region,</span><br><span class="line">      mutations: mutations.Slice(start, end),</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="batched-setPrimary"><a href="#batched-setPrimary" class="headerlink" title="batched::setPrimary"></a>batched::setPrimary</h5><p>分批结束后，使用 setPrimary 函数将 primaryIdx 对应 batchMutations 放到首位，方便后面先发送 Primary BatchMutations 中的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *batched)</span></span> setPrimary() <span class="type">bool</span> &#123;</span><br><span class="line">  <span class="comment">// If the batches include the primary key, put it to the first</span></span><br><span class="line">  <span class="keyword">if</span> b.primaryIdx &gt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(b.batches) &gt; <span class="number">0</span> &#123;</span><br><span class="line">      b.batches[b.primaryIdx].isPrimary = <span class="literal">true</span></span><br><span class="line">      b.batches[<span class="number">0</span>], b.batches[b.primaryIdx] = b.batches[b.primaryIdx], b.batches[<span class="number">0</span>] <span class="comment">// 互换</span></span><br><span class="line">      b.primaryIdx = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整 <em>doActionOnGroupMutations</em> 的核心逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *twoPhaseCommitter)</span></span> doActionOnGroupMutations(bo *Backoffer, action twoPhaseCommitAction, groups []groupedMutations) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1.每个分组内的再分批</span></span><br><span class="line">    <span class="keyword">for</span> _, group := <span class="keyword">range</span> groups &#123;</span><br><span class="line">        batchBuilder.appendBatchMutationsBySize(group.region, group.mutations, sizeFunc, txnCommitBatchSize)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    firstIsPrimary := batchBuilder.setPrimary()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 先同步提交 primary batchMutations</span></span><br><span class="line">    <span class="keyword">if</span> firstIsPrimary &amp;&amp;</span><br><span class="line">       ((actionIsCommit &amp;&amp; !c.isAsyncCommit()) || actionIsCleanup || actionIsPessimiticLock) &#123;</span><br><span class="line">       <span class="comment">// primary should be committed(not async commit)/cleanup/pessimistically locked first</span></span><br><span class="line">       err = c.doActionOnBatches(bo, action, batchBuilder.primaryBatch())</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">       batchBuilder.forgetPrimary() <span class="comment">// 去掉 batches 中的 primary batch</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 再异步提交 Secondary BatchMutations</span></span><br><span class="line">    <span class="keyword">if</span> actionIsCommit &amp;&amp; !actionCommit.retry &amp;&amp; !c.isAsyncCommit() &#123;</span><br><span class="line">         <span class="comment">//...</span></span><br><span class="line">         <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">           <span class="comment">// 其它的action异步提交</span></span><br><span class="line">           e := c.doActionOnBatches(secondaryBo, action, batchBuilder.allBatches())</span><br><span class="line">        &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         err = c.doActionOnBatches(bo, action, batchBuilder.allBatches())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="doActionOnBatches"><a href="#doActionOnBatches" class="headerlink" title="doActionOnBatches"></a>doActionOnBatches</h3><p>内部调用的 handleSingleBatch，不同的 actions 实现不同，下面结合乐观事务和悲观事务进行讲解。</p>
<h2 id="乐观事务"><a href="#乐观事务" class="headerlink" title="乐观事务"></a>乐观事务</h2><p>在 COMMIT阶段，TiDB 开始两阶段提交：</p>
<ul>
<li>TiDB 并发地向所有涉及的 TiKV 发起 prewrite 请求。TiKV 收到 prewrite 数据后，检查数据版本信息是否存在冲突或已过期。符合条件的数据会被加锁，将锁信息写入 CF_LOCK，{key_start_ts}，数据写入 CF_DAFAULT</li>
<li>TiDB 收到所有 prewrite 响应且所有 prewrite 都成功。</li>
<li>TiDB 向 PD 获取第二个全局唯一递增版本号，定义为本次事务的 commit_ts。</li>
<li>TiDB 向 Primary Key 所在 TiKV 发起第二阶段提交。TiKV 收到 commit 操作后，检查数据合法性，向 CF_WRITE中写入信息，并清理 prewrite 阶段留下的锁，即清理 CF_LOCK中的。</li>
<li>TiDB 收到两阶段提交成功的信息。</li>
</ul>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-8.png?raw=true" alt="tidb-transaction-8"></p>
<h3 id="actionPrewrite"><a href="#actionPrewrite" class="headerlink" title="actionPrewrite"></a>actionPrewrite</h3><h4 id="TiKV-Client"><a href="#TiKV-Client" class="headerlink" title="TiKV-Client"></a>TiKV-Client</h4><p>TiDB 向 TiKV发送 Prewrite 请求，</p>
<ul>
<li>遇到了 lock error， 则尝试 ResolveLock 去解决锁冲突， 然后重试；</li>
<li>如果遇到了regionError，说明之前获取的 region 信息错误，则需要重新调用 doActionONMutations 重新分组分批，重新尝试。</li>
</ul>
<p>如果没有 keyError，并且 Primary BatchMutations. 则启动一个 tllManager，给 txn 的 primary lock续命，ttlManager 会定期的向 TiKV 发送txnHeartbeat, 更新 primary lock 的 ttl。</p>
<h2 id="悲观事务"><a href="#悲观事务" class="headerlink" title="悲观事务"></a>悲观事务</h2><p>TiDB 在3.0版本引入了悲观事务，在两阶段提交之前增加了 Acquire Pessimistic Lock 获取悲观锁阶段，</p>
<ol>
<li>（同乐观锁）TiDB 收到来自客户端的 begin 请求，获取当前时间戳作为本事务的 StartTS。</li>
<li>TiDB 收到来自客户端的更新数据的请求：TiDB 向 TiKV 发起加悲观锁请求，该锁持久化到 TiKV。</li>
<li>（同乐观锁）客户端发起 commit，TiDB 开始执行与乐观锁一样的两阶段提交。</li>
</ol>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/TiDB/tidb-transaction-9.png?raw=true" alt="tidb-transaction-9"></p>
<h2 id="MvccTxn"><a href="#MvccTxn" class="headerlink" title="MvccTxn"></a>MvccTxn</h2><p>TiKV 有三个 ColumnFamily(CF)保存事务信息：</p>
<ul>
<li>CF_LOCK：用于保存事务的锁信息，表示有事务正在写这个 key，key &#x3D;&gt; lock_info</li>
<li>CF_DEFAULT：用于保存 MVCC 数据，(user_key,  start_ts) &#x3D;&gt; value</li>
<li>CF_WRITE ：用于保存 Value 可见的版本控制，(key, commit_ts)&#x3D;&gt; write_info</li>
</ul>
<p>这些数据经由MvccTxn类，写入 modifies，最终都会进入raft状态机，由leader节点同步给follower，超过半数节点确认后才会回应 client。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">MvccTxn</span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">new</span>(start_ts: TimeStamp, concurrency_manager: ConcurrencyManager) <span class="punctuation">-&gt;</span> MvccTxn &#123;</span><br><span class="line">        MvccTxn &#123;</span><br><span class="line">            start_ts,</span><br><span class="line">            write_size: <span class="number">0</span>,</span><br><span class="line">            modifies: <span class="built_in">vec!</span>[],</span><br><span class="line">            locks_for_1pc: <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>(),</span><br><span class="line">            concurrency_manager,</span><br><span class="line">            guards: <span class="built_in">vec!</span>[],</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// &#123;key, lock_info&#125;</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">put_lock</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: Key, lock: &amp;Lock) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">write</span> = Modify::<span class="title function_ invoke__">Put</span>(CF_LOCK, key, lock.<span class="title function_ invoke__">to_bytes</span>());</span><br><span class="line">        <span class="keyword">self</span>.write_size += write.<span class="title function_ invoke__">size</span>();</span><br><span class="line">        <span class="keyword">self</span>.modifies.<span class="title function_ invoke__">push</span>(write); <span class="comment">// 相同的 key 会覆盖之前</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ts 是 start_ts</span></span><br><span class="line">    <span class="comment">// &#123;&lt;key, start_ts&gt;, value&#125;</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">put_value</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: Key, ts: TimeStamp, value: Value) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">write</span> = Modify::<span class="title function_ invoke__">Put</span>(CF_DEFAULT, key.<span class="title function_ invoke__">append_ts</span>(ts), value);</span><br><span class="line">        <span class="keyword">self</span>.write_size += write.<span class="title function_ invoke__">size</span>();</span><br><span class="line">        <span class="keyword">self</span>.modifies.<span class="title function_ invoke__">push</span>(write);</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// ts 是 commit_ts</span></span><br><span class="line">    <span class="comment">// &#123;&lt;key, commit_ts&gt;, value&#125;</span></span><br><span class="line">    <span class="title function_ invoke__">pub</span>(<span class="keyword">crate</span>) <span class="keyword">fn</span> <span class="title function_">put_write</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, key: Key, ts: TimeStamp, value: Value) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">write</span> = Modify::<span class="title function_ invoke__">Put</span>(CF_WRITE, key.<span class="title function_ invoke__">append_ts</span>(ts), value);</span><br><span class="line">        <span class="keyword">self</span>.write_size += write.<span class="title function_ invoke__">size</span>();</span><br><span class="line">        <span class="keyword">self</span>.modifies.<span class="title function_ invoke__">push</span>(write);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">///...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="acquire-pessimistic-lock"><a href="#acquire-pessimistic-lock" class="headerlink" title="acquire_pessimistic_lock"></a>acquire_pessimistic_lock</h2><p>TiKV 使用 acquire_pessimistic_lock 函数来获得每个 key 的锁，即 向 CF_LOCK 中写入当前 key 的锁信息，用来占位，等待 prewrite 阶段再向 CF_LOCK 和 CF_DEFAULT 中分别写入具体的 lock_info 和数据。</p>
<p>TiKV 需要先从 CF_LOCK 中检测是否已经存在该 key 的锁信息：</p>
<ul>
<li><p>Yes: 此时就存在一些冲突了，需要解决这个冲突</p>
<ul>
<li>如果 lock.ts !&#x3D; reader.start_ts：则说明不是同一个事务。即设当前事务是 T1，则在 T1 之前已经有个事务 T0 抢占了这个 key 的锁，而且 T0 尚未 commit，那么就向 client 返回 ErrorInner::KeyIsLocked 错误，client 接受到这个错误就会进行 ResolveLock  处理本次冲突。</li>
<li>如果 lock.lock_type !&#x3D; LockType::Pessimistic：则已存在的 T0 事务和 T1 不是同一个类型的事务，则直接返 ErrorInner::LockTypeNotMatch 错误信息。</li>
</ul>
<p>如果上述两个 check 都通过了，则视为同一个事务 T0，此时会尝试更新 lock 的 for_update_ts 信息，然后根据 return_value、need_check_existence、need_old_value 等标志位来决定是否需要从 RocksdbDB 中读取数据返回给 client。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">acquire_pessimistic_lock</span>&lt;S: Snapshot&gt;(</span><br><span class="line">        txn: &amp;<span class="keyword">mut</span> MvccTxn,</span><br><span class="line">        reader: &amp;<span class="keyword">mut</span> SnapshotReader&lt;S&gt;,</span><br><span class="line">        key: Key,</span><br><span class="line">        primary: &amp;[<span class="type">u8</span>],</span><br><span class="line">        should_not_exist: <span class="type">bool</span>, <span class="comment">// 针对插入操作，应该不存在</span></span><br><span class="line">        lock_ttl: <span class="type">u64</span>,</span><br><span class="line">        for_update_ts: TimeStamp,</span><br><span class="line">        need_value: <span class="type">bool</span>,</span><br><span class="line">        need_check_existence: <span class="type">bool</span>,</span><br><span class="line">        min_commit_ts: TimeStamp,</span><br><span class="line">        need_old_value: <span class="type">bool</span>,</span><br><span class="line">    ) <span class="punctuation">-&gt;</span> MvccResult&lt;(<span class="type">Option</span>&lt;Value&gt;, OldValue)&gt; &#123;</span><br><span class="line">        <span class="comment">//... 检测 CF_LOCK 中是否有锁记录</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(lock) = reader.<span class="title function_ invoke__">load_lock</span>(&amp;key)? &#123;</span><br><span class="line">            <span class="comment">// CF_LOCK  </span></span><br><span class="line">            <span class="keyword">if</span> lock.ts != reader.start_ts &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ErrorInner::<span class="title function_ invoke__">KeyIsLocked</span>(lock.<span class="title function_ invoke__">into_lock_info</span>(key.<span class="title function_ invoke__">into_raw</span>()?)).<span class="title function_ invoke__">into</span>()); <span class="comment">// lock</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不是同一个事务</span></span><br><span class="line">            <span class="comment">// 上一个必须也是 LockType::Pessimistic</span></span><br><span class="line">            <span class="keyword">if</span> lock.lock_type != LockType::Pessimistic &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ErrorInner::LockTypeNotMatch &#123;</span><br><span class="line">                    start_ts: reader.start_ts,</span><br><span class="line">                    key: key.<span class="title function_ invoke__">into_raw</span>()?,</span><br><span class="line">                    pessimistic: <span class="literal">false</span>,</span><br><span class="line">                &#125;</span><br><span class="line">                .<span class="title function_ invoke__">into</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> need_load_value &#123;</span><br><span class="line">                val = reader.<span class="title function_ invoke__">get</span>(&amp;key, for_update_ts)?;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> need_check_existence &#123;</span><br><span class="line">                val = reader.<span class="title function_ invoke__">get_write</span>(&amp;key, for_update_ts)?.<span class="title function_ invoke__">map</span>(|_| <span class="built_in">vec!</span>[]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Pervious write is not loaded.</span></span><br><span class="line">            <span class="keyword">let</span> (prev_write_loaded, prev_write) = (<span class="literal">false</span>, <span class="literal">None</span>);</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">old_value</span> = <span class="title function_ invoke__">load_old_value</span>(</span><br><span class="line">                need_old_value,</span><br><span class="line">                need_load_value,</span><br><span class="line">                val.<span class="title function_ invoke__">as_ref</span>(),</span><br><span class="line">                reader,</span><br><span class="line">                &amp;key,</span><br><span class="line">                for_update_ts,</span><br><span class="line">                prev_write_loaded,</span><br><span class="line">                prev_write,</span><br><span class="line">            )?;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Overwrite the lock with small for_update_ts</span></span><br><span class="line">            <span class="keyword">if</span> for_update_ts &gt; lock.for_update_ts &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">lock</span> = PessimisticLock &#123;</span><br><span class="line">                    primary: primary.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">                    start_ts: reader.start_ts,</span><br><span class="line">                    ttl: lock_ttl,</span><br><span class="line">                    for_update_ts,</span><br><span class="line">                    min_commit_ts,</span><br><span class="line">                &#125;;</span><br><span class="line">                txn.<span class="title function_ invoke__">put_pessimistic_lock</span>(key, lock); <span class="comment">// 更新 lock 信息</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                MVCC_DUPLICATE_CMD_COUNTER_VEC</span><br><span class="line">                    .acquire_pessimistic_lock</span><br><span class="line">                    .<span class="title function_ invoke__">inc</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 视为同一个事务的重复请求</span></span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>((<span class="title function_ invoke__">ret_val</span>(need_value, need_check_existence, val), old_value));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>No: 如果 CF_LOCK 中没有 key 的锁信息，即 reader.load_lock(&amp;key) 返回的是 None，此时仍需要去 CF_WRTIE 中检测是否有对应的写记录，进一步判断当前事务 T1 的状态。<br>因为当前事务T1 可能其他事务清除了，或者TTL过期。当删除事务时会删除 Key 在 CF_LOCK、CF_DEFAULT 中的记录，在 CF_WRITE 中留下一条 Rollback记录。</p>
<p> reader.seek_write(&amp;key, TimeStamp::max()) 寻找的是 key 在 CF_WRITE 中最新的写入记录：</p>
<ul>
<li><p>如果返回不为 None 且假设为 Some(commit_ts, write)，则有两种可能： </p>
<ol>
<li>上次 committed 记录：正常情况下， T0 的 commit_ts &gt; T1 的 for_update_ts，如果违背了，则产生了一次写冲突</li>
<li>上次 rollback 记录</li>
</ol>
<p>如果 commit_ts &#x3D;&#x3D; reader.start_ts 并且满足 write.write_type &#x3D;&#x3D; WriteType::Rollback || write.has_overlapped_rollback，那么说明当前事务 T1 已经被删除了，只留下一条 rollback 记录，不能再获取锁了，则返回 ErrorInner::PessimisticLockRolledBack 错误给 client。</p>
<p>如果 commit_ts &gt; reader.start_ts，则说明当前事务已经过期，去检测 reader.start_ts 上一个事务的的状态，如果也是 rollback，则也向 client 回复 ErrorInner::PessimisticLockRolledBack 错误。</p>
</li>
<li><p>返回 None，则表示 CF_WRITE 中不存在 key 的记录，那么当前事物 T1 可以顺利获取Key的锁，则会向 CF_LOCK 中插入当前 key 的 lock 信息，表示获得该 key 的锁成功了。</p>
</li>
</ul>
<p>这部分代码如下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">acquire_pessimistic_lock</span>&lt;S: Snapshot&gt;( <span class="comment">/*..ingore params.*/</span> ) <span class="punctuation">-&gt;</span> MvccResult&lt;(<span class="type">Option</span>&lt;Value&gt;, OldValue)&gt; &#123;</span><br><span class="line">    <span class="comment">/// ... </span></span><br><span class="line">    <span class="comment">/// 当前没有 lock，即没有别的任务在写</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> (prev_write_loaded, <span class="keyword">mut</span> prev_write) = (<span class="literal">true</span>, <span class="literal">None</span>);</span><br><span class="line">    <span class="comment">// 进一步在 CF_WRITE 中寻找</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((commit_ts, write)) = reader.<span class="title function_ invoke__">seek_write</span>(&amp;key, TimeStamp::<span class="title function_ invoke__">max</span>())? &#123;</span><br><span class="line">        <span class="comment">// Find a previous write.</span></span><br><span class="line">        <span class="keyword">if</span> need_old_value &#123;</span><br><span class="line">            prev_write = <span class="title function_ invoke__">Some</span>(write.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 上个提交的版本，比当前事务的时间戳大</span></span><br><span class="line">        <span class="comment">// 产生了写冲突</span></span><br><span class="line">        <span class="keyword">if</span> commit_ts &gt; for_update_ts &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ErrorInner::WriteConflict &#123;</span><br><span class="line">                start_ts: reader.start_ts,</span><br><span class="line">                conflict_start_ts: write.start_ts,</span><br><span class="line">                conflict_commit_ts: commit_ts,</span><br><span class="line">                key: key.<span class="title function_ invoke__">into_raw</span>()?,</span><br><span class="line">                primary: primary.<span class="title function_ invoke__">to_vec</span>(),</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Handle rollback.</span></span><br><span class="line">        <span class="comment">// The rollback information may come from either a Rollback record or a record with</span></span><br><span class="line">        <span class="comment">// `has_overlapped_rollback` flag.</span></span><br><span class="line">        <span class="keyword">if</span> commit_ts == reader.start_ts</span><br><span class="line">            &amp;&amp; (write.write_type == WriteType::Rollback || write.has_overlapped_rollback)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">assert!</span>(write.has_overlapped_rollback || write.start_ts == commit_ts);</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ErrorInner::PessimisticLockRolledBack &#123;</span><br><span class="line">                start_ts: reader.start_ts,</span><br><span class="line">                key: key.<span class="title function_ invoke__">into_raw</span>()?,</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If `commit_ts` we seek is already before `start_ts`, the rollback must not exist.</span></span><br><span class="line">        <span class="comment">// 可能是一个反复重试的</span></span><br><span class="line">        <span class="keyword">if</span> commit_ts &gt; reader.start_ts &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((older_commit_ts, older_write)) =</span><br><span class="line">                reader.<span class="title function_ invoke__">seek_write</span>(&amp;key, reader.start_ts)?</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> older_commit_ts == reader.start_ts</span><br><span class="line">                    &amp;&amp; (older_write.write_type == WriteType::Rollback || older_write.has_overlapped_rollback)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ErrorInner::PessimisticLockRolledBack &#123;</span><br><span class="line">                        start_ts: reader.start_ts,</span><br><span class="line">                        key: key.<span class="title function_ invoke__">into_raw</span>()?,</span><br><span class="line">                    &#125;</span><br><span class="line">                    .<span class="title function_ invoke__">into</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lock</span> = PessimisticLock &#123;</span><br><span class="line">        primary: primary.<span class="title function_ invoke__">into</span>(),</span><br><span class="line">        start_ts: reader.start_ts,</span><br><span class="line">        ttl: lock_ttl,</span><br><span class="line">        for_update_ts,</span><br><span class="line">        min_commit_ts,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入的是 lock 信息，此 lock 信息稍后会统一写入存储层</span></span><br><span class="line">    txn.<span class="title function_ invoke__">put_pessimistic_lock</span>(key, lock);</span><br><span class="line">    <span class="comment">// TODO don&#x27;t we need to commit the modifies in txn?</span></span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((<span class="title function_ invoke__">ret_val</span>(need_value, need_check_existence, val), old_value))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="prewrite"><a href="#prewrite" class="headerlink" title="prewrite"></a>prewrite</h2><p>prewrite 目的是在 CF_LOCK 和 CF_DEFAULT 写入记录，如果成功，则客户端能顺利发起 Commit 请求。当然，如果是悲观事务，则在 acquire_pessimistic_lock 阶段就已经在 CF_LOCK 中写入记录，那么在 prewrite 阶段就肯定能成功。<br>因此，在 prewrite 函数中，先尝试从 CF_LOCK 中读取 lock 的信息:</p>
<ol>
<li>有 lock，则需要在 PrewriteMutation::check_lock 函数中进一步 check；</li>
<li>没有 lock，但是当前又是悲观事务，则需要在 CF_LOCK 中加上 lock_info：这是TiKV 在v6.1引入 pipeline write 设计可能出现的 corner case</li>
<li>返回None，即乐观事务</li>
</ol>
<p>代码如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">prewrite</span>&lt;S: Snapshot&gt;(</span><br><span class="line">    txn: &amp;<span class="keyword">mut</span> MvccTxn,</span><br><span class="line">    reader: &amp;<span class="keyword">mut</span> SnapshotReader&lt;S&gt;,</span><br><span class="line">    txn_props: &amp;TransactionProperties&lt;<span class="symbol">&#x27;_</span>&gt;,</span><br><span class="line">    mutation: Mutation,</span><br><span class="line">    secondary_keys: &amp;<span class="type">Option</span>&lt;<span class="type">Vec</span>&lt;<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;&gt;&gt;,</span><br><span class="line">    is_pessimistic_lock: <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(TimeStamp, OldValue)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">mutation</span> = PrewriteMutation::<span class="title function_ invoke__">from_mutation</span>(</span><br><span class="line">            mutation,</span><br><span class="line">            secondary_keys,</span><br><span class="line">            is_pessimistic_lock,</span><br><span class="line">            txn_props)?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update max_ts for Insert operation to guarante linearizability and snapshot isolation</span></span><br><span class="line">    <span class="keyword">if</span> mutation.should_not_exist &#123;</span><br><span class="line">        txn.concurrency_manager.<span class="title function_ invoke__">update_max_ts</span>(txn_props.start_ts);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock_amended</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">lock_status</span> = <span class="keyword">match</span> reader.<span class="title function_ invoke__">load_lock</span>(&amp;mutation.key)? &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(lock) =&gt; mutation.<span class="title function_ invoke__">check_lock</span>(lock, is_pessimistic_lock)?,</span><br><span class="line">        <span class="literal">None</span> <span class="keyword">if</span> is_pessimistic_lock =&gt; &#123;</span><br><span class="line">            <span class="title function_ invoke__">amend_pessimistic_lock</span>(&amp;mutation, reader)?;</span><br><span class="line">            lock_amended = <span class="literal">true</span>;</span><br><span class="line">            LockStatus::<span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">None</span> =&gt; LockStatus::<span class="literal">None</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PrewriteMutation-check-lock"><a href="#PrewriteMutation-check-lock" class="headerlink" title="PrewriteMutation::check_lock"></a>PrewriteMutation::check_lock</h3><p>check_lock 的逻辑和 acquire_pessimistic_lock 有点类似，仍假设当前事务为 T1，之前的事务为 T0<br>进入这个函数已经确定 CF_LOCK 中存在锁：</p>
<ul>
<li>若 lock.ts !&#x3D; self.txn_props.start_ts，则说明已经存在事务 T0:</li>
<li>若 T1 是悲观事务，则之前在 acquire_pessimistc_lock 阶段写入的 lock 不存在了，可能被清除了，则返回 ErrorInner::PessimisticLockNotFound 错误；</li>
<li>否则 T1 即乐观事务，由于乐观锁只是在 prewrite 阶段尝试上锁，如果相同key上的锁已经被其他事务 T0 占据，则返回 ErrorInner::KeyIsLocked， 则让客户端发起 ResolveLock 来解决这个锁冲突</li>
<li>如果 lock.ts &#x3D;&#x3D; start_ts， 则再检测 lock.lock_type 是否一致：<ul>
<li>如果不一致，则返回 ErrorInner::LockTypeNotMatch 错位。</li>
<li>如果一致：<ul>
<li>悲观事务：更新 lock_ttl、min_commit_ts</li>
<li>乐观事务：那么当前这次 prewrite 就是个重复指令，无需更新任何数，幂等操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Check whether the current key is locked at any timestamp.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">check_lock</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, lock: Lock, is_pessimistic_lock: <span class="type">bool</span>) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;LockStatus&gt; &#123;</span><br><span class="line">    <span class="comment">// 相同的事务的 start_ts 相同, 因此，不等则说明已经被其他事务锁住</span></span><br><span class="line">    <span class="keyword">if</span> lock.ts != <span class="keyword">self</span>.txn_props.start_ts &#123;</span><br><span class="line">        <span class="keyword">if</span> is_pessimistic_lock &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ErrorInner::PessimisticLockNotFound &#123;</span><br><span class="line">                start_ts: <span class="keyword">self</span>.txn_props.start_ts,</span><br><span class="line">                key: <span class="keyword">self</span>.key.<span class="title function_ invoke__">to_raw</span>()?,</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 乐观事务</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ErrorInner::<span class="title function_ invoke__">KeyIsLocked</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">lock_info</span>(lock)?).<span class="title function_ invoke__">into</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> lock.lock_type == LockType::Pessimistic &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.txn_props.<span class="title function_ invoke__">is_pessimistic</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ErrorInner::LockTypeNotMatch &#123;</span><br><span class="line">                start_ts: <span class="keyword">self</span>.txn_props.start_ts,</span><br><span class="line">                key: <span class="keyword">self</span>.key.<span class="title function_ invoke__">to_raw</span>()?,</span><br><span class="line">                pessimistic: <span class="literal">true</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            .<span class="title function_ invoke__">into</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The lock is pessimistic and owned by this txn, go through to overwrite it.</span></span><br><span class="line">        <span class="comment">// The ttl and min_commit_ts of the lock may have been pushed forward.</span></span><br><span class="line">        <span class="keyword">self</span>.lock_ttl = std::cmp::<span class="title function_ invoke__">max</span>(<span class="keyword">self</span>.lock_ttl, lock.ttl);</span><br><span class="line">        <span class="keyword">self</span>.min_commit_ts = std::cmp::<span class="title function_ invoke__">max</span>(<span class="keyword">self</span>.min_commit_ts, lock.min_commit_ts); <span class="comment">// 更新</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(LockStatus::Pessimistic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Duplicated command. No need to overwrite the lock and data.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">min_commit_ts</span> = <span class="keyword">if</span> lock.use_async_commit &#123;</span><br><span class="line">        lock.min_commit_ts</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        TimeStamp::<span class="title function_ invoke__">zero</span>()</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(LockStatus::<span class="title function_ invoke__">Locked</span>(min_commit_ts))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PrewriteMutation-write-lock"><a href="#PrewriteMutation-write-lock" class="headerlink" title="PrewriteMutation::write_lock"></a>PrewriteMutation::write_lock</h3><p>上述 check 都通过了，则将 CF_LOCK 和 CF_DEFAULT 中写入数据，流程如下：</p>
<ul>
<li><p>如果 sizoef(value) &lt; 256，即 is_short_value(&amp;value) 为 true，则直接会有个优化，直接将 value 写入到 CF_LOCK 中，否则value需要写入 CF_DEFAULT 中；</p>
</li>
<li><p>如果开启了 async_commit，则会在 key 中记录所有的 secondaries key，方便后续查询所有 secondaries 的状态。</p>
<p>如果开启了 async_commit，这里需要基于所有的 secondaries 计算 final_min_commit_ts，返回给 tikv-client，让 client 使用这个 final_min_commit_ts 来作为进行异步 commit 的时间戳</p>
</li>
<li><p>最后将向 txn 中写入 lock 信息<br>因此， prewtite 阶段成功后，Rocksdb 中就记录了 锁信息和真正的数据，就等待 commit 中的 write 信息了。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">write_lock</span>(<span class="keyword">self</span>, lock_status: LockStatus, txn: &amp;<span class="keyword">mut</span> MvccTxn) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;TimeStamp&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">try_one_pc</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">try_one_pc</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = Lock::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        <span class="keyword">self</span>.lock_type.<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        <span class="keyword">self</span>.txn_props.primary.<span class="title function_ invoke__">to_vec</span>(),</span><br><span class="line">        <span class="keyword">self</span>.txn_props.start_ts,</span><br><span class="line">        <span class="keyword">self</span>.lock_ttl,</span><br><span class="line">        <span class="literal">None</span>,</span><br><span class="line">        <span class="keyword">self</span>.txn_props.<span class="title function_ invoke__">for_update_ts</span>(),</span><br><span class="line">        <span class="keyword">self</span>.txn_props.txn_size,</span><br><span class="line">        <span class="keyword">self</span>.min_commit_ts,</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(value) = <span class="keyword">self</span>.value &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="title function_ invoke__">is_short_value</span>(&amp;value) &#123;</span><br><span class="line">            <span class="comment">// If the value is short, embed it in Lock.</span></span><br><span class="line">            lock.short_value = <span class="title function_ invoke__">Some</span>(value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// value is long</span></span><br><span class="line">            <span class="comment">// 向 CF_DEFAULT 中写入数据</span></span><br><span class="line">            txn.<span class="title function_ invoke__">put_value</span>(<span class="keyword">self</span>.key.<span class="title function_ invoke__">clone</span>(), <span class="keyword">self</span>.txn_props.start_ts, value); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(secondary_keys) = <span class="keyword">self</span>.secondary_keys &#123;</span><br><span class="line">        lock.use_async_commit = <span class="literal">true</span>;</span><br><span class="line">        lock.secondaries = secondary_keys.<span class="title function_ invoke__">to_owned</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">final_min_commit_ts</span> = <span class="keyword">if</span> lock.use_async_commit || try_one_pc &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = <span class="title function_ invoke__">async_commit_timestamps</span>(</span><br><span class="line">            &amp;<span class="keyword">self</span>.key,</span><br><span class="line">            &amp;<span class="keyword">mut</span> lock,</span><br><span class="line">            <span class="keyword">self</span>.txn_props.start_ts,</span><br><span class="line">            <span class="keyword">self</span>.txn_props.<span class="title function_ invoke__">for_update_ts</span>(),</span><br><span class="line">            <span class="keyword">self</span>.txn_props.<span class="title function_ invoke__">max_commit_ts</span>(),</span><br><span class="line">            txn,</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(<span class="title function_ invoke__">Error</span>(<span class="keyword">box</span> ErrorInner::CommitTsTooLarge &#123; .. &#125;)) = &amp;res &#123;</span><br><span class="line">            try_one_pc = <span class="literal">false</span>;</span><br><span class="line">            lock.use_async_commit = <span class="literal">false</span>;</span><br><span class="line">            lock.secondaries = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        res</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(TimeStamp::<span class="title function_ invoke__">zero</span>())</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> try_one_pc &#123;</span><br><span class="line">        txn.<span class="title function_ invoke__">put_locks_for_1pc</span>(<span class="keyword">self</span>.key, lock, lock_status.<span class="title function_ invoke__">has_pessimistic_lock</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        txn.<span class="title function_ invoke__">put_lock</span>(<span class="keyword">self</span>.key, &amp;lock); <span class="comment">// 向 CF_LOCK 中写入 lock 信息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    final_min_commit_ts</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h2><p>第一阶段 prewrite 成功，TiDB 向 PD 再获取一个单调递增的时间戳 commit_ts 用于第二段提交，在 CF_WRITE 中写入提交信息，并清除第一阶段prewrite中写入的 lock 信息。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">commit</span>&lt;S: Snapshot&gt;(</span><br><span class="line">    txn: &amp;<span class="keyword">mut</span> MvccTxn,</span><br><span class="line">    reader: &amp;<span class="keyword">mut</span> SnapshotReader&lt;S&gt;,</span><br><span class="line">    key: Key,</span><br><span class="line">    commit_ts: TimeStamp,</span><br><span class="line">) <span class="punctuation">-&gt;</span> MvccResult&lt;<span class="type">Option</span>&lt;ReleasedLock&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">lock</span> = <span class="keyword">match</span> reader.<span class="title function_ invoke__">load_lock</span>(&amp;key)? &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(<span class="keyword">mut</span> lock) <span class="keyword">if</span> lock.ts == reader.start_ts =&gt; &#123;</span><br><span class="line">            <span class="comment">// lock.ts == reader.start_ts =&gt; 确实是需要 commit 的 lock</span></span><br><span class="line">            <span class="comment">// commit_ts &lt; lock.min_commit_ts =&gt; 计算出来的 commit_ts 不满足要求</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// A lock with larger min_commit_ts than current commit_ts can&#x27;t be committed</span></span><br><span class="line">            <span class="keyword">if</span> commit_ts &lt; lock.min_commit_ts &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(ErrorInner::CommitTsExpired &#123;</span><br><span class="line">                    start_ts: reader.start_ts,</span><br><span class="line">                    commit_ts,</span><br><span class="line">                    key: key.<span class="title function_ invoke__">into_raw</span>()?,</span><br><span class="line">                    min_commit_ts: lock.min_commit_ts,</span><br><span class="line">                &#125;</span><br><span class="line">                .<span class="title function_ invoke__">into</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> lock.lock_type == LockType::Pessimistic &#123;</span><br><span class="line">                <span class="comment">// Commit with WriteType::Lock.</span></span><br><span class="line">                lock.lock_type = LockType::Lock; <span class="comment">// commit 更改 lock 类型</span></span><br><span class="line">            &#125;</span><br><span class="line">            lock</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; &#123;</span><br><span class="line">            <span class="comment">// lock 缺失</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">match</span> reader.<span class="title function_ invoke__">get_txn_commit_record</span>(&amp;key)?.<span class="title function_ invoke__">info</span>() &#123;</span><br><span class="line">                <span class="comment">// 一条 rollback 记录找不到了 =&gt; TxnLockNotFound</span></span><br><span class="line">                <span class="comment">// Rollback 自然就无法 commit</span></span><br><span class="line">                <span class="title function_ invoke__">Some</span>((_, WriteType::Rollback)) | <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">                    <span class="comment">// None: related Rollback has been collapsed.</span></span><br><span class="line">                    <span class="comment">// Rollback: rollback by concurrent transaction.</span></span><br><span class="line">                    <span class="title function_ invoke__">Err</span>(ErrorInner::TxnLockNotFound &#123;</span><br><span class="line">                        start_ts: reader.start_ts,</span><br><span class="line">                        commit_ts,</span><br><span class="line">                        key: key.<span class="title function_ invoke__">into_raw</span>()?,</span><br><span class="line">                    &#125;</span><br><span class="line">                    .<span class="title function_ invoke__">into</span>())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Committed by concurrent transaction.</span></span><br><span class="line">                <span class="title function_ invoke__">Some</span>((_, WriteType::Put))</span><br><span class="line">                | <span class="title function_ invoke__">Some</span>((_, WriteType::Delete))</span><br><span class="line">                | <span class="title function_ invoke__">Some</span>((_, WriteType::Lock)) =&gt; &#123;</span><br><span class="line">                    <span class="title function_ invoke__">Ok</span>(<span class="literal">None</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">write</span> = Write::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        WriteType::<span class="title function_ invoke__">from_lock_type</span>(lock.lock_type).<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        reader.start_ts,</span><br><span class="line">        lock.short_value.<span class="title function_ invoke__">take</span>(),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">ts</span> <span class="keyword">in</span> &amp;lock.rollback_ts &#123;</span><br><span class="line">        <span class="keyword">if</span> *ts == commit_ts &#123;</span><br><span class="line">            write = write.<span class="title function_ invoke__">set_overlapped_rollback</span>(<span class="literal">true</span>, <span class="literal">None</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 CF_WRITE 中写入数据才算 &#123;key, commit&#125; =&gt; write</span></span><br><span class="line">    txn.<span class="title function_ invoke__">put_write</span>(key.<span class="title function_ invoke__">clone</span>(), commit_ts, write.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">to_bytes</span>());</span><br><span class="line">    <span class="comment">// 再将 CF_LOCK 中删除 lock</span></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(txn.<span class="title function_ invoke__">unlock_key</span>(key, lock.<span class="title function_ invoke__">is_pessimistic_txn</span>()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><ul>
<li><a target="_blank" rel="noopener" href="https://cn.pingcap.com/blog/async-commit-principle">async commit</a></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ExecuteStmt"><span class="toc-number">1.</span> <span class="toc-text">ExecuteStmt</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EnterNewTxn"><span class="toc-number">1.1.</span> <span class="toc-text">EnterNewTxn</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunInNewTxn"><span class="toc-number">1.2.</span> <span class="toc-text">RunInNewTxn</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tikvStore-Begin"><span class="toc-number">1.2.1.</span> <span class="toc-text">tikvStore::Begin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KVStroe-Begin"><span class="toc-number">1.2.2.</span> <span class="toc-text">KVStroe::Begin</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DML"><span class="toc-number">2.</span> <span class="toc-text">DML</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#COMMIT"><span class="toc-number">3.</span> <span class="toc-text">COMMIT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#twoPhaseCommitter"><span class="toc-number">3.1.</span> <span class="toc-text">twoPhaseCommitter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doActionOnMutations"><span class="toc-number">3.2.</span> <span class="toc-text">doActionOnMutations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#groupSortedMutationsByRegion"><span class="toc-number">3.2.1.</span> <span class="toc-text">groupSortedMutationsByRegion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#preSplitRegion"><span class="toc-number">3.2.2.</span> <span class="toc-text">preSplitRegion</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#groupMutations"><span class="toc-number">3.2.3.</span> <span class="toc-text">groupMutations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doActionOnGroupMutations"><span class="toc-number">3.2.4.</span> <span class="toc-text">doActionOnGroupMutations</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#batched-appendBatchMutationsBySize"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">batched::appendBatchMutationsBySize</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#batched-setPrimary"><span class="toc-number">3.2.4.2.</span> <span class="toc-text">batched::setPrimary</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#doActionOnBatches"><span class="toc-number">3.3.</span> <span class="toc-text">doActionOnBatches</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E4%BA%8B%E5%8A%A1"><span class="toc-number">4.</span> <span class="toc-text">乐观事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#actionPrewrite"><span class="toc-number">4.1.</span> <span class="toc-text">actionPrewrite</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TiKV-Client"><span class="toc-number">4.1.1.</span> <span class="toc-text">TiKV-Client</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">悲观事务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MvccTxn"><span class="toc-number">6.</span> <span class="toc-text">MvccTxn</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#acquire-pessimistic-lock"><span class="toc-number">7.</span> <span class="toc-text">acquire_pessimistic_lock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#prewrite"><span class="toc-number">8.</span> <span class="toc-text">prewrite</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PrewriteMutation-check-lock"><span class="toc-number">8.1.</span> <span class="toc-text">PrewriteMutation::check_lock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrewriteMutation-write-lock"><span class="toc-number">8.2.</span> <span class="toc-text">PrewriteMutation::write_lock</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Commit"><span class="toc-number">9.</span> <span class="toc-text">Commit</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Others"><span class="toc-number">10.</span> <span class="toc-text">Others</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&text=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&title=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&is_video=false&description=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=tidb: 2PC transaction 写入 tikv 详解&body=Check out this article: https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&title=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&title=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&title=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&title=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&name=tidb: 2PC transaction 写入 tikv 详解&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/09/01/TiDB/tidb_tranasaction_1/&t=tidb: 2PC transaction 写入 tikv 详解"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
