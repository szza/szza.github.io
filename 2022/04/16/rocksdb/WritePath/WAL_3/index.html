<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本文是 WAL&#x2F;MemTable 生命周期的完结篇，主要关注 FlushJob 执行流程以及如何确定哪些 WAL&#x2F;MmmTable 可以安全地删除。 PickMemTableFlushJob 首先需要从 ColumnFamilyData::imm_ 中挑选出本次所需的 FlushJob::mems_ ，这部分功能由 PickMemTable 函数实现。最大可以选择的 MemTa">
<meta property="og:type" content="article">
<meta property="og:title" content="WAL、MemTable 的生命周期管理(3)">
<meta property="og:url" content="https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="本文是 WAL&#x2F;MemTable 生命周期的完结篇，主要关注 FlushJob 执行流程以及如何确定哪些 WAL&#x2F;MmmTable 可以安全地删除。 PickMemTableFlushJob 首先需要从 ColumnFamilyData::imm_ 中挑选出本次所需的 FlushJob::mems_ ，这部分功能由 PickMemTable 函数实现。最大可以选择的 MemTa">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-04-16T06:15:35.000Z">
<meta property="article:modified_time" content="2023-08-07T09:26:04.729Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="RocksDb">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>WAL、MemTable 的生命周期管理(3)</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2023/04/02/Paper/Morsel-Driven-Parallelism/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022/04/05/rocksdb/WritePath/WAL_2/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&text=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&title=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&is_video=false&description=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=WAL、MemTable 的生命周期管理(3)&body=Check out this article: https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&title=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&title=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&title=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&title=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&name=WAL、MemTable 的生命周期管理(3)&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&t=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PickMemTable"><span class="toc-number">1.</span> <span class="toc-text">PickMemTable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PickMemtablesToFlush"><span class="toc-number">1.1.</span> <span class="toc-text">PickMemtablesToFlush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RollbackMemtableFlush"><span class="toc-number">1.2.</span> <span class="toc-text">RollbackMemtableFlush</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FlushJob-Run"><span class="toc-number">2.</span> <span class="toc-text">FlushJob::Run</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WriteLevel0Table"><span class="toc-number">2.1.</span> <span class="toc-text">WriteLevel0Table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TryInstallMemtableFlushResults"><span class="toc-number">2.2.</span> <span class="toc-text">TryInstallMemtableFlushResults</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrecomputeMinLogNumberToKeepNon2PC"><span class="toc-number">2.3.</span> <span class="toc-text">PrecomputeMinLogNumberToKeepNon2PC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FindObsoleteFiles"><span class="toc-number">3.</span> <span class="toc-text">FindObsoleteFiles</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        WAL、MemTable 的生命周期管理(3)
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-04-16T06:15:35.000Z" itemprop="datePublished">2022-04-16</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Timeline/">Timeline</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/RocksDb/" rel="tag">RocksDb</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>本文是 WAL&#x2F;MemTable 生命周期的完结篇，主要关注 FlushJob 执行流程以及如何确定哪些 WAL&#x2F;MmmTable 可以安全地删除。</p>
<h2 id="PickMemTable"><a href="#PickMemTable" class="headerlink" title="PickMemTable"></a>PickMemTable</h2><p>FlushJob 首先需要从 <em>ColumnFamilyData::imm_</em> 中挑选出本次所需的 <em>FlushJob::mems_</em> ，这部分功能由 <code>PickMemTable</code> 函数实现。最大可以选择的 MemTable::id_ 是 <em>max_memtable_id_</em> ，该参数值的设置见由上一节 <a href="https://szza.github.io/2022/04/05/rocksdb/WritePath/WAL_2">WAL、MemTable 的生命周期管理(2)</a>。</p>
<p>每个 FlushJob 选中的 <em>mems_</em> 是基于 MemTable 的创建时间排序，即 <code>mems_[0]</code> 是最早创建的，<code>mems.back()</code> 是最晚创建的。具体从 imm_ 获取 <em>mems_</em> 的逻辑由 <code>PickMemtablesToFlush</code> 函数实现。</p>
<p>每次 Flush 操作都产生一个 VersionEdit。FlushJob 将 VersionEdit 信息记录在 <code>mems_[0]-&gt;edit_</code> 中，edit_ 中 <code>log_number_</code> 主要是用于追踪 WAL 的生命周期，其值是<code>max_next_log_number</code>，如何与WAL生命周期产生联系可见后文分析。</p>
<p>此外，<code>FlushJob::meta_</code> 中记录着成功 Flush 后生成的 level0 SST 文件的元信息数据。</p>
<p>PickMemTable 核心代码逻辑如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlushJob::PickMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  pick_memtable_called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> max_next_log_number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the earliest memtable as a new Table</span></span><br><span class="line">  cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">PickMemtablesToFlush</span>(max_memtable_id_, &amp;mems_,</span><br><span class="line">                                    &amp;max_next_log_number);</span><br><span class="line">  <span class="keyword">if</span> (mems_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* m = mems_[<span class="number">0</span>];</span><br><span class="line">  edit_ = m-&gt;<span class="built_in">GetEdits</span>();</span><br><span class="line">  edit_-&gt;<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);</span><br><span class="line">  edit_-&gt;<span class="built_in">SetLogNumber</span>(max_next_log_number);</span><br><span class="line">  edit_-&gt;<span class="built_in">SetColumnFamily</span>(cfd_-&gt;<span class="built_in">GetID</span>());</span><br><span class="line"></span><br><span class="line">  meta_.fd = <span class="built_in">FileDescriptor</span>(versions_-&gt;<span class="built_in">NewFileNumber</span>(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  meta_.epoch_number = cfd_-&gt;<span class="built_in">NewEpochNumber</span>();</span><br><span class="line"></span><br><span class="line">  base_ = cfd_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  base_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PickMemtablesToFlush"><a href="#PickMemtablesToFlush" class="headerlink" title="PickMemtablesToFlush"></a>PickMemtablesToFlush</h3><p>SwitchMemTable 函数在调用 <code>MemTableList::Add</code> 函数向 imm_ 中插入新的 ImmtableMemTable 时，是在 <code>current-&gt;memlist_</code> 头部插入节点，因此 memlist_ 尾部是最旧的 ImmutableMemTable，头部是最新的。因此需要逆序遍历 memlist_，才能获得按照 MemTable 创建顺序的 <code>FlushJob::mems_</code>。</p>
<p>当前可能多个 FlushJob 在并发地执行，因此从 <code>current-&gt;memtables_</code> 选择 MemTable 时，需要过滤掉不符合条件的:</p>
<ul>
<li><p>MemTable::id_ &lt; max_memtable_id</p>
</li>
<li><p>MemTable::flush_in_progress_ 为 false: 即当前没有被其他 FlushJob 选中</p>
<p>由于 Flush MemTable 以及后续的 COMMIT 操作都需要保持顺序，因此，如果发现 flush_in_progress_ 为 true，则中断本次 Pick 操作，这样能保证选中的 <code>mems_</code> 是连续创建的。</p>
</li>
</ul>
<p>在 SwitchMemTable 函数中，将 old_mem 添加到 <code>current-&gt;memlist_</code> 之前会先调用 <code>MemTableList::FlushRequested</code>，将 <em>flush_requested_</em> 设置为 true，表示该 CF 的 memlist_ 当前等待 Flush 操作。接着在 <code>MemTable::Add</code> 函数中会递增 <em>num_flush_not_started_</em> ，表示 memlist_ 中尚未被 Picked 的 MemTable 数量。</p>
<p>当 flush_requested_ 为 true 并且 num_flush_not_started_ &gt; 0，则 <code>IsFlushPending</code> 返回 true，则该 CF 可以触发下一次 FlushJob。</p>
<p>直到 <code>PickMemtablesToFlush</code> 函数执行完，如果 <em>num_flush_not_started_</em> 为 0， 会将 <code>flush_requested_</code> 设置为 false，表示已经所有待 Picked 的 MemTable 都已选中了，准备进行 Flush。如果后续 Flush 流程失败，会调用 <code>RollbackMemtableFlush</code> 函数进行回滚，恢复状态。</p>
<p>最后，有个基于 RAII 设计的类 <code>AutoThreadOperationStageUpdater</code>，用来表征当前 FlushJob 线程的执行状态。 该函数核心代码及注释如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTableList::PickMemtablesToFlush</span><span class="params">(<span class="type">uint64_t</span> max_memtable_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        autovector&lt;MemTable*&gt;* ret,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint64_t</span>* max_next_log_number)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_PICK_MEMTABLES_TO_FLUSH)</span></span>;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; memlist = current_-&gt;memlist_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = memlist.<span class="built_in">rbegin</span>(); it != memlist.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    MemTable* m = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤超过 max_memtable_id 的 MemTable</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;<span class="built_in">GetID</span>() &gt; max_memtable_id) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;flush_in_progress_) &#123;</span><br><span class="line">      <span class="comment">// 还没被添加到某个 Flush 任务中</span></span><br><span class="line">      num_flush_not_started_--;</span><br><span class="line">      <span class="keyword">if</span> (num_flush_not_started_ == <span class="number">0</span>) &#123;</span><br><span class="line">        imm_flush_needed.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置标志位: 表示被 Picked</span></span><br><span class="line">      m-&gt;flush_in_progress_ = <span class="literal">true</span>;  </span><br><span class="line">      <span class="keyword">if</span> (max_next_log_number) &#123;</span><br><span class="line">        *max_next_log_number =</span><br><span class="line">            std::<span class="built_in">max</span>(m-&gt;<span class="built_in">GetNextLogNumber</span>(), *max_next_log_number);</span><br><span class="line">      &#125;</span><br><span class="line">      ret-&gt;<span class="built_in">push_back</span>(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ret-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// 遇到已经被其他 Flush 线程选中的 memtable，中断</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (num_flush_not_started_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// start-flush request is complete</span></span><br><span class="line">    flush_requested_ = <span class="literal">false</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RollbackMemtableFlush"><a href="#RollbackMemtableFlush" class="headerlink" title="RollbackMemtableFlush"></a>RollbackMemtableFlush</h3><p>如果后续的 Flush 任务执行失败，<em>mems_</em> 不会从 <code>memlist_</code> 中删除，则只需要把 PickMemtablesToFlush 中修改的状态重置即可，等待下一次 Flush。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTableList::RollbackMemtableFlush</span><span class="params">(<span class="type">const</span> autovector&lt;MemTable*&gt;&amp; mems,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">uint64_t</span> <span class="comment">/*file_number*/</span>)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_MEMTABLE_ROLLBACK)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置状态</span></span><br><span class="line">  <span class="keyword">for</span> (MemTable* m : mems) &#123;</span><br><span class="line">    m-&gt;flush_in_progress_ = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;flush_completed_ = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;edit_.<span class="built_in">Clear</span>();</span><br><span class="line">    num_flush_not_started_++;</span><br><span class="line">  &#125;</span><br><span class="line">  imm_flush_needed.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FlushJob-Run"><a href="#FlushJob-Run" class="headerlink" title="FlushJob::Run"></a>FlushJob::Run</h2><p>FlushJob 目前（branch-8.2.fb）有两种实现：</p>
<ul>
<li>默认将 MemTables 中的数据写入 level0，</li>
<li>设置 <em>experimental_mempurge_threshold &gt; 0</em>，开启内存裁剪（Memory Purge）。</li>
</ul>
<p>本文只讲解默认实现，MemoryPurge 后续有空再说。默认的 FlushJob::Run 流程主要有两个部分：</p>
<ol>
<li>根据选中的 <em>mems_</em> 生成 SST 并写入 level0，由 <code>file_meta</code> 记录该 SST 文件元数据</li>
<li>如果 step(1) 成功则更新 CF 的 version，并将本次更新记录 <em>FlushJob::edit_</em> 序列化后写入到 MANIFEST 中</li>
<li>如果 step(1) 不成功，则 <code>RollbackMemtableFlush</code> 进行回滚。</li>
</ol>
<p><code>FlushJob::Run</code> 核心代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FlushJob::Run</span><span class="params">(LogsWithPrepTracker* prep_tracker, FileMetaData* file_meta,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">bool</span>* switched_to_mempurge)</span> </span>&#123;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_run</span><span class="params">(ThreadStatus::STAGE_FLUSH_RUN)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mems_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 1. 将 mems_ 写入 level0</span></span><br><span class="line">  Status s = <span class="built_in">WriteLevel0Table</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 2. 判断 Flush 结果</span></span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">RollbackMemtableFlush</span>(mems_, meta_.fd.<span class="built_in">GetNumber</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (write_manifest_) &#123;</span><br><span class="line">    <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">    s = cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">TryInstallMemtableFlushResults</span>(</span><br><span class="line">        cfd_, mutable_cf_options_, mems_, prep_tracker, versions_, db_mutex_,</span><br><span class="line">        meta_.fd.<span class="built_in">GetNumber</span>(), &amp;job_context_-&gt;memtables_to_free, db_directory_,</span><br><span class="line">        log_buffer_, &amp;committed_flush_jobs_info_, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; file_meta != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *file_meta = meta_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="WriteLevel0Table"><a href="#WriteLevel0Table" class="headerlink" title="WriteLevel0Table"></a>WriteLevel0Table</h3><p>WriteLevel0Table 核心部分主要有三个部分，每个部分都很复杂，值得单独开一期讲解，这里主要讲解下每个部分的作用：</p>
<ul>
<li><p>NewMergingIterator: 用于将输入的多个 MemTable&#x2F;SST 合并成一个有序的数据流</p>
<p>在 <code>merger_test.cc</code> 的测试用例中，对于多批次随机数据，<code>NewMergingIterator</code> 合并多个数据流后表现和 <code>VectorIterator</code> 表现的一致，都是有序输出。</p>
<p>多批输入数据流打平后再输入给 VectorIterator，在 VectorIterator 构造函数中对输入的数据流基于 <code>std::sort</code> 排序，因此 VectorIterator 的输出是全局有序的。而 NewMergingIterator 的输出和 VectorIterator 是一致的，则说明 NewMergingIterator 的作用是合并输入流并使输出有序，不过更加高效。</p>
</li>
<li><p>range_del_iter</p>
<p>NewMergingIterator 只是将输入数据排序好，但是通常上层应用也会进行删除操作。在 MemTable 中，专门为 <em>DeleteRange</em> 操作单独分配了个 range_del_table_。当插入数据是 kTypeRangeDeletion 类型时，则将数据写入 range_del_table_。因此，在遍历 MemTable 时，也需要考虑 range_del_iter 来过滤那些已经被删除的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in MemTable::Add function</span></span><br><span class="line">std::unique_ptr&lt;MemTableRep&gt;&amp; table =</span><br><span class="line">    type == kTypeRangeDeletion </span><br><span class="line">    ? range_del_table_ </span><br><span class="line">    : table_;</span><br></pre></td></tr></table></figure>

<p>关于 range_delete 操作的详细设计可以参考 <a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/DeleteRange-Implementation">DeleteRange-Implementation</a>，后续有时间再讲解其中细节。</p>
</li>
<li><p>BuildTable</p>
<p>内部流程：<code>CompactionIterator</code> 基于 {NewMergingIterator, range_del_iter} 过滤已删除数据并输出全局有序的数据，可以通过 CompactionIterator::Next 进行迭代遍历，获得输出 <code>&#123;key, value&#125;</code>，再用 TableBuilder::Add 函数将该 {key, value} 添加到 level0 的新 SST 文件中。运行结束，新生成的 level0 SST 的元信息保存在 <em>meta_</em> 中。</p>
</li>
</ul>
<p>实际上，Compaction 的核心流程也是这三个部分，逻辑流程都是一样的，后续会专注分析每个具体的部分。<code>WriteLevel0Table</code> 核心流程如下代码注释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FlushJob::WriteLevel0Table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_FLUSH_WRITE_L0)</span></span>;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  std::vector&lt;BlobFileAddition&gt; blob_file_additions;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> write_hint = cfd_-&gt;<span class="built_in">CalculateSSTWriteHint</span>(<span class="number">0</span>);</span><br><span class="line">    Env::IOPriority io_priority = <span class="built_in">GetRateLimiterPriorityForWrite</span>();</span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;InternalIterator*&gt; memtables;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;FragmentedRangeTombstoneIterator&gt;&gt;</span><br><span class="line">        range_del_iters;</span><br><span class="line">    ReadOptions ro;</span><br><span class="line">    ro.total_order_seek = <span class="literal">true</span>;</span><br><span class="line">    ro.io_activity = Env::IOActivity::kFlush;</span><br><span class="line">    Arena arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从 MemTables 构建 range_delete_iter，获悉哪些 keys 已被删除</span></span><br><span class="line">    <span class="keyword">for</span> (MemTable* m : mems_) &#123;</span><br><span class="line">      <span class="keyword">auto</span>* range_del_iter = m-&gt;<span class="built_in">NewRangeTombstoneIterator</span>(</span><br><span class="line">          ro, kMaxSequenceNumber, <span class="literal">true</span> <span class="comment">/* immutable_memtable */</span>);</span><br><span class="line">      <span class="keyword">if</span> (range_del_iter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        range_del_iters.<span class="built_in">emplace_back</span>(range_del_iter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 2. 合并多个 memtable 迭代器，使得 memtables 能有序输出</span></span><br><span class="line">      <span class="function">ScopedArenaIterator <span class="title">iter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          NewMergingIterator(&amp;cfd_-&gt;internal_comparator(), memtables.data(),</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">static_cast</span>&lt;<span class="type">int</span>&gt;(memtables.size()), &amp;arena))</span></span>;</span><br><span class="line">      <span class="type">int64_t</span> _current_time = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">auto</span> status = clock_-&gt;<span class="built_in">GetCurrentTime</span>(&amp;_current_time);</span><br><span class="line">      <span class="type">const</span> <span class="type">uint64_t</span> current_time = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(_current_time);</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> oldest_key_time = mems_.<span class="built_in">front</span>()-&gt;<span class="built_in">ApproximateOldestKeyTime</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// It&#x27;s not clear whether oldest_key_time is always available. In case</span></span><br><span class="line">      <span class="comment">// it is not available, use current_time.</span></span><br><span class="line">      <span class="type">uint64_t</span> oldest_ancester_time = std::<span class="built_in">min</span>(current_time, oldest_key_time);</span><br><span class="line"></span><br><span class="line">      meta_.oldest_ancester_time = oldest_ancester_time;</span><br><span class="line">      meta_.file_creation_time = current_time;</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> num_input_entries = <span class="number">0</span>;</span><br><span class="line">      <span class="type">uint64_t</span> memtable_payload_bytes = <span class="number">0</span>;</span><br><span class="line">      <span class="type">uint64_t</span> memtable_garbage_bytes = <span class="number">0</span>;</span><br><span class="line">      IOStatus io_s;</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> std::string* <span class="type">const</span> full_history_ts_low =</span><br><span class="line">          (full_history_ts_low_.<span class="built_in">empty</span>()) ? <span class="literal">nullptr</span> : &amp;full_history_ts_low_;</span><br><span class="line">      <span class="function">TableBuilderOptions <span class="title">tboptions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          *cfd_-&gt;ioptions(), mutable_cf_options_, cfd_-&gt;internal_comparator(),</span></span></span><br><span class="line"><span class="params"><span class="function">          cfd_-&gt;int_tbl_prop_collector_factories(), output_compression_,</span></span></span><br><span class="line"><span class="params"><span class="function">          mutable_cf_options_.compression_opts, cfd_-&gt;GetID(), cfd_-&gt;GetName(),</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="number">0</span> <span class="comment">/* level */</span>, <span class="literal">false</span> <span class="comment">/* is_bottommost */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          TableFileCreationReason::kFlush, oldest_key_time, current_time,</span></span></span><br><span class="line"><span class="params"><span class="function">          db_id_, db_session_id_, <span class="number">0</span> <span class="comment">/* target_file_size */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          meta_.fd.GetNumber())</span></span>;</span><br><span class="line">      <span class="type">const</span> SequenceNumber job_snapshot_seq =</span><br><span class="line">          job_context_-&gt;<span class="built_in">GetJobSnapshotSequence</span>();</span><br><span class="line">      <span class="function"><span class="type">const</span> ReadOptions <span class="title">read_options</span><span class="params">(Env::IOActivity::kFlush)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 合并多个 memtables 的数据，输出到 level0 sst 中</span></span><br><span class="line">      s = <span class="built_in">BuildTable</span>(dbname_, versions_, db_options_, tboptions, file_options_,</span><br><span class="line">                     read_options, cfd_-&gt;<span class="built_in">table_cache</span>(), iter.<span class="built_in">get</span>(),</span><br><span class="line">                     std::<span class="built_in">move</span>(range_del_iters), &amp;meta_, &amp;blob_file_additions,</span><br><span class="line">                     existing_snapshots_, earliest_write_conflict_snapshot_,</span><br><span class="line">                     job_snapshot_seq, snapshot_checker_,</span><br><span class="line">                     mutable_cf_options_.paranoid_file_checks,</span><br><span class="line">                     cfd_-&gt;<span class="built_in">internal_stats</span>(), &amp;io_s, io_tracer_,</span><br><span class="line">                     BlobFileCreationReason::kFlush, seqno_to_time_mapping_,</span><br><span class="line">                     event_logger_, job_context_-&gt;job_id, io_priority,</span><br><span class="line">                     &amp;table_properties_, write_hint, full_history_ts_low,</span><br><span class="line">                     blob_callback_, base_, &amp;num_input_entries,</span><br><span class="line">                     &amp;memtable_payload_bytes, &amp;memtable_garbage_bytes);</span><br><span class="line">     <span class="comment">//... handle error</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 4. 尝试 SYNC SST 目录</span></span><br><span class="line">     <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; output_file_directory_ != <span class="literal">nullptr</span> &amp;&amp; sync_output_directory_) &#123;</span><br><span class="line">      s = output_file_directory_-&gt;<span class="built_in">FsyncWithDirOptions</span>(</span><br><span class="line">          <span class="built_in">IOOptions</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">          <span class="built_in">DirFsyncOptions</span>(DirFsyncOptions::FsyncReason::kNewFileSynced));</span><br><span class="line">    &#125;</span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  base_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> has_output = meta_.fd.<span class="built_in">GetFileSize</span>() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 将生成的 level0 文件元数据信息写入 VersionEdit </span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; has_output) &#123;</span><br><span class="line">    <span class="comment">// Add file to L0</span></span><br><span class="line">    edit_-&gt;<span class="built_in">AddFile</span>(<span class="number">0</span> <span class="comment">/* level */</span>, meta_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Piggyback FlushJobInfo on the first first flushed memtable.</span></span><br><span class="line">  mems_[<span class="number">0</span>]-&gt;<span class="built_in">SetFlushJobInfo</span>(<span class="built_in">GetFlushJobInfo</span>());</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TryInstallMemtableFlushResults"><a href="#TryInstallMemtableFlushResults" class="headerlink" title="TryInstallMemtableFlushResults"></a>TryInstallMemtableFlushResults</h3><p>如果上一步 <code>WriteLevel0Table</code> 成功，则需要将 Flush 的信息 COMMIT 到 MANIFEST。实际上 MANIFEST 可以视为 transaction log，保存着每次 Flush&#x2F;Compaction 的记录。</p>
<p>当前可能有多个线程在并发执行 Flush 操作，但是只能有一个线程能 COMMIT：率先进入的此函数的线程，它先将 <code>commit_in_progress_</code> 设置为 true，来阻止后来的线程。因此判断 commit_in_progress_ 是否为 true 是个分界点：</p>
<ul>
<li><p>之前：所有 Flush 线程都都先更新 mems[i] 的 {flush_completed_, file_number_} 状态</p>
<p> flush_completed_ 表示 mems[i] 已经成功 Flush，file_number_ 则是指向 Flush 后生成的 SST 文件。 由于 mems 是 Flush 线程的局部变量，因此这一步操作线程安全。</p>
</li>
<li><p>之后</p>
<p>由于只有一个线程能进行 COMMIT。因此 COMMIT 对象是 <em>memlist_</em> 中所有已经 Flushed MemTable，即进入此函数的线程会将所有 Flush 线程中的 mems 一起 COMMIT。 后面进入此函数的线程发现 commit_in_progress_ 为 false 则直接返回。</p>
<p>其次，COMMIT 也需要按照 MemTable 的创建顺序，即 <code>MemTable::id_</code> 递增的顺序，因此需要逆序遍历 memlist_，并且如果中途某个 MemTable 在 WriteLevel0Table 中失败了，则需要中断当前 COMMIT 操作，只能将前面成功 Flush 的连续 MemTables 的 VersionEdit 写入 MANIFEST，并在回调函数 <code>RemoveMemTablesOrRestoreFlags</code> 中将这部分 MemTable 从 memlist_ 中删除。</p>
<p>因此，Flush 失败的 MemTable 就会变成 oldeest memtable，等待下一次 FlushJob 再次选择它，重复上述执行流程。</p>
</li>
</ul>
<p>这部分代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MemTableList::TryInstallMemtableFlushResults</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ColumnFamilyData* cfd, <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> autovector&lt;MemTable*&gt;&amp; mems, LogsWithPrepTracker* prep_tracker,</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionSet* vset, InstrumentedMutex* mu, <span class="type">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">    autovector&lt;MemTable*&gt;* to_delete, FSDirectory* db_directory,</span></span></span><br><span class="line"><span class="params"><span class="function">    LogBuffer* log_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::list&lt;std::unique_ptr&lt;FlushJobInfo&gt;&gt;* committed_flush_jobs_info,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> write_edits)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_MEMTABLE_INSTALL_FLUSH_RESULTS)</span></span>;</span><br><span class="line">  mu-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> ReadOptions <span class="title">read_options</span><span class="params">(Env::IOActivity::kFlush)</span></span>;</span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 更改所有成功 Flush 的 MemTable 状态</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mems.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    mems[i]-&gt;flush_completed_ = <span class="literal">true</span>;</span><br><span class="line">    mems[i]-&gt;file_number_ = file_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 分界点: 只有一个线程可以 commit</span></span><br><span class="line">  <span class="keyword">if</span> (commit_in_progress_) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 commit 流程</span></span><br><span class="line">  commit_in_progress_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; memlist = current_-&gt;memlist_;</span><br><span class="line">    <span class="comment">// 3. 遇到 Flush 失败的 memtable 则中断</span></span><br><span class="line">    <span class="keyword">if</span> (memlist.<span class="built_in">empty</span>() || !memlist.<span class="built_in">back</span>()-&gt;flush_completed_) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> batch_file_number = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> batch_count = <span class="number">0</span>;</span><br><span class="line">    autovector&lt;VersionEdit*&gt; edit_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照 memtable 创建的顺序 scan and commit</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = memlist.<span class="built_in">rbegin</span>(); it != memlist.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">      MemTable* m = *it;</span><br><span class="line">      <span class="comment">// 3.1 遇到 Flush 失败的 memtable 则中断</span></span><br><span class="line">      <span class="keyword">if</span> (!m-&gt;flush_completed_) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遇到一个新的 FlushJob</span></span><br><span class="line">      <span class="comment">// 此时 file_number_ 和 edit 都是新的</span></span><br><span class="line">      <span class="keyword">if</span> (it == memlist.<span class="built_in">rbegin</span>() || batch_file_number != m-&gt;file_number_) &#123;</span><br><span class="line">        batch_file_number = m-&gt;file_number_;</span><br><span class="line">        edit_list.<span class="built_in">push_back</span>(&amp;m-&gt;edit_);</span><br><span class="line">        std::unique_ptr&lt;FlushJobInfo&gt; info = m-&gt;<span class="built_in">ReleaseFlushJobInfo</span>();</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          committed_flush_jobs_info-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(info));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      batch_count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 commit 已经 Flush 成功的</span></span><br><span class="line">    <span class="keyword">if</span> (batch_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 计算当前 oldest_wal</span></span><br><span class="line">      <span class="type">uint64_t</span> min_wal_number_to_keep =</span><br><span class="line">          <span class="built_in">PrecomputeMinLogNumberToKeepNon2PC</span>(vset, *cfd, edit_list);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// logfile_num &lt; min_wal_number_to_keep 都应该删除</span></span><br><span class="line">      VersionEdit wal_deletion;</span><br><span class="line">      wal_deletion.<span class="built_in">SetMinLogNumberToKeep</span>(min_wal_number_to_keep);</span><br><span class="line">      <span class="keyword">if</span> (vset-&gt;<span class="built_in">db_options</span>()-&gt;track_and_verify_wals_in_manifest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_wal_number_to_keep &gt;</span><br><span class="line">            vset-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">GetMinWalNumberToKeep</span>()) &#123;</span><br><span class="line">          wal_deletion.<span class="built_in">DeleteWalsBefore</span>(min_wal_number_to_keep);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      edit_list.<span class="built_in">push_back</span>(&amp;wal_deletion);</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> manifest_write_cb = [<span class="keyword">this</span>, cfd, batch_count, log_buffer,</span><br><span class="line">                                      to_delete, mu](<span class="type">const</span> Status&amp; status) &#123;</span><br><span class="line">        <span class="comment">// 从 memlist_ 中删除 flushed memtable</span></span><br><span class="line">        <span class="built_in">RemoveMemTablesOrRestoreFlags</span>(status, cfd, batch_count, log_buffer,</span><br><span class="line">                                      to_delete, mu);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 写入 MANIFEST</span></span><br><span class="line">      s = vset-&gt;<span class="built_in">LogAndApply</span>(cfd, mutable_cf_options, read_options, edit_list,</span><br><span class="line">                            mu, db_directory, <span class="comment">/*new_descriptor_log=*/</span><span class="literal">false</span>,</span><br><span class="line">                            <span class="comment">/*column_family_options=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">                            manifest_write_cb);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 退出 commit 流程</span></span><br><span class="line">  commit_in_progress_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PrecomputeMinLogNumberToKeepNon2PC"><a href="#PrecomputeMinLogNumberToKeepNon2PC" class="headerlink" title="PrecomputeMinLogNumberToKeepNon2PC"></a>PrecomputeMinLogNumberToKeepNon2PC</h3><p>PrecomputeMinLogNumberToKeepNon2PC 函数返回的 <code>min_wal_number_to_keep</code> 用来删除满足 logfile_num &lt; min_wal_number_to_keep 条件的 WAL。由于 min_wal_number_to_keep 也写入 VersionEdit 并最终序列化到 MANIFEST，因此在 Recovery 过程中，如果磁盘上存在部分这些 WAL 也会被忽略，不会被加载。</p>
<p>min_log_number_to_keep 的计算分为三个阶段：</p>
<ol>
<li>每个 <code>FlushJob::edit_</code> 中记录的 <code>log_number_</code> 是在 <code>FlushJob::PickMemTable</code> 函数中设置，指向了每个 CF 最大可以删除的 WAL</li>
</ol>
<p>  因为 CF memlist_ 指向的 WAL 对于当前 CF 来说都是可以删除的，因此 FlushJob::mems_[-1]-&gt;GetNextLogNumber() 就是FlushJob::edit_::log_numer_ 能取到的最大值。通过迭代不同 FlushJob 的 edit_，则可以获得所有 FlushJobs 中最小的 log_number_ ，作为 min_log_number_to_keep</p>
<ol start="2">
<li><p>ColumnFamilyData::log_number_ 字段记录了 CF 当前指向的 WAL 文件。因此小于 <code>ColumnFamilyData::log_number_</code> 的 WAL 对于当前 CF 来说都可以删除。</p>
<p>这一步和 step(1) 是互斥的，如果没有成功执行的 FlushJobs，则 step(1) 中不会修改 min_log_number_to_keep 的值，此时就会进入 step(2)，来获得他们中最小的 <code>min_log_number_to_keep</code>；</p>
</li>
<li><p>再检查没有执行 Flush 的或者 Flush 失败的的 CFs 的 <code>ColumnFamilyData::log_number_</code> 字段，和 <code>min_log_number_to_keep</code> 进行比较最小值</p>
</li>
</ol>
<p>上述三步结束，所得的 <code>min_log_number_to_keep</code> 即生命周期没有结束的最小 WAL：所有满足 <code>logfile_num &lt; min_log_number_to_keep</code> 的 WAL 可以安全地从磁盘上删除了，Recovery 期间也不会被加载了，即生命周期可以结束了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">PrecomputeMinLogNumberToKeepNon2PC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionSet* vset, <span class="type">const</span> autovector&lt;ColumnFamilyData*&gt;&amp; cfds_to_flush,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> autovector&lt;autovector&lt;VersionEdit*&gt;&gt;&amp; edit_lists)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> min_log_number_to_keep = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 检测 min_log_number_to_keep</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edit_list : edit_lists) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> log = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edit_list) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e-&gt;<span class="built_in">HasLogNumber</span>()) &#123;</span><br><span class="line">        log = std::<span class="built_in">max</span>(log, e-&gt;<span class="built_in">GetLogNumber</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (log != <span class="number">0</span>) &#123;</span><br><span class="line">      min_log_number_to_keep = std::<span class="built_in">min</span>(min_log_number_to_keep, log);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如果 edit_lists 为空</span></span><br><span class="line">  <span class="keyword">if</span> (min_log_number_to_keep == std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">    min_log_number_to_keep = cfds_to_flush[<span class="number">0</span>]-&gt;<span class="built_in">GetLogNumber</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; cfds_to_flush.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      min_log_number_to_keep =</span><br><span class="line">          std::<span class="built_in">min</span>(min_log_number_to_keep, cfds_to_flush[i]-&gt;<span class="built_in">GetLogNumber</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 检测没有 Flush 或者 Flush 失败的 CFs</span></span><br><span class="line">  <span class="function">std::unordered_set&lt;<span class="type">const</span> ColumnFamilyData*&gt; <span class="title">flushed_cfds</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      cfds_to_flush.begin(), cfds_to_flush.end())</span></span>;</span><br><span class="line">  min_log_number_to_keep =</span><br><span class="line">      std::<span class="built_in">min</span>(min_log_number_to_keep,</span><br><span class="line">               vset-&gt;<span class="built_in">PreComputeMinLogNumberWithUnflushedData</span>(flushed_cfds));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> min_log_number_to_keep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">PreComputeMinLogNumberWithUnflushedData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">const</span> ColumnFamilyData* cfd_to_skip)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="type">uint64_t</span> min_log_num = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> cfd : *column_family_set_) &#123;</span><br><span class="line">   <span class="comment">// 跳过 step(2) 中处理过的 CF</span></span><br><span class="line">   <span class="keyword">if</span> (cfd == cfd_to_skip) &#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 和 min_log_num 取较小值</span></span><br><span class="line">   <span class="keyword">if</span> (min_log_num &gt; cfd-&gt;<span class="built_in">GetLogNumber</span>() &amp;&amp; !cfd-&gt;<span class="built_in">IsDropped</span>()) &#123;</span><br><span class="line">     min_log_num = cfd-&gt;<span class="built_in">GetLogNumber</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> min_log_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FindObsoleteFiles"><a href="#FindObsoleteFiles" class="headerlink" title="FindObsoleteFiles"></a>FindObsoleteFiles</h2><p>上述获得 <code>min_log_number_to_keep</code> 后，会生成一个 VersionEdit 对象 wal_deletion，它写入 MANIFEST 的过程中，会更新<code>VersionSet::min_log_number_to_keep_</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in function: VersionSet::ProcessManifestWrites</span></span><br><span class="line"><span class="type">uint64_t</span> last_min_log_number_to_keep = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : batch_edits) &#123;</span><br><span class="line">  <span class="comment">//... other code</span></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;has_min_log_number_to_keep_) &#123;</span><br><span class="line">    last_min_log_number_to_keep =</span><br><span class="line">        std::<span class="built_in">max</span>(last_min_log_number_to_keep, e-&gt;min_log_number_to_keep_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (last_min_log_number_to_keep != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">MarkMinLogNumberToKeep</span>(last_min_log_number_to_keep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 FindObsoleteFiles 函数中，会根据 <code>VersionSet::min_log_number_to_keep_</code> 来判断一个 WAL 的生命周期是否已经结束：已经结束的则加入 <code>JobContextl::log_delete_files</code> 中，在 <code>PurgeObsoleteFiles</code> 函数中从磁盘上删除该文件，再释放 <code>JobContextl::logs_to_free_</code> 中记录的 <code>LogWriter</code> 内存。</p>
<p>到此，一个 WAL 生命周期才算结束。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VersionSet::MarkMinLogNumberToKeep</span><span class="params">(<span class="type">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (min_log_number_to_keep_.<span class="built_in">load</span>(std::memory_order_relaxed) &lt; number) &#123;</span><br><span class="line">   min_log_number_to_keep_.<span class="built_in">store</span>(number, std::memory_order_relaxed);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::FindObsoleteFiles</span><span class="params">(JobContext* job_context, <span class="type">bool</span> force,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> no_full_scan)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//... ignore other code...</span></span><br><span class="line">  job_context-&gt;log_number = versions_-&gt;<span class="built_in">min_log_number_to_keep</span>();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (alive_log_files_.<span class="built_in">empty</span>() || logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!alive_log_files_.<span class="built_in">empty</span>() &amp;&amp; !logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// logfile_num &lt;= min_log_number 都应该删除</span></span><br><span class="line">    <span class="type">uint64_t</span> min_log_number = job_context-&gt;log_number;</span><br><span class="line">    <span class="type">size_t</span> num_alive_log_files = alive_log_files_.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检测新的 obsoleted WAL files，即生命周期已结束的</span></span><br><span class="line">    <span class="keyword">while</span> (alive_log_files_.<span class="built_in">begin</span>()-&gt;number &lt; min_log_number) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; earliest = *alive_log_files_.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否回收，不收回则加入待删除队列</span></span><br><span class="line">      <span class="keyword">if</span> (immutable_db_options_.recycle_log_file_num &gt; log_recycle_files_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        log_recycle_files_.<span class="built_in">push_back</span>(earliest.number);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        job_context-&gt;log_delete_files.<span class="built_in">push_back</span>(earliest.number);</span><br><span class="line">      &#125;</span><br><span class="line">      alive_log_files_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检测待释的 LogWriter</span></span><br><span class="line">    log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    <span class="keyword">while</span> (!logs_.<span class="built_in">empty</span>() &amp;&amp; logs_.<span class="built_in">front</span>().number &lt; min_log_number) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; log = logs_.<span class="built_in">front</span>();</span><br><span class="line">      <span class="keyword">if</span> (log.<span class="built_in">IsSyncing</span>()) &#123;</span><br><span class="line">        log_sync_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      logs_to_free_.<span class="built_in">push_back</span>(log.<span class="built_in">ReleaseWriter</span>());</span><br><span class="line">      logs_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job_context-&gt;logs_to_free = logs_to_free_;</span><br><span class="line">  logs_to_free_.<span class="built_in">clear</span>();</span><br><span class="line">  log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 回收</span></span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  job_context-&gt;log_recycle_files.<span class="built_in">assign</span>(log_recycle_files_.<span class="built_in">begin</span>(),</span><br><span class="line">                                        log_recycle_files_.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PickMemTable"><span class="toc-number">1.</span> <span class="toc-text">PickMemTable</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PickMemtablesToFlush"><span class="toc-number">1.1.</span> <span class="toc-text">PickMemtablesToFlush</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RollbackMemtableFlush"><span class="toc-number">1.2.</span> <span class="toc-text">RollbackMemtableFlush</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FlushJob-Run"><span class="toc-number">2.</span> <span class="toc-text">FlushJob::Run</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WriteLevel0Table"><span class="toc-number">2.1.</span> <span class="toc-text">WriteLevel0Table</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TryInstallMemtableFlushResults"><span class="toc-number">2.2.</span> <span class="toc-text">TryInstallMemtableFlushResults</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PrecomputeMinLogNumberToKeepNon2PC"><span class="toc-number">2.3.</span> <span class="toc-text">PrecomputeMinLogNumberToKeepNon2PC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FindObsoleteFiles"><span class="toc-number">3.</span> <span class="toc-text">FindObsoleteFiles</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&text=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&title=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&is_video=false&description=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=WAL、MemTable 的生命周期管理(3)&body=Check out this article: https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&title=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&title=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&title=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&title=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&name=WAL、MemTable 的生命周期管理(3)&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/&t=WAL、MemTable 的生命周期管理(3)"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
