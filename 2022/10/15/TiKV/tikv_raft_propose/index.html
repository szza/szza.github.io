<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="PollHandler::handle_normal12345678910111213141516171819202122232425262728293031fn handle_normal(&amp;mut self, peer: &amp;mut impl DerefMut&lt;Target &#x3D; PeerFsm&lt;EK, ER&gt;&gt;) -&gt; HandleResult &amp;#">
<meta property="og:type" content="article">
<meta property="og:title" content="tikv: RaftStore propose 过程">
<meta property="og:url" content="https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="PollHandler::handle_normal12345678910111213141516171819202122232425262728293031fn handle_normal(&amp;mut self, peer: &amp;mut impl DerefMut&lt;Target &#x3D; PeerFsm&lt;EK, ER&gt;&gt;) -&gt; HandleResult &amp;#">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-15T02:00:01.000Z">
<meta property="article:modified_time" content="2023-09-02T04:51:22.000Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="tidb-v6.1">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>tikv: RaftStore propose 过程</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2022/10/21/TiFlash/tiflash_region/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022/10/13/TiKV/tikv_batch_system/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&text=tikv: RaftStore propose 过程"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&title=tikv: RaftStore propose 过程"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&is_video=false&description=tikv: RaftStore propose 过程"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=tikv: RaftStore propose 过程&body=Check out this article: https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&title=tikv: RaftStore propose 过程"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&title=tikv: RaftStore propose 过程"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&title=tikv: RaftStore propose 过程"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&title=tikv: RaftStore propose 过程"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&name=tikv: RaftStore propose 过程&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&t=tikv: RaftStore propose 过程"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PollHandler-handle-normal"><span class="toc-number">1.</span> <span class="toc-text">PollHandler::handle_normal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Propose"><span class="toc-number">1.1.</span> <span class="toc-text">Propose</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PeerFsmDelegate-propose-batch-raft-command"><span class="toc-number">1.1.1.</span> <span class="toc-text">PeerFsmDelegate::propose_batch_raft_command</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PeerFsmDelegate-propose-raft-command-internal"><span class="toc-number">1.1.2.</span> <span class="toc-text">PeerFsmDelegate::propose_raft_command_internal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ready"><span class="toc-number">1.2.</span> <span class="toc-text">Ready</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Peer-handle-raft-ready-append-before-ready"><span class="toc-number">1.2.1.</span> <span class="toc-text">Peer::handle_raft_ready_append(before ready)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Peer-handle-raft-ready-append-after-ready"><span class="toc-number">1.2.2.</span> <span class="toc-text">Peer::handle_raft_ready_append(after ready)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PeerStorage-snapshot"><span class="toc-number">1.2.3.</span> <span class="toc-text">PeerStorage::snapshot</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyFsm-handle-snapshot"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">ApplyFsm::handle_snapshot</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SnapContext-generate-snap"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">SnapContext::generate_snap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#store-do-snapshot"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">store::do_snapshot</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplyFsm-handle-apply"><span class="toc-number">1.2.4.</span> <span class="toc-text">ApplyFsm::handle_apply</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyFsm-append-proposal"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">ApplyFsm::append_proposal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyDelegate-handle-raft-committed-entries"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">ApplyDelegate::handle_raft_committed_entries</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyContext-prepare-for"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">ApplyContext::prepare_for</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyContext-commit"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">ApplyContext::commit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyContext-write-to-db"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">ApplyContext::write_to_db</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyContext-finish-for"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">ApplyContext::finish_for</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyDelegate-handle-raft-entry-normal"><span class="toc-number">1.2.4.7.</span> <span class="toc-text">ApplyDelegate::handle_raft_entry_normal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyDelegate-end"><span class="toc-number">1.2.4.8.</span> <span class="toc-text">ApplyDelegate::end</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyContext-flush"><span class="toc-number">1.2.4.9.</span> <span class="toc-text">ApplyContext::flush</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PeerStorage-handle-raft-ready"><span class="toc-number">1.2.5.</span> <span class="toc-text">PeerStorage::handle_raft_ready</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Advance"><span class="toc-number">1.3.</span> <span class="toc-text">Advance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PeerFsmDelegate-on-raft-message"><span class="toc-number">1.4.</span> <span class="toc-text">PeerFsmDelegate::on_raft_message</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step"><span class="toc-number">1.4.1.</span> <span class="toc-text">step</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        tikv: RaftStore propose 过程
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-10-15T02:00:01.000Z" itemprop="datePublished">2022-10-15</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/tidb-v6-1/" rel="tag">tidb-v6.1</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="PollHandler-handle-normal"><a href="#PollHandler-handle-normal" class="headerlink" title="PollHandler::handle_normal"></a>PollHandler::handle_normal</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_normal</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, peer: &amp;<span class="keyword">mut</span> <span class="keyword">impl</span> <span class="title class_">DerefMut</span>&lt;Target = PeerFsm&lt;EK, ER&gt;&gt;) <span class="punctuation">-&gt;</span> HandleResult &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">handle_result</span> = HandleResult::KeepProcessing;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">self</span>.peer_msg_buf.<span class="title function_ invoke__">len</span>() &lt; <span class="keyword">self</span>.messages_per_tick &#123;</span><br><span class="line">        <span class="keyword">match</span> peer.receiver.<span class="title function_ invoke__">try_recv</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(msg) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.peer_msg_buf.<span class="title function_ invoke__">push</span>(msg);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(TryRecvError::Empty) =&gt; &#123;</span><br><span class="line">                handle_result = HandleResult::<span class="title function_ invoke__">stop_at</span>(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(TryRecvError::Disconnected) =&gt; &#123;</span><br><span class="line">                peer.<span class="title function_ invoke__">stop</span>();</span><br><span class="line">                handle_result = HandleResult::<span class="title function_ invoke__">stop_at</span>(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">delegate</span> = PeerFsmDelegate::<span class="title function_ invoke__">new</span>(peer, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.poll_ctx);</span><br><span class="line">    delegate.<span class="title function_ invoke__">handle_msgs</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.peer_msg_buf);</span><br><span class="line">    <span class="comment">// No readiness is generated and using sync write, skipping calling ready and release early.</span></span><br><span class="line">    <span class="keyword">if</span> !delegate.<span class="title function_ invoke__">collect_ready</span>() &amp;&amp; <span class="keyword">self</span>.poll_ctx.sync_write_worker.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">HandleResult</span>::StopAt &#123; skip_end, .. &#125; = &amp;<span class="keyword">mut</span> handle_result &#123;</span><br><span class="line">            *skip_end = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handle_result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Propose"><a href="#Propose" class="headerlink" title="Propose"></a>Propose</h3><p>这里有两类 propose 方法，</p>
<ol>
<li><p>是积累 batch_propose，即积累了一定熟练的 proposal，再统一提交到状态机</p>
<p> 目前只是支持对 put&#x2F;delete 进行 batch 操作，然后调用 <code>BatchRaftCmdRequestBuilder::add</code> 方法将 put&#x2F;Delete command 缓存起来，当达到阈值<code>BatchRaftCmdRequestBuilder::should_finish</code> 返回 true，表示可以发送给 raft。</p>
<blockquote>
<p>Question: 如果没有发送出去就宕机了呢???</p>
</blockquote>
</li>
<li><p>非 Put&#x2F;Delete 指令，或者没有开启 batch 操作，就直接 propose</p>
</li>
</ol>
<p>下面以 <code>propose_batch_raft_command</code> 操作为例进行说明。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">handle_msgs</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, msgs: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;PeerMsg&lt;EK&gt;&gt;) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    PeerMsg::<span class="title function_ invoke__">RaftCommand</span>(cmd) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="title function_ invoke__">Err</span>(e)) = cmd.extra_opts.deadline.<span class="title function_ invoke__">map</span>(|deadline| deadline.<span class="title function_ invoke__">check</span>()) &#123;</span><br><span class="line">            cmd.callback.<span class="title function_ invoke__">invoke_with_response</span>(<span class="title function_ invoke__">new_error</span>(e.<span class="title function_ invoke__">into</span>()));</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">req_size</span> = cmd.request.<span class="title function_ invoke__">compute_size</span>();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.ctx.cfg.cmd_batch</span><br><span class="line">            &amp;&amp; <span class="keyword">self</span>.fsm.batch_req_builder.<span class="title function_ invoke__">can_batch</span>(&amp;<span class="keyword">self</span>.ctx.cfg, &amp;cmd.request, req_size)</span><br><span class="line">            <span class="comment">// Avoid to merge requests with different `DiskFullOpt`s into one,</span></span><br><span class="line">            <span class="comment">// so that normal writes can be rejected when proposing if the</span></span><br><span class="line">            <span class="comment">// store&#x27;s disk is full.</span></span><br><span class="line">            &amp;&amp; ((<span class="keyword">self</span>.ctx.self_disk_usage == DiskUsage::Normal</span><br><span class="line">                &amp;&amp; !<span class="keyword">self</span>.fsm.peer.disk_full_peers.<span class="title function_ invoke__">majority</span>())</span><br><span class="line">                || cmd.extra_opts.disk_full_opt == DiskFullOpt::NotAllowedOnFull)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">self</span>.fsm.batch_req_builder.<span class="title function_ invoke__">add</span>(cmd, req_size);</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.fsm.batch_req_builder.<span class="title function_ invoke__">should_finish</span>(&amp;<span class="keyword">self</span>.ctx.cfg) &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">propose_batch_raft_command</span>(<span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">propose_raft_command</span>(</span><br><span class="line">                cmd.request,</span><br><span class="line">                cmd.callback,</span><br><span class="line">                cmd.extra_opts.disk_full_opt,</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PeerFsmDelegate-propose-batch-raft-command"><a href="#PeerFsmDelegate-propose-batch-raft-command" class="headerlink" title="PeerFsmDelegate::propose_batch_raft_command"></a>PeerFsmDelegate::propose_batch_raft_command</h4><p><code>propose_batch_raft_command</code> 第二个参数 <code>force</code> 用来表示是否强制执行 propose 操作，</p>
<ul>
<li>可能为 true 的情况：<ul>
<li>当前积累的 proposals，已到达 batch 的条件；</li>
<li>在同步写入 kv-rocksdb 情况下也需要每次都 propose。</li>
</ul>
</li>
<li>如果 force 为 false，并且当前等持久化的 proposals 个数已经达到阈值 <code>cmd_batch_concurrent_ready_max_count</code>，则也拒绝当前的 propose 请求。</li>
</ul>
<p>如果上述条件 check 通过，则调用 <code>BatchRaftCmdRequestBuilder::build</code> 构建出 <code>&#123;request, callback&#125;</code>，调用 <code>propose_raft_command_internal</code> 进入 propose 状态（没有开启 batch 时，也是进入 <code>propose_raft_command_internal</code> 函数）。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">propose_batch_raft_command</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, force: <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.fsm.batch_req_builder.request.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !force</span><br><span class="line">        &amp;&amp; <span class="keyword">self</span>.ctx.cfg.cmd_batch_concurrent_ready_max_count != <span class="number">0</span></span><br><span class="line">        &amp;&amp; <span class="keyword">self</span>.fsm.peer.<span class="title function_ invoke__">unpersisted_ready_len</span>()</span><br><span class="line">            &gt;= <span class="keyword">self</span>.ctx.cfg.cmd_batch_concurrent_ready_max_count</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fail_point!(<span class="string">&quot;propose_batch_raft_command&quot;</span>, !force, |_| &#123;&#125;);</span><br><span class="line">    <span class="keyword">let</span> (request, callback) = <span class="keyword">self</span></span><br><span class="line">        .fsm</span><br><span class="line">        .batch_req_builder</span><br><span class="line">        .<span class="title function_ invoke__">build</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.ctx.raft_metrics)</span><br><span class="line">        .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">propose_raft_command_internal</span>(request, callback, DiskFullOpt::NotAllowedOnFull)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PeerFsmDelegate-propose-raft-command-internal"><a href="#PeerFsmDelegate-propose-raft-command-internal" class="headerlink" title="PeerFsmDelegate::propose_raft_command_internal"></a>PeerFsmDelegate::propose_raft_command_internal</h4><p><code>propose_raft_command_internal</code> 函数中，主要是做一些校验工作，通过之后才能完将 proposal 提交到 raft 中进行处理。</p>
<ul>
<li>当前 region 不能处于待删除的状态，即 <code>pending_remove</code> 不能为 false；</li>
<li>在 <code>pre_propose_raft_command</code> 函数中进一步 check</li>
</ul>
<p>如果成功提交到 raft 中，则返回。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">propose_raft_command_internal</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    <span class="keyword">mut</span> msg: RaftCmdRequest,</span><br><span class="line">    cb: Callback&lt;EK::Snapshot&gt;,</span><br><span class="line">    diskfullopt: DiskFullOpt,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.fsm.peer.pending_remove &#123;</span><br><span class="line">        apply::<span class="title function_ invoke__">notify_req_region_removed</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">region_id</span>(), cb); <span class="comment">// 回复客户端</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">pre_propose_raft_command</span>(&amp;msg) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(<span class="title function_ invoke__">Some</span>(resp)) =&gt; &#123;</span><br><span class="line">            cb.<span class="title function_ invoke__">invoke_with_response</span>(resp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">            debug!(</span><br><span class="line">                <span class="string">&quot;failed to propose&quot;</span>;</span><br><span class="line">                <span class="string">&quot;region_id&quot;</span> =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">region_id</span>(),</span><br><span class="line">                <span class="string">&quot;peer_id&quot;</span> =&gt; <span class="keyword">self</span>.fsm.<span class="title function_ invoke__">peer_id</span>(),</span><br><span class="line">                <span class="string">&quot;message&quot;</span> =&gt; ?msg,</span><br><span class="line">                <span class="string">&quot;err&quot;</span> =&gt; %e,</span><br><span class="line">            );</span><br><span class="line">            cb.<span class="title function_ invoke__">invoke_with_response</span>(<span class="title function_ invoke__">new_error</span>(e));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Ready"><a href="#Ready" class="headerlink" title="Ready"></a>Ready</h3><h4 id="Peer-handle-raft-ready-append-before-ready"><a href="#Peer-handle-raft-ready-append-before-ready" class="headerlink" title="Peer::handle_raft_ready_append(before ready)"></a>Peer::handle_raft_ready_append(before ready)</h4><p>根据 raft 状态机处理机制，propose 之后需要收集已 ready 的状态和数据并对其进行处理。调用链是 <code>PeerFsmDelegate::collect_ready</code> &#x3D;&gt; <code>Peer::handle_raft_ready_append</code></p>
<p><code>Peer::handle_raft_ready_append</code> 其实就是个大杂烩，里面会对各种情况进行处理，比如 leader 切换、replicate、Snapshot 处理以及 apply 已经 commit 的数据、持久化等。，因此下面的执行流程并不是表示在一次 <code>handle_raft_ready_append</code> 调用中都同时发生的，即只有处于 ready 状态，才会被执行。 </p>
<p>在 处理 ready 之前，先处理 snapshot 之前的相关状态：</p>
<ol>
<li><p>先检测当前是否存在 snapshot，如果当前 region 正在 apply snapshot，则需要等待这个过程结束，此时 <code>self.check_snap_status</code> 返回 false；3</p>
</li>
<li><p>当前 region 是否存在未 committed 的 snapshot</p>
<p> 注意，这一步检测的是 uncommitted 的 snapshot，数据的流程是从 commit &#x3D;&#x3D;&gt; apply</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">ready_to_handle_pending_snap</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">   <span class="keyword">self</span>.last_applying_idx == <span class="keyword">self</span>.<span class="title function_ invoke__">get_store</span>().<span class="title function_ invoke__">applied_index</span>()</span><br><span class="line">       &amp;&amp; <span class="keyword">self</span>.pending_request_snapshot_count.<span class="title function_ invoke__">load</span>(Ordering::SeqCst) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>destroy_regions</code> 如果当前没有待处理的 snapshot，再检测是否有待删除的 region，可能是 split&#x2F;merge 过程导致的需要删除的 region.</p>
</li>
<li><p>如果 raft 当前没有 ready，则检测是否存在待生成 snapshot 的任务，如果有，则调用 ApplyFsm 异步去生成 snapshot</p>
</li>
</ol>
<blockquote>
<p>那么就有个问题，在什么情况下 <code>self.mut_store().take_gen_snap_task()</code> 的返回值不是 <code>None</code> 呢？</p>
<p>这个 snapshot 不是由外部产生的，是 Raft 状态机在 replication 的过程自动产生的：比如新加入一个 follower，或者一个 follower 滞后的 log 较多，此时 leader 就会调用 PeerStore::snapshot 函数生成包含最新 commit 数据的 snapshot 将其发送给 follower:</p>
<ul>
<li>leader 需要生成 snapshot</li>
<li>follower 在接受到 snapshot 之后需要 apply snapshot</li>
</ul>
<p>只要等 leader &amp;&amp; follower 这个流程都执行完，Raft-group 才能处于执行 ready 状态</p>
</blockquote>
<p>下面代码是去除注释和非必要啊部分后的。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">handle_raft_ready_append</span>&lt;T: Transport&gt;(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    ctx: &amp;<span class="keyword">mut</span> PollContext&lt;EK, ER, T&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;ReadyResult&gt; &#123;</span><br><span class="line">    <span class="comment">// region 是否已删除 or 当前是否有 snapshot 正在处理</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.pending_remove &amp;&amp; !<span class="keyword">self</span>.<span class="title function_ invoke__">check_snap_status</span>(ctx) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">destroy_regions</span> = <span class="built_in">vec!</span>[];</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">has_pending_snapshot</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">ready_to_handle_pending_snap</span>() &amp;&amp; !<span class="keyword">self</span>.unpersisted_readies.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">meta</span> = ctx.store_meta.<span class="title function_ invoke__">lock</span>().<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(wait_destroy_regions) = meta.atomic_snap_regions.<span class="title function_ invoke__">get</span>(&amp;<span class="keyword">self</span>.region_id) &#123;</span><br><span class="line">            <span class="title function_ invoke__">for</span> (source_region_id, is_ready) <span class="keyword">in</span> wait_destroy_regions &#123;</span><br><span class="line">                <span class="keyword">if</span> !is_ready &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                destroy_regions.<span class="title function_ invoke__">push</span>(meta.regions[source_region_id].<span class="title function_ invoke__">clone</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !<span class="keyword">self</span>.raft_group.<span class="title function_ invoke__">has_ready</span>() &#123;</span><br><span class="line">        <span class="comment">// Generating snapshot task won&#x27;t set ready for raft group.</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(gen_task) = <span class="keyword">self</span>.<span class="title function_ invoke__">mut_store</span>().<span class="title function_ invoke__">take_gen_snap_task</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.pending_request_snapshot_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::SeqCst);</span><br><span class="line">            <span class="comment">// 让 ApplyFsm 去异步生成 snapshot</span></span><br><span class="line">            ctx.apply_router.<span class="title function_ invoke__">schedule_task</span>(<span class="keyword">self</span>.region_id, ApplyTask::<span class="title function_ invoke__">Snapshot</span>(gen_task));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Peer-handle-raft-ready-append-after-ready"><a href="#Peer-handle-raft-ready-append-after-ready" class="headerlink" title="Peer::handle_raft_ready_append(after ready)"></a>Peer::handle_raft_ready_append(after ready)</h4><p>下面就是 raft ready 才能处理的部分，关于 snapshot 的部分，后面再说。</p>
<ol>
<li><p>leader 是否发生切换、leader 状态是否更改、还需要对 leader 进行 renew_leader_lease 等一些列操作；</p>
</li>
<li><p>ready.messages() 是前面用户 propose 的消息，需要将其 replicate 给其他 TiKV follower；</p>
<p> <code>send_raft_messages</code> 中发送消息使用的就是 <code>Transport::send</code>，内部实际上封装的 <code>raft_client</code></p>
</li>
<li><p>如果 TiKV 中已存在 committed 数据，那么下一步就是将 committed 的数据 apply 到 kv-rocksdb 中</p>
</li>
<li><p>经过第 3 步，此时最新的 committed 的数据都已经 applied。如果此时新来了 gen_snaps_task 并异步调用 PeerStorage::snapshot，这样可以保证生成的 snapshot 包含最新的数据；</p>
</li>
<li><p>最后一步，需要将 applied 的数据写入到 kv-rocksdb 中，具体是 sync_write 还是 async_write 取决于配置</p>
</li>
</ol>
<p>代码简化后如下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">handle_raft_ready_append</span>&lt;T: Transport&gt;(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    ctx: &amp;<span class="keyword">mut</span> PollContext&lt;EK, ER, T&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;ReadyResult&gt; &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">ready</span> = <span class="keyword">self</span>.raft_group.<span class="title function_ invoke__">ready</span>();</span><br><span class="line">    <span class="comment">// 1. 节点的角色是否发生了变化</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">on_role_changed</span>(ctx, &amp;ready);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(hs) = ready.<span class="title function_ invoke__">hs</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pre_commit_index</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">get_store</span>().<span class="title function_ invoke__">commit_index</span>();</span><br><span class="line">        <span class="built_in">assert!</span>(hs.<span class="title function_ invoke__">get_commit</span>() &gt;= pre_commit_index);</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">is_leader</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">on_leader_commit_idx_changed</span>(pre_commit_index, hs.<span class="title function_ invoke__">get_commit</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将 proposal 发送消息到其他 node</span></span><br><span class="line">    <span class="keyword">if</span> !ready.<span class="title function_ invoke__">messages</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="built_in">assert!</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">is_leader</span>());</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">raft_msgs</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">build_raft_messages</span>(ctx, ready.<span class="title function_ invoke__">take_messages</span>());</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">send_raft_messages</span>(ctx, raft_msgs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">apply_reads</span>(ctx, &amp;ready);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发送到 ApplyBatchSystem 进行持久化 ==&gt; 应用到状态机</span></span><br><span class="line">    <span class="keyword">if</span> !ready.<span class="title function_ invoke__">committed_entries</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">handle_raft_committed_entries</span>(ctx, ready.<span class="title function_ invoke__">take_committed_entries</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 检测是否有个 snapshot task，需要发送到 apply system</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(gen_task) = <span class="keyword">self</span>.<span class="title function_ invoke__">mut_store</span>().<span class="title function_ invoke__">take_gen_snap_task</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.pending_request_snapshot_count.<span class="title function_ invoke__">fetch_add</span>(<span class="number">1</span>, Ordering::SeqCst);</span><br><span class="line">        ctx.apply_router.<span class="title function_ invoke__">schedule_task</span>(<span class="keyword">self</span>.region_id, ApplyTask::<span class="title function_ invoke__">Snapshot</span>(gen_task));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. handle_raft_ready，将 raft 相关数据写入到 raft_rocksdb</span></span><br><span class="line">    <span class="keyword">let</span> (res, <span class="keyword">mut</span> task) = <span class="keyword">match</span> <span class="keyword">self</span></span><br><span class="line">        .<span class="title function_ invoke__">mut_store</span>()</span><br><span class="line">        .<span class="title function_ invoke__">handle_raft_ready</span>(&amp;<span class="keyword">mut</span> ready, destroy_regions)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="title function_ invoke__">Ok</span>(r) =&gt; r,</span><br><span class="line">        <span class="title function_ invoke__">Err</span>(e) =&gt; &#123;</span><br><span class="line">            <span class="comment">// We may have written something to writebatch and it can&#x27;t be reverted, so has</span></span><br><span class="line">            <span class="comment">// to panic here.</span></span><br><span class="line">            <span class="built_in">panic!</span>(<span class="string">&quot;&#123;&#125; failed to handle raft ready: &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.tag, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ready_number</span> = ready.<span class="title function_ invoke__">number</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">persisted_msgs</span> = ready.<span class="title function_ invoke__">take_persisted_messages</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">has_write_ready</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">match</span> &amp;res  &#123;</span><br><span class="line">        <span class="comment">// 根据配置，决定是同步 or 异步写入 rocksdb</span></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="title function_ invoke__">Some</span>(ReadyResult &#123;</span><br><span class="line">        state_role,</span><br><span class="line">        has_new_entries,</span><br><span class="line">        has_write_ready,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面主要讲解 <code>Peer::handle_raft_ready_append</code> 函数中和 replication 有关的部分，关于 leader 切换后面单独说。</p>
<h4 id="PeerStorage-snapshot"><a href="#PeerStorage-snapshot" class="headerlink" title="PeerStorage::snapshot"></a>PeerStorage::snapshot</h4><p><code>PeerStorage::snapshot</code> 函数是个异步任务，内部有个 <code>&#123;sender, recevier&#125;</code> 连接着生产消费者两端，本质上是用于创建生成 snapshot 的任务（gen_snap_task），而 gen_snap_task 会异步执行去生成 snapshot:</p>
<ol>
<li><p>先检测当前是否已经有正在生成 snapshot 的任务；</p>
<p> 如果有，则先检测上一个异步 gen_snap_task 是否已经完成：即 <code>receiver.try_recv()</code> 返回的 <code>snap</code>，如果经过 <code>PeerStore::validate_snap</code> 函数校验，确认这个 snap 有效则直接返回，不会产生新的异步 gen_snap_task。</p>
<p> 然后，这个 snap 就会被 leader 发送给 follower。</p>
</li>
<li><p>如果当前没 gen_snap_task 任务，或者上一个异步 gen_snap_task 尚未完成，或者 snap 校验没有通过，则生成新的 gen_snap_task。</p>
</li>
</ol>
<p>在 <code>PeerStorage::snapshot</code> 设置了 <code>gen_snap_task</code> 之后，在 <code>Peer::handle_raft_ready_append</code> 中检测到之后，就会基于 <code>apply_router</code> 将该异步任务发送给 <code>ApplyFsm</code>，让 ApplyFsm 真正创建 snpahot。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">snapshot</span>(&amp;<span class="keyword">self</span>, request_index: <span class="type">u64</span>, to: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> raft::<span class="type">Result</span>&lt;Snapshot&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">snap_state</span> = <span class="keyword">self</span>.snap_state.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">tried_cnt</span> = <span class="keyword">self</span>.snap_tried_cnt.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (<span class="keyword">mut</span> tried, <span class="keyword">mut</span> last_canceled, <span class="keyword">mut</span> snap) = (<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">None</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">SnapState</span>::Generating &#123;</span><br><span class="line">        <span class="keyword">ref</span> canceled,</span><br><span class="line">        <span class="keyword">ref</span> receiver,</span><br><span class="line">        ..</span><br><span class="line">    &#125; = *snap_state</span><br><span class="line">    &#123;</span><br><span class="line">        tried = <span class="literal">true</span>;</span><br><span class="line">        last_canceled = canceled.<span class="title function_ invoke__">load</span>(Ordering::SeqCst);</span><br><span class="line">        <span class="keyword">match</span> receiver.<span class="title function_ invoke__">try_recv</span>() &#123;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(TryRecvError::Empty) =&gt; &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">e</span> = raft::StorageError::SnapshotTemporarilyUnavailable;</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(raft::Error::<span class="title function_ invoke__">Store</span>(e));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(s) <span class="keyword">if</span> !last_canceled =&gt; snap = <span class="title function_ invoke__">Some</span>(s),</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(TryRecvError::Disconnected) | <span class="title function_ invoke__">Ok</span>(_) =&gt; &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> tried &#123;</span><br><span class="line">        *snap_state = SnapState::Relax;</span><br><span class="line">        <span class="keyword">match</span> snap &#123;</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(s) =&gt; &#123;</span><br><span class="line">                *tried_cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">validate_snap</span>(&amp;s, request_index) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; &#123; <span class="comment">/* warn_log */</span>&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> SnapState::Relax != *snap_state &#123;</span><br><span class="line">        <span class="built_in">panic!</span>(<span class="string">&quot;&#123;&#125; unexpected state: &#123;:?&#125;&quot;</span>, <span class="keyword">self</span>.tag, *snap_state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 gen_snap_task</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> (sender, receiver) = mpsc::<span class="title function_ invoke__">sync_channel</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">canceled</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicBool::<span class="title function_ invoke__">new</span>(<span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span> = Arc::<span class="title function_ invoke__">new</span>(AtomicU64::<span class="title function_ invoke__">new</span>(<span class="number">0</span>));</span><br><span class="line">    *snap_state = SnapState::Generating &#123;</span><br><span class="line">        canceled: canceled.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        index: index.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        receiver,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">to_store_id</span> = <span class="number">0</span>; <span class="comment">// follower 的 store_id</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(peer) = <span class="keyword">self</span>.<span class="title function_ invoke__">region</span>().<span class="title function_ invoke__">get_peers</span>().<span class="title function_ invoke__">iter</span>().<span class="title function_ invoke__">find</span>(|p| p.id == to) &#123;</span><br><span class="line">        to_store_id = peer.store_id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建异步任务</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">task</span> = GenSnapTask::<span class="title function_ invoke__">new</span>(<span class="keyword">self</span>.region.<span class="title function_ invoke__">get_id</span>(), index, canceled, sender, to_store_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">gen_snap_task</span> = <span class="keyword">self</span>.gen_snap_task.<span class="title function_ invoke__">borrow_mut</span>();</span><br><span class="line">    <span class="built_in">assert!</span>(gen_snap_task.<span class="title function_ invoke__">is_none</span>());</span><br><span class="line">    *gen_snap_task = <span class="title function_ invoke__">Some</span>(task);</span><br><span class="line">    <span class="title function_ invoke__">Err</span>(raft::Error::<span class="title function_ invoke__">Store</span>(</span><br><span class="line">        raft::StorageError::SnapshotTemporarilyUnavailable,</span><br><span class="line">    ))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ApplyFsm-handle-snapshot"><a href="#ApplyFsm-handle-snapshot" class="headerlink" title="ApplyFsm::handle_snapshot"></a>ApplyFsm::handle_snapshot</h5><p>ApplyFsm 在接受到 <code>Msg::Snapshot</code> 类型的消息后，就会进入 <code>ApplyFsm::handle_snapshot</code> 处理该 gen_snap_task。</p>
<p>由于生成 snapshot 是个 io 任务，比较耗时，自然也不会同步阻塞执行。</p>
<p>因此，<code>handle_snapshot</code> 函数内部调用 <code>GenSnapTask::generate_and_schedule_snapshot</code> 异步执行。</p>
<p>不过，在执行前，需要将这个 region 中 unpersisted 的数据给 flush 到 kv-rocksdb 中，确保生成的 snapshot 是最新的。这个 <code>ApplyContext::flush</code> 流程后面再说，目前先关注 <code>gen_snap_task</code>。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_snapshot</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, apply_ctx: &amp;<span class="keyword">mut</span> ApplyContext&lt;EK&gt;, snap_task: GenSnapTask) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.delegate.pending_remove || <span class="keyword">self</span>.delegate.stopped &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">applied_index</span> = <span class="keyword">self</span>.delegate.apply_state.<span class="title function_ invoke__">get_applied_index</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">need_sync</span> = apply_ctx</span><br><span class="line">        .apply_res</span><br><span class="line">        .<span class="title function_ invoke__">iter</span>()</span><br><span class="line">        .<span class="title function_ invoke__">any</span>(|res| res.region_id == <span class="keyword">self</span>.delegate.<span class="title function_ invoke__">region_id</span>())</span><br><span class="line">        &amp;&amp; <span class="keyword">self</span>.delegate.last_flush_applied_index != applied_index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> need_sync &#123;</span><br><span class="line">        <span class="keyword">self</span>.delegate.<span class="title function_ invoke__">write_apply_state</span>(apply_ctx.<span class="title function_ invoke__">kv_wb_mut</span>());</span><br><span class="line">        apply_ctx.<span class="title function_ invoke__">flush</span>();</span><br><span class="line">        <span class="keyword">self</span>.delegate.last_flush_applied_index = applied_index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = snap_task.generate_and_schedule_snapshot::&lt;EK&gt;(</span><br><span class="line">        apply_ctx.engine.<span class="title function_ invoke__">snapshot</span>(),</span><br><span class="line">        <span class="keyword">self</span>.delegate.applied_index_term,</span><br><span class="line">        <span class="keyword">self</span>.delegate.apply_state.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        &amp;apply_ctx.region_scheduler,</span><br><span class="line">    ) &#123; <span class="comment">/* error!(...); */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.delegate.pending_request_snapshot_count.<span class="title function_ invoke__">fetch_sub</span>(<span class="number">1</span>, Ordering::SeqCst);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="SnapContext-generate-snap"><a href="#SnapContext-generate-snap" class="headerlink" title="SnapContext::generate_snap"></a>SnapContext::generate_snap</h5><p>最终异步调用到 <code>SnapContext::generate_snap</code> 函数中，基于 <code>store::do_snapshot</code> 函数生成 snapshot：</p>
<ul>
<li><p>notifier</p>
<p> snapshot 创建后，<code>notify</code> 通知 <code>gen_snap_task</code> 的消费端，即 <code>PeerStore::snapshot()</code> 中的 <code>receiver.try_recv()</code> 返回 snap，这样就可以让 raft-group 的 <code>ready.snapshot()</code> 不为空；</p>
<p> 这样就可以在下一次调用 <code>Peer::handle_raft_ready_append</code> 函数时，继续处理已经 ready 的 snapshot，即将其发送到指定 follower，（这一部分在 <code>Peer::handle_raft_ready</code> 中）。</p>
</li>
<li><p>rotuer</p>
<p>这里的 <code>router</code> 的消费端是 <code>PeerDelegate</code>，此处则是用于通知 leader 去处理已经生成的 snapshot。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">generate_snap</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    region_id: <span class="type">u64</span>,</span><br><span class="line">    last_applied_index_term: <span class="type">u64</span>,</span><br><span class="line">    last_applied_state: RaftApplyState,</span><br><span class="line">    kv_snap: EK::Snapshot,</span><br><span class="line">    notifier: SyncSender&lt;RaftSnapshot&gt;,</span><br><span class="line">    for_balance: <span class="type">bool</span>,</span><br><span class="line">    allow_multi_files_snapshot: <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// 基于 PeerStore 创建 snapshot</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">snap</span> = box_try!(store::do_snapshot::&lt;EK&gt;(</span><br><span class="line">        <span class="keyword">self</span>.mgr.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        &amp;<span class="keyword">self</span>.engine,</span><br><span class="line">        kv_snap,</span><br><span class="line">        region_id,</span><br><span class="line">        last_applied_index_term,</span><br><span class="line">        last_applied_state,</span><br><span class="line">        for_balance,</span><br><span class="line">        allow_multi_files_snapshot,</span><br><span class="line">    ));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将生成的 snapshot 数据发送给消费端，</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Err</span>(e) = notifier.<span class="title function_ invoke__">try_send</span>(snap) &#123;</span><br><span class="line">        <span class="comment">// info!(...);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再通知消息类型</span></span><br><span class="line">    <span class="keyword">self</span>.router.<span class="title function_ invoke__">send</span>(region_id, CasualMessage::SnapshotGenerated);</span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="store-do-snapshot"><a href="#store-do-snapshot" class="headerlink" title="store::do_snapshot"></a>store::do_snapshot</h5><p>生成 snapshot，则需要获得当前 kv-rocksdb 的最新数据和元信息，主要包括三部分：</p>
<ul>
<li><p>RaftApplyState</p>
<ul>
<li>apply_index 表示当前 apply raft log 的进度。如果 apply raft log 在 persist 前发生宕机，那么重启后就会从较老的 apply index 开始重放日志。所以 apply raftlog 是需要支持幂等的，对于一些特殊的不支持幂等的指令，就需要 apply 完立刻 persist 并 fsync。</li>
<li>因为日志不可能无限增长，所以 TiKV 会定期做 CompactLog 来 gc raft log。<code>truncated_state</code> 表示上次做完 CompactLog 后现有日志的头部。</li>
</ul>
</li>
<li><p>RegionLocalState</p>
<ul>
<li>RegionLocalState 主要包含 Region 的 range、epoch、各个 peer 以及当前 Region 状态，其中 RegionEpoch 会在 ConfChange，以及 Split 和 Merge 的时候发生变化，在处理 Raft 消息时，我们会校验 RegionEpoch 并拒绝掉过期的消息</li>
<li>PeerState 状态比如 Normal、Applying、Merging、Tombstone等。</li>
</ul>
</li>
<li><p>RaftSnapshotData</p>
</li>
</ul>
<p>数据都是保存在 <code>CF_RAFT</code> column family 中。 代码如下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">do_snapshot</span>&lt;E&gt;(</span><br><span class="line">    mgr: SnapManager,</span><br><span class="line">    engine: &amp;E,</span><br><span class="line">    kv_snap: E::Snapshot,</span><br><span class="line">    region_id: <span class="type">u64</span>,</span><br><span class="line">    last_applied_index_term: <span class="type">u64</span>,</span><br><span class="line">    last_applied_state: RaftApplyState,</span><br><span class="line">    for_balance: <span class="type">bool</span>,</span><br><span class="line">    allow_multi_files_snapshot: <span class="type">bool</span>,</span><br><span class="line">) <span class="punctuation">-&gt;</span> raft::<span class="type">Result</span>&lt;Snapshot&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    E: KvEngine,</span><br><span class="line">&#123;</span><br><span class="line">    debug!( <span class="string">&quot;begin to generate a snapshot&quot;</span>; <span class="string">&quot;region_id&quot;</span> =&gt; region_id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得最新的 apply_state</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msg</span> = kv_snap</span><br><span class="line">        .<span class="title function_ invoke__">get_msg_cf</span>(CF_RAFT, &amp;keys::<span class="title function_ invoke__">apply_state_key</span>(region_id))</span><br><span class="line">        .<span class="title function_ invoke__">map_err</span>(into_other::&lt;_, raft::Error&gt;)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">apply_state</span>: RaftApplyState = <span class="keyword">match</span> msg &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123; <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="comment">/**/</span>); &#125;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(state) =&gt; state,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(apply_state, last_applied_state);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">key</span> = SnapKey::<span class="title function_ invoke__">new</span>(</span><br><span class="line">        region_id,</span><br><span class="line">        last_applied_index_term,</span><br><span class="line">        apply_state.<span class="title function_ invoke__">get_applied_index</span>(),</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    mgr.<span class="title function_ invoke__">register</span>(key.<span class="title function_ invoke__">clone</span>(), SnapEntry::Generating);</span><br><span class="line">    defer!(mgr.<span class="title function_ invoke__">deregister</span>(&amp;key, &amp;SnapEntry::Generating));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得最新的 local_state</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">state</span>: RegionLocalState = kv_snap</span><br><span class="line">        .<span class="title function_ invoke__">get_msg_cf</span>(CF_RAFT, &amp;keys::<span class="title function_ invoke__">region_state_key</span>(key.region_id))</span><br><span class="line">        .<span class="title function_ invoke__">and_then</span>(|res| <span class="keyword">match</span> res &#123;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="title function_ invoke__">Err</span>(box_err!(<span class="string">&quot;region &#123;&#125; could not find region info&quot;</span>, region_id)),</span><br><span class="line">            <span class="title function_ invoke__">Some</span>(state) =&gt; <span class="title function_ invoke__">Ok</span>(state),</span><br><span class="line">        &#125;)</span><br><span class="line">        .<span class="title function_ invoke__">map_err</span>(into_other::&lt;_, raft::Error&gt;)?;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> state.<span class="title function_ invoke__">get_state</span>() != PeerState::Normal &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(<span class="title function_ invoke__">storage_error</span>(<span class="built_in">format!</span>(</span><br><span class="line">            <span class="string">&quot;snap job for &#123;&#125; seems stale, skip.&quot;</span>,</span><br><span class="line">            region_id</span><br><span class="line">        )));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">snapshot</span> = Snapshot::<span class="title function_ invoke__">default</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set snapshot metadata.</span></span><br><span class="line">    snapshot.<span class="title function_ invoke__">mut_metadata</span>().<span class="title function_ invoke__">set_index</span>(key.idx);</span><br><span class="line">    snapshot.<span class="title function_ invoke__">mut_metadata</span>().<span class="title function_ invoke__">set_term</span>(key.term);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">conf_state</span> = util::<span class="title function_ invoke__">conf_state_from_region</span>(state.<span class="title function_ invoke__">get_region</span>());</span><br><span class="line">    snapshot.<span class="title function_ invoke__">mut_metadata</span>().<span class="title function_ invoke__">set_conf_state</span>(conf_state);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set snapshot data.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">snap_data</span> = RaftSnapshotData::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    snap_data.<span class="title function_ invoke__">set_region</span>(state.<span class="title function_ invoke__">get_region</span>().<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = mgr.<span class="title function_ invoke__">get_snapshot_for_building</span>(&amp;key)?;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">stat</span> = SnapshotStatistics::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    s.<span class="title function_ invoke__">build</span>(</span><br><span class="line">        engine,</span><br><span class="line">        &amp;kv_snap,</span><br><span class="line">        state.<span class="title function_ invoke__">get_region</span>(),</span><br><span class="line">        &amp;<span class="keyword">mut</span> snap_data, <span class="comment">// 获得 snapshot 数据</span></span><br><span class="line">        &amp;<span class="keyword">mut</span> stat,</span><br><span class="line">        allow_multi_files_snapshot,</span><br><span class="line">    )?;</span><br><span class="line">    snap_data.<span class="title function_ invoke__">mut_meta</span>().<span class="title function_ invoke__">set_for_balance</span>(for_balance);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">v</span> = snap_data.<span class="title function_ invoke__">write_to_bytes</span>()?;</span><br><span class="line">    snapshot.<span class="title function_ invoke__">set_data</span>(v.<span class="title function_ invoke__">into</span>());</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>(snapshot)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ApplyFsm-handle-apply"><a href="#ApplyFsm-handle-apply" class="headerlink" title="ApplyFsm::handle_apply"></a>ApplyFsm::handle_apply</h4><p><code>Peer::handle_raft_committed_entries</code> </p>
<p>此函数用于处理已经 committed 数据：</p>
<ul>
<li>对于 leader 来说，即接受到超过半数 follower 回应的 proposals；</li>
<li>对于 follower 来说，即已经 Append 到 raft-log 的 proposals。</li>
</ul>
<p>在 <code>Peer::handle_raft_committed_entries</code> 函数中构建的 <code>ApplyTask</code>，最终在 <code>ApplyFsm::handle_apply</code> 中使用</p>
<ul>
<li>更新当前 ApplyDelegate 的状态及元数据；</li>
<li>添加 proposals</li>
<li>handle_raft_committed_entries</li>
</ul>
<p>代码简化如下：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_apply</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, apply_ctx: &amp;<span class="keyword">mut</span> ApplyContext&lt;EK&gt;, <span class="keyword">mut</span> apply: Apply&lt;EK::Snapshot&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.delegate.pending_remove || <span class="keyword">self</span>.delegate.stopped &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">entries</span> = <span class="type">Vec</span>::<span class="title function_ invoke__">new</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">dangle_size</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">cached_entries</span> <span class="keyword">in</span> apply.entries &#123;</span><br><span class="line">        <span class="keyword">let</span> (e, sz) = cached_entries.<span class="title function_ invoke__">take_entries</span>();</span><br><span class="line">        dangle_size += sz;</span><br><span class="line">        <span class="keyword">if</span> e.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">rid</span> = <span class="keyword">self</span>.delegate.<span class="title function_ invoke__">region_id</span>();</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">StdRange</span> &#123; start, end &#125; = cached_entries.range;</span><br><span class="line">            <span class="keyword">self</span>.delegate</span><br><span class="line">                .raft_engine</span><br><span class="line">                .<span class="title function_ invoke__">fetch_entries_to</span>(rid, start, end, <span class="literal">None</span>, &amp;<span class="keyword">mut</span> entries)</span><br><span class="line">                .<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> entries.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            entries = e;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            entries.<span class="title function_ invoke__">extend</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.delegate.term = apply.term;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">cur_state</span> = (apply.commit_index, apply.commit_term);</span><br><span class="line">    <span class="keyword">self</span>.delegate.apply_state.<span class="title function_ invoke__">set_commit_index</span>(cur_state.<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">self</span>.delegate.apply_state.<span class="title function_ invoke__">set_commit_term</span>(cur_state.<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 proposal</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">append_proposal</span>(apply.cbs.<span class="title function_ invoke__">drain</span>(..));</span><br><span class="line">    <span class="comment">// If there is any apply task, we change this fsm to normal-priority.</span></span><br><span class="line">    <span class="comment">// When it meets a ingest-request or a delete-range request, it will change to</span></span><br><span class="line">    <span class="comment">// low-priority.</span></span><br><span class="line">    <span class="keyword">self</span>.delegate.priority = Priority::Normal;</span><br><span class="line">    <span class="keyword">self</span>.delegate</span><br><span class="line">        .<span class="title function_ invoke__">handle_raft_committed_entries</span>(apply_ctx, entries.<span class="title function_ invoke__">drain</span>(..));</span><br><span class="line">    fail_point!(<span class="string">&quot;post_handle_apply_1003&quot;</span>, <span class="keyword">self</span>.delegate.<span class="title function_ invoke__">id</span>() == <span class="number">1003</span>, |_| &#123;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ApplyFsm-append-proposal"><a href="#ApplyFsm-append-proposal" class="headerlink" title="ApplyFsm::append_proposal"></a>ApplyFsm::append_proposal</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Handles proposals, and appends the commands to the apply delegate.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">append_proposal</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, props_drainer: Drain&lt;<span class="symbol">&#x27;_</span>, Proposal&lt;EK::Snapshot&gt;&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> (region_id, peer_id) = (<span class="keyword">self</span>.delegate.<span class="title function_ invoke__">region_id</span>(), <span class="keyword">self</span>.delegate.<span class="title function_ invoke__">id</span>());</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.delegate.stopped &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="variable">p</span> <span class="keyword">in</span> props_drainer &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">cmd</span> = PendingCmd::&lt;EK::Snapshot&gt;::<span class="title function_ invoke__">new</span>(p.index, p.term, p.cb);</span><br><span class="line">            <span class="title function_ invoke__">notify_stale_command</span>(region_id, peer_id, <span class="keyword">self</span>.delegate.term, cmd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">propose_num</span> = props_drainer.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">p</span> <span class="keyword">in</span> props_drainer &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cmd</span> = PendingCmd::<span class="title function_ invoke__">new</span>(p.index, p.term, p.cb);</span><br><span class="line">        <span class="keyword">if</span> p.is_conf_change &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(cmd) = <span class="keyword">self</span>.delegate.pending_cmds.<span class="title function_ invoke__">take_conf_change</span>() &#123;</span><br><span class="line">                <span class="title function_ invoke__">notify_stale_command</span>(region_id, peer_id, <span class="keyword">self</span>.delegate.term, cmd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.delegate.pending_cmds.<span class="title function_ invoke__">set_conf_change</span>(cmd);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.delegate.pending_cmds.<span class="title function_ invoke__">append_normal</span>(cmd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ApplyDelegate-handle-raft-committed-entries"><a href="#ApplyDelegate-handle-raft-committed-entries" class="headerlink" title="ApplyDelegate::handle_raft_committed_entries"></a>ApplyDelegate::handle_raft_committed_entries</h5><p>这里的处理，即对 committed entries 进行 apply。</p>
<p>函数有个 ApplyContext 参数，用来控制一些调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplyContext::prepare_for -&gt; ApplyContext::commit [-&gt; ApplyContext::commit ...] -&gt; ApplyContext::finish_for.</span><br></pre></td></tr></table></figure>
<p>从这个函数处理流程可以看出也是符合这个流程：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Handles all the committed_entries, namely, applies the committed entries.</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_raft_committed_entries</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    apply_ctx: &amp;<span class="keyword">mut</span> ApplyContext&lt;EK&gt;,</span><br><span class="line">    <span class="keyword">mut</span> committed_entries_drainer: Drain&lt;<span class="symbol">&#x27;_</span>, Entry&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> committed_entries_drainer.<span class="title function_ invoke__">len</span>() == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    apply_ctx.<span class="title function_ invoke__">prepare_for</span>(<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">// If we send multiple ConfChange commands, only first one will be proposed correctly,</span></span><br><span class="line">    <span class="comment">// others will be saved as a normal entry with no data, so we must re-propose these</span></span><br><span class="line">    <span class="comment">// commands again.</span></span><br><span class="line">    apply_ctx.committed_count += committed_entries_drainer.<span class="title function_ invoke__">len</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">results</span> = VecDeque::<span class="title function_ invoke__">new</span>();</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(entry) = committed_entries_drainer.<span class="title function_ invoke__">next</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.pending_remove &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">res</span> = <span class="keyword">match</span> entry.<span class="title function_ invoke__">get_entry_type</span>() &#123;</span><br><span class="line">            EntryType::EntryNormal =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">handle_raft_entry_normal</span>(apply_ctx, &amp;entry),</span><br><span class="line">            EntryType::EntryConfChange | EntryType::EntryConfChangeV2 =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">handle_raft_entry_conf_change</span>(apply_ctx, &amp;entry)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">match</span> res &#123;</span><br><span class="line">            ApplyResult::<span class="literal">None</span> =&gt; &#123;&#125;</span><br><span class="line">            ApplyResult::<span class="title function_ invoke__">Res</span>(res) =&gt; results.<span class="title function_ invoke__">push_back</span>(res),</span><br><span class="line">            ApplyResult::Yield | ApplyResult::<span class="title function_ invoke__">WaitMergeSource</span>(_) =&gt; &#123;</span><br><span class="line">                <span class="comment">// Both cancel and merge will yield current processing.</span></span><br><span class="line">                apply_ctx.committed_count -= committed_entries_drainer.<span class="title function_ invoke__">len</span>() + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">pending_entries</span> =</span><br><span class="line">                    <span class="type">Vec</span>::<span class="title function_ invoke__">with_capacity</span>(committed_entries_drainer.<span class="title function_ invoke__">len</span>() + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">// Note that current entry is skipped when yield.</span></span><br><span class="line">                pending_entries.<span class="title function_ invoke__">push</span>(entry);</span><br><span class="line">                pending_entries.<span class="title function_ invoke__">extend</span>(committed_entries_drainer);</span><br><span class="line">                apply_ctx.<span class="title function_ invoke__">finish_for</span>(<span class="keyword">self</span>, results);</span><br><span class="line">                <span class="keyword">self</span>.yield_state = <span class="title function_ invoke__">Some</span>(YieldState &#123;</span><br><span class="line">                    pending_entries,</span><br><span class="line">                    pending_msgs: <span class="type">Vec</span>::<span class="title function_ invoke__">default</span>(),</span><br><span class="line">                    heap_size: <span class="literal">None</span>,</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">ApplyResult</span>::<span class="title function_ invoke__">WaitMergeSource</span>(logs_up_to_date) = res &#123;</span><br><span class="line">                    <span class="keyword">self</span>.wait_merge_state = <span class="title function_ invoke__">Some</span>(WaitSourceMergeState &#123; logs_up_to_date &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    apply_ctx.<span class="title function_ invoke__">finish_for</span>(<span class="keyword">self</span>, results);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.pending_remove &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">destroy</span>(apply_ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ApplyContext-prepare-for"><a href="#ApplyContext-prepare-for" class="headerlink" title="ApplyContext::prepare_for"></a>ApplyContext::prepare_for</h5><h5 id="ApplyContext-commit"><a href="#ApplyContext-commit" class="headerlink" title="ApplyContext::commit"></a>ApplyContext::commit</h5><p>在 commit 函数中先将 RaftApplyState 写入 kv_wb，这样在 <code>commit_opt</code> 函数中就可以一起将最新的 delegate.apply_state 和 kv 数据一起持久化到 rocksdb 中，并在持久化完成后，更新 ApplyDelegate::last_flush_applied_index 字段。</p>
<p>因此， commit 函数返回后，所有 unflushed 的数据都持久化到 rocksdb 中了。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">commit</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, delegate: &amp;<span class="keyword">mut</span> ApplyDelegate&lt;EK&gt;) &#123;</span><br><span class="line">    <span class="comment">// 写入 &#123;apply_state_key, RaftApplyState&#125; 最新的状态</span></span><br><span class="line">    <span class="keyword">if</span> delegate.last_flush_applied_index &lt; delegate.apply_state.<span class="title function_ invoke__">get_applied_index</span>() &#123;</span><br><span class="line">        delegate.<span class="title function_ invoke__">write_apply_state</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">kv_wb_mut</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 再写入数据到 write_batch</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">commit_opt</span>(delegate, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">commit_opt</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, delegate: &amp;<span class="keyword">mut</span> ApplyDelegate&lt;EK&gt;, persistent: <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> persistent &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">write_to_db</span>();</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_for</span>(delegate);</span><br><span class="line">        delegate.last_flush_applied_index = delegate.apply_state.<span class="title function_ invoke__">get_applied_index</span>()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.kv_wb_last_bytes = <span class="keyword">self</span>.<span class="title function_ invoke__">kv_wb</span>().<span class="title function_ invoke__">data_size</span>() <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line">    <span class="keyword">self</span>.kv_wb_last_keys = <span class="keyword">self</span>.<span class="title function_ invoke__">kv_wb</span>().<span class="title function_ invoke__">count</span>() <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ApplyContext-write-to-db"><a href="#ApplyContext-write-to-db" class="headerlink" title="ApplyContext::write_to_db"></a>ApplyContext::write_to_db</h5><p><code>write_to_db</code> 主要就是将 pendig_sst、kv、delete_sst 数据导入到 rocksdb 中，没有什么特别的操作。持久化完成，则调用 callback 回复 client。</p>
<p>简化后如下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">write_to_db</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> <span class="variable">need_sync</span> = <span class="keyword">self</span>.sync_log_hint;</span><br><span class="line">      <span class="comment">// There may be put and delete requests after ingest request in the same fsm.</span></span><br><span class="line">      <span class="comment">// To guarantee the correct order, we must ingest the pending_sst first, and</span></span><br><span class="line">      <span class="comment">// then persist the kv write batch to engine.</span></span><br><span class="line">      <span class="keyword">if</span> !<span class="keyword">self</span>.pending_ssts.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">          <span class="keyword">let</span> <span class="variable">tag</span> = <span class="keyword">self</span>.tag.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">          <span class="keyword">self</span>.importer</span><br><span class="line">              .<span class="title function_ invoke__">ingest</span>(&amp;<span class="keyword">self</span>.pending_ssts, &amp;<span class="keyword">self</span>.engine)</span><br><span class="line">              .<span class="title function_ invoke__">unwrap_or_else</span>(|e| &#123;</span><br><span class="line">                  <span class="built_in">panic!</span>(</span><br><span class="line">                      <span class="string">&quot;&#123;&#125; failed to ingest ssts &#123;:?&#125;: &#123;:?&#125;&quot;</span>,</span><br><span class="line">                      tag, <span class="keyword">self</span>.pending_ssts, e</span><br><span class="line">                  );</span><br><span class="line">              &#125;);</span><br><span class="line">          <span class="keyword">self</span>.pending_ssts = <span class="built_in">vec!</span>[];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">kv_wb_mut</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">          <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">write_opts</span> = engine_traits::WriteOptions::<span class="title function_ invoke__">new</span>();</span><br><span class="line">          write_opts.<span class="title function_ invoke__">set_sync</span>(need_sync);</span><br><span class="line">         <span class="comment">// 写入 rocksdb，是否需要 sync_log</span></span><br><span class="line">          <span class="keyword">self</span>.<span class="title function_ invoke__">kv_wb</span>().<span class="title function_ invoke__">write_opt</span>(&amp;write_opts).<span class="title function_ invoke__">unwrap_or_else</span>(|e| &#123;</span><br><span class="line">              <span class="built_in">panic!</span>(<span class="string">&quot;failed to write to engine: &#123;:?&#125;&quot;</span>, e);</span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">self</span>.sync_log_hint = <span class="literal">false</span>;</span><br><span class="line">          <span class="keyword">let</span> <span class="variable">data_size</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">kv_wb</span>().<span class="title function_ invoke__">data_size</span>();</span><br><span class="line">          <span class="keyword">if</span> data_size &gt; APPLY_WB_SHRINK_SIZE &#123;</span><br><span class="line">              <span class="comment">// 内存太大，不释放会有影响，因此重新生成 write_batch</span></span><br><span class="line">              <span class="keyword">self</span>.kv_wb = <span class="keyword">self</span>.engine.<span class="title function_ invoke__">write_batch_with_cap</span>(DEFAULT_APPLY_WB_SIZE);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">// 内存不大，那就不用释放了，直接清除原来的数据即可</span></span><br><span class="line">              <span class="keyword">self</span>.<span class="title function_ invoke__">kv_wb_mut</span>().<span class="title function_ invoke__">clear</span>();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">self</span>.kv_wb_last_bytes = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">self</span>.kv_wb_last_keys = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> !<span class="keyword">self</span>.delete_ssts.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">          <span class="keyword">let</span> <span class="variable">tag</span> = <span class="keyword">self</span>.tag.<span class="title function_ invoke__">clone</span>();</span><br><span class="line">          <span class="keyword">for</span> <span class="variable">sst</span> <span class="keyword">in</span> <span class="keyword">self</span>.delete_ssts.<span class="title function_ invoke__">drain</span>(..) &#123;</span><br><span class="line">              <span class="keyword">self</span>.importer.<span class="title function_ invoke__">delete</span>(&amp;sst.meta).<span class="title function_ invoke__">unwrap_or_else</span>(|e| &#123;</span><br><span class="line">                  <span class="built_in">panic!</span>(<span class="string">&quot;&#123;&#125; cleanup ingested file &#123;:?&#125;: &#123;:?&#125;&quot;</span>, tag, sst, e);</span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Take the applied commands and their callback</span></span><br><span class="line">      <span class="keyword">let</span> <span class="variable">ApplyCallbackBatch</span> &#123;</span><br><span class="line">          cmd_batch,</span><br><span class="line">          batch_max_level,</span><br><span class="line">          <span class="keyword">mut</span> cb_batch,</span><br><span class="line">      &#125; = mem::<span class="title function_ invoke__">replace</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.applied_batch, ApplyCallbackBatch::<span class="title function_ invoke__">new</span>());</span><br><span class="line">      <span class="comment">// Invoke callbacks</span></span><br><span class="line">      <span class="title function_ invoke__">for</span> (cb, resp) <span class="keyword">in</span> cb_batch.<span class="title function_ invoke__">drain</span>(..) &#123;</span><br><span class="line">          cb.<span class="title function_ invoke__">invoke_with_response</span>(resp); <span class="comment">// 回复客户端</span></span><br><span class="line">      &#125;</span><br><span class="line">      need_sync</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h5 id="ApplyContext-finish-for"><a href="#ApplyContext-finish-for" class="headerlink" title="ApplyContext::finish_for"></a>ApplyContext::finish_for</h5><p><code>finish_for</code> 函数和 <code>commit</code> 函数功能类似，区别在于</p>
<ul>
<li><code>commit_opt(delegate, false)</code>，即不会持久化数据到 rocksdb，仅是更新统计数字。</li>
<li>保存 ApplyRes</li>
</ul>
<p>留在 <code>ApplyPoller::end</code> 中处理。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">finish_for</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    delegate: &amp;<span class="keyword">mut</span> ApplyDelegate&lt;EK&gt;,</span><br><span class="line">    results: VecDeque&lt;ExecResult&lt;EK::Snapshot&gt;&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">if</span> !delegate.pending_remove &#123;</span><br><span class="line">        delegate.<span class="title function_ invoke__">write_apply_state</span>(<span class="keyword">self</span>.<span class="title function_ invoke__">kv_wb_mut</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">commit_opt</span>(delegate, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">self</span>.apply_res.<span class="title function_ invoke__">push</span>(ApplyRes &#123;</span><br><span class="line">        region_id: delegate.<span class="title function_ invoke__">region_id</span>(),</span><br><span class="line">        apply_state: delegate.apply_state.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        exec_res: results,</span><br><span class="line">        metrics: delegate.metrics.<span class="title function_ invoke__">clone</span>(),</span><br><span class="line">        applied_index_term: delegate.applied_index_term,</span><br><span class="line">        bucket_stat: delegate.buckets.<span class="title function_ invoke__">clone</span>().<span class="title function_ invoke__">map</span>(<span class="type">Box</span>::new),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ApplyDelegate-handle-raft-entry-normal"><a href="#ApplyDelegate-handle-raft-entry-normal" class="headerlink" title="ApplyDelegate::handle_raft_entry_normal"></a>ApplyDelegate::handle_raft_entry_normal</h5><p>在 <code>ApplyDelegate::process_raft_cmd</code> 函数真正处理本次 proposals 之前，需要先保证之前的数据都已经持久化到 rocksdb 中，即 <code>[last_flush_applied_index, apply_state.applied_index)</code> 区间没有数据。</p>
<p>在 <code>process_raft_cmd</code> 中处理完 proposals，就更新 <code>apply_state.applied_index</code>，即增大了 <code>[last_flush_applied_index, apply_state.applied_index)</code> 区间，如果是有多个 proposals，那么处理下一个 proposal 就会先持久化数据，最后一个 proposal 则在 handle_destory 处理。</p>
<blockquote>
<p>TODO: 这里有个时间片 &amp;&amp; 优先级的设计</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_raft_entry_normal</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    apply_ctx: &amp;<span class="keyword">mut</span> ApplyContext&lt;EK&gt;,</span><br><span class="line">    entry: &amp;Entry,</span><br><span class="line">) <span class="punctuation">-&gt;</span> ApplyResult&lt;EK::Snapshot&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">index</span> = entry.<span class="title function_ invoke__">get_index</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">term</span> = entry.<span class="title function_ invoke__">get_term</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">data</span> = entry.<span class="title function_ invoke__">get_data</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !data.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">cmd</span> = util::<span class="title function_ invoke__">parse_data_at</span>(data, index, &amp;<span class="keyword">self</span>.tag);</span><br><span class="line">        <span class="comment">// 调整优先级</span></span><br><span class="line">        <span class="keyword">if</span> apply_ctx.yield_high_latency_operation &amp;&amp; <span class="title function_ invoke__">has_high_latency_operation</span>(&amp;cmd) &#123;</span><br><span class="line">            <span class="keyword">self</span>.priority = Priority::Low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是否存在 unflushed 的数据</span></span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">has_unflushed_data</span> =</span><br><span class="line">            <span class="keyword">self</span>.last_flush_applied_index != <span class="keyword">self</span>.apply_state.<span class="title function_ invoke__">get_applied_index</span>();</span><br><span class="line">        <span class="keyword">if</span> has_unflushed_data &amp;&amp; <span class="title function_ invoke__">should_write_to_engine</span>(&amp;cmd)</span><br><span class="line">            || apply_ctx.<span class="title function_ invoke__">kv_wb</span>().<span class="title function_ invoke__">should_write_to_engine</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这是将数据写入 rocksdb</span></span><br><span class="line">            apply_ctx.<span class="title function_ invoke__">commit</span>(<span class="keyword">self</span>);</span><br><span class="line">            <span class="comment">// 是否耗时过长，切出时间片</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(start) = <span class="keyword">self</span>.handle_start.<span class="title function_ invoke__">as_ref</span>() &#123;</span><br><span class="line">                <span class="keyword">if</span> start.<span class="title function_ invoke__">saturating_elapsed</span>() &gt;= apply_ctx.yield_duration &#123;</span><br><span class="line">                    <span class="keyword">return</span> ApplyResult::Yield;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            has_unflushed_data = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可能是上面切出的情况</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.priority != apply_ctx.priority &#123;</span><br><span class="line">            <span class="keyword">if</span> has_unflushed_data &#123;</span><br><span class="line">                apply_ctx.<span class="title function_ invoke__">commit</span>(<span class="keyword">self</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ApplyResult::Yield;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理真正的指令</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.<span class="title function_ invoke__">process_raft_cmd</span>(apply_ctx, index, term, cmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.apply_state.<span class="title function_ invoke__">set_applied_index</span>(index);</span><br><span class="line">    <span class="keyword">self</span>.applied_index_term = term;</span><br><span class="line">    <span class="built_in">assert!</span>(term &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. When a peer become leader, it will send an empty entry.</span></span><br><span class="line">    <span class="comment">// 2. When a leader tries to read index during transferring leader,</span></span><br><span class="line">    <span class="comment">//    it will also propose an empty entry. But that entry will not contain</span></span><br><span class="line">    <span class="comment">//    any associated callback. So no need to clear callback.</span></span><br><span class="line">    <span class="comment">// 清理所有的过时的 normal proposal</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="variable">Some</span>(<span class="keyword">mut</span> cmd) = <span class="keyword">self</span>.pending_cmds.<span class="title function_ invoke__">pop_normal</span>(<span class="type">u64</span>::MAX, term - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(cb) = cmd.cb.<span class="title function_ invoke__">take</span>() &#123;</span><br><span class="line">            apply_ctx</span><br><span class="line">                .applied_batch</span><br><span class="line">                .<span class="title function_ invoke__">push_cb</span>(cb, cmd_resp::<span class="title function_ invoke__">err_resp</span>(Error::StaleCommand, term));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ApplyResult::<span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="ApplyDelegate-end"><a href="#ApplyDelegate-end" class="headerlink" title="ApplyDelegate::end"></a>ApplyDelegate::end</h5><p>执行流程是： ApplyDelegate::handle_normal –&gt; ApplyDelegate::end；</p>
<p>上面的都是在 <code>ApplyDelegate::handle_normal</code> 中执行，最后在 <code>ApplyDelegate::end</code> 做收尾工作，这里就是向 peer 返回执行结果。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">end</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, fsms: &amp;<span class="keyword">mut</span> [<span class="type">Option</span>&lt;<span class="keyword">impl</span> <span class="title class_">DerefMut</span>&lt;Target = ApplyFsm&lt;EK&gt;&gt;&gt;]) &#123;</span><br><span class="line">    <span class="keyword">self</span>.apply_ctx.<span class="title function_ invoke__">flush</span>(); <span class="comment">// 向 peer 返回执行结果</span></span><br><span class="line">    <span class="keyword">for</span> <span class="variable">fsm</span> <span class="keyword">in</span> fsms.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">flatten</span>() &#123;</span><br><span class="line">        fsm.delegate.last_flush_applied_index = fsm.delegate.apply_state.<span class="title function_ invoke__">get_applied_index</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="ApplyContext-flush"><a href="#ApplyContext-flush" class="headerlink" title="ApplyContext::flush"></a>ApplyContext::flush</h5><p>主要做两个事：</p>
<ol>
<li>将 unflushed 数据写入到 rocksdb 中，</li>
<li>并将 ApplyRes 返回给 PeerFsm，更新 RaftLocalState、region 等。</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">flush</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// Write to engine</span></span><br><span class="line">    <span class="comment">// raftstore.sync-log = true means we need prevent data loss when power failure.</span></span><br><span class="line">    <span class="comment">// take raft log gc for example, we write kv WAL first, then write raft WAL,</span></span><br><span class="line">    <span class="comment">// if power failure happen, raft WAL may synced to disk, but kv WAL may not.</span></span><br><span class="line">    <span class="comment">// so we use sync-log flag here.</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">is_synced</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">write_to_db</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !<span class="keyword">self</span>.apply_res.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">apply_res</span> = mem::<span class="title function_ invoke__">take</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>.apply_res);</span><br><span class="line">        <span class="keyword">self</span>.notifier.<span class="title function_ invoke__">notify</span>(apply_res); <span class="comment">// 通知 PeerFsm 本次的 ApplyRes</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    slow_log!(</span><br><span class="line">        elapsed,</span><br><span class="line">        <span class="string">&quot;&#123;&#125; handle ready &#123;&#125; committed entries&quot;</span>,</span><br><span class="line">        <span class="keyword">self</span>.tag,</span><br><span class="line">        <span class="keyword">self</span>.committed_count</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">self</span>.committed_count = <span class="number">0</span>;</span><br><span class="line">    is_synced</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PeerStorage-handle-raft-ready"><a href="#PeerStorage-handle-raft-ready" class="headerlink" title="PeerStorage::handle_raft_ready"></a>PeerStorage::handle_raft_ready</h4><p>raft_ready：</p>
<ul>
<li>leader: 可以处理新增的 entries</li>
<li>follower： 可以处理新增的 snapshot、entries</li>
</ul>
<p>reft_ready，则可以将新增数据写入自己的 raft-rocksdb 中，这里是以 rocksdb 的 write_batch 为单位，即将一个 ready 中的数据写入到 write_batch，然后一起 commit 到 raft-rocksdb 中。</p>
<p>因此 <code>handle_raft_ready</code> 函数返回，如果存在待写的数据，则都在返回的 write_task 中，用 HandleReadyResult 来标志是否有数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">handle_raft_ready</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    ready: &amp;<span class="keyword">mut</span> Ready,</span><br><span class="line">    destroy_regions: <span class="type">Vec</span>&lt;metapb::Region&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;(HandleReadyResult, WriteTask&lt;EK, ER&gt;)&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">region_id</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">get_region_id</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">prev_raft_state</span> = <span class="keyword">self</span>.raft_state.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">write_task</span> = WriteTask::<span class="title function_ invoke__">new</span>(region_id, <span class="keyword">self</span>.peer_id, ready.<span class="title function_ invoke__">number</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">res</span> = HandleReadyResult::SendIOTask; <span class="comment">// 有数据，但是没有 snapshot</span></span><br><span class="line">    <span class="comment">// 1. 处理 snapshot</span></span><br><span class="line">    <span class="keyword">if</span> !ready.<span class="title function_ invoke__">snapshot</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        fail_point!(<span class="string">&quot;raft_before_apply_snap&quot;</span>);</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">last_first_index</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">first_index</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">snap_region</span> =</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">apply_snapshot</span>(ready.<span class="title function_ invoke__">snapshot</span>(), &amp;<span class="keyword">mut</span> write_task, &amp;destroy_regions)?; <span class="comment">// apply 的是元数据</span></span><br><span class="line"></span><br><span class="line">        res = HandleReadyResult::Snapshot &#123;</span><br><span class="line">            msgs: ready.<span class="title function_ invoke__">take_persisted_messages</span>(),</span><br><span class="line">            snap_region,</span><br><span class="line">            destroy_regions,</span><br><span class="line">            last_first_index,</span><br><span class="line">        &#125;;</span><br><span class="line">        fail_point!(<span class="string">&quot;raft_after_apply_snap&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 处理新增的 entries</span></span><br><span class="line">    <span class="keyword">if</span> !ready.<span class="title function_ invoke__">entries</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">append</span>(ready.<span class="title function_ invoke__">take_entries</span>(), &amp;<span class="keyword">mut</span> write_task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Last index is 0 means the peer is created from raft message</span></span><br><span class="line">    <span class="comment">// and has not applied snapshot yet, so skip persistent hard state.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.raft_state.<span class="title function_ invoke__">get_last_index</span>() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(hs) = ready.<span class="title function_ invoke__">hs</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.raft_state.<span class="title function_ invoke__">set_hard_state</span>(hs.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save raft state if it has changed or there is a snapshot.</span></span><br><span class="line">    <span class="keyword">if</span> prev_raft_state != <span class="keyword">self</span>.raft_state || !ready.<span class="title function_ invoke__">snapshot</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        write_task.raft_state = <span class="title function_ invoke__">Some</span>(<span class="keyword">self</span>.raft_state.<span class="title function_ invoke__">clone</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !ready.<span class="title function_ invoke__">snapshot</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="comment">// In case of restart happens when we just write region state to Applying,</span></span><br><span class="line">        <span class="comment">// but not write raft_local_state to raft db in time.</span></span><br><span class="line">        <span class="comment">// We write raft state to kv db, with last index set to snap index,</span></span><br><span class="line">        <span class="comment">// in case of recv raft log after snapshot.</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">save_snapshot_raft_state_to</span>(</span><br><span class="line">            ready.<span class="title function_ invoke__">snapshot</span>().<span class="title function_ invoke__">get_metadata</span>().<span class="title function_ invoke__">get_index</span>(),</span><br><span class="line">            write_task.kv_wb.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>(),</span><br><span class="line">        )?;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">save_apply_state_to</span>(write_task.kv_wb.<span class="title function_ invoke__">as_mut</span>().<span class="title function_ invoke__">unwrap</span>())?;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !write_task.<span class="title function_ invoke__">has_data</span>() &#123;</span><br><span class="line">        res = HandleReadyResult::NoIOTask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_ invoke__">Ok</span>((res, write_task))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后 <code>Peer::handle_raft_reafy_append</code> 中再基于 <code>handle_raft_ready</code> 的返回结果，进行处理。</p>
<p>每次 raft ready，都会有个 ready_number，这个用于异步确认当前一些过时的消息。</p>
<p>如果有新增的 entries or snapshot，在 <code>PeerStorage::handle_raft_ready</code> 中更新 meta 信息后，下面就需要将真实的 raft 数据写入到 raft-rocksdb。这里有两种方案：</p>
<ul>
<li><p>同步写：此时 <code>PollContext::sync_write_worker</code> 字段的值不为 None，直接调用 handle_write_task 完成写;</p>
</li>
<li><p>异步写：将 write_task 发送到 StoreWriters 的线程池中，在线程池中调用 handle_write_task 完成写。</p>
<p>  async_write 问题在于线程吃中写操作完成后怎么通知 PeerFsm 写操作完成了以及哪次的 raft-reay 完成了写？</p>
<ul>
<li>这在 StoreWriters 内部包含了一个 PeerFsm 的 router 的 sender，通过他就能通知 PeerFsm；</li>
<li>第二个问题是靠 ready_number 建立联系的</li>
</ul>
<p>  StoreWriters 完成后发的消息是<br>  <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PeerMsg::Persisted &#123;</span><br><span class="line">    peer_id,      <span class="comment">// 哪个 peer 完成了</span></span><br><span class="line">    ready_number, <span class="comment">// 哪次 raft-ready 完成了写</span></span><br><span class="line">&#125; =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">on_persisted_msg</span>(peer_id, ready_number),</span><br></pre></td></tr></table></figure><br>  PeerFsm 接受到 <code>PeerMsg::Persisted</code> 后就会进行后续的处理。</p>
<p>  异步写时，没有完成的操作都会缓存在 <code>self.unpersisted_readies</code> 中，也依赖 ready_number 来建立联系。</p>
</li>
</ul>
<p><code>Ready::persisted_message()</code> 和 <code>Ready::messsage()</code> 内部都是message，只是区别于leader、follower</p>
<ul>
<li>leader：调用的是 <code>ready.take_messages()</code> 获得的 message 需要发送给 follower，follower 调用 <code>ready.take_messages()</code> 返回空的数组；</li>
<li>follower：调用的是 <code>ready.take_persisted_messages()</code> 获得的是返回给 leader 的response，leader 调用 <code>ready.take_persisted_messages()</code> 返回的也是空数组；</li>
</ul>
<p>只要 <code>ready.take_persisted_messages()</code> 返回了非空数组:</p>
<ul>
<li>如果当前 write_tasks 非空：此时返回的 res 不是 HandleReadyResult::NoIOTask，无论是同步还是异步写，都会在 <code>handle_write_task</code> 中等待写完成后，将这个 msg 发送给 leader；</li>
<li>如果当前 write_task 没有数据，返回的 res 是 HandleReadyResult::NoIOTask：<ul>
<li>如果之前有未完成的写，则将其添加到 <code>unpersisted_readies.raft_msgs</code> 中，等写完成后，回应 leader</li>
<li>如果当前没有未完成的写，则直接将其发送出去，回应 leader</li>
</ul>
</li>
</ul>
<p>关于 <strong>advance</strong> 下一节再说。 其余的主要逻辑大致如下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">ready_number</span> = ready.<span class="title function_ invoke__">number</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="variable">persisted_msgs</span> = ready.<span class="title function_ invoke__">take_persisted_messages</span>();</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">has_write_ready</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">match</span> &amp;res &#123;</span><br><span class="line">    HandleReadyResult::SendIOTask | HandleReadyResult::Snapshot &#123; .. &#125; =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> !persisted_msgs.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            task.messages = <span class="keyword">self</span>.<span class="title function_ invoke__">build_raft_messages</span>(ctx, persisted_msgs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> !request_times.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">            task.request_times = request_times;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/// 根据配置，决定是同步还是异步写入 rocksdb</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(write_worker) = &amp;<span class="keyword">mut</span> ctx.sync_write_worker &#123;</span><br><span class="line">            <span class="comment">// 同步写</span></span><br><span class="line">            write_worker.<span class="title function_ invoke__">handle_write_task</span>(task);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">assert_eq!</span>(<span class="keyword">self</span>.unpersisted_ready, <span class="literal">None</span>);</span><br><span class="line">            <span class="keyword">self</span>.unpersisted_ready = <span class="title function_ invoke__">Some</span>(ready);</span><br><span class="line">            has_write_ready = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 异步写</span></span><br><span class="line">            <span class="comment">// 将写任务发送到 StoreWriters 的线程池中</span></span><br><span class="line">            <span class="comment">// 在线程池中调用 handle_write_task 函数</span></span><br><span class="line">            <span class="keyword">self</span>.write_router.<span class="title function_ invoke__">send_write_msg</span>(</span><br><span class="line">                ctx,</span><br><span class="line">                <span class="keyword">self</span>.unpersisted_readies.<span class="title function_ invoke__">back</span>().<span class="title function_ invoke__">map</span>(|r| r.number),</span><br><span class="line">                WriteMsg::<span class="title function_ invoke__">WriteTask</span>(task),</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 缓存队列，记录未完成的写操作</span></span><br><span class="line">            <span class="keyword">self</span>.unpersisted_readies.<span class="title function_ invoke__">push_back</span>(UnpersistedReady &#123;</span><br><span class="line">                number: ready_number,</span><br><span class="line">                max_empty_number: ready_number,</span><br><span class="line">                raft_msgs: <span class="built_in">vec!</span>[],</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 清空本轮 ready 数据，尚未持久化部分数据</span></span><br><span class="line">            <span class="keyword">self</span>.raft_group.<span class="title function_ invoke__">advance_append_async</span>(ready);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    HandleReadyResult::NoIOTask =&gt; &#123;</span><br><span class="line">        <span class="comment">/// 1. 之前存在未持久化的 raft_log</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>(last) = <span class="keyword">self</span>.unpersisted_readies.<span class="title function_ invoke__">back_mut</span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> ready_number &lt;= last.max_empty_number &#123;</span><br><span class="line">                <span class="built_in">panic!</span>(</span><br><span class="line">                    <span class="string">&quot;&#123;&#125; ready number is not monotonically increaing, &#123;&#125; &lt;= &#123;&#125;&quot;</span>,</span><br><span class="line">                    <span class="keyword">self</span>.tag, ready_number, last.max_empty_number</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">            last.max_empty_number = ready_number;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 等待 raft_log 持久化之后，在 callback 中执行</span></span><br><span class="line">            <span class="comment">// 即 on_persist_ready 函数中执行</span></span><br><span class="line">            <span class="keyword">if</span> !persisted_msgs.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                <span class="keyword">self</span>.unpersisted_message_count += persisted_msgs.<span class="title function_ invoke__">capacity</span>();</span><br><span class="line">                last.raft_msgs.<span class="title function_ invoke__">push</span>(persisted_msgs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/// 2. 当前没有任何未完成的 raft_log 未持久化完成的任务, 则 follower 直接回应 leader</span></span><br><span class="line">            <span class="keyword">self</span>.persisted_number = ready_number;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> !persisted_msgs.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                <span class="keyword">let</span> <span class="variable">msgs</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">build_raft_messages</span>(ctx, persisted_msgs);</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">send_raft_messages</span>(ctx, msgs);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// advance_append 表示 follower 的 append 完成</span></span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">light_rd</span> = <span class="keyword">self</span>.raft_group.<span class="title function_ invoke__">advance_append</span>(ready);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The committed entries may not be empty when the size is too large to</span></span><br><span class="line">            <span class="comment">// be fetched in the previous ready.</span></span><br><span class="line">            <span class="keyword">if</span> !light_rd.<span class="title function_ invoke__">committed_entries</span>().<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">handle_raft_committed_entries</span>(ctx, light_rd.<span class="title function_ invoke__">take_committed_entries</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Advance"><a href="#Advance" class="headerlink" title="Advance"></a>Advance</h3><p>大的流程是 <code>propose ==&gt; ready ==&gt; advance</code>，上面已经讲解了 propose &#x3D;&#x3D;&gt; ready 的流程，下面就是 advance。</p>
<p>advance 主要是在 ready、apply 之后进行一些元数据信息的更改，而同步和异步的区别也在于 advance 流程的拆分。</p>
<ul>
<li>同步的 advance 在消息处理状态机快结束的时候处理的，即在 <code>RaftPoller::end</code> 函数中执行了 <code>Peer::handle_raft_ready_advance</code></li>
<li>异步的 advance 将同步的逻辑整体划分为 <ul>
<li><p>raft_log 持久化前</p>
<p>先将已经 ready 的数据取出，异步发送到 StorageWriter 中的线程池去持久化，然后调用 <code>RawNode::advance_append_async</code> 在内存中更新 commit 相关状态，raft 中的 ready 的数据（entries、snapshot）重置为None。</p>
</li>
<li><p>raft-log 持久化后</p>
<p>调用 on_persist_ready 更新相关操作。</p>
</li>
</ul>
</li>
</ul>
<h3 id="PeerFsmDelegate-on-raft-message"><a href="#PeerFsmDelegate-on-raft-message" class="headerlink" title="PeerFsmDelegate::on_raft_message"></a>PeerFsmDelegate::on_raft_message</h3><p>发出的的消息的处理。</p>
<h4 id="step"><a href="#step" class="headerlink" title="step"></a>step</h4>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PollHandler-handle-normal"><span class="toc-number">1.</span> <span class="toc-text">PollHandler::handle_normal</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Propose"><span class="toc-number">1.1.</span> <span class="toc-text">Propose</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PeerFsmDelegate-propose-batch-raft-command"><span class="toc-number">1.1.1.</span> <span class="toc-text">PeerFsmDelegate::propose_batch_raft_command</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PeerFsmDelegate-propose-raft-command-internal"><span class="toc-number">1.1.2.</span> <span class="toc-text">PeerFsmDelegate::propose_raft_command_internal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Ready"><span class="toc-number">1.2.</span> <span class="toc-text">Ready</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Peer-handle-raft-ready-append-before-ready"><span class="toc-number">1.2.1.</span> <span class="toc-text">Peer::handle_raft_ready_append(before ready)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Peer-handle-raft-ready-append-after-ready"><span class="toc-number">1.2.2.</span> <span class="toc-text">Peer::handle_raft_ready_append(after ready)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PeerStorage-snapshot"><span class="toc-number">1.2.3.</span> <span class="toc-text">PeerStorage::snapshot</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyFsm-handle-snapshot"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">ApplyFsm::handle_snapshot</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SnapContext-generate-snap"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">SnapContext::generate_snap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#store-do-snapshot"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">store::do_snapshot</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplyFsm-handle-apply"><span class="toc-number">1.2.4.</span> <span class="toc-text">ApplyFsm::handle_apply</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyFsm-append-proposal"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">ApplyFsm::append_proposal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyDelegate-handle-raft-committed-entries"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">ApplyDelegate::handle_raft_committed_entries</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyContext-prepare-for"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">ApplyContext::prepare_for</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyContext-commit"><span class="toc-number">1.2.4.4.</span> <span class="toc-text">ApplyContext::commit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyContext-write-to-db"><span class="toc-number">1.2.4.5.</span> <span class="toc-text">ApplyContext::write_to_db</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyContext-finish-for"><span class="toc-number">1.2.4.6.</span> <span class="toc-text">ApplyContext::finish_for</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyDelegate-handle-raft-entry-normal"><span class="toc-number">1.2.4.7.</span> <span class="toc-text">ApplyDelegate::handle_raft_entry_normal</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyDelegate-end"><span class="toc-number">1.2.4.8.</span> <span class="toc-text">ApplyDelegate::end</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ApplyContext-flush"><span class="toc-number">1.2.4.9.</span> <span class="toc-text">ApplyContext::flush</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PeerStorage-handle-raft-ready"><span class="toc-number">1.2.5.</span> <span class="toc-text">PeerStorage::handle_raft_ready</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Advance"><span class="toc-number">1.3.</span> <span class="toc-text">Advance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PeerFsmDelegate-on-raft-message"><span class="toc-number">1.4.</span> <span class="toc-text">PeerFsmDelegate::on_raft_message</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step"><span class="toc-number">1.4.1.</span> <span class="toc-text">step</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&text=tikv: RaftStore propose 过程"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&title=tikv: RaftStore propose 过程"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&is_video=false&description=tikv: RaftStore propose 过程"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=tikv: RaftStore propose 过程&body=Check out this article: https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&title=tikv: RaftStore propose 过程"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&title=tikv: RaftStore propose 过程"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&title=tikv: RaftStore propose 过程"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&title=tikv: RaftStore propose 过程"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&name=tikv: RaftStore propose 过程&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/10/15/TiKV/tikv_raft_propose/&t=tikv: RaftStore propose 过程"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2026
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
