<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="raft_rs这边博客主要是从源码角度分析下 raft-rs 的日志复制和选举过程。 Entry1234567891011121314151617&#x2F;&#x2F; The entry is a type of change that needs to be applied. It contains two data fields.&#x2F;&#x2F; While the fields are built into the m">
<meta property="og:type" content="article">
<meta property="og:title" content="raft-rs: raft replication">
<meta property="og:url" content="https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="raft_rs这边博客主要是从源码角度分析下 raft-rs 的日志复制和选举过程。 Entry1234567891011121314151617&#x2F;&#x2F; The entry is a type of change that needs to be applied. It contains two data fields.&#x2F;&#x2F; While the fields are built into the m">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2022-10-02T02:00:01.000Z">
<meta property="article:modified_time" content="2023-08-29T01:57:30.262Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="TiKV6.1">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>raft-rs: raft replication</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2022/10/02/TiFlash/DeltaTreeIndex-2/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2022/10/01/TiFlash/DeltaTreeIndex-1/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&text=raft-rs: raft replication"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&title=raft-rs: raft replication"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&is_video=false&description=raft-rs: raft replication"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=raft-rs: raft replication&body=Check out this article: https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&title=raft-rs: raft replication"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&title=raft-rs: raft replication"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&title=raft-rs: raft replication"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&title=raft-rs: raft replication"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&name=raft-rs: raft replication&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&t=raft-rs: raft replication"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#raft-rs"><span class="toc-number">1.</span> <span class="toc-text">raft_rs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entry"><span class="toc-number">2.</span> <span class="toc-text">Entry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Message"><span class="toc-number">3.</span> <span class="toc-text">Message</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#propose"><span class="toc-number">4.</span> <span class="toc-text">propose</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft-append-entry"><span class="toc-number">4.0.1.</span> <span class="toc-text">Raft::append_entry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft-bcast-append"><span class="toc-number">4.0.2.</span> <span class="toc-text">Raft::bcast_append</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftLog-entries"><span class="toc-number">4.0.3.</span> <span class="toc-text">RaftLog::entries</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftCore-prepare-send-entries"><span class="toc-number">4.0.4.</span> <span class="toc-text">RaftCore::prepare_send_entries</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftCore-maybe-send-append"><span class="toc-number">4.0.5.</span> <span class="toc-text">RaftCore::maybe_send_append</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftCore-send"><span class="toc-number">4.0.6.</span> <span class="toc-text">RaftCore::send</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Raft-handle-append-entries"><span class="toc-number">4.1.</span> <span class="toc-text">Raft::handle_append_entries</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftLog-find-conflict-by-term"><span class="toc-number">4.1.1.</span> <span class="toc-text">RaftLog::find_conflict_by_term</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftLog-find-conflict"><span class="toc-number">4.1.2.</span> <span class="toc-text">RaftLog::find_conflict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftLog-maybe-append"><span class="toc-number">4.1.3.</span> <span class="toc-text">RaftLog::maybe_append</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RaftLog-handle-append-response"><span class="toc-number">4.2.</span> <span class="toc-text">RaftLog::handle_append_response</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E5%86%B2%E7%AA%81"><span class="toc-number">4.2.1.</span> <span class="toc-text">存在冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%86%B2%E7%AA%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">不存在冲突</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        raft-rs: raft replication
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2022-10-02T02:00:01.000Z" itemprop="datePublished">2022-10-02</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/TiKV6-1/" rel="tag">TiKV6.1</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="raft-rs"><a href="#raft-rs" class="headerlink" title="raft_rs"></a>raft_rs</h2><p>这边博客主要是从源码角度分析下 <a target="_blank" rel="noopener" href="https://github.com/tikv/raft-rs">raft-rs</a> 的日志复制和选举过程。</p>
<h2 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// The entry is a type of change that needs to be applied. It contains two data fields.</span><br><span class="line">// While the fields are built into the model; their usage is determined by the entry_type.</span><br><span class="line">//</span><br><span class="line">// For normal entries, the data field should contain the data change that should be applied.</span><br><span class="line">// The context field can be used for any contextual data that might be relevant to the</span><br><span class="line">// application of the data.</span><br><span class="line">//</span><br><span class="line">// For configuration changes, the data will contain the ConfChange message and the</span><br><span class="line">// context will provide anything needed to assist the configuration change. The context</span><br><span class="line">// if for the user to set and use in this case.</span><br><span class="line">message Entry &#123;</span><br><span class="line">    EntryType entry_type = 1;</span><br><span class="line">    uint64 term = 2;</span><br><span class="line">    uint64 index = 3;</span><br><span class="line">    bytes data = 4;</span><br><span class="line">    bytes context = 6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>term：选举任期，每次选举之后递增1。它的主要作用是标记信息的时效性，比方说当一个节点发出来的消息中携带的term是2，而另一个节点携带的term是3，那我们就认为第一个节点的信息过时了。</li>
<li>index：当前这个entry在整个raft日志中的位置索引。有了Term和Index之后，一个log entry就能被唯一标识。</li>
<li>type：当前entry的类型，目前etcd支持两种类型：EntryNormal和EntryConfChange，EntryNormal代表当前Entry是对状态机的操作，EntryConfChange则代表对当前集群配置进行更改的操作，比如增加或者减少节点。</li>
<li>data：一个被序列化后的byte数组，代表当前entry真正要执行的操作，比方说如果上面的Type是EntryNormal，那这里的Data就可能是具体要更改的key-value pair，如果Type是EntryConfChange，那Data就是具体的配置更改项ConfChange。raft算法本身并不关心这个数据是什么，它只是把这段数据当做log同步过程中的payload来处理，具体对这个数据的解析则有上层应用来完成。</li>
</ul>
<h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p>TiKV 接受用户发送过来的 command，并将其封装成 entry，然后调用 RawNode::propose 方法，将数据进一步封装。</p>
<p><a href=".">Message</a> 由 proto 定义，在 raft 之间传输数据的消息格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">message Message &#123;</span><br><span class="line">    MessageType msg_type = 1;</span><br><span class="line">    uint64 to = 2;</span><br><span class="line">    uint64 from = 3;</span><br><span class="line">    uint64 term = 4;</span><br><span class="line">    uint64 log_term = 5;</span><br><span class="line">    uint64 index = 6;</span><br><span class="line">    repeated Entry entries = 7;</span><br><span class="line">    uint64 commit = 8;</span><br><span class="line">    Snapshot snapshot = 9;</span><br><span class="line">    uint64 request_snapshot = 13;</span><br><span class="line">    bool reject = 10;</span><br><span class="line">    uint64 reject_hint = 11;</span><br><span class="line">    bytes context = 12;</span><br><span class="line">    uint64 priority = 14;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Type：当前传递的消息类型，它的取值有很多个，但大致可以分成两类：<ul>
<li>Raft 协议相关的，包括心跳 MsgHeartbeat、日志 MsgApp、投票消息MsgVote等。</li>
<li>上层应用触发的（没错，上层应用并不是通过api与raft库交互的，而是通过发消息），比如应用对数据更改的消息MsgPropose</li>
</ul>
</li>
</ul>
<p>不同类型的消息会用到下面不同的字段：</p>
<ul>
<li>to, from：分别代表了这个消息的接受者和发送者。</li>
<li>term：这个消息发出时整个集群所处的任期。</li>
<li>log_term：消息发出者所保存的日志中最后一条的任期号，一般MsgVote会用到这个字段。</li>
<li>index：日志索引号。如果当前消息是MsgVote的话，代表这个 candidate 最后一条日志的索引号，它跟上面的 log_term 一起代表这个 candidate 所拥有的最新日志信息，这样别人就可以比较自己的日志是不是比 candidata 的日志要新，从而决定是否投票。</li>
<li>entries：需要存储的日志。</li>
<li>commit：已经提交的日志的索引值，用来向别人同步日志的提交信息。</li>
<li>snapshot：一般跟 MsgSnap 合用，用来放置具体的 Snapshot 值。</li>
<li>reject，reject_hint：代表对方节点拒绝了当前节点的请求(MsgVote&#x2F;MsgApp&#x2F;MsgSnap…)</li>
</ul>
<h2 id="propose"><a href="#propose" class="headerlink" title="propose"></a>propose</h2><p>RawNode::propose 函数，将传入的数据 <code>data</code> 封装成 <code>message</code> 格式，再交给 <code>Raft::step</code> 函数处理。</p>
<p>注意，propose 的目的是将传入的数据 <code>data</code> 封装成可以发送到其他的 TiKV 的消息格式，在 RawNode::propose 函数中只是简单处理了下，下面进一步的操作，会进入 Raft::step 函数。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Propose proposes data be appended to the raft log.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">propose</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, context: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;, data: <span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = Message::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    m.<span class="title function_ invoke__">set_msg_type</span>(MessageType::MsgPropose);</span><br><span class="line">    m.from = <span class="keyword">self</span>.raft.id;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">e</span> = Entry::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    e.data = data.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    e.context = context.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    m.<span class="title function_ invoke__">set_entries</span>(<span class="built_in">vec!</span>[e].<span class="title function_ invoke__">into</span>());</span><br><span class="line">    <span class="keyword">self</span>.raft.<span class="title function_ invoke__">step</span>(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RawNode::propose 封装完的 m 的 m.term 并没初始化，默认值是 0, 即本地消息，因此在 Raft::step 函数中会进入 <code>Raft::step_leader</code> 函数，最终会进入 <code>MessageType::MsgPropose</code> 处理分支。处理逻辑如下：</p>
<ol>
<li>如果待处理的 m.entries 是空的，不处理；</li>
<li>当集群的配置发生更改，而这个 leader 已经被标记为删除。即便这个 leader 仍然 alive，也就不能接受 proposal；</li>
<li>正在迁移 leader 也不能处理 proposal</li>
<li>在 Raft::append_entry 中处理 m.entries，传入的类型是可变类型，是因为在 Raft::append_entry 需要丰富 m.entries 中每个 entry 的信息，比如 term, index。 </li>
<li>Raft::bcast_append 广播给其他的 tikv</li>
</ol>
<p>这些过程走完，其实消息并没有发送出去，只是缓存在 RaftLog 中 。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">step_leader</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> m: Message) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> m.<span class="title function_ invoke__">get_msg_type</span>() &#123;</span><br><span class="line">        MessageType::MsgPropose =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> m.entries.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">                fatal!(<span class="keyword">self</span>.logger, <span class="string">&quot;stepped empty MsgProp&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>.prs.<span class="title function_ invoke__">progress</span>().<span class="title function_ invoke__">contains_key</span>(&amp;<span class="keyword">self</span>.id) &#123;</span><br><span class="line">                <span class="comment">// If we are not currently a member of the range (i.e. this node</span></span><br><span class="line">                <span class="comment">// was removed from the configuration while serving as leader),</span></span><br><span class="line">                <span class="comment">// drop any new proposals.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::ProposalDropped);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.lead_transferee.<span class="title function_ invoke__">is_some</span>() &#123;</span><br><span class="line">                debug!(</span><br><span class="line">                    <span class="keyword">self</span>.logger,</span><br><span class="line">                    <span class="string">&quot;[term &#123;term&#125;] transfer leadership to &#123;lead_transferee&#125; is in progress; dropping \</span></span><br><span class="line"><span class="string">                        proposal&quot;</span>,</span><br><span class="line">                    term = <span class="keyword">self</span>.term,</span><br><span class="line">                    lead_transferee = <span class="keyword">self</span>.lead_transferee.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::ProposalDropped);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">if</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">append_entry</span>(m.<span class="title function_ invoke__">mut_entries</span>()) &#123;</span><br><span class="line">                <span class="comment">// return ProposalDropped when uncommitted size limit is reached</span></span><br><span class="line">                debug!(</span><br><span class="line">                    <span class="keyword">self</span>.logger,</span><br><span class="line">                    <span class="string">&quot;entries are dropped due to overlimit of max uncommitted size, uncommitted_size: &#123;&#125;&quot;</span>,</span><br><span class="line">                    <span class="keyword">self</span>.<span class="title function_ invoke__">uncommitted_size</span>()</span><br><span class="line">                );</span><br><span class="line">                <span class="keyword">return</span> <span class="title function_ invoke__">Err</span>(Error::ProposalDropped);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">bcast_append</span>();</span><br><span class="line">            <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(());</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Raft-append-entry"><a href="#Raft-append-entry" class="headerlink" title="Raft::append_entry"></a>Raft::append_entry</h4><p>当前 raft 的已经本地保存的 entry 的 index 是 self.raft_log.last_index()，新加入的 entries 的 index 就需要在 last_index 之后连续递增，同时每个 entry 的 term 都是当前 raft leader 的 term。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">message Entry &#123;</span><br><span class="line">    EntryType entry_type = 1;</span><br><span class="line">    uint64 term = 2;</span><br><span class="line">    uint64 index = 3;</span><br><span class="line">    bytes data = 4;</span><br><span class="line">    bytes context = 6;</span><br><span class="line"></span><br><span class="line">    // Deprecated! It is kept for backward compatibility.</span><br><span class="line">    // TODO: remove it in the next major release.</span><br><span class="line">    bool sync_log = 5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>填充完 entries，则调用 <code>RaftLog::append</code> 将其 <strong>append</strong> 到 raft_log 中，这样在 leader 节点上就不会丢失。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">append_entry</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, es: &amp;<span class="keyword">mut</span> [Entry]) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">maybe_increase_uncommitted_size</span>(es) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">li</span> = <span class="keyword">self</span>.raft_log.<span class="title function_ invoke__">last_index</span>();</span><br><span class="line">    <span class="title function_ invoke__">for</span> (i, e) <span class="keyword">in</span> es.<span class="title function_ invoke__">iter_mut</span>().<span class="title function_ invoke__">enumerate</span>() &#123;</span><br><span class="line">        e.term = <span class="keyword">self</span>.term;</span><br><span class="line">        e.index = li + <span class="number">1</span> + i <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.raft_log.<span class="title function_ invoke__">append</span>(es);</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Raft-bcast-append"><a href="#Raft-bcast-append" class="headerlink" title="Raft::bcast_append"></a>Raft::bcast_append</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Sends RPC, with entries to all peers that are not up-to-date</span></span><br><span class="line"><span class="comment">/// according to the progress recorded in r.prs().</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">bcast_append</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">self_id</span> = <span class="keyword">self</span>.id;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">core</span> = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.r;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">msgs</span> = &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.msgs;</span><br><span class="line">    <span class="keyword">self</span>.prs</span><br><span class="line">        .<span class="title function_ invoke__">iter_mut</span>()</span><br><span class="line">        .<span class="title function_ invoke__">filter</span>(|&amp;(id, _)| *id != self_id)</span><br><span class="line">        .<span class="title function_ invoke__">for_each</span>(|(id, pr)| core.<span class="title function_ invoke__">send_append</span>(*id, pr, msgs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>RaftCore::maybe_send_append</code> 函数，将待发送的消息，封装成 Message</p>
<h4 id="RaftLog-entries"><a href="#RaftLog-entries" class="headerlink" title="RaftLog::entries"></a>RaftLog::entries</h4><p>RaftCore::maybe_send_append 函数需要将发送给 to 的消息封装起来。那么问题来了，该函数的入参并没传入 propose 中封装的 m，那又怎么得到该 m.entries。</p>
<p>依赖的是 <code>RaftLog::entries</code>: 由于上面 <code>Raft::append_entry</code> 将 entries </p>
<ul>
<li>idx: 是我们需要读取的 entries 的起始位置，实际上传入的 <strong>pr.next_idx</strong></li>
<li>self.last_index() 记录的是 raft_log 最后一个 entry 的位置，</li>
</ul>
<p>那么，[idx, last_index + 1) 即刚在 <code>Raft::append_entry</code> 函数中写入 raft_log 的 entries 数据，那么调用 RaftLog::slice 函数，即可获得所需 entries 的视图，即 slice。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">entries</span>(</span><br><span class="line">    &amp;<span class="keyword">self</span>,</span><br><span class="line">    idx: <span class="type">u64</span>,</span><br><span class="line">    max_size: <span class="keyword">impl</span> <span class="title class_">Into</span>&lt;<span class="type">Option</span>&lt;<span class="type">u64</span>&gt;&gt;,</span><br><span class="line">    context: GetEntriesContext,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&lt;<span class="type">Vec</span>&lt;Entry&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">max_size</span> = max_size.<span class="title function_ invoke__">into</span>();</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">last</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">last_index</span>();</span><br><span class="line">    <span class="keyword">if</span> idx &gt; last &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Ok</span>(<span class="type">Vec</span>::<span class="title function_ invoke__">new</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">slice</span>(idx, last + <span class="number">1</span>, max_size, context)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RaftCore-prepare-send-entries"><a href="#RaftCore-prepare-send-entries" class="headerlink" title="RaftCore::prepare_send_entries"></a>RaftCore::prepare_send_entries</h4><p>在 RaftCore::prepare_send_entries 函数中，将待发送的消息封装成 MessageType::MsgAppend 类型。在 <code>Raft::append_entry</code> 中已填充了 m.entries 的<br><code>&#123;term, index&#125;</code>，当 m 需要发送给其他 TiKV 节点，则需要填充 leader 中记录的 follower 的 <code>&#123;index, log_term, commit&#125;</code>。</p>
<ul>
<li>p.next_idx：复制给 pr 对应的 raft-node 下一条数据的位置，next_index -1 则是上次的位置。</li>
<li>log_term： 上次和 followrt 同步的 term</li>
<li>commit：当前 raft_log 已经 committed 的数据位置</li>
</ul>
<p>m.entries.last().unwrap().index 记录的是 append 到 raft_log 的最后一条 entry 的位置，</p>
<ul>
<li>用这个来更新对应的 pr 的记录，</li>
<li>同时更新和 follower 发送消息的滑动窗口</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">update_state</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, last: <span class="type">u64</span>) &#123;</span><br><span class="line">    <span class="keyword">match</span> <span class="keyword">self</span>.state &#123;</span><br><span class="line">        ProgressState::Replicate =&gt; &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">optimistic_update</span>(last);</span><br><span class="line">            <span class="keyword">self</span>.ins.<span class="title function_ invoke__">add</span>(last); <span class="comment">// 右移滑动窗口</span></span><br><span class="line">        &#125;</span><br><span class="line">        ProgressState::Probe =&gt; <span class="keyword">self</span>.<span class="title function_ invoke__">pause</span>(),</span><br><span class="line">        ProgressState::Snapshot =&gt; <span class="built_in">panic!</span>(</span><br><span class="line">            <span class="string">&quot;updating progress state in unhandled state &#123;:?&#125;&quot;</span>,</span><br><span class="line">            <span class="keyword">self</span>.state</span><br><span class="line">        ),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码如下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">prepare_send_entries</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    m: &amp;<span class="keyword">mut</span> Message,</span><br><span class="line">    pr: &amp;<span class="keyword">mut</span> Progress,</span><br><span class="line">    term: <span class="type">u64</span>,</span><br><span class="line">    ents: <span class="type">Vec</span>&lt;Entry&gt;,</span><br><span class="line">) &#123;</span><br><span class="line">    m.<span class="title function_ invoke__">set_msg_type</span>(MessageType::MsgAppend);</span><br><span class="line">    m.index = pr.next_idx - <span class="number">1</span>; <span class="comment">// 对端 committed 的位置</span></span><br><span class="line">    m.log_term = term;         <span class="comment">// 对端 committed 的 term</span></span><br><span class="line">    m.<span class="title function_ invoke__">set_entries</span>(ents.<span class="title function_ invoke__">into</span>());</span><br><span class="line">    m.commit = <span class="keyword">self</span>.raft_log.committed; <span class="comment">// 本地commit的记录</span></span><br><span class="line">    <span class="keyword">if</span> !m.entries.<span class="title function_ invoke__">is_empty</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">last</span> = m.entries.<span class="title function_ invoke__">last</span>().<span class="title function_ invoke__">unwrap</span>().index;</span><br><span class="line">        pr.<span class="title function_ invoke__">update_state</span>(last);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RaftCore-maybe-send-append"><a href="#RaftCore-maybe-send-append" class="headerlink" title="RaftCore::maybe_send_append"></a>RaftCore::maybe_send_append</h4><p>暂时忽略 snanshot 部分的逻辑，仅看 entries 的逻辑如下：</p>
<ol>
<li><p>先基于 RaftLog::entries 提取出 propose 的 entries；</p>
</li>
<li><p>再基于 RaftLog::term 提取出 m 对应的 <strong>log_term</strong>，log_term 需要是连续的？</p>
</li>
<li><p>基于 RaftCore::prepare_send_entries 和上面提取到的 {entries, term, to} 将 m 封装成待发送给 to 的 MessageType::MsgAppend 类型的消息。</p>
<p> 如果是 m 已经封装好了，则直接走 try_batching，</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>RaftCore::send 将<br>逻辑大致如下。</p>
</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">maybe_send_append</span>(</span><br><span class="line">    &amp;<span class="keyword">mut</span> <span class="keyword">self</span>,</span><br><span class="line">    to: <span class="type">u64</span>,</span><br><span class="line">    pr: &amp;<span class="keyword">mut</span> Progress,</span><br><span class="line">    allow_empty: <span class="type">bool</span>,</span><br><span class="line">    msgs: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;Message&gt;,</span><br><span class="line">) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = Message::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    m.to = to;</span><br><span class="line">    <span class="keyword">if</span> pr.pending_request_snapshot != INVALID_INDEX &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">ents</span> = <span class="keyword">self</span>.raft_log.<span class="title function_ invoke__">entries</span>(</span><br><span class="line">            pr.next_idx,</span><br><span class="line">            <span class="keyword">self</span>.max_msg_size,</span><br><span class="line">            <span class="title function_ invoke__">GetEntriesContext</span>(GetEntriesFor::SendAppend &#123;</span><br><span class="line">                to,</span><br><span class="line">                term: <span class="keyword">self</span>.term,</span><br><span class="line">                aggressively: !allow_empty,</span><br><span class="line">            &#125;),</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> !allow_empty &amp;&amp; ents.<span class="title function_ invoke__">as_ref</span>().<span class="title function_ invoke__">ok</span>().<span class="title function_ invoke__">map_or</span>(<span class="literal">true</span>, |e| e.<span class="title function_ invoke__">is_empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">term</span> = <span class="keyword">self</span>.raft_log.<span class="title function_ invoke__">term</span>(pr.next_idx - <span class="number">1</span>); <span class="comment">// 上一个 entry 的 term</span></span><br><span class="line">        <span class="title function_ invoke__">match</span> (term, ents) &#123;</span><br><span class="line">            (<span class="title function_ invoke__">Ok</span>(term), <span class="title function_ invoke__">Ok</span>(<span class="keyword">mut</span> ents)) =&gt; &#123;</span><br><span class="line">                <span class="comment">// 上次已经封装好，则不需要再次封装，直接走 try_batching</span></span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">self</span>.batch_append &amp;&amp; <span class="keyword">self</span>.<span class="title function_ invoke__">try_batching</span>(to, msgs, pr, &amp;<span class="keyword">mut</span> ents) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">self</span>.<span class="title function_ invoke__">prepare_send_entries</span>(&amp;<span class="keyword">mut</span> m, pr, term, ents)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//... </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">send</span>(m, msgs);</span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="RaftCore-send"><a href="#RaftCore-send" class="headerlink" title="RaftCore::send"></a>RaftCore::send</h4><p>RaftCore::send 中给 MessageType::MsgAppend 类型的消息 m 添加赋值 leader 的 term，然后将数据添加到消息队列 msgs</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">send</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, <span class="keyword">mut</span> m: Message, msgs: &amp;<span class="keyword">mut</span> <span class="type">Vec</span>&lt;Message&gt;) &#123;</span><br><span class="line">    <span class="keyword">if</span> m.from == INVALID_ID &#123;</span><br><span class="line">        m.from = <span class="keyword">self</span>.id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> m.<span class="title function_ invoke__">get_msg_type</span>() == MessageType::MsgRequestVote</span><br><span class="line">        || m.<span class="title function_ invoke__">get_msg_type</span>() == MessageType::MsgRequestPreVote</span><br><span class="line">        || m.<span class="title function_ invoke__">get_msg_type</span>() == MessageType::MsgRequestVoteResponse</span><br><span class="line">        || m.<span class="title function_ invoke__">get_msg_type</span>() == MessageType::MsgRequestPreVoteResponse</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">assert_eq!</span>(m.term, <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert_ne!</span>(m.term, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> m.<span class="title function_ invoke__">get_msg_type</span>() != MessageType::MsgPropose</span><br><span class="line">            &amp;&amp; m.<span class="title function_ invoke__">get_msg_type</span>() != MessageType::MsgReadIndex</span><br><span class="line">        &#123;</span><br><span class="line">            m.term = <span class="keyword">self</span>.term;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> m.<span class="title function_ invoke__">get_msg_type</span>() == MessageType::MsgRequestVote</span><br><span class="line">        || m.<span class="title function_ invoke__">get_msg_type</span>() == MessageType::MsgRequestPreVote</span><br><span class="line">    &#123;</span><br><span class="line">        m.priority = <span class="keyword">self</span>.priority;</span><br><span class="line">    &#125;</span><br><span class="line">    msgs.<span class="title function_ invoke__">push</span>(m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Raft-handle-append-entries"><a href="#Raft-handle-append-entries" class="headerlink" title="Raft::handle_append_entries"></a>Raft::handle_append_entries</h3><p>下面来看看 follower 怎么处理接受到的 MsgAppend 消息。</p>
<ol>
<li><p>如果 follower 当前正在向 leader 请求 snapshot，则拒绝本次来自 leader 的 Append 请求。</p>
 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">fn</span> <span class="title function_">send_request_snapshot</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">m</span> = Message::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    m.<span class="title function_ invoke__">set_msg_type</span>(MessageType::MsgAppendResponse);</span><br><span class="line">    m.index = <span class="keyword">self</span>.raft_log.committed;</span><br><span class="line">    m.reject = <span class="literal">true</span>;</span><br><span class="line">    m.reject_hint = <span class="keyword">self</span>.raft_log.<span class="title function_ invoke__">last_index</span>();</span><br><span class="line">    m.to = <span class="keyword">self</span>.leader_id;</span><br><span class="line">    m.request_snapshot = <span class="keyword">self</span>.pending_request_snapshot;</span><br><span class="line">    <span class="keyword">self</span>.r.<span class="title function_ invoke__">send</span>(m, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.msgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>检测接受到的消息 m 是否是过时的消息。m.index 是 follower 在 leader 端记录的上次 committed 的位置，如果 <code>m.index &lt; self.raft.log.committed</code> 则说明接受到的是过时的消息，此时回应 leader 自己真实的 committed 位置（leader 端不会处理这种情况）；</p>
</li>
<li><p>不是过时的消息，则调用 <code>RaftLog::maybe_append</code> 尝试 append 到 follower 的 raft_log 中</p>
<ul>
<li><p><code>RaftLog::maybe_append</code> 返回 Some，则表示本次 append 成功，并将返回的 <code>last_index</code> 返回给 leader，用于更新 leader 侧关于此 follower 的 <code>pr.next_idx</code>；</p>
</li>
<li><p><code>RaftLog::maybe_append</code> 返回 None：就要拒绝本次 Append 请求。</p>
<p><code>maybe_append</code> 返回 <code>None</code> ，说明：follower 中的 <code>m.index</code> 对应的 term 和 m.log_term 不匹配，则说明 follower 中存储着的是旧值，</p>
<p>通过 <code>RaftLog::find_conflict_by_term</code> 找到 raft_log 中第一个 <code>&#123;hint_index, hint_term&#125;</code>，并满足 <code>hint_term &lt;= log_term</code> 的  hint_index。</p>
<p>拒绝本次请求，再将相关参数设置，让 leader 重新发送一次 Append 请求。</p>
</li>
</ul>
</li>
<li><p>设置 follower 的 committed 位置</p>
</li>
</ol>
<p>发现一个问题，在 rust 里，proto 定义的类成员变量都是 pub 的，因此直接对成员变量复制和使用 set_xxx 效果是一致的。比如</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">to_send.commit = <span class="keyword">self</span>.raft_log.committed;</span><br><span class="line">to_send.<span class="title function_ invoke__">set_commit</span>(<span class="keyword">self</span>.raft_log.committed);</span><br></pre></td></tr></table></figure>
<p>完整的代码如下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// For a given message, append the entries to the log.</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">handle_append_entries</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, m: &amp;Message) &#123;</span><br><span class="line">    <span class="comment">// 当前已经存在等待 snapshot, 则不接受新的 entry</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.pending_request_snapshot != INVALID_INDEX &#123;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">send_request_snapshot</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旧消息</span></span><br><span class="line">    <span class="keyword">if</span> m.index &lt; <span class="keyword">self</span>.raft_log.committed &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">to_send</span> = Message::<span class="title function_ invoke__">default</span>();</span><br><span class="line">        to_send.<span class="title function_ invoke__">set_msg_type</span>(MessageType::MsgAppendResponse);</span><br><span class="line">        to_send.to = m.from;</span><br><span class="line">        to_send.index = <span class="keyword">self</span>.raft_log.committed;</span><br><span class="line">        to_send.commit = <span class="keyword">self</span>.raft_log.committed;</span><br><span class="line">        <span class="keyword">self</span>.r.<span class="title function_ invoke__">send</span>(to_send, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.msgs);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">to_send</span> = Message::<span class="title function_ invoke__">default</span>();</span><br><span class="line">    to_send.to = m.from;</span><br><span class="line">    to_send.<span class="title function_ invoke__">set_msg_type</span>(MessageType::MsgAppendResponse);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="variable">Some</span>((_, last_idx)) = <span class="keyword">self</span></span><br><span class="line">        .raft_log</span><br><span class="line">        .<span class="title function_ invoke__">maybe_append</span>(m.index, m.log_term, m.commit, &amp;m.entries)</span><br><span class="line">    &#123;</span><br><span class="line">        to_send.index = last_idx;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// &#123;m.index, m.log_term&#125; 不存在 follower 的 raft_log</span></span><br><span class="line">        <span class="comment">// 拒绝请求</span></span><br><span class="line">        <span class="keyword">let</span> <span class="variable">hint_index</span> = cmp::<span class="title function_ invoke__">min</span>(m.index, <span class="keyword">self</span>.raft_log.<span class="title function_ invoke__">last_index</span>());</span><br><span class="line">        <span class="keyword">let</span> (hint_index, hint_term) =</span><br><span class="line">            <span class="keyword">self</span>.raft_log.<span class="title function_ invoke__">find_conflict_by_term</span>(hint_index, m.log_term);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> hint_term.<span class="title function_ invoke__">is_none</span>() &#123;</span><br><span class="line">            fatal!(</span><br><span class="line">                <span class="keyword">self</span>.logger,</span><br><span class="line">                <span class="string">&quot;term(&#123;index&#125;) must be valid&quot;</span>,</span><br><span class="line">                index = hint_index</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        to_send.index = m.index;</span><br><span class="line">        to_send.reject = <span class="literal">true</span>;</span><br><span class="line">        to_send.reject_hint = hint_index;</span><br><span class="line">        to_send.log_term = hint_term.<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    to_send.commit = <span class="keyword">self</span>.raft_log.committed</span><br><span class="line">    <span class="keyword">self</span>.r.<span class="title function_ invoke__">send</span>(to_send, &amp;<span class="keyword">mut</span> <span class="keyword">self</span>.msgs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来阐述下 RaftLog::maybe_append 及相关冲突检测细节。</p>
<h4 id="RaftLog-find-conflict-by-term"><a href="#RaftLog-find-conflict-by-term" class="headerlink" title="RaftLog::find_conflict_by_term"></a>RaftLog::find_conflict_by_term</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">find_conflict_by_term</span>(&amp;<span class="keyword">self</span>, index: <span class="type">u64</span>, term: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> (<span class="type">u64</span>, <span class="type">Option</span>&lt;<span class="type">u64</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">conflict_index</span> = index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">last_index</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">last_index</span>();</span><br><span class="line">    <span class="keyword">if</span> index &gt; last_index &#123;</span><br><span class="line">        warn!(</span><br><span class="line">            <span class="keyword">self</span>.unstable.logger,</span><br><span class="line">            <span class="string">&quot;index(&#123;&#125;) is out of range [0, last_index(&#123;&#125;)] in find_conflict_by_term&quot;</span>,</span><br><span class="line">            index,</span><br><span class="line">            last_index,</span><br><span class="line">        );</span><br><span class="line">        <span class="title function_ invoke__">return</span> (index, <span class="literal">None</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.<span class="title function_ invoke__">term</span>(conflict_index) &#123;</span><br><span class="line">            <span class="title function_ invoke__">Ok</span>(t) =&gt; &#123;</span><br><span class="line">                <span class="comment">// 直到找到 log_term &lt;= term</span></span><br><span class="line">                <span class="keyword">if</span> t &gt; term &#123;</span><br><span class="line">                    conflict_index -= <span class="number">1</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="title function_ invoke__">return</span> (conflict_index, <span class="title function_ invoke__">Some</span>(t));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="title function_ invoke__">Err</span>(_) =&gt; <span class="title function_ invoke__">return</span> (conflict_index, <span class="literal">None</span>),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RaftLog-find-conflict"><a href="#RaftLog-find-conflict" class="headerlink" title="RaftLog::find_conflict"></a>RaftLog::find_conflict</h4><p>所谓冲突，即 index 相同而 term 不一致。那么我们就对 leaoder 发送过来的 entries 中每个 entry 进行冲突检测。 <code>RaftLog::term</code> 函数根据指定的 index 返回本地 raft_log 该 index 对应的 term，<code>RaftLog::match_term</code> 在此基础上判断指定 index 返回的 term 是否是指定的 term。</p>
<ul>
<li><p><code>RaftLog::match_term</code> 函数返回 false，则表示 e.index 对应的 term 不匹配（不存在视为不匹配的一种case）。由 ents 是当前 leader 发送过来消息，那么如果 follower 的 raft_log 中即便之前存在 <code>&#123;e.index, old_term&#125;</code>，那么将新的 <code>&#123;e.index, e.term&#125;</code> 组合对应的数据写入 follower 的 raft_log，来覆盖旧的数据。当然，如果 raft_log 中不存在 e.index 对应的 term，那么说明当前 entry 是新的，也是可以直接 append。</p>
</li>
<li><p><code>RaftLog::match_term</code> 函数全部返回 true，即 <code>RaftLog::find_conflict</code> 返回 0，则表示 <code>ents</code> 已经都包含在 follower 的 raft_log 中。</p>
</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">match_term</span>(&amp;<span class="keyword">self</span>, idx: <span class="type">u64</span>, term: <span class="type">u64</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">term</span>(idx).<span class="title function_ invoke__">map</span>(|t| t == term).<span class="title function_ invoke__">unwrap_or</span>(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">find_conflict</span>(&amp;<span class="keyword">self</span>, ents: &amp;[Entry]) <span class="punctuation">-&gt;</span> <span class="type">u64</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">e</span> <span class="keyword">in</span> ents &#123;</span><br><span class="line">        <span class="keyword">if</span> !<span class="keyword">self</span>.<span class="title function_ invoke__">match_term</span>(e.index, e.term) &#123;</span><br><span class="line">            <span class="keyword">return</span> e.index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="RaftLog-maybe-append"><a href="#RaftLog-maybe-append" class="headerlink" title="RaftLog::maybe_append"></a>RaftLog::maybe_append</h4><p>RaftLog::maybe_append 函数传入参数中的 <code>&#123;idx, term, committed&#125;</code> 分别是 <code>&#123;m.index, m.log_term, m.committed&#125;</code>，由 <code>Raft::bcast_append</code> 函数中设置的参数可知，分别表示：</p>
<ul>
<li>idx: leader 中记录的 follower 已经复制的 entry 的最后一个位置</li>
<li>term: 该 idx 对应的 term</li>
<li>committed: 复制时 leader 的 committed 位置</li>
</ul>
<p>因此，这个 <code>&#123;idx, term&#125;</code>  肯定需要在 follower 中能找到对应的匹配值，否则这个 follower 就落后 leader 太多，需要接受 leader 的 snapshot。</p>
<ul>
<li><p><code>RaftLog::match_term</code> 返回 false </p>
<p>  表示 leader 中关于这个 follower 记录的 <code>&#123;idx, term&#125;</code> 有误，此时 <code>RaftLpg::maybe_append</code> 返回 None， 再由上层的 <code>Raft::handle_append_entries</code> 拒绝本次的 append 请求；</p>
</li>
<li><p><code>self.match(idx, term)</code> 返回 true</p>
<p>  说明 leader 记录的关于这个 follower 的 <code>&#123;idx, term&#125;</code>  pair 在 follower 的 raft_log 中是存在的， 但该 pair 不一定是最新的。比如 当前 leader 曾经同步过 <code>&#123;idx, term&#125;</code> pair 给这个 follower，但是之后 leader 宕机过，后来又重新选上 leader，那么此时关于这个 follower 的 laster 最近的同步记录可能就是这个 <code>&#123;idx, term&#125;</code> pair。（分析不一定对，后续看论文再仔细check）</p>
<p>  基于 <code>RaftLog::find_conflict</code> 判断新加入的 ents 和 follower 的 raft_log 是否有冲突:</p>
<ul>
<li><strong>conflict_idx &#x3D;&#x3D; 0:</strong> 则表示 ents 已全部都在 follower 的 raft_log 中；</li>
<li><strong>conglict_idx &lt; self.committed</strong>: 已经 committed 之前的 entry 不可能存在冲突，这种情况下则fatal，让 follower 直接 crash，重启同步 leader 的 snapshot；</li>
<li><strong>conflict_idx &gt;&#x3D; self.committed</strong>：如果 ents 和 follower 的 raft_log 存在冲突，即 (idx, conflict_idx) 区间已经存在于 follower 的 raft_log 中，则需要将 ents 中前 <code>confict_idx - idx - 1</code> 个元素去掉，再 append 到 follower 的 raft_log 中。</li>
</ul>
</li>
</ul>
<p>整体代码如下。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">maybe_append</span>( &amp;<span class="keyword">mut</span> <span class="keyword">self</span>, idx: <span class="type">u64</span>, term: <span class="type">u64</span>, committed: <span class="type">u64</span>, ents: &amp;[Entry],) <span class="punctuation">-&gt;</span> <span class="type">Option</span>&lt;(<span class="type">u64</span>, <span class="type">u64</span>)&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">match_term</span>(idx, term) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">conflict_idx</span> = <span class="keyword">self</span>.<span class="title function_ invoke__">find_conflict</span>(ents);</span><br><span class="line">        <span class="keyword">if</span> conflict_idx == <span class="number">0</span> &#123;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> conflict_idx &lt;= <span class="keyword">self</span>.committed &#123;</span><br><span class="line">            fatal!(</span><br><span class="line">                <span class="keyword">self</span>.unstable.logger,</span><br><span class="line">                <span class="string">&quot;entry &#123;&#125; conflict with committed entry &#123;&#125;&quot;</span>,</span><br><span class="line">                conflict_idx,</span><br><span class="line">                <span class="keyword">self</span>.committed</span><br><span class="line">            )</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="variable">start</span> = (conflict_idx - (idx + <span class="number">1</span>)) <span class="keyword">as</span> <span class="type">usize</span>;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">append</span>(&amp;ents[start..]);</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">self</span>.persisted &gt; conflict_idx - <span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">self</span>.persisted = conflict_idx - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">last_new_index</span> = idx + ents.<span class="title function_ invoke__">len</span>() <span class="keyword">as</span> <span class="type">u64</span>;</span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">commit_to</span>(cmp::<span class="title function_ invoke__">min</span>(committed, last_new_index));</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_ invoke__">Some</span>((conflict_idx, last_new_index));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">None</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="RaftLog-handle-append-response"><a href="#RaftLog-handle-append-response" class="headerlink" title="RaftLog::handle_append_response"></a>RaftLog::handle_append_response</h3><h4 id="存在冲突"><a href="#存在冲突" class="headerlink" title="存在冲突"></a>存在冲突</h4><p>下面 leader 开始处理 follower 返回的 MsgAppend 响应。</p>
<p><strong>1.</strong> 先来考虑 follower 拒绝了leader 发出的 MsgAppend 请求。</p>
<p>如果 follower 的 raft_log 的尾部存在没有 committed 的部分，那么 leader 需要知道 follower 当前 committed 的具体位置，再向 follower 同步自 committed 之后数据。</p>
<p>最朴素的实现方式即逐个 entry 探测。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">For example, if the leader has:</span><br><span class="line"></span><br><span class="line">idx        1 2 3 4 5 6 7 8 9</span><br><span class="line">           -----------------</span><br><span class="line">term (L)   1 3 3 3 5 5 5 5 5</span><br><span class="line">term (F)   1 1 1 1 2 2</span><br></pre></td></tr></table></figure>
<p>leader 发送了一个 <code>&#123;idx=9, term=5&#125;</code> 的 MsgAppend 请求，收到的回复是 <code>&#123;reject_hint = 6, log_term = 2&#125;</code>，那么 leader 将会再次尝试发送 <code>&#123;idx=6, term=5&#125;</code>，follower 返回的是 <code>&#123;reject_hint = 5, term = 2&#125;</code>，逐个尝试。</p>
<p>leader 的 log_term 总是大于 follower 返回的 reject_term</p>
<p><strong>2.</strong> 根据 m.from 取出 leader 中对应的 Process:</p>
<ul>
<li>更新 follower 的状态为 active，说明 follower 是活跃的；</li>
<li>更新 pr 中该 follower 的 committed 位置。</li>
</ul>
<p><strong>3.</strong> 如果 m.reject 则再探测一次<br><strong>4.</strong> 更新 pr 和 leader 同步的位置；<br>    - Probe: 变成 replicate 模式<br>    - replicate 模式，变成滑动窗口；<br>    - </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_append_response</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, m: &amp;Message) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">next_probe_index</span>: <span class="type">u64</span> = m.reject_hint;</span><br><span class="line">    <span class="keyword">if</span> m.reject &amp;&amp; m.log_term &gt; <span class="number">0</span> &#123;</span><br><span class="line">        next_probe_index = <span class="keyword">self</span></span><br><span class="line">            .raft_log</span><br><span class="line">            .<span class="title function_ invoke__">find_conflict_by_term</span>(m.reject_hint, m.log_term)</span><br><span class="line">            .<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pr</span> = <span class="keyword">match</span> <span class="keyword">self</span>.prs.<span class="title function_ invoke__">get_mut</span>(m.from) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(pr) =&gt; pr,</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    pr.recent_active = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update followers committed index via append response</span></span><br><span class="line">    pr.<span class="title function_ invoke__">update_committed</span>(m.commit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> m.reject &#123;</span><br><span class="line">        <span class="keyword">if</span> pr.<span class="title function_ invoke__">maybe_decr_to</span>(m.index, next_probe_index, m.request_snapshot) &#123;</span><br><span class="line">            <span class="keyword">if</span> pr.state == ProgressState::Replicate &#123;</span><br><span class="line">                pr.<span class="title function_ invoke__">become_probe</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">send_append</span>(m.from);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="不存在冲突"><a href="#不存在冲突" class="headerlink" title="不存在冲突"></a>不存在冲突</h4><p>如果不村子冲突，正常情况下，代码逻辑比较简单。</p>
<ul>
<li>leader 在对应的 pr 中更新 follower 的 commited、append 位置；</li>
<li>如果接受到半数以上的回应，则 commit</li>
<li>leader 更换</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">handle_append_response</span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, m: &amp;Message) &#123;</span><br><span class="line">    <span class="comment">// 确保 follower 还在集群中</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">pr</span> = <span class="keyword">match</span> <span class="keyword">self</span>.prs.<span class="title function_ invoke__">get_mut</span>(m.from) &#123;</span><br><span class="line">        <span class="title function_ invoke__">Some</span>(pr) =&gt; pr,</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    pr.recent_active = <span class="literal">true</span>; <span class="comment">// 更新状态为活跃</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于发送的回应消息，更新 follower 当前 committed 的位置</span></span><br><span class="line">    <span class="comment">// 这个无论是否发生冲突，follower 都要回应正确自己的 committed</span></span><br><span class="line">    pr.<span class="title function_ invoke__">update_committed</span>(m.commit);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个是更新的 follower 的 append 的位置，</span></span><br><span class="line">    <span class="comment">// - 这个记录会记录在 pr 中的 matched 字段，</span></span><br><span class="line">    <span class="comment">// - pr.next_idx</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">old_paused</span> = pr.<span class="title function_ invoke__">is_paused</span>();</span><br><span class="line">    <span class="keyword">if</span> !pr.<span class="title function_ invoke__">maybe_update</span>(m.index) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> pr.state &#123;</span><br><span class="line">        ProgressState::Probe =&gt; pr.<span class="title function_ invoke__">become_replicate</span>(),</span><br><span class="line">        ProgressState::Snapshot =&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> pr.<span class="title function_ invoke__">is_snapshot_caught_up</span>() &#123;</span><br><span class="line">                pr.<span class="title function_ invoke__">become_probe</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ProgressState::Replicate =&gt; pr.ins.<span class="title function_ invoke__">free_to</span>(m.<span class="title function_ invoke__">get_index</span>()), <span class="comment">// 成功append，则释放已经发送消息</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// leader 自己是先将 proposal 发送出去的</span></span><br><span class="line">    <span class="comment">// 如果等待了半数以上的回应，则 commit proposal</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">maybe_commit</span>() &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.<span class="title function_ invoke__">should_bcast_commit</span>() &#123;</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">bcast_append</span>()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> old_paused &#123;</span><br><span class="line">        <span class="comment">// 如果从 probe -&gt; replicated 模式</span></span><br><span class="line">        <span class="comment">// 则先发送消息</span></span><br><span class="line">        <span class="keyword">self</span>.<span class="title function_ invoke__">send_append</span>(m.from);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试发送可能堵塞的消息</span></span><br><span class="line">    <span class="keyword">self</span>.<span class="title function_ invoke__">send_append_aggressively</span>(m.from);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transfer leadership is in progress.</span></span><br><span class="line">    <span class="comment">// 如果正在更换 leader, 并且 followr 已经和 leader 保持完全同步</span></span><br><span class="line">    <span class="comment">// 则发送 MsgTimeout 请求</span></span><br><span class="line">    <span class="keyword">if</span> <span class="title function_ invoke__">Some</span>(m.from) == <span class="keyword">self</span>.r.lead_transferee &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">last_index</span> = <span class="keyword">self</span>.r.raft_log.<span class="title function_ invoke__">last_index</span>();</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">pr</span> = <span class="keyword">self</span>.prs.<span class="title function_ invoke__">get_mut</span>(m.from).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">        <span class="keyword">if</span> pr.matched == last_index &#123;</span><br><span class="line">            info!(</span><br><span class="line">                <span class="keyword">self</span>.logger,</span><br><span class="line">                <span class="string">&quot;sent MsgTimeoutNow to &#123;from&#125; after received MsgAppResp&quot;</span>,</span><br><span class="line">                from = m.from;</span><br><span class="line">            );</span><br><span class="line">            <span class="keyword">self</span>.<span class="title function_ invoke__">send_timeout_now</span>(m.from);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消息通信就到此位置，下面从 MessageType::MsgTimeoutNow 触发 follower 进入选举状态，对 candidate 无效。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#raft-rs"><span class="toc-number">1.</span> <span class="toc-text">raft_rs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Entry"><span class="toc-number">2.</span> <span class="toc-text">Entry</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Message"><span class="toc-number">3.</span> <span class="toc-text">Message</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#propose"><span class="toc-number">4.</span> <span class="toc-text">propose</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft-append-entry"><span class="toc-number">4.0.1.</span> <span class="toc-text">Raft::append_entry</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Raft-bcast-append"><span class="toc-number">4.0.2.</span> <span class="toc-text">Raft::bcast_append</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftLog-entries"><span class="toc-number">4.0.3.</span> <span class="toc-text">RaftLog::entries</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftCore-prepare-send-entries"><span class="toc-number">4.0.4.</span> <span class="toc-text">RaftCore::prepare_send_entries</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftCore-maybe-send-append"><span class="toc-number">4.0.5.</span> <span class="toc-text">RaftCore::maybe_send_append</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftCore-send"><span class="toc-number">4.0.6.</span> <span class="toc-text">RaftCore::send</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Raft-handle-append-entries"><span class="toc-number">4.1.</span> <span class="toc-text">Raft::handle_append_entries</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftLog-find-conflict-by-term"><span class="toc-number">4.1.1.</span> <span class="toc-text">RaftLog::find_conflict_by_term</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftLog-find-conflict"><span class="toc-number">4.1.2.</span> <span class="toc-text">RaftLog::find_conflict</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RaftLog-maybe-append"><span class="toc-number">4.1.3.</span> <span class="toc-text">RaftLog::maybe_append</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RaftLog-handle-append-response"><span class="toc-number">4.2.</span> <span class="toc-text">RaftLog::handle_append_response</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E5%86%B2%E7%AA%81"><span class="toc-number">4.2.1.</span> <span class="toc-text">存在冲突</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%86%B2%E7%AA%81"><span class="toc-number">4.2.2.</span> <span class="toc-text">不存在冲突</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&text=raft-rs: raft replication"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&title=raft-rs: raft replication"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&is_video=false&description=raft-rs: raft replication"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=raft-rs: raft replication&body=Check out this article: https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&title=raft-rs: raft replication"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&title=raft-rs: raft replication"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&title=raft-rs: raft replication"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&title=raft-rs: raft replication"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&name=raft-rs: raft replication&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2022/10/02/TiKV/raft_rs_1_append/&t=raft-rs: raft replication"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
