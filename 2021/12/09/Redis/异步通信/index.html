<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="异步通信之前有两期讲解了服务端框的架构，这一期来讲下服务器是如何与客户端进行异步通信的，下一期再讲述客户端是如何异步非阻塞connect服务器的。  通信，无外乎两点：1）服务器读取对端发送过来的数据；2）向对端发送数据。 异步，目前常用的是epoll + 回调函数。  下面从非阻塞IO开始，逐步构建异步通信框架。 Non-Blocking IO在服务端常用的IO读写操作，主要是read、writ">
<meta property="og:type" content="article">
<meta property="og:title" content="异步通信">
<meta property="og:url" content="https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="异步通信之前有两期讲解了服务端框的架构，这一期来讲下服务器是如何与客户端进行异步通信的，下一期再讲述客户端是如何异步非阻塞connect服务器的。  通信，无外乎两点：1）服务器读取对端发送过来的数据；2）向对端发送数据。 异步，目前常用的是epoll + 回调函数。  下面从非阻塞IO开始，逐步构建异步通信框架。 Non-Blocking IO在服务端常用的IO读写操作，主要是read、writ">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-12-09T03:40:15.000Z">
<meta property="article:modified_time" content="2022-02-14T14:14:46.000Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="nio">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>异步通信</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/12/21/C++/unique_ptr/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/11/26/rocksdb/utility/HashTablel/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&text=异步通信"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&title=异步通信"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&is_video=false&description=异步通信"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=异步通信&body=Check out this article: https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&title=异步通信"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&title=异步通信"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&title=异步通信"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&title=异步通信"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&name=异步通信&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&t=异步通信"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">1.</span> <span class="toc-text">异步通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Non-Blocking-IO"><span class="toc-number">1.1.</span> <span class="toc-text">Non-Blocking IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ET-amp-LT"><span class="toc-number">1.2.</span> <span class="toc-text">ET &amp; LT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BD%8E%E7%94%B5%E5%B9%B3"><span class="toc-number">1.2.1.</span> <span class="toc-text">高低电平</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LT%EF%BC%88Level-Triggered%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">LT（Level Triggered）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%AF%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">可读事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%86%99%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">可写事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ET%EF%BC%88Edge-Triggered%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">ET（Edge Triggered）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%AF%BB%E4%BA%8B%E4%BB%B6-1"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">可读事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%86%99%E4%BA%8B%E4%BB%B6-1"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">可写事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LT-or-ET"><span class="toc-number">1.2.4.</span> <span class="toc-text">LT  or ET ?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#muduo%E6%BA%90%E7%A0%81%E5%B1%95%E7%A4%BA"><span class="toc-number">1.3.</span> <span class="toc-text">muduo源码展示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">1.3.1.</span> <span class="toc-text">监听客户端连接请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%86%99%E4%BA%8B%E4%BB%B6-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">可写事件</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        异步通信
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-12-09T03:40:15.000Z" itemprop="datePublished">2021-12-09</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/nio/">nio</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/nio/" rel="tag">nio</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h1><p>之前有两期讲解了服务端框的架构，这一期来讲下服务器是如何与客户端进行异步通信的，下一期再讲述客户端是如何异步非阻塞connect服务器的。</p>
<ul>
<li>通信，无外乎两点：1）服务器读取对端发送过来的数据；2）向对端发送数据。</li>
<li>异步，目前常用的是<code>epoll</code> + 回调函数。</li>
</ul>
<p>下面从非阻塞IO开始，逐步构建异步通信框架。</p>
<h2 id="Non-Blocking-IO"><a href="#Non-Blocking-IO" class="headerlink" title="Non-Blocking IO"></a>Non-Blocking IO</h2><p>在服务端常用的IO读写操作，主要是<code>read</code>、<code>write</code>及其衍生函数。</p>
<p>所谓阻塞模式，也是<code>read</code>、<code>write</code>等操作的默认行为，比如<code>read</code>函数从<code>stdin</code>读取输入，如果用户没有从终端输入，则会一直阻塞在<code>read</code>函数处。</p>
<p>在非阻塞模式下，<code>read</code>继续从终端读取数据，如果用户没有在终端输入数据，<code>read</code>函数并不会阻塞等待，而是立即返回-1，并将错误码<code>errno</code> 设置为<code>EAGAIN</code> 或者 <code>EWOULDBLOCK</code>。此时<code>read</code>函数返回值<code>n</code>有三种可能：</p>
<ul>
<li><code>n &gt; 0</code>：读取到<code>n</code>个字节；</li>
<li><code>n == 0</code>：对端关闭、文件末尾；</li>
<li><code>n == -1</code>：表示遇到问题，<ul>
<li><code>errno == EAGAIN/EWOULDBLOCK </code>：在非阻塞IO模式下，表示没有数据可读，可忽略本次<code>read</code>操作；</li>
<li><code>errno == EINTR</code>：表示被信号中断，重新读取一次即可。</li>
<li>其他错误类型。</li>
</ul>
</li>
</ul>
<p>写操作<code>write</code>函数也基本类似，更加详细可以<code>man 2 read/write</code> 查看。</p>
<p>因此，非阻塞IO非常适合服务器设计，不会在<code>read/write</code>处发生堵塞。</p>
<p>将文件描述符fd设置为非阻塞模式，有如下两种方式（来自muduo）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNonBlockAndCloseOnExec</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> flags = ::<span class="built_in">fcntl</span>(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">  flags |= O_NONBLOCK;</span><br><span class="line">  <span class="type">int</span> ret = ::<span class="built_in">fcntl</span>(sockfd, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// close-on-exec</span></span><br><span class="line">  flags = ::<span class="built_in">fcntl</span>(sockfd, F_GETFD, <span class="number">0</span>);</span><br><span class="line">  flags |= FD_CLOEXEC;</span><br><span class="line">  ret = ::<span class="built_in">fcntl</span>(sockfd, F_SETFD, flags);</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sockets::createNonblockingOrDie</span><span class="params">(<span class="type">sa_family_t</span> family)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VALGRIND</span></span><br><span class="line">  <span class="comment">// 方式1 </span></span><br><span class="line">  <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(family, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;sockets::createNonblockingOrDie&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setNonBlockAndCloseOnExec</span>(sockfd);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">// 方式2：系统内核支持 SOCK_NONBLOCK 标志，更加安全。</span></span><br><span class="line">  <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(family, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;sockets::createNonblockingOrDie&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ET-amp-LT"><a href="#ET-amp-LT" class="headerlink" title="ET &amp; LT"></a>ET &amp; LT</h2><p>众所周知，<code>epoll</code>有两种工作模式：<code>ET </code>&amp; <code>LT</code>。但是在讲解 ET &amp; LT 之前，先讲解下「高电平」和「低电平」的概念。</p>
<h3 id="高低电平"><a href="#高低电平" class="headerlink" title="高低电平"></a>高低电平</h3><p>对于可读事件：</p>
<ul>
<li>内核中<code>socket</code>的<code>recv_buff </code> 为空，此时为「低电平」状态，即无数据可读</li>
<li>内核中<code>socket</code>的<code>recv_buff </code> 不空，此时为「高电平」状态，此时有数据可读</li>
</ul>
<p>对于可写事件：</p>
<ul>
<li>内核中<code>socket</code>的<code>send_buff</code>为满 ，此时为「低电平」状态，不可发送数据</li>
<li>内核中<code>socket</code>的<code>send_buff</code>不满，此时为「高电平」状态，可发送数据</li>
</ul>
<p>简而言之，「低电平」状态下不能进行读、写操作，「高电平」则可以读、写。</p>
<p>为便于描述，<code>socket</code>的接受缓冲区定义为<code>recv_buff</code>，<code>socket</code>的发送缓冲区定义为<code>send_buff</code>，<code>connfd</code>是服务端与对端建立连接的文件描述符。</p>
<h3 id="LT（Level-Triggered）"><a href="#LT（Level-Triggered）" class="headerlink" title="LT（Level Triggered）"></a>LT（Level Triggered）</h3><p>LT，电平触发，即socket缓冲区处于高电平时触发事件。此外，<code>epoll_wait</code>的默认工作模式也是LT。</p>
<h4 id="可读事件"><a href="#可读事件" class="headerlink" title="可读事件"></a>可读事件</h4><p>为接受对端<code>connfd</code>发送的数据，服务器首先要为<code>connfd</code>注册可读事件<code>EPOLLIN</code>。</p>
<p>如此，当对端发送数据过来，服务器<code>connfd</code>的<code>recv_buff </code> 不为空，则<code>epoll_wait</code>上的可读事件触发，在读回调函数<code>HandleRead</code>中从<code>socket</code>的<code>recv_buff </code> 中读取数据。</p>
<p>然而，即使服务端本次没有将scoket<code>recv_buff </code> 中的数据全部读取，下次调用<code>epoll_wait</code>时也依然会触发可读事件。</p>
<p>为啥？</p>
<p>因为，只要<code>recv_buff </code> 中的数据没有读取完，即为「高电平」状态，那么就会一直触发<code>epoll_wait</code>的<code>EPOLLIN</code> 事件，直到<code>recv_buff </code> 变空，即为「低电平」状态。</p>
<p>因此<code>LT</code>模式下，不用担心数据漏读的问题。</p>
<h4 id="可写事件"><a href="#可写事件" class="headerlink" title="可写事件"></a>可写事件</h4><p>然而，可写事件与可读事件不同：可读事件是被动触发的，即服务端不知道对端何时发送数据。因此服务端与对端建立连接之后，要立即为<code>connfd</code>注册可读事件，然后在<code>epoll_wait</code>上阻塞等待客户端发送数据过来。</p>
<p>那么，可写事件呢？是服务端主动触发的。</p>
<p>服务端与对端建立连接后，<code>connfd</code>的<code>send_buff</code>是空的，即处于高电平，是可以直接发送数据的。</p>
<p>如果此时为<code>connfd</code>注册可写事件，这就会导致<code>epoll_wait</code>一直检测到<code>connfd</code>上的可写事件触发，但实际上服务端又没有数据可以发送给对端，造成服务端的CPU资源无端被消耗。</p>
<p>因此，在<code>LT</code>模式下，当服务端要向对端发送数据时，不需要先通过<code>epoll_ctl</code>注册可写事件，然后阻塞在<code>epoll_wait</code>上等待可写事件的发生。<font color=red> 正确的做法如下</font>：</p>
<ul>
<li>直接发送数据 <code>n = write(connfd, outbuffer, sizeof(outbuffer))</code>；</li>
<li>如果此次数据没有发送完毕，即<code>n != sizeof(outbuffer)</code>，则为<code>connfd</code>注册可写事件；</li>
<li>在<code>epoll_wait</code>上等待可写事件触发；</li>
<li>可写事件触发，则将剩余的数据发送完毕；</li>
<li>如果没有发送完毕，则等待下次的可写事件；发送完毕，则取消关注可写事件。</li>
</ul>
<p><strong>注意</strong>：当数据发送完毕，一定要取消可写事件，否则当<code>connfd</code>的<code>send_buff</code>变空，后面又没有可发的数据，则又会导致<code>epoll_wait</code>一直触发可写事件。</p>
<h3 id="ET（Edge-Triggered）"><a href="#ET（Edge-Triggered）" class="headerlink" title="ET（Edge Triggered）"></a>ET（Edge Triggered）</h3><p>ET，所谓边缘触发，即只有在电平状态发生变化时才会触发。开启ET模式，需要设置如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET; <span class="comment">// ET 模式</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br></pre></td></tr></table></figure>

<h4 id="可读事件-1"><a href="#可读事件-1" class="headerlink" title="可读事件"></a>可读事件</h4><p>注册了可读事件后，阻塞于<code>epoll_wait</code>等待对端发送数据，再触发可读事件。</p>
<p><strong>注意</strong>：如果服务端没有将<code>recv_buff </code> 中的数据全部读取，那么进入下一轮循环并阻塞在<code>epoll_wait</code>后，可读事件就再也不会触发。</p>
<p>为啥？</p>
<p>在<code>ET</code>模式下，只有<code>connfd</code>的<code>recv_buffer</code>电平状态发生变化才会触发可读事件，但只要<code>recv_buff </code> 中还有数据，则一直为高电平状态，那么即便下次对端又发送数据过来，并不会改<code>recv_buff </code> 的电平状态，这就导致<code>epoll_wait</code>就无法再检测到<code>connfd</code>上的可读事件。</p>
<p>那么对端发送了数据，服务端迟迟无法给出回应。如果是<code>listenfd</code>，那么这个服务器就不再能处理新的连接请求了。</p>
<p>因此，如果不熟悉<code>ET</code>模式的正确使用方法，很可能导致整个服务器无法使用。</p>
<p>那<code>ET</code>模式下，怎么处理可读事件？</p>
<p>一旦检测到<code>connfd</code>上的可读事件，需要不停地从<code>recv_buff </code> 中读取数据，直到<code>read</code>函数返回<code>-1</code>，且错误码<code>errno</code>是<code>EAGAIN</code>标志。</p>
<p>这标志着<code>recv_buff </code> 中的数据已经读取完（已处于低电平），下次对端再发送数据过来（变为高电平），就能再次触发可读事件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(; ; ;) &#123; </span><br><span class="line">  ret = <span class="built_in">read</span>(connfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EAGAIN) &#123; </span><br><span class="line">     <span class="built_in">LOG</span>(NOTICE) &lt;&lt; <span class="string">&quot;READ DONE&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>但是又有一个问题：</p>
<ul>
<li><code>read</code>函数，什么情况下才会返回<code>EAGAIN</code>？</li>
<li>要是<code>read</code> 函数不返回<code>EAGAIN</code>，那么岂不是一直在<code>while/for</code>循环？</li>
</ul>
<p>仅在<code>connfd</code>设置为非阻塞模式时，<code>read</code>函数无法从空的<code>recv_buff</code>继续读取到数据，此时错误码<code>errno</code>就会被设置为<code>EAGAIN</code>。</p>
<h4 id="可写事件-1"><a href="#可写事件-1" class="headerlink" title="可写事件"></a>可写事件</h4><p>ET模式下，在与客户端建立连接后，<strong>可以为<code>connfd</code>注册可写事件</strong>，因为此时<code>connfd</code>的<code>send_buff</code>是空的，处于高电平，不会触发可写事件。</p>
<p>当服务端要通过<code>connfd</code>向客户端发送数据时，直接发送即可：</p>
<ul>
<li><p>如果应用层缓冲区<code>outbuffer</code>的数据大小小于<code>send_buff</code>大小，则无须任何操作；</p>
<p>换言之，<code>connfd</code>的<code>send_buff</code>能容纳<code>outbuffer</code>中的全部数据，那么<code>send_buff</code>依然未满，即处于高电平状态。下次应用层有待发送的数据，直接发送即可；</p>
</li>
<li><p>如果<code>outbuffer</code>中的数据大小大于<code>send_buff</code>大小，那么<code>write(connfd, outbuffer, size)</code>返回-1 且 <code>errno</code>是<code>EAGAIN</code>。</p>
<p>由于<code>send_buff</code>满了，即处于「低电平」状态，表示不可再接受来自应用层的数据。为了将<code>outbuffer</code>中剩余的数据也发送到对端，此时需要为<code>connfd</code>注册可写事件。</p>
<p>当<code>send_buff</code>的数据发送出去，则会变为「高电平」状态，此时就会触发<code>connfd</code>上的可写事件，进而就能继续发送<code>outbuffer</code>中剩下的数据了。</p>
</li>
</ul>
<p>总结下，写操作要一直写到应用层<code>outBuffer</code>为空，或者<code>write</code>函数返回<code>EAGAIN</code>。</p>
<p>上面的 <code>epoll LT</code> 模式注：如果数据未发送完毕，需要注册可写事件；可写事件触发后，尝试发送<code>outBuffer</code>中的剩余数据，如果数据此时还不能全部发送完，<strong>不用再次注册可写事件，若全部发送完毕，需要取消注册可写事件</strong>。</p>
<p>如果是 <code>epoll ET</code> 模：如果数据未发送完毕，注册可写事件；可写事件触发后，尝试发送剩余数据，如果数据此时还不能全部发送完，<strong>需要再次注册可写事件，以便让可写事件下次再次触发，数据全部发送完毕，不用取消注册可写事件</strong>。</p>
<h3 id="LT-or-ET"><a href="#LT-or-ET" class="headerlink" title="LT  or ET ?"></a>LT  or ET ?</h3><p>说了这么多，那自己设计一个服务器，到底是选 <code>ET</code> 还是 <code>LT</code> ?</p>
<p>从个人的目前经验来说，看到的大多数都是<code>LT</code>。</p>
<p>对于可读事件，<code>ET</code>模式只会触发一次<code>epoll_wait</code>，而<code>LT</code>模式下，如果不能一次性读取完<code>recv_buff </code> 中的数据，则会多次触发<code>epoll_wait</code>，增加系统调用开销。</p>
<p>如果我使用<code>LT</code>模式，且一次就将<code>recv_buff </code> 中的数据全部读取出来，那不也就只调用一次<code>epoll_wait</code>，不就和<code>ET</code>模式一样了？</p>
<p>此外，LT模式下的<code>read</code>函数可以少一次系统调用，因为<code>ET</code>模式下的<code>read</code>操作必须读取到返回<code>EAGAIN</code>，就多了一次系统调用开销。</p>
<p>这就是<code>muduo</code>设计了一个<code>InputBuffer</code>的原因，而在<code>redis</code>中也有个输入缓冲区。</p>
<blockquote>
<p>muduo、libuv、redis等都是采用LT模式，其他库不太清楚。</p>
</blockquote>
<p>更为重要的是，<code>ET</code>模式操作不当，容易造成数据漏读、甚至服务器阻塞等问题，而良好的设计的<code>LT</code>模式效率也依然很高。</p>
<p>下面我们从muduo源码角度还原上述过程。</p>
<h2 id="muduo源码展示"><a href="#muduo源码展示" class="headerlink" title="muduo源码展示"></a>muduo源码展示</h2><p>确定好大的方向是「LT模式的<code>epoll</code> + 非阻塞IO」来设计异步通信之后。下面，我们就根据「网络编程」的前三期大致梳理下muduo服务端的源码。</p>
<h3 id="监听客户端连接请求"><a href="#监听客户端连接请求" class="headerlink" title="监听客户端连接请求"></a>监听客户端连接请求</h3><p>当muduo的服务器<code>TcpServer</code>运行时，会先在<code>Acceptor</code>中创建一个非阻塞的<code>listenfd</code>，用于监听客户端的连接请求，即muduo中的<code>acceptSocket_</code>字段， 并为<code>acceptSocket_</code>注册可读事件、设置可读回调函数 <code>Acceptor::handleRead</code>。</p>
<p>这样，服务端就能监听客户端<code>cli</code>的连接请求：</p>
<ul>
<li>当监听到客户端的连接请求后，在读取回调函数<code>Acceptor::handleRead</code>中为请求连接的客户端<code>cli</code>创建<code>TcpConnection</code>对象<code>conn</code>；</li>
<li>在众多<code>sub-eventloops</code>线程中，选择一个<code>sub-loop</code>线程，将<code>conn</code>分发到该<code>sub-loop</code>线程；</li>
<li>以后服务端与该<code>cli</code>的通信，都在<code>sub-loop</code>线程中完成，而<code>Acceptor</code>所在的<code>main-eventloop</code>线程，只是负责监听客户端的连接请求。</li>
</ul>
<p>如此，<code>Accptor</code>的作用即任务分发器<code>dispatcher</code>：</p>
<p>整个框架逻辑如图。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop* loop, <span class="type">const</span> InetAddress&amp; listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">  : <span class="built_in">loop_</span>(loop),</span><br><span class="line">    <span class="built_in">acceptSocket_</span>(sockets::<span class="built_in">createNonblockingOrDie</span>(listenAddr.<span class="built_in">family</span>())),</span><br><span class="line">    <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()),</span><br><span class="line">    <span class="built_in">listening_</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">idleFd_</span>(::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">assert</span>(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line">  acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">  acceptSocket_.<span class="built_in">setReusePort</span>(reuseport); <span class="comment">// 设置端口复用</span></span><br><span class="line">  acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// 绑定地址</span></span><br><span class="line">  acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>)); <span class="comment">// 可读事件回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自然，分发任务的操作就是在可读事件的回调函数<code>Acceptor::handleRead</code>中完成的，其核心就是<code>newConnectionCallback_</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  InetAddress peerAddr;</span><br><span class="line">  <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr); <span class="comment">// 获取客户端的 ip:port</span></span><br><span class="line">  <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">      <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      sockets::<span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">&quot;in Acceptor::handleRead&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">      ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">      idleFd_ = ::<span class="built_in">accept</span>(acceptSocket_.<span class="built_in">fd</span>(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">      idleFd_ = ::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而回调函数<code>newConnectionCallback_</code>最终初始化为<code>TcpServer</code>类中的<code>TcpServer::newConnection</code>函数：</p>
<ul>
<li>创建<code>TcpConnection</code>对象 <code>conn</code>；</li>
<li><code>TcpServer</code>中的<code>connections_</code>记录着每个客户端，因此要把新创建的客户端记录在<code>connections_</code>中；</li>
<li>为<code>conn</code>设置一些回调函数；</li>
<li>将<code>conn</code>放到<code>sub-eventloop</code>中运行，以后服务器与该客户端的通讯就在<code>ioLoop</code>中进行了。</li>
</ul>
<p>整个逻辑如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress&amp; peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  EventLoop* ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>(); <span class="comment">// 从子线程中选择一个</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">  LOG_INFO &lt;&lt; <span class="string">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_</span><br><span class="line">           &lt;&lt; <span class="string">&quot;] - new connection [&quot;</span> &lt;&lt; connName</span><br><span class="line">           &lt;&lt; <span class="string">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class="built_in">toIpPort</span>();</span><br><span class="line">  <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">  <span class="comment">// 创建TcpConnection对象</span></span><br><span class="line">  <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          peerAddr))</span></span>;</span><br><span class="line">  connections_[connName] = conn;</span><br><span class="line">  <span class="comment">// 设置相关的回调函数</span></span><br><span class="line">  conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">  conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">  conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">  <span class="comment">// 放到 sub-eventloop 中运行</span></span><br><span class="line">  ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>TcpConnection::connectEstablished</code>回调函数中，为每个刚建立连接的<code>TcpConnection</code>对象注册可读事件，这是为了监听等待客户端的发送数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="built_in">assert</span>(state_ == kConnecting);</span><br><span class="line">  <span class="built_in">setState</span>(kConnected);</span><br><span class="line">  channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">  channel_-&gt;<span class="built_in">enableReading</span>(); <span class="comment">// 注册可读事件</span></span><br><span class="line">  <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而这个<code>conn</code>的可读、可写等事件的回调函数在<code>TcpConnection</code>构造函数中就完成了初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop* loop,</span><br><span class="line">                             <span class="type">const</span> string&amp; nameArg,</span><br><span class="line">                             <span class="type">int</span> sockfd,</span><br><span class="line">                             <span class="type">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                             <span class="type">const</span> InetAddress&amp; peerAddr)</span><br><span class="line">  : <span class="built_in">loop_</span>(<span class="built_in">CHECK_NOTNULL</span>(loop)),</span><br><span class="line">    <span class="built_in">name_</span>(nameArg),</span><br><span class="line">    <span class="built_in">state_</span>(kConnecting),</span><br><span class="line">    <span class="built_in">reading_</span>(<span class="literal">true</span>),</span><br><span class="line">    <span class="built_in">socket_</span>(<span class="keyword">new</span> <span class="built_in">Socket</span>(sockfd)),</span><br><span class="line">    <span class="built_in">channel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop, sockfd)),</span><br><span class="line">    <span class="built_in">localAddr_</span>(localAddr),</span><br><span class="line">    <span class="built_in">peerAddr_</span>(peerAddr),</span><br><span class="line">    <span class="built_in">highWaterMark_</span>(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">  channel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1)); <span class="comment">// 读回调</span></span><br><span class="line">  channel_-&gt;<span class="built_in">setWriteCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));   <span class="comment">// 写回调</span></span><br><span class="line">  channel_-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));   <span class="comment">// 关闭回调</span></span><br><span class="line">  channel_-&gt;<span class="built_in">setErrorCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>));   <span class="comment">// 错误处理回调</span></span><br><span class="line">  LOG_DEBUG &lt;&lt; <span class="string">&quot;TcpConnection::ctor[&quot;</span> &lt;&lt;  name_ &lt;&lt; <span class="string">&quot;] at &quot;</span> &lt;&lt; <span class="keyword">this</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; sockfd;</span><br><span class="line">  socket_-&gt;<span class="built_in">setKeepAlive</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，当<code>conn</code>对应的客户端发送过来数据时，触发可读事件后，会调用<code>TcpConnection::handleRead</code>来进行处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">  <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">handleClose</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleRead&quot;</span>;</span><br><span class="line">    <span class="built_in">handleError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，启动服务器到和客户端建立连接请求的过程、接受数据的流程大致结束了。</p>
<h3 id="可写事件-2"><a href="#可写事件-2" class="headerlink" title="可写事件"></a>可写事件</h3><p>在前面说过<code>LT</code>模式下的可写事件需要注意的点，下面顺着代码注释去看就好了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="type">ssize_t</span> nwrote   = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> remaining = len;</span><br><span class="line">  <span class="type">bool</span> faultError  = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (state_ == kDisconnected)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;disconnected, give up writing&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 如果没有关注可写事件 且 outbuffer_ 中无待发送数据，说明之前的数据都已经写完</span></span><br><span class="line">  <span class="comment">/// 对于 用户来说是向 outbuffer_ 中写，</span></span><br><span class="line">  <span class="comment">/// 对于 socket 来说是从 outbuffer_ 中读取</span></span><br><span class="line">  <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outbuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    nwrote = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(), data, len);</span><br><span class="line">    <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      remaining = len - nwrote;</span><br><span class="line">      <span class="comment">// 全部写完了，那么就执行写完成回调</span></span><br><span class="line">      <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)</span><br><span class="line">      &#123;</span><br><span class="line">        loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">    &#123;</span><br><span class="line">      nwrote = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/// socket 的发送缓冲已经满，无法将 outbuffer_ 的数据都复制到 socket 的 send_buff</span></span><br><span class="line">      <span class="comment">/// 非阻塞模式下，函数返回 -1 &amp;&amp; errno == EWOULDBLOCK</span></span><br><span class="line">      <span class="comment">/// 如果错误码不是EWOULDBLOCK，那么是真的产生错误了，需要关闭连接</span></span><br><span class="line">      <span class="keyword">if</span> (errno != EWOULDBLOCK) </span><br><span class="line">      &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::sendInLoop&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></span><br><span class="line">        &#123;</span><br><span class="line">          faultError = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(remaining &lt;= len);</span><br><span class="line">  <span class="comment">/// @brief: 运行到这有两种可能：</span></span><br><span class="line">  <span class="comment">/// 1 之前没有注册可写事件，且 outbuffer_ 中没有可读取数据，</span></span><br><span class="line">  <span class="comment">/// 	运行到此是因为此次数据 data 没有发送完</span></span><br><span class="line">  <span class="comment">/// 2 之前的数据没有发送完，又来了新的数据</span></span><br><span class="line">  <span class="comment">/// 无论哪种情况，处理方式：</span></span><br><span class="line">  <span class="comment">///  将数据复制到 outbuffer_ 中，关注 EPOLLOUT 事件，等待可写事件触发，发送数据</span></span><br><span class="line">  <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> oldLen = outbuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">    <span class="comment">// 待发送的内容已经超过标志位了，就调用高水位这个函数</span></span><br><span class="line">    <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_  &amp;&amp;</span><br><span class="line">        oldLen &lt; highWaterMark_  &amp;&amp;</span><br><span class="line">        highWaterMarkCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(highWaterMarkCallback_, </span><br><span class="line">                                   <span class="built_in">shared_from_this</span>(), </span><br><span class="line">                                   oldLen + remaining));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 将剩余的内容加如 outbuffer_</span></span><br><span class="line">    outbuffer_.<span class="built_in">append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data)+nwrote, remaining);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在LT 模式下不需要重复关注可写事件，即使运行到此的第二种情况不需要再关注可写事件</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      channel_-&gt;<span class="built_in">enableWriting</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief: 写回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="comment">/// 触发写回调函数</span></span><br><span class="line">  <span class="comment">/// 将 @b outbuffer_ 中的数据复制到 @b socket 的`send_buff`</span></span><br><span class="line">  <span class="keyword">if</span> (channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),</span><br><span class="line">                               outbuffer_.<span class="built_in">peek</span>(),</span><br><span class="line">                               outbuffer_.<span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      outbuffer_.<span class="built_in">retrieve</span>(n);</span><br><span class="line">      <span class="comment">/// 如果 @b outbuffer_ 中的数据全部写完，</span></span><br><span class="line">      <span class="comment">/// 那么就可以取消关注 @b EPOLLOUT ，防止出现 busy loop</span></span><br><span class="line">      <span class="comment">/// 并且调用写完成回调函数</span></span><br><span class="line">      <span class="comment">/// 如果全部写完，此时就需要取消关注可写事件</span></span><br><span class="line">      <span class="comment">/// 如果 @b outbuffer_ 中还有数据，就继续等待下次可写事件的触发</span></span><br><span class="line">      <span class="keyword">if</span> (outbuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">        <span class="keyword">if</span> (writeCompleteCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">          loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (state_ == kDisconnecting)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleWrite&quot;</span>;</span><br><span class="line">      <span class="comment">// if (state_ == kDisconnecting)</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   shutdownInLoop();</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;Connection fd = &quot;</span> &lt;&lt; channel_-&gt;<span class="built_in">fd</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot; is down, no more writing&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>到此，就差不多了。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">1.</span> <span class="toc-text">异步通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Non-Blocking-IO"><span class="toc-number">1.1.</span> <span class="toc-text">Non-Blocking IO</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ET-amp-LT"><span class="toc-number">1.2.</span> <span class="toc-text">ET &amp; LT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E4%BD%8E%E7%94%B5%E5%B9%B3"><span class="toc-number">1.2.1.</span> <span class="toc-text">高低电平</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LT%EF%BC%88Level-Triggered%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">LT（Level Triggered）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%AF%BB%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">可读事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%86%99%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">可写事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ET%EF%BC%88Edge-Triggered%EF%BC%89"><span class="toc-number">1.2.3.</span> <span class="toc-text">ET（Edge Triggered）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%AF%BB%E4%BA%8B%E4%BB%B6-1"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">可读事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E5%86%99%E4%BA%8B%E4%BB%B6-1"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">可写事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LT-or-ET"><span class="toc-number">1.2.4.</span> <span class="toc-text">LT  or ET ?</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#muduo%E6%BA%90%E7%A0%81%E5%B1%95%E7%A4%BA"><span class="toc-number">1.3.</span> <span class="toc-text">muduo源码展示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E5%90%AC%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">1.3.1.</span> <span class="toc-text">监听客户端连接请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E5%86%99%E4%BA%8B%E4%BB%B6-2"><span class="toc-number">1.3.2.</span> <span class="toc-text">可写事件</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&text=异步通信"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&title=异步通信"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&is_video=false&description=异步通信"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=异步通信&body=Check out this article: https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&title=异步通信"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&title=异步通信"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&title=异步通信"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&title=异步通信"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&name=异步通信&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/&t=异步通信"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
