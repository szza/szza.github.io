<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="hiredis是为客户端redis-cli设计的。在sentinel中，也是使用的是hiredis中的 redisAsyncContext 来创建连接、建立通信，而不是普通的client对象。因此在介绍sentinel的工作原理之前，先介绍hiredis设计。">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析REDIS的 hiredis">
<meta property="og:url" content="https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="hiredis是为客户端redis-cli设计的。在sentinel中，也是使用的是hiredis中的 redisAsyncContext 来创建连接、建立通信，而不是普通的client对象。因此在介绍sentinel的工作原理之前，先介绍hiredis设计。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-02-03T15:20:18.000Z">
<meta property="article:modified_time" content="2023-08-07T09:25:48.502Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Redis6.0">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>剖析REDIS的 hiredis</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&text=剖析REDIS的 hiredis"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&title=剖析REDIS的 hiredis"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&is_video=false&description=剖析REDIS的 hiredis"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS的 hiredis&body=Check out this article: https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&title=剖析REDIS的 hiredis"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&title=剖析REDIS的 hiredis"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&title=剖析REDIS的 hiredis"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&title=剖析REDIS的 hiredis"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&name=剖析REDIS的 hiredis&description=&lt;p&gt;hiredis是为客户端&lt;code&gt;redis-cli&lt;/code&gt;设计的。在sentinel中，也是使用的是hiredis中的 &lt;code&gt;redisAsyncContext&lt;/code&gt; 来创建连接、建立通信，而不是普通的&lt;code&gt;client&lt;/code&gt;对象。因此在介绍&lt;code&gt;sentinel&lt;/code&gt;的工作原理之前，先介绍hiredis设计。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&t=剖析REDIS的 hiredis"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#redisAsyncContext"><span class="toc-number">1.</span> <span class="toc-text">redisAsyncContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAsyncConnectBind"><span class="toc-number">1.1.</span> <span class="toc-text">redisAsyncConnectBind</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncConnectWithOptions"><span class="toc-number">1.1.1.</span> <span class="toc-text">redisAsyncConnectWithOptions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisConnectWithOptions"><span class="toc-number">1.1.2.</span> <span class="toc-text">redisConnectWithOptions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncInitialize"><span class="toc-number">1.1.3.</span> <span class="toc-text">redisAsyncInitialize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncSetConnectCallback"><span class="toc-number">1.1.4.</span> <span class="toc-text">redisAsyncSetConnectCallback</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAeAttach"><span class="toc-number">1.2.</span> <span class="toc-text">redisAeAttach</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EL-ADD-WRITE-ac"><span class="toc-number">2.</span> <span class="toc-text">_EL_ADD_WRITE(ac)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAsyncHandleWrite"><span class="toc-number">2.1.</span> <span class="toc-text">redisAsyncHandleWrite</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncHandleConnect"><span class="toc-number">2.1.1.</span> <span class="toc-text">__redisAsyncHandleConnect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncWrite"><span class="toc-number">2.1.2.</span> <span class="toc-text">redisAsyncWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisBufferWrite"><span class="toc-number">2.1.3.</span> <span class="toc-text">redisBufferWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisNetWrite"><span class="toc-number">2.1.4.</span> <span class="toc-text">redisNetWrite</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisvAsyncCommand"><span class="toc-number">2.2.</span> <span class="toc-text">redisvAsyncCommand</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisPushCallback"><span class="toc-number">2.2.1.</span> <span class="toc-text">__redisPushCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisShiftCallback"><span class="toc-number">2.2.2.</span> <span class="toc-text">__redisShiftCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisRunCallback"><span class="toc-number">2.2.3.</span> <span class="toc-text">__redisRunCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncCommand"><span class="toc-number">2.2.4.</span> <span class="toc-text">__redisAsyncCommand</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EL-ADD-READ-ac"><span class="toc-number">3.</span> <span class="toc-text">_EL_ADD_READ(ac)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAsyncRead"><span class="toc-number">3.1.</span> <span class="toc-text">redisAsyncRead</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisBufferRead"><span class="toc-number">3.1.1.</span> <span class="toc-text">redisBufferRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisNetRead"><span class="toc-number">3.1.2.</span> <span class="toc-text">redisNetRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisReaderFeed"><span class="toc-number">3.1.3.</span> <span class="toc-text">redisReaderFeed</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisGetReply"><span class="toc-number">3.2.</span> <span class="toc-text">redisGetReply</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisGetReplyFromReader"><span class="toc-number">3.2.1.</span> <span class="toc-text">redisGetReplyFromReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createArrayObject"><span class="toc-number">3.2.2.</span> <span class="toc-text">createArrayObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createIntegerObject"><span class="toc-number">3.2.3.</span> <span class="toc-text">createIntegerObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#processItem"><span class="toc-number">3.2.4.</span> <span class="toc-text">processItem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#processLineItem"><span class="toc-number">3.2.5.</span> <span class="toc-text">processLineItem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#moveToNextTask"><span class="toc-number">3.2.6.</span> <span class="toc-text">moveToNextTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#processAggregateItem"><span class="toc-number">3.2.7.</span> <span class="toc-text">processAggregateItem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisReaderGetReply"><span class="toc-number">3.2.8.</span> <span class="toc-text">redisReaderGetReply</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisProcessCallbacks"><span class="toc-number">3.3.</span> <span class="toc-text">redisProcessCallbacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redisAsyncDisconnect"><span class="toc-number">4.</span> <span class="toc-text">__redisAsyncDisconnect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAsyncFree"><span class="toc-number">4.1.</span> <span class="toc-text">__redisAsyncFree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelDisconnectCallback"><span class="toc-number">4.2.</span> <span class="toc-text">sentinelDisconnectCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAsyncFree-1"><span class="toc-number">4.3.</span> <span class="toc-text">redisAsyncFree</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        剖析REDIS的 hiredis
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-02-03T15:20:18.000Z" itemprop="datePublished">2021-02-03</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Timeline/">Timeline</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Redis6-0/" rel="tag">Redis6.0</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>hiredis是为客户端<code>redis-cli</code>设计的。在sentinel中，也是使用的是hiredis中的 <code>redisAsyncContext</code> 来创建连接、建立通信，而不是普通的<code>client</code>对象。因此在介绍<code>sentinel</code>的工作原理之前，先介绍hiredis设计。</p>
<span id="more"></span>

<h2 id="redisAsyncContext"><a href="#redisAsyncContext" class="headerlink" title="redisAsyncContext"></a>redisAsyncContext</h2><p><code>redisAsyncContext</code> 结构体作用类似于<code>client</code>结构体，用于实现客户端与服务器、以及服务器之间的数据通信。因此，也需要<code>scoketfd</code>、与<code>sockfd</code>相关的发起连接、读写回调函数等。在REDIS中，<code>redisAsyncContext</code>用于两个地方： </p>
<ul>
<li><code>sentinel</code>与主服务器、从服务器以及其他sentinels通信</li>
<li>客户端与服务器通信，比如实现<code>redis-cli</code></li>
</ul>
<p>因此，<code>redisAsyncContext</code>的基本设计和<code>client</code>类似。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisAsyncContext</span> &#123;</span><br><span class="line">    redisContext c;     <span class="comment">// 同步环境下的</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err;            <span class="comment">// c-&gt;err</span></span><br><span class="line">    <span class="type">char</span> *errstr;       <span class="comment">// c-&gt;errstr</span></span><br><span class="line">    <span class="type">void</span> *data; 	    <span class="comment">// 用于 sentinel 中时， 保存 instanceLink*  </span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">void</span> *data;		<span class="comment">// 用于 sentinel 中时，保存 redisAeEvents*</span></span><br><span class="line">		<span class="comment">// 读写回调函数</span></span><br><span class="line">        <span class="built_in">void</span> (*addRead)(<span class="type">void</span> *privdata);</span><br><span class="line">        <span class="built_in">void</span> (*delRead)(<span class="type">void</span> *privdata);</span><br><span class="line">        <span class="built_in">void</span> (*addWrite)(<span class="type">void</span> *privdata);</span><br><span class="line">        <span class="built_in">void</span> (*delWrite)(<span class="type">void</span> *privdata);</span><br><span class="line">        <span class="built_in">void</span> (*cleanup)(<span class="type">void</span> *privdata);</span><br><span class="line">        <span class="built_in">void</span> (*scheduleTimer)(<span class="type">void</span> *privdata, <span class="keyword">struct</span> timeval tv);</span><br><span class="line">    &#125; ev;</span><br><span class="line"></span><br><span class="line">    redisDisconnectCallback* onDisconnect;  <span class="comment">// 断开连接的回调函数</span></span><br><span class="line">    redisConnectCallback *onConnect;        <span class="comment">// 连接上的回调函数    </span></span><br><span class="line">    redisCallbackList replies;              <span class="comment">// 常规指令的回调函数  </span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 用于connect()地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockaddr</span> *saddr;</span><br><span class="line">    <span class="type">size_t</span> addrlen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 订阅回调函数</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        redisCallbackList invalid;  <span class="comment">// 无效指令的回调函数</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">dict</span> *channels;      <span class="comment">// 订阅通道: channel --&gt; 回复</span></span><br><span class="line">        <span class="keyword">struct</span> <span class="title class_">dict</span> *patterns;      <span class="comment">// 订阅模式: pattern --&gt; 回复</span></span><br><span class="line">    &#125; sub;</span><br><span class="line">&#125; redisAsyncContext;</span><br></pre></td></tr></table></figure>

<p>redisContext</p>
<p><code>redisAsyncContext</code>是异步环境下，而<code>redisContext</code>可以简单的看作是同步环境下的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为客户端创建环境</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisContext</span> &#123;</span><br><span class="line">    <span class="type">const</span> redisContextFuncs* funcs;   <span class="comment">// 读写回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> err; 			<span class="comment">// 错误，err ==0 时即无错误</span></span><br><span class="line">    <span class="type">char</span> errstr[<span class="number">128</span>];	 <span class="comment">// 错误的字符串表示</span></span><br><span class="line"></span><br><span class="line">    redisFD fd;         <span class="comment">// socketfd</span></span><br><span class="line">    <span class="type">int</span> 	flags;		          </span><br><span class="line">    <span class="type">char</span> *  obuf;		<span class="comment">// 发送缓冲区 </span></span><br><span class="line">    redisReader* reader; <span class="comment">// 读取缓冲区</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">redisConnectionType</span> connection_type;   <span class="comment">// 连接类型</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">timeval</span> *timeout; <span class="comment">// 超时时间</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// tcp连接</span></span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">char</span> *host;</span><br><span class="line">        <span class="type">char</span> *source_addr;</span><br><span class="line">        <span class="type">int</span> port;</span><br><span class="line">    &#125; tcp;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">        <span class="type">char</span> *path;</span><br><span class="line">    &#125; unix_sock;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 连接地址</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">sockadr</span> *saddr;</span><br><span class="line">    <span class="type">size_t</span> addrlen;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span> *privdata;  <span class="comment">// 私有数据</span></span><br><span class="line">&#125; redisContext;</span><br></pre></td></tr></table></figure>

<p><strong>funcs</strong></p>
<p><code>funcs</code>不仅封装了适用于<code>redisContext</code>的读写回调函数，也封装了用于异步对象<code>redisAsyncContext</code>的回调函数。<code>redisContextFuncs</code> 封装如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisContextFuncs</span> &#123;</span><br><span class="line">    <span class="built_in">void</span> (*free_privdata)(<span class="type">void</span> *);                      <span class="comment">// 释放 privdata</span></span><br><span class="line">    <span class="built_in">void</span> (*async_read)(<span class="keyword">struct</span> redisAsyncContext *);     <span class="comment">// 异步读取</span></span><br><span class="line">    <span class="built_in">void</span> (*async_write)(<span class="keyword">struct</span> redisAsyncContext *);    <span class="comment">// 异步发送</span></span><br><span class="line">    <span class="built_in">int</span>  (*read)(<span class="keyword">struct</span> redisContext *, <span class="type">char</span> *, <span class="type">size_t</span>); <span class="comment">// 同步读取</span></span><br><span class="line">    <span class="built_in">int</span>  (*write)(<span class="keyword">struct</span> redisContext *);                <span class="comment">// 同步发送</span></span><br><span class="line">&#125; redisContextFuncs;</span><br></pre></td></tr></table></figure>

<p><code>hiredis.c</code>文件中，<code>redisContextFuncs</code>结构体有一个默认的对象<code>redisContextDefaultFuncs</code>，初始化如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> redisContextFuncs redisContextDefaultFuncs = &#123;</span><br><span class="line">    .free_privdata = <span class="literal">NULL</span>,</span><br><span class="line">    .async_read    = redisAsyncRead,	</span><br><span class="line">    .async_write   = redisAsyncWrite,	</span><br><span class="line">    .read          = redisNetRead,</span><br><span class="line">    .write         = redisNetWrite</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="redisAsyncConnectBind"><a href="#redisAsyncConnectBind" class="headerlink" title="redisAsyncConnectBind"></a>redisAsyncConnectBind</h3><p>下面开始讲解，创建一个<code>struct redisAsyncContext</code>对象到建立连接的过程。</p>
<p>每个TCP连接属性都有一些可选参数，这个由<code>struct redisOptions</code>设置：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;   			<span class="comment">// 连接类型：REDIS_CONN_TCP 、REDIS_CONN_UNIX</span></span><br><span class="line">    <span class="type">int</span> options;			<span class="comment">// TCP选项： REDIS_OPT_xxx </span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">timeout</span>;</span> <span class="comment">// 超时时间</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">// 用于 TCP 连接</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *source_addr; <span class="comment">// 绑定的本地地址</span></span><br><span class="line">            <span class="type">const</span> <span class="type">char</span> *ip;			<span class="comment">// 对端ip</span></span><br><span class="line">            <span class="type">int</span> port;				<span class="comment">// 对端port</span></span><br><span class="line">        &#125; tcp;</span><br><span class="line">        <span class="comment">// 用于 unix-domain </span></span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *unix_socket;</span><br><span class="line">        <span class="comment">// hireds 用于操作一个已打开的fd</span></span><br><span class="line">        redisFD fd;</span><br><span class="line">    &#125; endpoint;</span><br><span class="line">&#125; redisOptions;</span><br></pre></td></tr></table></figure>

<p>对于<code>options</code>中TCP相关参数的设置，由<code>REDIS_OPTIONS_SET_TCP</code>宏实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_OPTIONS_SET_TCP(opts, ip_, port_) \</span></span><br><span class="line"><span class="meta">    (opts)-&gt;type = REDIS_CONN_TCP;              \		<span class="comment">// 设置TCP连接</span></span></span><br><span class="line">    (opts)-&gt;endpoint.tcp.ip = ip_;              \		<span class="comment">// 对端 ip</span></span><br><span class="line">    (opts)-&gt;endpoint.tcp.port = port_;				   <span class="comment">// 对端 port</span></span><br></pre></td></tr></table></figure>

<p><code>redisAsyncConnectBind</code>函数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">redisAsyncContext *<span class="title">redisAsyncConnectBind</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *ip, <span class="type">int</span> port, <span class="type">const</span> <span class="type">char</span>* source_addr)</span> </span>&#123;</span><br><span class="line">    redisOptions options = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">REDIS_OPTIONS_SET_TCP</span>(&amp;options, ip, port);</span><br><span class="line">    options.endpoint.tcp.source_addr = source_addr;</span><br><span class="line">    <span class="comment">// 非阻塞连接并绑定到 source_addr</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">redisAsyncConnectWithOptions</span>(&amp;options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisAsyncConnectWithOptions"><a href="#redisAsyncConnectWithOptions" class="headerlink" title="redisAsyncConnectWithOptions"></a>redisAsyncConnectWithOptions</h4><p><code>redisAsyncConnectWithOptions</code>函数步骤如下：</p>
<ul>
<li>由<code>options</code>参数将TCP连接设置为<strong>非阻塞连接</strong> ，<code>options</code>在 <code>redisAsyncConnect</code>函数中设置。</li>
<li>创建同步环境 <code>c</code></li>
<li>创建异步环境 <code>ac</code></li>
<li>将<code>c-&gt;err</code>的设置到<code>ac-&gt;err</code>，方便可以直接访问</li>
</ul>
<p>由<code>redisAsyncConnectWithOptions</code>函数获得<code>ac</code>，默认是非阻塞IO。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">redisAsyncContext* <span class="title">redisAsyncConnectWithOptions</span><span class="params">(<span class="type">const</span> redisOptions *options)</span> </span>&#123;</span><br><span class="line">    redisOptions myOptions = *options;</span><br><span class="line">    redisContext *c;</span><br><span class="line">    redisAsyncContext *ac;</span><br><span class="line">	<span class="comment">// 1) 设置为非阻塞连接</span></span><br><span class="line">    myOptions.options |= REDIS_OPT_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 将c-&gt;e-&gt;fd设置为非阻塞IO，并客户端对象C</span></span><br><span class="line">    c = <span class="built_in">redisConnectWithOptions</span>(&amp;myOptions);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3) 基于同步客户端c，初始化异步对象 ac</span></span><br><span class="line">    ac = <span class="built_in">redisAsyncInitialize</span>(c);</span><br><span class="line">    <span class="keyword">if</span> (ac == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">redisFree</span>(c);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4) 将 c-&gt;err 复制到 ac-&gt;err</span></span><br><span class="line">    __redisAsyncCopyError(ac);</span><br><span class="line">    <span class="keyword">return</span> ac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisConnectWithOptions"><a href="#redisConnectWithOptions" class="headerlink" title="redisConnectWithOptions"></a>redisConnectWithOptions</h4><p>设置TCP连接选择，比如常见的是否阻塞、是否地址复用，在REDIS多了个密码认证。然后就是调用<code>redisContextConnectBindTcp</code>函数来连接并绑定本地地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">redisContext* <span class="title function_">redisConnectWithOptions</span><span class="params">(<span class="type">const</span> redisOptions *options)</span> &#123;</span><br><span class="line">    redisContext* c = redisContextInit(options);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 设置了 REDIS_OPT_NONBLOCK，则为非阻塞IO</span></span><br><span class="line">    <span class="keyword">if</span> (!(options-&gt;options &amp; REDIS_OPT_NONBLOCK)) &#123;</span><br><span class="line">        c-&gt;flags |= REDIS_BLOCK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 地址复用</span></span><br><span class="line">    <span class="keyword">if</span> (options-&gt;options &amp; REDIS_OPT_REUSEADDR) &#123;</span><br><span class="line">        c-&gt;flags |= REDIS_REUSEADDR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 认证</span></span><br><span class="line">    <span class="keyword">if</span> (options-&gt;options &amp; REDIS_OPT_NOAUTOFREE) &#123;</span><br><span class="line">      c-&gt;flags |= REDIS_NO_AUTO_FREE;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// tcp连接</span></span><br><span class="line">    <span class="keyword">if</span> (options-&gt;type == REDIS_CONN_TCP) &#123;</span><br><span class="line">        redisContextConnectBindTcp(c, </span><br><span class="line">                                   options-&gt;endpoint.tcp.ip, </span><br><span class="line">                                   options-&gt;endpoint.tcp.port, </span><br><span class="line">                                   options-&gt;timeout,</span><br><span class="line">                                   options-&gt;endpoint.tcp.source_addr);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (options-&gt;type == REDIS_CONN_UNIX) &#123;</span><br><span class="line">        redisContextConnectUnix(c, </span><br><span class="line">                                options-&gt;endpoint.unix_socket,</span><br><span class="line">                                options-&gt;timeout);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (options-&gt;type == REDIS_CONN_USERFD) &#123;</span><br><span class="line">        c-&gt;fd = options-&gt;endpoint.fd;</span><br><span class="line">        c-&gt;flags |= REDIS_CONNECTED;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Unknown type - FIXME - FREE</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 仅对阻塞连接才有效</span></span><br><span class="line">    <span class="comment">/// 设置超时时间</span></span><br><span class="line">    <span class="keyword">if</span> (options-&gt;timeout != <span class="literal">NULL</span> &amp;&amp; </span><br><span class="line">        (c-&gt;flags &amp; REDIS_BLOCK) &amp;&amp; </span><br><span class="line">        c-&gt;fd != REDIS_INVALID_FD) </span><br><span class="line">    &#123;</span><br><span class="line">        redisContextSetTimeout(c, *options-&gt;timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisAsyncInitialize"><a href="#redisAsyncInitialize" class="headerlink" title="redisAsyncInitialize"></a>redisAsyncInitialize</h4><p><code>redisAsyncInitialize</code>函数，基于创建的同步对象<code>c</code>来初始化一个 <code>redisAsyncContext</code> 对象<code>ac</code>。</p>
<p>由于设置了非阻塞连接<code>options.options |= REDIS_OPT_NONBLOCK;</code>，因此要监测<code>connect</code>是否成功连接上对端，需要等待第一次可写事件触发。因此，在此<code>redisAsyncInitialize</code>函数中需要去除<code>REDIS_CONNECTED</code> 标志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> redisAsyncContext* <span class="title function_">redisAsyncInitialize</span><span class="params">(redisContext *c)</span> &#123;</span><br><span class="line">    <span class="comment">// c 是 redisAsyncContext对象的第一个字段，且是栈对象</span></span><br><span class="line">    <span class="comment">// 因此可以调用 realloc 是为了继续在c后面创建数据</span></span><br><span class="line">    redisAsyncContext *ac = <span class="built_in">realloc</span>(c, <span class="keyword">sizeof</span>(redisAsyncContext));</span><br><span class="line">    <span class="keyword">if</span> (ac == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    c = &amp;(ac-&gt;c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 同步connect函数返回，则成功连接，可以直接设置 REDIS_CONNECT 标志，</span></span><br><span class="line"><span class="comment">     * 异步模式下，connect函数返回并不一定就成功连接，</span></span><br><span class="line"><span class="comment">     * 直到第一个写事件触发后才算是成功连接，那个时候再设置 REDIS_CONNECT 标志，</span></span><br><span class="line"><span class="comment">     * 因此在这里重置它 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    c-&gt;flags &amp;= ~REDIS_CONNECTED;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 其他字段初始化需要根据应用场景</span></span><br><span class="line">    <span class="comment">// 应用于 sentinel ，则在 sentinel.c/redisAeAttach 函数中初始化</span></span><br><span class="line">    ac-&gt;err = <span class="number">0</span>;</span><br><span class="line">    ac-&gt;errstr = <span class="literal">NULL</span>;</span><br><span class="line">    ac-&gt;data = <span class="literal">NULL</span>;</span><br><span class="line">    ac-&gt;ev.data = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> ac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisAsyncSetConnectCallback"><a href="#redisAsyncSetConnectCallback" class="headerlink" title="redisAsyncSetConnectCallback"></a>redisAsyncSetConnectCallback</h4><p>在<code>sentinel.c</code>中，调用了<code>redisAsyncConnectBind</code>函数来连接对端后，就会调用<code>redisAsyncSetConnectCallback</code>函数，主要有两个作用：</p>
<ol>
<li><p>设置连接回调函数<code>fn</code>。在<code>sentinel.c</code>中将建立连接的回调函数<code>fn</code>设置的是<code>sentinelLinkEstablishedCallback</code>函数，用来检测连接结果是否正确</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelLinkEstablishedCallback</span><span class="params">(<span class="type">const</span> redisAsyncContext *c, <span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (status != C_OK) instanceLinkConnectionError(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><font color="red"> 重要：</font>前面说过了，在异步环境下<code>redisAsyncConnectBind</code>函数执行完毕，此时不知道是否建立成功，只有等第一次可写事件触发才能知晓，因此需要注册可写事件来监听可写事件的触发。</p>
</li>
</ol>
<p><font color="yellow">可能有人好奇，为啥这里是注册可写事件，而不是可读事件???</font></p>
<p>因为，刚建立连接的时候，<code>c-&gt;fd</code>的发送缓冲区是空的，会立即触发可写事件；但是刚建立连接时可不一定就有数据可读取。因此，要为<code>c-&gt;fd</code>注册可写事件。至于具体的可写事件触发流程以及验证是否成功建立连接，见下文分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisAsyncSetConnectCallback</span><span class="params">(redisAsyncContext *ac, redisConnectCallback *fn)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ac-&gt;onConnect == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ac-&gt;onConnect = fn;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The common way to detect an established connection is to wait for</span></span><br><span class="line"><span class="comment">         * the first write event to be fired. This assumes the related event</span></span><br><span class="line"><span class="comment">         * library functions are already set. */</span></span><br><span class="line">        <span class="comment">// 检测连接建立，最常用的方法是为其注册可写事件，第一个可写事件触发时，则连接建立</span></span><br><span class="line">        _EL_ADD_WRITE(ac);</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redisAeAttach"><a href="#redisAeAttach" class="headerlink" title="redisAeAttach"></a>redisAeAttach</h3><p>当<code>redisAsyncContext*</code>用于<code>sentinel</code>中，对于<code>ac</code>其余未初始化字段在<code>sentinel.c/redisAeAttach</code>函数中初始化。</p>
<p><code>redisAeAttach</code>函数，将异步客户端<code>ac</code>添加到<code>loop</code>循环中，使<code>ac</code>能像<code>client</code>一样处理各项事情。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">redisAeAttach</span><span class="params">(aeEventLoop *loop, redisAsyncContext *ac)</span> &#123;</span><br><span class="line">    redisContext* c = &amp;(ac-&gt;c);</span><br><span class="line">    redisAeEvents *e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ac-&gt;ev.data != <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create container for context and r/w events */</span></span><br><span class="line">    e = (redisAeEvents*)zmalloc(<span class="keyword">sizeof</span>(*e));</span><br><span class="line">    e-&gt;context = ac;</span><br><span class="line">    e-&gt;loop = loop;</span><br><span class="line">    e-&gt;fd = c-&gt;fd;		<span class="comment">// 与对端通信的 sockfd !!!</span></span><br><span class="line">    e-&gt;reading = e-&gt;writing = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置各类回调函数</span></span><br><span class="line">    ac-&gt;ev.addRead  = redisAeAddRead;</span><br><span class="line">    ac-&gt;ev.delRead  = redisAeDelRead;</span><br><span class="line">    ac-&gt;ev.addWrite = redisAeAddWrite;</span><br><span class="line">    ac-&gt;ev.delWrite = redisAeDelWrite;</span><br><span class="line">    ac-&gt;ev.cleanup  = redisAeCleanup;</span><br><span class="line">    ac-&gt;ev.data = e;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整地创建<code>redisAsyncContext</code>客户端，及其运行在<code>sentinel.c/sentinelReconnectInstance</code>函数实现，这个待下一章讲解<code>sentinel</code>再讲解。</p>
<h2 id="EL-ADD-WRITE-ac"><a href="#EL-ADD-WRITE-ac" class="headerlink" title="_EL_ADD_WRITE(ac)"></a>_EL_ADD_WRITE(ac)</h2><p>下面从 <code>_EL_ADD_WRITE</code> 宏开始讲解可写事件的触发及其处理流程。</p>
<p><code>_EL_ADD_WRITE</code> 宏展开如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#define _EL_ADD_WRITE(ctx)                                          \</span><br><span class="line">    do &#123;                                                            \</span><br><span class="line">        refreshTimeout(ctx);                                        \</span><br><span class="line">        if ((ctx)-&gt;ev.addWrite) (ctx)-&gt;ev.addWrite((ctx)-&gt;ev.data); \</span><br><span class="line">    &#125; while (0)</span><br></pre></td></tr></table></figure>

<p>在<code>sentinel</code>中，<code>addWrite</code>指向的函数是<code>redisAeAddWrite</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac-&gt;ev.addWrite = redisAeAddWrite;</span><br></pre></td></tr></table></figure>

<p>在<code>redisAeAddWrite</code>函数中，为<code>e-&gt;fd</code>注册可写事件，设置可写事件回调函数<code>redisAeWriteEvent</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">redisAeAddWrite</span><span class="params">(<span class="type">void</span> *privdata)</span> &#123;</span><br><span class="line">    redisAeEvents *e = (redisAeEvents*)privdata;</span><br><span class="line">    aeEventLoop *loop = e-&gt;loop;</span><br><span class="line">    <span class="keyword">if</span> (!e-&gt;writing) &#123;</span><br><span class="line">        e-&gt;writing = <span class="number">1</span>;</span><br><span class="line">        aeCreateFileEvent(loop,e-&gt;fd,AE_WRITABLE,redisAeWriteEvent,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>e-&gt;fd</code>发送缓冲区有空，则<strong>触发可写事件</strong>并调用 <code>redisAeWriteEvent</code>函数来发送数据，内部是调用 <code>redisAsyncHandleWrite</code> 函数完成的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">redisAeWriteEvent</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    ((<span class="type">void</span>)el); </span><br><span class="line">    ((<span class="type">void</span>)fd); </span><br><span class="line">    ((<span class="type">void</span>)mask);</span><br><span class="line"></span><br><span class="line">    redisAeEvents *e = (redisAeEvents*)privdata;</span><br><span class="line">    redisAsyncHandleWrite(e-&gt;context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redisAsyncHandleWrite"><a href="#redisAsyncHandleWrite" class="headerlink" title="redisAsyncHandleWrite"></a>redisAsyncHandleWrite</h3><p>当触发可写事件时，如果是第一次调用<code>redisAsyncHandleWrite</code>函数不一定是本端有数据待发送，可能是因为连接连接了，整个函数流程如下：</p>
<ul>
<li>先判断当前是否建立连接。在前文说过，在<code>redisAsyncConnectBind</code>函数调用过后，可能并没有直接和对端建立连接，在第一次调用<code>redisAsyncHandleWrite</code>函数时需要通过<code>__redisAsyncHandleConnect</code>函数对结果进行判断。</li>
<li>成功建立连接后，再调用<code>c-&gt;funcs-&gt;async_write</code>向<code>e-&gt;fd</code>发送数据</li>
</ul>
<p>其中，<code>c-&gt;funcs-&gt;async_write</code>指向的是<code>redisAsyncWrite</code>函数。整个流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">redisAsyncHandleWrite</span><span class="params">(redisAsyncContext *ac)</span> &#123;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有建立连接，则先建立</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_CONNECTED)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (__redisAsyncHandleConnect(ac) != REDIS_OK) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_CONNECTED)) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送数据</span></span><br><span class="line">    c-&gt;funcs-&gt;async_write(ac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisAsyncHandleConnect"><a href="#redisAsyncHandleConnect" class="headerlink" title="__redisAsyncHandleConnect"></a>__redisAsyncHandleConnect</h4><p>在<code>__redisAsyncHandleConnect</code>函数中，需要通过<code>redisCheckConnectDone</code>函数对此次可写事件的状态进行判断，以确认是是否真的成功建立了连接。</p>
<p>方法是，此时直接调用<code>connect</code>函数向对端发起连接：</p>
<ul>
<li>如果<code>connect</code>函数返回0，无论之前是否成功连接，此时调用<code>connect</code>函数成功建立连接；</li>
<li>如果<code>connect</code>函数返回-1，需要根据错误标志<code>errno</code>来判断是否成功连接。<ul>
<li>如果 <font color="yellow"><code>errno == EISCONN</code></font>，表示之前已经建立了连接，使得此次调用<code>connect</code>函数返回-1。因此，<code>redisCheckConnectDone</code>函数仍返回 <code>REDIS_OK</code>。</li>
<li><code>errno</code>是其他值，都表示没有建立连接。此时，返回<code>REEDIS_ERR</code>，忽略此次可写事件。</li>
</ul>
</li>
</ul>
<p>因此在<code>redisCheckConnectDone</code>函数中完成了异步连接的确认：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisCheckConnectDone</span><span class="params">(redisContext *c, <span class="type">int</span> *completed)</span> &#123;</span><br><span class="line">    <span class="type">int</span> rc = connect(c-&gt;fd, (<span class="type">const</span> <span class="keyword">struct</span> sockaddr *)c-&gt;saddr, c-&gt;addrlen);</span><br><span class="line">    <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">        *completed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (errno) &#123;</span><br><span class="line">    <span class="keyword">case</span> EISCONN:</span><br><span class="line">        *completed = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    <span class="keyword">case</span> EALREADY:</span><br><span class="line">    <span class="keyword">case</span> EINPROGRESS:</span><br><span class="line">    <span class="keyword">case</span> EWOULDBLOCK:</span><br><span class="line">        *completed = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>redisCheckConnectDone</code>函数，无论返回<code>REDIS_ERR</code>还是<code>REDIS_OK</code>，都会调用之前设置的连接回调函数<code>ac-&gt;onConnect</code>，即<code>sentinelLinkEstablishedCallback</code>函数，不过只在无法建立成功连接时才有效：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelLinkEstablishedCallback</span><span class="params">(<span class="type">const</span> redisAsyncContext *c, <span class="type">int</span> status)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (status != C_OK) instanceLinkConnectionError(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此，当成功建立连接后，只是会加上<font color="yellow"><code> c-&gt;flags |= REDIS_CONNECTED</code> </font>标志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __redisAsyncHandleConnect(redisAsyncContext *ac) &#123;</span><br><span class="line">    <span class="type">int</span> completed = <span class="number">0</span>;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line">    <span class="keyword">if</span> (redisCheckConnectDone(c, &amp;completed) == REDIS_ERR) &#123;</span><br><span class="line">        redisCheckSocketError(c);			<span class="comment">// 设置 c-&gt;err</span></span><br><span class="line">        <span class="keyword">if</span> (ac-&gt;onConnect) 					<span class="comment">// 连接回调函数</span></span><br><span class="line">            ac-&gt;onConnect(ac, REDIS_ERR);</span><br><span class="line">        __redisAsyncDisconnect(ac); 		<span class="comment">// 断开连接</span></span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 成功建立连接</span></span><br><span class="line">     <span class="keyword">if</span> (completed == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ac-&gt;onConnect) </span><br><span class="line">            ac-&gt;onConnect(ac, REDIS_OK);</span><br><span class="line">         <span class="comment">// 加上标志位：REDIS_CONNECTED</span></span><br><span class="line">        c-&gt;flags |= REDIS_CONNECTED;</span><br><span class="line">    &#125; </span><br><span class="line">	<span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisAsyncWrite"><a href="#redisAsyncWrite" class="headerlink" title="redisAsyncWrite"></a>redisAsyncWrite</h4><p><code>redisAsyncWrite</code>函数，即<code>c-&gt;funcs-&gt;async_write</code>，异步发送数据。</p>
<ul>
<li>会尝试调用<code>redisBufferWrite</code>函数直接发送数据</li>
<li>如果<code>c-&gt;obuf</code>中的数据全部发送完毕，则取消可写事件。<br><code>_EL_DEL_WRITE</code> 宏展开如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _EL_DEL_WRITE(ctx) do &#123;                                     \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((ctx)-&gt;ev.delWrite) (ctx)-&gt;ev.delWrite((ctx)-&gt;ev.data); \</span></span><br><span class="line"><span class="meta">    &#125; while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向的函数</span></span><br><span class="line">ac-&gt;ev.delWrite = redisAeDelWrite;</span><br></pre></td></tr></table></figure>
通过<code>redisAeDelWrite</code>调用函数，取消<code>e-&gt;fd</code>上的可写事件<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">redisAeDelWrite</span><span class="params">(<span class="type">void</span> *privdata)</span> &#123;</span><br><span class="line">    redisAeEvents *e = (redisAeEvents*)privdata;</span><br><span class="line">    aeEventLoop *loop = e-&gt;loop;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;writing) &#123;</span><br><span class="line">        e-&gt;writing = <span class="number">0</span>;</span><br><span class="line">        aeDeleteFileEvent(loop,e-&gt;fd,AE_WRITABLE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果<code>c-&gt;obuf</code>中的数据没有发送完毕，此时<code>_EL_ADD_WRITE(ac)</code>宏无效，因为已经注册了可写事件。</li>
<li>每次都会注册一次可读事件（如果已经注册则忽略，下一部分专门讲解）</li>
</ul>
<p>整个流程大致如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">redisAsyncWrite</span><span class="params">(redisAsyncContext *ac)</span> &#123;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line">    <span class="type">int</span> done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接发送数据</span></span><br><span class="line">    <span class="keyword">if</span> (redisBufferWrite(c,&amp;done) == REDIS_ERR) &#123;</span><br><span class="line">        __redisAsyncDisconnect(ac);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 没有写完，继续注册可写事件</span></span><br><span class="line">        <span class="keyword">if</span> (!done)</span><br><span class="line">            _EL_ADD_WRITE(ac);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 写完，则删除可写事件</span></span><br><span class="line">            _EL_DEL_WRITE(ac);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Always schedule reads after writes */</span></span><br><span class="line">        <span class="comment">// 若ac为注册可读事件，则注册</span></span><br><span class="line">        _EL_ADD_READ(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisBufferWrite"><a href="#redisBufferWrite" class="headerlink" title="redisBufferWrite"></a>redisBufferWrite</h4><p><code>redisBufferWrite</code>函数，内部调用<code>c-&gt;funcs-&gt;write</code>指向的函数将发送缓冲区<code>c-&gt;obuf</code>中的数据发送至网络。<code>redisBufferWrite</code>函数，返回<code>REDIS_OK</code>，表示成功发送。进一步，如果<code>done==1</code>则表示<code>c-&gt;obuf</code>清空。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisBufferWrite</span><span class="params">(redisContext *c, <span class="type">int</span> *done)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;err) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sdslen(c-&gt;obuf) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> nwritten = c-&gt;funcs-&gt;write(c);</span><br><span class="line">        <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span>) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nwritten == (<span class="type">signed</span>)sdslen(c-&gt;obuf)) &#123;</span><br><span class="line">                sdsfree(c-&gt;obuf);</span><br><span class="line">                c-&gt;obuf = sdsempty();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                sdsrange(c-&gt;obuf,nwritten,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完全发送完毕，则done置1</span></span><br><span class="line">    <span class="keyword">if</span> (done != <span class="literal">NULL</span>) *done = (sdslen(c-&gt;obuf) == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisNetWrite"><a href="#redisNetWrite" class="headerlink" title="redisNetWrite"></a>redisNetWrite</h4><p><code>redisNetWrite</code>函数，即<code>c-&gt;funcs-&gt;write</code>， 内部调用<code>send</code>函数将<code>c-&gt;obuf</code>中数据发送出去。<code>send</code>函数返回值<code>nwritten</code>有几种可能：</p>
<ol>
<li><p><code>nwritten &lt; 0 </code>时，以下两种情况不是错误：</p>
<ul>
<li><code>errno == EWOULDBLOCK</code>：在非阻塞IO模式下， <code>errno == EWOULDBLOCK</code> 只是表示当前<code>e-&gt;fd</code>的发送缓冲区是满的，无法将<code>c-&gt;obuf</code>中的数据复制到<code>e-&gt;fd</code>的发送缓冲区。</li>
<li><code>errno == EINTR</code>：表示当前发送数据操作被系统中断了。</li>
</ul>
<p>因此，对这两种情况，只需要直接return，等待下一次的可写事件触发即可。<font color="red"> 问题：此时return也是 <code>nwritten &lt; 0</code>，那么会造成这个连接被关闭???</font></p>
</li>
<li><p><code>nwritten &gt;= 0</code>：正常情况</p>
</li>
</ol>
<p>整个流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisNetWrite</span><span class="params">(redisContext *c)</span> &#123;</span><br><span class="line">    <span class="type">int</span> nwritten = send(c-&gt;fd, c-&gt;obuf, sdslen(c-&gt;obuf), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nwritten &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 非阻塞IO下的错误</span></span><br><span class="line">        <span class="keyword">if</span> ((errno == EWOULDBLOCK &amp;&amp; !(c-&gt;flags &amp; REDIS_BLOCK)) || (errno == EINTR)) &#123;</span><br><span class="line">            <span class="comment">// 难到不缺少一个 return 0;</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            __redisSetError(c, REDIS_ERR_IO, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nwritten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redisvAsyncCommand"><a href="#redisvAsyncCommand" class="headerlink" title="redisvAsyncCommand"></a>redisvAsyncCommand</h3><p>上面的过程是将<code>c-&gt;obuf</code>的数据发送出去，那么<code>c-&gt;obuf</code>的数据是从何而来？</p>
<p><code>redisAsyncCommand*</code>系列函数用于将待发送数据添加到<code>c-&gt;obuf</code>中：主要有以下几个，作用都是相同的：</p>
<ul>
<li>将<code>ap/.../argv/cmd</code>中的请求数据添加到<code>ac-&gt;c-&gt;obuf</code>中</li>
<li>设置这些请求的回调函数<code>fn</code>。当接收到对端对这些请求时执行<code>fn</code>，因此这些回调函数<code>fn</code>是在可读事件中执行的。</li>
</ul>
<p>因此下面只选择其中的<code>redisvAsyncCommand</code>作为讲解。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisvAsyncCommand</span><span class="params">(redisAsyncContext *ac, </span></span><br><span class="line"><span class="params">                       redisCallbackFn *fn, </span></span><br><span class="line"><span class="params">                       <span class="type">void</span> *privdata, </span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">char</span> *format, </span></span><br><span class="line"><span class="params">                       va_list ap)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">redisAsyncCommand</span><span class="params">(redisAsyncContext *ac, </span></span><br><span class="line"><span class="params">                      redisCallbackFn *fn, </span></span><br><span class="line"><span class="params">                      <span class="type">void</span> *privdata, </span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">char</span> *format, </span></span><br><span class="line"><span class="params">                      ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">redisAsyncCommandArgv</span><span class="params">(redisAsyncContext *ac, </span></span><br><span class="line"><span class="params">                          redisCallbackFn *fn, </span></span><br><span class="line"><span class="params">                          <span class="type">void</span> *privdata, </span></span><br><span class="line"><span class="params">                          <span class="type">int</span> argc, </span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="type">char</span>** argv, </span></span><br><span class="line"><span class="params">                          <span class="type">const</span> <span class="type">size_t</span> *argvlen)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">redisAsyncFormattedCommand</span><span class="params">(redisAsyncContext *ac, </span></span><br><span class="line"><span class="params">                               redisCallbackFn *fn, </span></span><br><span class="line"><span class="params">                               <span class="type">void</span> *privdata, </span></span><br><span class="line"><span class="params">                               <span class="type">const</span> <span class="type">char</span> *cmd, </span></span><br><span class="line"><span class="params">                               <span class="type">size_t</span> len)</span>;</span><br></pre></td></tr></table></figure>

<p><code>redisvAsyncCommand</code>函数，先是调用<code>redisvFormatCommand</code>函数对不定参数<code>ap</code>按照<code>format</code>提供的格式进行格式化，结果存储在<code>cmd</code>，再调用<code>__redisAsyncCommand</code>函数将<code>cmd</code>序列化到<code>c-&gt;obuf</code>中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisvAsyncCommand</span><span class="params">(redisAsyncContext *ac, </span></span><br><span class="line"><span class="params">                       redisCallbackFn *fn, </span></span><br><span class="line"><span class="params">                       <span class="type">void</span> *privdata, </span></span><br><span class="line"><span class="params">                       <span class="type">const</span> <span class="type">char</span> *format, </span></span><br><span class="line"><span class="params">                       va_list ap)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *cmd;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line">    <span class="comment">// 1 按照format格式解析ap参数，输出至cmd，参数个数返回到len</span></span><br><span class="line">    len = redisvFormatCommand(&amp;cmd,format,ap);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We don&#x27;t want to pass -1 or -2 to future functions as a length. */</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 将 fn 添加到任务队列，并将 cmd 添加到 c-&gt;obuf 中</span></span><br><span class="line">    status = __redisAsyncCommand(ac,fn,privdata,cmd,len);</span><br><span class="line">    <span class="built_in">free</span>(cmd);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在介绍<code>__redisAsyncCommand</code> 函数之前，先具体介绍下hiredis中回调函数的相关实现。</p>
<p>在<code>struct redisAsyncContext</code>中有四个回调函数任务队列：订阅指令<code>subscribe channle</code> 、<code>psubscribe pattern</code>有专门的任务队列，当<code>(p)subscribe</code>指令的键不正确时，会存储在<code>ac-&gt;sub.invalid</code>中。其他的指令回调函数都存储在 <code>ac-&gt;replies</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规指令的回调函数</span></span><br><span class="line"> redisCallbackList replies;    </span><br><span class="line"> <span class="comment">// 订阅指令的回调函数</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     redisCallbackList invalid;  <span class="comment">// 指令名不正确时回调函数</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> *<span class="title">channels</span>;</span>      <span class="comment">// channel_name ---&gt; callback</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> *<span class="title">patterns</span>;</span>      <span class="comment">// pattern_name ---&gt; callback</span></span><br><span class="line"> &#125; sub;</span><br></pre></td></tr></table></figure>

<p>而每个回调函数节点都是 <code>redisCallback</code>对象，由<code>redisCallback</code>对象形成的回调函数链表、任务队列。而这些任务列表，都是<strong>从尾部插入，头部取出</strong>，即先响应的请求先执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisCallback</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">redisCallback</span>* next; <span class="comment">// 单链表</span></span><br><span class="line">    redisCallbackFn* fn;        <span class="comment">// 回调函数</span></span><br><span class="line">    <span class="type">int</span> pending_subs;           <span class="comment">// 对应的通道/模式订阅次数</span></span><br><span class="line">    <span class="type">void</span> *privdata;			   </span><br><span class="line">&#125; redisCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">redisCallbackList</span> &#123;</span><br><span class="line">    redisCallback *head; <span class="comment">// 链表头部</span></span><br><span class="line">    redisCallback *tail; <span class="comment">// 链表尾部</span></span><br><span class="line">&#125; redisCallbackList;</span><br></pre></td></tr></table></figure>

<h4 id="redisPushCallback"><a href="#redisPushCallback" class="headerlink" title="__redisPushCallback"></a>__redisPushCallback</h4><p><code>__redisPushCallback</code>函数， 在任务列表<code>list</code>的尾部添加新的节点<code>source</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __redisPushCallback(redisCallbackList* <span class="built_in">list</span>, redisCallback *source) &#123;</span><br><span class="line">    redisCallback *cb;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Copy callback from stack to heap */</span></span><br><span class="line">    cb = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*cb));</span><br><span class="line">    <span class="keyword">if</span> (cb == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR_OOM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (source != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(cb,source,<span class="keyword">sizeof</span>(*cb));</span><br><span class="line">        cb-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 单独一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将这个节点 cb 插入在在 list 的尾部</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = cb;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">list</span>-&gt;tail != <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">list</span>-&gt;tail-&gt;next = cb;</span><br><span class="line">    <span class="built_in">list</span>-&gt;tail = cb;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisShiftCallback"><a href="#redisShiftCallback" class="headerlink" title="__redisShiftCallback"></a>__redisShiftCallback</h4><p><code>__redisShiftCallback</code>函数，从从任务列表<code>list</code>头部取出任务节点至<code>target</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __redisShiftCallback(redisCallbackList *<span class="built_in">list</span>, redisCallback *target) &#123;</span><br><span class="line">    redisCallback* cb = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">if</span> (cb != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head = cb-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cb == <span class="built_in">list</span>-&gt;tail)</span><br><span class="line">            <span class="built_in">list</span>-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (target != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">memcpy</span>(target,cb,<span class="keyword">sizeof</span>(*cb));</span><br><span class="line">        <span class="built_in">free</span>(cb);</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisRunCallback"><a href="#redisRunCallback" class="headerlink" title="__redisRunCallback"></a>__redisRunCallback</h4><p><code>__redisRunCallback</code>函数，执行回调函数<code>cb-&gt;fn</code>。<code>REDIS_IN_CALLBACK</code>标志位表示正在执行中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __redisRunCallback(redisAsyncContext *ac, redisCallback *cb, redisReply *reply) &#123;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line">    <span class="keyword">if</span> (cb-&gt;fn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        c-&gt;flags |= REDIS_IN_CALLBACK;  <span class="comment">// 在执行中</span></span><br><span class="line">        cb-&gt;fn(ac,reply,cb-&gt;privdata);  </span><br><span class="line">        c-&gt;flags &amp;= ~REDIS_IN_CALLBACK; <span class="comment">// 执行完毕</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisAsyncCommand"><a href="#redisAsyncCommand" class="headerlink" title="__redisAsyncCommand"></a>__redisAsyncCommand</h4><p><code>__redisAsyncCommand</code>函数要完成两个任务：</p>
<ol>
<li><p>根据指令<code>cmd</code>类型，将<code>fn</code>回调函数设置到<code>ac</code>相应的队列中。  </p>
<p>指令字符串 <code>cmd</code> 格式依然满足之前在<a href="./OutputBuffer">剖析REDIS的输出缓冲区</a>章中所述的字符串格式。 hiredis通过<code>nextArgument</code>函数解析<code>cmd</code>指令，来根据指令类型为回调函数<code>fn</code>选择任务队列。</p>
</li>
<li><p>将指令字符串<code>cmd</code>写入到<code>c-&gt;obuf</code>中，待发送</p>
</li>
</ol>
<p>整个过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __redisAsyncCommand(redisAsyncContext *ac,</span><br><span class="line">                               redisCallbackFn *fn, </span><br><span class="line">                               <span class="type">void</span> *privdata, </span><br><span class="line">                               <span class="type">const</span> <span class="type">char</span> *cmd, </span><br><span class="line">                               <span class="type">size_t</span> len) </span><br><span class="line">&#123;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line">    redisCallback cb;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> *<span class="title">cbdict</span>;</span></span><br><span class="line">    dictEntry *de;</span><br><span class="line">    redisCallback *existcb;</span><br><span class="line">    <span class="type">int</span> pvariant, hasnext;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *cstr, *astr;</span><br><span class="line">    <span class="type">size_t</span> clen, alen;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *p;</span><br><span class="line">    sds sname;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果连接即将关闭，则并不再接受新的指令</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (REDIS_DISCONNECTING | REDIS_FREEING))  <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置回调函数节点</span></span><br><span class="line">    cb.fn = fn;</span><br><span class="line">    cb.privdata = privdata;</span><br><span class="line">    cb.pending_subs = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 解析指令字符串：</span></span><br><span class="line">    <span class="comment">// 	cstr 存储是指令名字，clen 是指令长度，</span></span><br><span class="line">    <span class="comment">// 	p 指向指令参数的起始位置</span></span><br><span class="line">    p = nextArgument(cmd,&amp;cstr,&amp;clen);</span><br><span class="line">    assert(p != <span class="literal">NULL</span>);</span><br><span class="line">    hasnext = (p[<span class="number">0</span>] == <span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">    pvariant = (<span class="built_in">tolower</span>(cstr[<span class="number">0</span>]) == <span class="string">&#x27;p&#x27;</span>) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    cstr += pvariant;</span><br><span class="line">    clen -= pvariant;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*************** 1 将回调函数 fn 加入到相应的任务队列 ************************/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1.1) 发出去的指令是：subscribe channel/pattern</span></span><br><span class="line">    <span class="keyword">if</span> (hasnext &amp;&amp; strncasecmp(cstr,<span class="string">&quot;subscribe\r\n&quot;</span>,<span class="number">11</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        c-&gt;flags |= REDIS_SUBSCRIBED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取订阅的 pattern/channel 参数</span></span><br><span class="line">        <span class="keyword">while</span> ((p = nextArgument(p,&amp;astr,&amp;alen)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sname = sdsnewlen(astr,alen);  <span class="comment">// pattern_name / channel_name</span></span><br><span class="line">            <span class="comment">// pvariant =1，订阅模式</span></span><br><span class="line">            <span class="comment">// pvariant =0，订阅通道</span></span><br><span class="line">            <span class="keyword">if</span> (pvariant)</span><br><span class="line">                cbdict = ac-&gt;sub.patterns;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cbdict = ac-&gt;sub.channels;</span><br><span class="line"></span><br><span class="line">            de = dictFind(cbdict, sname); <span class="comment">// name --&gt; 该通道的回调函数</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果订阅的通道/模式已经存在</span></span><br><span class="line">            <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                existcb = dictGetEntryVal(de);</span><br><span class="line">                cb.pending_subs = existcb-&gt;pending_subs + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 sname 的回调函数重新设置为 cb</span></span><br><span class="line">            ret = dictReplace(cbdict,sname,&amp;cb);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ret == <span class="number">0</span>) sdsfree(sname);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">	<span class="comment">// 1.2) 发出去指令是 : unsubscribe</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(cstr,<span class="string">&quot;unsubscribe\r\n&quot;</span>,<span class="number">13</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 只有之前执行过 subscribed， 现在执行 unsubscribe 才有用</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_SUBSCRIBED)) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// UNSUBSCRIBE 指令不设置回调函数</span></span><br><span class="line">     &#125; </span><br><span class="line">    <span class="comment">// 1.3) 发出去的指令是 : monitor </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(strncasecmp(cstr,<span class="string">&quot;monitor\r\n&quot;</span>,<span class="number">9</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">         c-&gt;flags |= REDIS_MONITORING;			<span class="comment">// 设置标志位</span></span><br><span class="line">         __redisPushCallback(&amp;ac-&gt;replies,&amp;cb);	 <span class="comment">// 加入到 ac-&gt;replies 队列</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 1.4) 其他指令</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经处于被订阅，在取消订阅之前无法指令其他指令</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_SUBSCRIBED)</span><br><span class="line">            __redisPushCallback(&amp;ac-&gt;sub.invalid,&amp;cb);	<span class="comment">// 因为加入无效队列</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则就是常规的请求，加入到 ac-&gt;replies</span></span><br><span class="line">            __redisPushCallback(&amp;ac-&gt;replies,&amp;cb);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/********* 2 将格式化指令字符串 cmd 写入 c-&gt;obuf **********/</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 再将 cmd 加入到 c 的发送缓冲区</span></span><br><span class="line">    __redisAppendCommand(c,cmd,len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册可写事件，并设置回调函数</span></span><br><span class="line">    <span class="comment">// 此时注册可写事件，只要发送缓冲区不是满的，则立马触发</span></span><br><span class="line">    _EL_ADD_WRITE(ac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送数据的流程，介绍完毕。</p>
<h2 id="EL-ADD-READ-ac"><a href="#EL-ADD-READ-ac" class="headerlink" title="_EL_ADD_READ(ac)"></a>_EL_ADD_READ(ac)</h2><p>下面从 <code>_EL_ADD_READ</code> 宏讲解可读事件的处理流程。</p>
<p><code>_EL_ADD_READ</code>宏展开如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _EL_ADD_READ(ctx)                                         \</span></span><br><span class="line"><span class="meta">    do &#123;                                                          \</span></span><br><span class="line"><span class="meta">        refreshTimeout(ctx);                                      \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> ((ctx)-&gt;ev.addRead) (ctx)-&gt;ev.addRead((ctx)-&gt;ev.data); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p>在<code>sentinel</code>中 <code>addRead</code> 指向的函数是 <code>redisAeAddRead</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ac-&gt;ev.addRead = redisAeAddRead;</span><br></pre></td></tr></table></figure>

<p>而 <code>redisAeAddRead</code> 函数，实现的是为 <code>e-&gt;fd</code>注册可读事件，而可读事件的回调函数是 <code>redisAeReadEvent</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">redisAeAddRead</span><span class="params">(<span class="type">void</span> *privdata)</span> &#123;</span><br><span class="line">    redisAeEvents *e = (redisAeEvents*)privdata;</span><br><span class="line">    aeEventLoop *loop = e-&gt;loop;</span><br><span class="line">    <span class="keyword">if</span> (!e-&gt;reading) &#123;</span><br><span class="line">        e-&gt;reading = <span class="number">1</span>;</span><br><span class="line">        aeCreateFileEvent(loop,e-&gt;fd,AE_READABLE,redisAeReadEvent,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当可读事件触发</strong>，读取回调函数<code>redisAeReadEvent</code>，内部调用 <code>redisAsyncHandleRead</code>函数处理可读事件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">redisAeReadEvent</span><span class="params">(aeEventLoop *el, <span class="type">int</span> fd, <span class="type">void</span> *privdata, <span class="type">int</span> mask)</span> &#123;</span><br><span class="line">    ((<span class="type">void</span>)el); </span><br><span class="line">    ((<span class="type">void</span>)fd); </span><br><span class="line">    ((<span class="type">void</span>)mask);</span><br><span class="line"></span><br><span class="line">    redisAeEvents *e = (redisAeEvents*)privdata;</span><br><span class="line">    redisAsyncHandleRead(e-&gt;context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>redisAsyncHandleRead</code>函数：</p>
<ul>
<li>判断有没有建立客户端<code>ac</code>是否已经连接，没有则调用<code>__redisAsyncHandleConnect</code>函数发起连接请求</li>
<li>如果已经建立连接或者上面成功建立连接，则调用异步读取函数<code>c-&gt;funcs-&gt;async_read</code>读取网络中的数据。</li>
</ul>
<p>其中<code>c-&gt;funcs-&gt;async_read</code>指向的是<code>redisAsyncRead</code>函数。整个流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">redisAsyncHandleRead</span><span class="params">(redisAsyncContext *ac)</span> &#123;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有建立连接，则先建立</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_CONNECTED)) &#123;</span><br><span class="line">        <span class="comment">/* Abort connect was not successful. */</span></span><br><span class="line">        <span class="keyword">if</span> (__redisAsyncHandleConnect(ac) != REDIS_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">/* Try again later when the context is still not connected. */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_CONNECTED))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步读</span></span><br><span class="line">    c-&gt;funcs-&gt;async_read(ac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redisAsyncRead"><a href="#redisAsyncRead" class="headerlink" title="redisAsyncRead"></a>redisAsyncRead</h3><p><code>redisAsyncRead</code>函数， 会先调用<code>redisBufferRead</code>函数尝试直接读取数据，读取成功后：</p>
<ul>
<li>如果此时没有注册可读事件，则注册可读事件<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_EL_ADD_READ(ac); </span><br></pre></td></tr></table></figure></li>
<li>对读取到的数据进行处理<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redisProcessCallbacks(ac)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>整个过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">redisAsyncRead</span><span class="params">(redisAsyncContext *ac)</span> &#123;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (redisBufferRead(c) == REDIS_ERR) &#123;</span><br><span class="line">        __redisAsyncDisconnect(ac);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Always re-schedule reads */</span></span><br><span class="line">        <span class="comment">// 如果没有注册可读事件，则注册</span></span><br><span class="line">        _EL_ADD_READ(ac);</span><br><span class="line">        <span class="comment">// 读取到数据，则执行相应的回调函数</span></span><br><span class="line">        redisProcessCallbacks(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisBufferRead"><a href="#redisBufferRead" class="headerlink" title="redisBufferRead"></a>redisBufferRead</h4><p><code>redisBufferRead</code> 函数分为两步：</p>
<ul>
<li>先将数据从网络中读取到<code>buf</code>。这里使用的 <code>c-&gt;funcs-&gt;read</code>同步读函数，即<code>redisNetRead</code>函数，</li>
<li>如果<code>c-&gt;funcs-&gt;read</code>返回值大于0，则成功从网络中读取到数据，那么将读取到的f数据写入到接受缓冲区 <code>c-&gt;reader-&gt;buf</code>，这部分由<code>redisReaderFeed</code>函数实现。</li>
</ul>
<p>因此，<code>redisBufferRead</code>函数是直接从当前网络中读取数据，如果有数据 or 对端关闭则返回<code>REDIS_OK</code>，否则返回<code>REDIS_ERR</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisBufferRead</span><span class="params">(redisContext *c)</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">1024</span>*<span class="number">16</span>];</span><br><span class="line">    <span class="type">int</span> nread;</span><br><span class="line">	<span class="comment">// 有错误则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;err) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    <span class="comment">// 1）将数据从网络中读取到 buf</span></span><br><span class="line">    <span class="comment">// 内部还是调用 c-&gt;funcs-&gt;read，</span></span><br><span class="line">    nread = c-&gt;funcs-&gt;read(c, buf, <span class="keyword">sizeof</span>(buf)); <span class="comment">// 同步读取</span></span><br><span class="line">    <span class="keyword">if</span> (nread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 2) 将buf中数据写入到 c-&gt;reader 中</span></span><br><span class="line">        <span class="keyword">if</span> (redisReaderFeed(c-&gt;reader, buf, nread) != REDIS_OK) &#123;</span><br><span class="line">            <span class="comment">// 将 1）或 2）中发生的错误记录到 c-err 中</span></span><br><span class="line">            __redisSetError(c, c-&gt;reader-&gt;err, c-&gt;reader-&gt;errstr);</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisNetRead"><a href="#redisNetRead" class="headerlink" title="redisNetRead"></a>redisNetRead</h4><p><code>redisNetRead</code>函数，即 <code>c-&gt;funcs-&gt;read</code>，实现从网络读取数据。根据<code>recv</code>函数的返回值<code>nread</code>对结果进行判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisNetRead</span><span class="params">(redisContext *c, <span class="type">char</span> *buf, <span class="type">size_t</span> bufcap)</span> &#123;</span><br><span class="line">    <span class="type">int</span> nread = recv(c-&gt;fd, buf, bufcap, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 非阻塞IO模式下的，errno == EWOULDBLOCK 表示当前没有可读数据 </span></span><br><span class="line">        <span class="comment">// errno == EINTR 表示读取操作被中断</span></span><br><span class="line">        <span class="comment">// 以上不是错误，稍后再试</span></span><br><span class="line">        <span class="keyword">if</span> ((errno == EWOULDBLOCK &amp;&amp; !(c-&gt;flags &amp; REDIS_BLOCK)) || (errno == EINTR)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞模式下，读取数据超时是错误</span></span><br><span class="line">        <span class="keyword">if</span>(errno == ETIMEDOUT &amp;&amp; (c-&gt;flags &amp; REDIS_BLOCK)) &#123;</span><br><span class="line">            __redisSetError(c, REDIS_ERR_TIMEOUT, <span class="string">&quot;recv timeout&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 其他错误标志，</span></span><br><span class="line">        __redisSetError(c, REDIS_ERR_IO, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">// 对端关闭</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;</span><br><span class="line">        __redisSetError(c, REDIS_ERR_EOF, <span class="string">&quot;Server closed the connection&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 你read &gt; 0：真正读取到数据</span></span><br><span class="line">    <span class="keyword">return</span> nread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisReaderFeed"><a href="#redisReaderFeed" class="headerlink" title="redisReaderFeed"></a>redisReaderFeed</h4><p><code>redisReaderFeed</code>函数，用于将从网络中读取到数据<code>buf</code>写入到客户端的接受缓冲区<code>c-&gt;reader</code>中。<code>redisReader</code>结构如下，本次读取数据即将接受到的数据存储到<code>c-&gt;reader-&gt;buf</code>中，但是对<code>c-&gt;reader-&gt;buf</code>最大未使用空间有限制，不得超过<code>c-&gt;reader-&gt;maxbuf</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisReader</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> err;            </span><br><span class="line">    <span class="type">char</span> errstr[<span class="number">128</span>];   </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储接受到的数据</span></span><br><span class="line">    <span class="type">char</span>*  buf;         <span class="comment">/* Read buffer  读取缓冲区 */</span></span><br><span class="line">    <span class="type">size_t</span> pos;         <span class="comment">/* Buffer cursor 当前指针位置 */</span></span><br><span class="line">    <span class="type">size_t</span> len;         <span class="comment">/* Buffer length 读取缓冲区长度*/</span></span><br><span class="line">    <span class="type">size_t</span> maxbuf;      <span class="comment">/* Max length of unused buffer  最大未使用长度*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面字段用于解析接收到的数据</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125; redisReader;	</span><br></pre></td></tr></table></figure>

<p>因此完整的操作如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisReaderFeed</span><span class="params">(redisReader *r, <span class="type">const</span> <span class="type">char</span> *buf, <span class="type">size_t</span> len)</span> &#123;</span><br><span class="line">    sds newbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果前面从网络中读取数据发生错误，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;err) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf != <span class="literal">NULL</span> &amp;&amp; len &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 r-&gt;buf 是空的，并且 r-&gt;buf 的容量大于 r-&gt;maxbuf</span></span><br><span class="line">        <span class="comment">// 则释放 r-&gt;buf</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;len == <span class="number">0</span> &amp;&amp; r-&gt;maxbuf != <span class="number">0</span> &amp;&amp; sdsavail(r-&gt;buf) &gt; r-&gt;maxbuf) &#123;</span><br><span class="line">            sdsfree(r-&gt;buf);</span><br><span class="line">            r-&gt;buf = sdsempty();</span><br><span class="line">            r-&gt;pos = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            assert(r-&gt;buf != <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 buf 数据添加到 r-&gt;buf 后</span></span><br><span class="line">        newbuf = sdscatlen(r-&gt;buf,buf,len);</span><br><span class="line">        <span class="keyword">if</span> (newbuf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            __redisReaderSetErrorOOM(r);</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新参数</span></span><br><span class="line">        r-&gt;buf = newbuf;</span><br><span class="line">        r-&gt;len = sdslen(r-&gt;buf);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再将视线拉回到<code>redisAsyncRead</code>函数：如果 <code>redisBufferRead(c)</code>函数将对端请求数据存储至<code>c-&gt;reader-&gt;buf</code>没有发生错误，那么就要对<code>c-&gt;reader-&gt;buf</code>中的数据进行处理，而处理过程由<code>redisProcessCallbacks</code>函数完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (redisBufferRead(c) == REDIS_ERR) &#123;</span><br><span class="line">    __redisAsyncDisconnect(ac);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    _EL_ADD_READ(ac);</span><br><span class="line">    redisProcessCallbacks(ac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，<code>c-&gt;reader-&gt;buf</code>中的数据就类似于<code>readQueryFromClient</code>函数读取的<code>c-&gt;querybuf</code>数据，这次是原始的数据，<code>readQueryFromClient</code>读取到<code>c-&gt;quetybuf</code>后，还需要经过<code>processInputBuffer</code>解析后才能正常使用。在这里，也是也从此。在被 <code>redisProcessCallbacks</code> 使用前会先经过 <code>redisGetReply</code>函数处理。</p>
<p>因此，数据从对端传递到本端输入缓冲区<code>ac-&gt;c-&gt;reader-&gt;buf</code>中后，下面要做的:</p>
<ul>
<li>解析<code>c-&gt;reader-&gt;buf</code>中的数据，并将解析结果保存至<code>reply</code>。这一部分由<code>redisGetReply</code> 函数实现。</li>
<li>根据<code>reply</code>，执行相应的回调函数。这一部分由 <code>redisProcessCallbacks</code> 实现，即相当于 <code>processCommand</code>函数。而每个单独的<code>xxxCallback</code>就相当于之前的<code>xxxCommand</code>。</li>
</ul>
<p>下面依次介绍解析数据到执行回调函数。</p>
<h3 id="redisGetReply"><a href="#redisGetReply" class="headerlink" title="redisGetReply"></a>redisGetReply</h3><p><code>redisGetReply</code>函数，会先调用<code>redisGetReplyFromReader</code>函数尝试直接从<code>c-&gt;reader-&gt;buf</code>中获取<code>reply</code>，如果读取到了则返回。如果没有读取到并且<code>c</code>与对端是阻塞连接，再经过两个步骤：</p>
<ul>
<li>先将发送缓冲区<code>c-&gt;obuf</code>中的数据全部发送至对端</li>
<li>再阻塞等待数据对端发送数据，当对端发送数据了，<code>redisBufferRead</code>函数将对端发送的数据存储到输入缓冲区<code>c-&gt;reader</code>中，再调用 <code>redisGetReplyFromReader</code>函数从<code>c-&gt;reader</code>解析。</li>
</ul>
<p>因此，在非阻塞IO模式下，返回<code>REDIS_OK</code>也不一定会读取到数据，而在阻塞IO模式下，返回<code>REDIS_OK</code>即读取到数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisGetReply</span><span class="params">(redisContext *c, <span class="type">void</span> **reply)</span> &#123;</span><br><span class="line">    <span class="type">int</span> wdone = <span class="number">0</span>;</span><br><span class="line">    <span class="type">void</span> *aux = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 尝试直接读取</span></span><br><span class="line">    <span class="keyword">if</span> (redisGetReplyFromReader(c, &amp;aux) == REDIS_ERR)</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于阻塞类型，</span></span><br><span class="line">    <span class="comment">//   1）就将 c-&gt;obuf 中的数据全部发送出去</span></span><br><span class="line">    <span class="comment">//   2）一直阻塞等待回应</span></span><br><span class="line">    <span class="keyword">if</span> (aux == <span class="literal">NULL</span> &amp;&amp; c-&gt;flags &amp; REDIS_BLOCK) &#123;</span><br><span class="line">        <span class="comment">// 一直向c中写数据，直到将 c-&gt;obuf 发送完毕</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redisBufferWrite(c,&amp;wdone) == REDIS_ERR)</span><br><span class="line">                <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!wdone);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 阻塞等待读取数据</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (redisBufferRead(c) == REDIS_ERR)</span><br><span class="line">                <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            <span class="keyword">if</span> (redisGetReplyFromReader(c,&amp;aux) == REDIS_ERR)</span><br><span class="line">                <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125; <span class="keyword">while</span> (aux == <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) *reply = aux;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisGetReplyFromReader"><a href="#redisGetReplyFromReader" class="headerlink" title="redisGetReplyFromReader"></a>redisGetReplyFromReader</h4><p><code>redisGetReplyFromReader</code>函数，在内部是调用 <code>redisReaderGetReply</code>函数完成功能。如果发生错误则将在<code>c-&gt;reader</code>中的错误复制至<code>c-&gt;err</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisGetReplyFromReader</span><span class="params">(redisContext *c, <span class="type">void</span> **reply)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (redisReaderGetReply(c-&gt;reader,reply) == REDIS_ERR) &#123;</span><br><span class="line">        __redisSetError(c,c-&gt;reader-&gt;err,c-&gt;reader-&gt;errstr);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在讲解<code>redisReaderGetReply</code>解析过程之前。先熟悉下输入缓冲区<code>redisReader</code>。<code>redisReader</code>有两个作用：</p>
<ul>
<li>输入缓冲区：<code>r-&gt;buf</code> 接受对端的数据</li>
<li>存储回应：<code>r-&gt;reply</code>中存储着对<code>r-&gt;buf</code>的解析结果</li>
</ul>
<p>上面已经完成了第一步，下面就是要进行第二步骤：对<code>r-&gt;buf</code>中的数据进行解析后存储至<code>r-&gt;reply</code>。对端每种请求都会相应的回调函数，<code>r-&gt;reply</code>后续会用于各种请求的回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisReader</span> &#123;</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">//上面字段用于接受对端数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析接收到的数据</span></span><br><span class="line">    redisReadTask rstack[<span class="number">9</span>]; 	<span class="comment">// 用于递归解析</span></span><br><span class="line">    <span class="type">int</span> ridx;    			   <span class="comment">// 递归层次</span></span><br><span class="line">    <span class="type">void</span>* reply; </span><br><span class="line"></span><br><span class="line">    redisReplyObjectFunctions* fn; <span class="comment">// 创建REDIS对象</span></span><br><span class="line">    <span class="type">void</span> *privdata;</span><br><span class="line">&#125; redisReader;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>fn</strong></li>
</ol>
<p>之前在<a href="../OutputBffer">剖析REDIS的输出缓冲区</a>一章中，讲过REDIS传输协议有不同的类型。在此为创建不同的对象都是由 <code>fn</code> 函数指针实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisReplyObjectFunctions</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *(*createString)(<span class="type">const</span> redisReadTask*, <span class="type">char</span>*, <span class="type">size_t</span>); <span class="comment">// 创建 string 类型对象</span></span><br><span class="line">    <span class="type">void</span> *(*createArray)(<span class="type">const</span> redisReadTask*, <span class="type">size_t</span>);         <span class="comment">// 创建 Array, Map, Set 类型对象</span></span><br><span class="line">    <span class="type">void</span> *(*createInteger)(<span class="type">const</span> redisReadTask*, <span class="type">long</span> <span class="type">long</span>);	<span class="comment">// 创建整数类型对象</span></span><br><span class="line">    <span class="type">void</span> *(*createDouble)(<span class="type">const</span> redisReadTask*, <span class="type">double</span>, <span class="type">char</span>*, <span class="type">size_t</span>); <span class="comment">// 创建 double 类型对象</span></span><br><span class="line">    <span class="type">void</span> *(*createNil)(<span class="type">const</span> redisReadTask*);				   <span class="comment">// 创建 NULL 对象</span></span><br><span class="line">    <span class="type">void</span> *(*createBool)(<span class="type">const</span> redisReadTask*, <span class="type">int</span>);			    <span class="comment">// 创建 bool 类型对象</span></span><br><span class="line">    <span class="type">void</span> (*freeObject)(<span class="type">void</span>*);								  <span class="comment">// 是释放对象内存</span></span><br><span class="line">&#125; redisReplyObjectFunctions;</span><br></pre></td></tr></table></figure>

<p>对应的函数指针是<code>defaultFunctions</code>，如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> redisReplyObjectFunctions defaultFunctions = &#123;</span><br><span class="line">    createStringObject,</span><br><span class="line">    createArrayObject,</span><br><span class="line">    createIntegerObject,</span><br><span class="line">    createDoubleObject,</span><br><span class="line">    createNilObject,</span><br><span class="line">    createBoolObject,</span><br><span class="line">    freeReplyObject</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>rstack[9]</strong></li>
</ol>
<p>由于某些数据类型可能是<code>Map、Set、Array</code>等复合类型，因此可能发生嵌套，比如<code>Array&lt;Array&lt;Map&gt;&gt;&gt;</code>等，因此为了解析复合类型依靠 <code>rstack[9]</code>来追踪深入递归的路径（这是不是很像基于栈实现的函数调用），这里对嵌套层次有规定，最多只能嵌套9层。</p>
<p>那么问题来了，怎么返回到上一层，就像函数如何返回到主函数？下面来看看 <code>redisReadTask</code> 结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisReadTask</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;                       <span class="comment">// 回复类型</span></span><br><span class="line">    <span class="comment">// 针对符合类型</span></span><br><span class="line">    <span class="type">int</span> elements;                   <span class="comment">/* 元素个数 */</span></span><br><span class="line">    <span class="type">int</span> idx;                        <span class="comment">/* 如果复合类型，idx 表示当前元素的index*/</span></span><br><span class="line">    <span class="type">void</span> *obj;                      <span class="comment">/* 实际类型是 redisReply* ，即父节点的reply */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisReadTask</span> *<span class="title">parent</span>;</span>   <span class="comment">/* 指向上一层，即父节点 */</span></span><br><span class="line">    <span class="type">void</span> *privdata;                 </span><br><span class="line">&#125; redisReadTask;</span><br></pre></td></tr></table></figure>

<p>假设 <code>node</code> 是 <code>redisReadTask*</code> 对象，那么每个<code>node</code>都包含了一个指针<code>parent</code> 指向上一层，即<code>node-&gt;parent</code>可以用于返回上一层；<code>node-&gt;idx</code>字段指示着<code>node</code>该位于复合类型的哪个位置。而当前节点从<code>c-&gt;reader</code>解析所得数据存储在 <code>node-&gt;obj</code>，其实际类型是<code>redisReply*</code>；解析所得数据类型是<code>node-&gt;tyoe</code>，如果是复合类型则<code>node-&gt;elements</code>指示着元素个数。</p>
<p>因此，可总结如下：</p>
<ul>
<li><code>redisReadTask[9]</code>中每个<code>redisReadTask</code>都可以视为一个单链表，通过<code>parent*</code>串联各个嵌套层之间关系，而每一层的数据都由<code>obj*</code>存储。</li>
<li><code>ridx</code> 变量，表征着当前嵌套的层数，可以在O(1)时间定位当前的层数。</li>
</ul>
<p>其中，<code>type</code>可能值如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_STRING  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_ARRAY   2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_INTEGER 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_NIL     4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_STATUS  5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_ERROR   6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_DOUBLE  7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_BOOL    8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_MAP     9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_SET     10</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_ATTR    11</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_PUSH    12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_BIGNUM  13</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REDIS_REPLY_VERB    14</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>reply</strong></li>
</ol>
<p><code>reply</code>的实际类型是<code>redisReply</code>结构体，用于保存回复的类型以及数据。其中当<code>type==REDIS_REPLY_DOUBLE</code>时，使用<code>dval</code>和<code>str</code>两个方式来保存数据，当使用<code>str</code>字段时，也要使用<code>len</code>来表示<code>str</code>的长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisReply</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type;           <span class="comment">/* REDIS_REPLY_* */</span></span><br><span class="line">    <span class="comment">// 下面是针对不同 type 的值</span></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> integer;  <span class="comment">/* type == REDIS_REPLY_INTEGER 时的整数值*/</span></span><br><span class="line">    <span class="type">double</span> dval;        <span class="comment">/* type == REDIS_REPLY_DOUBLE 时的 double 值 */</span></span><br><span class="line">    <span class="type">size_t</span> len;         <span class="comment">/* 字符串的长度*/</span></span><br><span class="line">    <span class="type">char</span> *str;          <span class="comment">/* type == REDIS_REPLY_ERROR | REDIS_REPLY_STRING | REDIS_REPLY_DOUBLE */</span></span><br><span class="line">    <span class="type">char</span> vtype[<span class="number">4</span>];      <span class="comment">/* type == REDIS_REPLY_VERB, 最后一个字节 vtype[3]==&#x27;\0&#x27; */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> elements;    <span class="comment">/* type == REDIS_REPLY_ARRAY，元素个数 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisReply</span>** <span class="title">element</span>;</span> <span class="comment">/* type == REDIS_REPLY_ARRAY，数据实体 */</span></span><br><span class="line">&#125; redisReply;</span><br></pre></td></tr></table></figure>

<h4 id="createArrayObject"><a href="#createArrayObject" class="headerlink" title="createArrayObject"></a>createArrayObject</h4><p>下面以创建<code>Array、Map、Set</code>类型的<code>createArrayObject</code>函数来讲解是如何深入递归的。</p>
<ul>
<li><p>先调用<code>createReplyObject</code>函数创建一个回复<code>redisReply</code>对象，此时只具有类型数据<code>r-&gt;type=type</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> redisReply *<span class="title function_">createReplyObject</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">    redisReply *r = <span class="built_in">calloc</span>(<span class="number">1</span>, <span class="keyword">sizeof</span>(*r));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    r-&gt;type = type;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为<code>elements</code>个元素分配内存，每个元素都是都是使用<code>redisReply</code>对象存储。</p>
</li>
<li><p>将当前回复节点<code>r</code>放入到复合类型指定的索引位置</p>
</li>
</ul>
<p>因此，<code>createArrayObject</code>函数只是完成了：1）创建<code>elements</code>个<code>redisReply</code>节点，提供了一个容器；3）将<code>r</code>和所在的复合类型建立关系，即放入指定的位置。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">createArrayObject</span><span class="params">(<span class="type">const</span> redisReadTask* task, <span class="type">size_t</span> elements)</span> &#123;</span><br><span class="line">    redisReply *r, *parent;</span><br><span class="line">	<span class="comment">// 1) 创建reply节点</span></span><br><span class="line">    r = createReplyObject(task-&gt;type);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">// 2) 设置元素个数</span></span><br><span class="line">    <span class="keyword">if</span> (elements &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        r-&gt;element = <span class="built_in">calloc</span>(elements,<span class="keyword">sizeof</span>(redisReply*));</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;element == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            freeReplyObject(r);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r-&gt;elements = elements;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3) 判断是不是复合类型</span></span><br><span class="line">	<span class="comment">// 如果 task-&gt;parent != NULL</span></span><br><span class="line">    <span class="comment">// 则说明 r 是某个复合类型（Map,Set,Array）的一个节点</span></span><br><span class="line">    <span class="keyword">if</span> (task-&gt;parent) &#123;</span><br><span class="line">        parent = task-&gt;parent-&gt;obj;  <span class="comment">// 父节点的回应</span></span><br><span class="line">        <span class="comment">// 父节点肯定某个复合类型</span></span><br><span class="line">        assert(parent-&gt;type == REDIS_REPLY_ARRAY ||</span><br><span class="line">               parent-&gt;type == REDIS_REPLY_MAP ||</span><br><span class="line">               parent-&gt;type == REDIS_REPLY_SET);</span><br><span class="line">        <span class="comment">// 将自己(r)加入到父节点当前的索引位置</span></span><br><span class="line">        parent-&gt;element[task-&gt;idx] = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回此次回应</span></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createIntegerObject"><a href="#createIntegerObject" class="headerlink" title="createIntegerObject"></a>createIntegerObject</h4><p><code>createArrayObject</code>函数调用结束并返回<code>r</code>，但是此时<code>r</code> 中还没有数据 ，需要等<code>STING</code>、<code>INTEGER</code> 、<code>DOUBLE</code>等类型创建好，发现自己是属于某个复合类型<code>r</code>则将自己放置到<code>r</code>中。</p>
<p>以整数为例，会调用<code>createIntegerObject</code> 函数创建整数对象，并将值<code>value</code>存储在 <code>r-&gt;integer</code>。发现自己属于某个复合类型，<code>task-&gt;parent !=NULL</code>，则会自己放置到相应的位置。</p>
<p>最后，会将这个<code>reply</code>返回给调用者。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">createIntegerObject</span><span class="params">(<span class="type">const</span> redisReadTask *task, <span class="type">long</span> <span class="type">long</span> value)</span> &#123;</span><br><span class="line">    redisReply *r, *parent;</span><br><span class="line"></span><br><span class="line">    r = createReplyObject(REDIS_REPLY_INTEGER);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    r-&gt;integer = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (task-&gt;parent) &#123;</span><br><span class="line">        parent = task-&gt;parent-&gt;obj;</span><br><span class="line">        assert(parent-&gt;type == REDIS_REPLY_ARRAY ||</span><br><span class="line">               parent-&gt;type == REDIS_REPLY_MAP ||</span><br><span class="line">               parent-&gt;type == REDIS_REPLY_SET);</span><br><span class="line">        parent-&gt;element[task-&gt;idx] = r;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="processItem"><a href="#processItem" class="headerlink" title="processItem"></a>processItem</h4><p><code>processItem</code>函数， 解析<code>c-&gt;reader</code>数据，主要是两步：</p>
<ul>
<li>读取一个字节的类型数据，获取当前数据类型<code>cur-&gt;type</code></li>
<li>根据<code>cur-&gt;type</code>，调用相应的函数来解析</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">processItem</span><span class="params">(redisReader *r)</span> &#123;</span><br><span class="line">    redisReadTask* cur = &amp;(r-&gt;rstack[r-&gt;ridx]); <span class="comment">// 当前读取任务</span></span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否需要读取类型</span></span><br><span class="line">    <span class="keyword">if</span> (cur-&gt;type &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 读取一个字节的类型数据</span></span><br><span class="line">        <span class="keyword">if</span> ((p = readBytes(r,<span class="number">1</span>)) == <span class="literal">NULL</span>) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不同类型的回复，其前缀不同</span></span><br><span class="line">        <span class="keyword">switch</span> (p[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: cur-&gt;type = REDIS_REPLY_ERROR; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: cur-&gt;type = REDIS_REPLY_STATUS;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;:&#x27;</span>: cur-&gt;type = REDIS_REPLY_INTEGER;<span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;,&#x27;</span>: cur-&gt;type = REDIS_REPLY_DOUBLE; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;_&#x27;</span>: cur-&gt;type = REDIS_REPLY_NIL; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;$&#x27;</span>: cur-&gt;type = REDIS_REPLY_STRING; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: cur-&gt;type = REDIS_REPLY_ARRAY; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;%&#x27;</span>: cur-&gt;type = REDIS_REPLY_MAP; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;~&#x27;</span>: cur-&gt;type = REDIS_REPLY_SET; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;#&#x27;</span>: cur-&gt;type = REDIS_REPLY_BOOL; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;=&#x27;</span>: cur-&gt;type = REDIS_REPLY_VERB; <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 默认协议错误</span></span><br><span class="line">        <span class="keyword">default</span>: __redisReaderSetErrorProtocolByte(r,*p); <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同前缀，调用不同函数对c-&gt;reader进行解析</span></span><br><span class="line">    <span class="keyword">switch</span>(cur-&gt;type) &#123;</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_ERROR  :</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_STATUS :</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_INTEGER:</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_DOUBLE :</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_NIL    :</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_BOOL   : <span class="keyword">return</span> processLineItem(r);</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_STRING :</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_VERB   : <span class="keyword">return</span> processBulkItem(r);</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_ARRAY  :</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_MAP    :</span><br><span class="line">    <span class="keyword">case</span> REDIS_REPLY_SET    : <span class="keyword">return</span> processAggregateItem(r);</span><br><span class="line">    <span class="keyword">default</span>: assert(<span class="literal">NULL</span>);    <span class="keyword">return</span> REDIS_ERR; <span class="comment">/* Avoid warning. */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="processLineItem"><a href="#processLineItem" class="headerlink" title="processLineItem"></a>processLineItem</h4><p><code>processLineItem</code>函数，解析非字符串的简单类型。下面是以整数为例，其他流程基本一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">processLineItem</span><span class="params">(redisReader *r)</span> &#123;</span><br><span class="line">    redisReadTask *cur = &amp;(r-&gt;rstack[r-&gt;ridx]);</span><br><span class="line">    <span class="type">void</span> *obj;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = readLine(r,&amp;len)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 整数类型</span></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;type == REDIS_REPLY_INTEGER) &#123;</span><br><span class="line">			<span class="comment">// 判断是不是有对应的函数</span></span><br><span class="line">            <span class="keyword">if</span> (r-&gt;fn &amp;&amp; r-&gt;fn-&gt;createInteger) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> v;</span><br><span class="line">                <span class="keyword">if</span> (string2ll(p, len, &amp;v) == REDIS_ERR) &#123;</span><br><span class="line">                    __redisReaderSetError(r,</span><br><span class="line">                                          REDIS_ERR_PROTOCOL,</span><br><span class="line">                                          <span class="string">&quot;Bad integer value&quot;</span>);</span><br><span class="line">                    <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 创建对象</span></span><br><span class="line">                obj = r-&gt;fn-&gt;createInteger(cur,v);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                obj = (<span class="type">void</span>*)REDIS_REPLY_INTEGER;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;type == REDIS_REPLY_DOUBLE) &#123; <span class="comment">/*****/</span> &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;type == REDIS_REPLY_NIL)	  &#123; <span class="comment">/*****/</span> &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cur-&gt;type == REDIS_REPLY_BOOL)   &#123; <span class="comment">/*****/</span> &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">/* Type will be error or status. */</span>  &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            __redisReaderSetErrorOOM(r); <span class="comment">// error: out of memory </span></span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// r-&gt;ridx ==0，则说明处于最上层，</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;ridx == <span class="number">0</span>) r-&gt;reply = obj;</span><br><span class="line">        moveToNextTask(r); <span class="comment">// !!! 重要</span></span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="moveToNextTask"><a href="#moveToNextTask" class="headerlink" title="moveToNextTask"></a>moveToNextTask</h4><p><code>moveToNextTask</code> 函数，控制着解析<code>c-&gt;reader</code>的流程。<code>processLineItem</code>函数将<code>c-&gt;reader</code>数据解析后，将解析结果保存在<code>c-&gt;reader-&gt;reply</code>。如果<code>reply-&gt;type</code>是非复合类型，解析就到此结束。但是如果是个复合类型，就需要继续解析：</p>
<ul>
<li>如果当前嵌套层还没解析完，则向当前嵌套层的下一个位置</li>
<li>如果当前嵌套层解析完，则需要返回上一层</li>
</ul>
<p>具体地说，对于下面的嵌套层：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::vector&lt;std::vector&lt;....&gt;&gt;&gt;  var <span class="comment">// 最多只能有8层嵌套</span></span><br></pre></td></tr></table></figure>

<p><font color="red"><code>moveToNextTask</code>的作用是指定下次解析所得元素的存储位置</font>，对于某层<code>var[ridx][idx]</code>元素：</p>
<ul>
<li>当<code>idx == var[ridx].size()-1</code>时，则<code>var[ridx]</code>已经完全填满了，下一个元素将填充到<code>var[ridx+1]</code>中的位置。</li>
</ul>
<p>  如果 <code>ridx+1 == var[ridx-1].size()</code>，那么就继续返回。如果var所有位置全部填了，就直接返回此次解析结果var。否则，var某个位置没有数据，则返回至该位置<code>var[i][j]</code>，下次元素将复制至此。</p>
<ul>
<li>当<code>idx &lt; var[ridx].size()-1</code>时，下次解析所得的参数复制到<code>var[ridx][idx++]</code>的位置，而不至于覆盖<code>var[ridx][idx]</code>的元素</li>
</ul>
<p>无论当前正在解析是个复合类型，还是简单类型。整个流程成功解析完毕后，<font color="red"> <strong><code>r-&gt;ridx == -1</code></strong></font>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">moveToNextTask</span><span class="params">(redisReader *r)</span> &#123;</span><br><span class="line">    redisReadTask *cur, *prv;</span><br><span class="line">    <span class="keyword">while</span> (r-&gt;ridx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 解析完毕，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;ridx == <span class="number">0</span>) &#123;</span><br><span class="line">            r-&gt;ridx--;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = &amp;(r-&gt;rstack[r-&gt;ridx]);        <span class="comment">// 当前嵌套层</span></span><br><span class="line">        prv = &amp;(r-&gt;rstack[r-&gt;ridx<span class="number">-1</span>]);      <span class="comment">// 上一个嵌套层</span></span><br><span class="line"></span><br><span class="line">        assert(prv-&gt;type == REDIS_REPLY_ARRAY ||</span><br><span class="line">               prv-&gt;type == REDIS_REPLY_MAP   ||</span><br><span class="line">               prv-&gt;type == REDIS_REPLY_SET);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;idx == prv-&gt;elements<span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 说明当前嵌套层的元素个数，已经把上一层容器的坑位都填满了</span></span><br><span class="line">            <span class="comment">// 就好比定义了 ： std::vector&lt;int&gt; vec(3);</span></span><br><span class="line">            <span class="comment">// 现在vec已经有3个元素了，那么就需要返回到上一层了，</span></span><br><span class="line">            <span class="comment">// 即 r-&gt;ridx--;</span></span><br><span class="line">            r-&gt;ridx--;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意：</span></span><br><span class="line">            <span class="comment">// 	这里可能会逐层递归，即如果每一层的元素都满了，那么会在此逐层递归</span></span><br><span class="line">            <span class="comment">// 	一直到返回最上层，即 r-&gt;ridx==0，那么整个复合类型的解析完毕</span></span><br><span class="line">            <span class="comment">// 	在上面的 if(r-&gt;ridx==0) 处返回</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则就移动到当前层的下一个坑位</span></span><br><span class="line"></span><br><span class="line">            assert(cur-&gt;idx &lt; prv-&gt;elements);</span><br><span class="line">            <span class="comment">// 先将下一个坑位状态初始化，</span></span><br><span class="line">            cur-&gt;type = <span class="number">-1</span>;      <span class="comment">// 在读取下一个reply时，先读取reply类型</span></span><br><span class="line">            cur-&gt;elements = <span class="number">-1</span>;</span><br><span class="line">            cur-&gt;idx++;         <span class="comment">// 移动到下一个坑位</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="processAggregateItem"><a href="#processAggregateItem" class="headerlink" title="processAggregateItem"></a>processAggregateItem</h4><p><code>processAggregateItem</code>函数，解析复合类型 <code>array/map/set</code>。当解析到此时，剩下的数据格式是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n\r\n</span><br><span class="line">len_1\r\narg_1\r\n</span><br><span class="line">...</span><br><span class="line">len_n\r\narg_n\r\n</span><br></pre></td></tr></table></figure>

<p>因为 <code>processItem</code> 函数已经将前缀 <code>*</code> 读取了，那么此时剩下的就是上面的数据。第一行<code>n</code>即这个复合类型的元素个数，下面的n行是具体参数。这也解释了上面每次调用<code>processLineItem</code>函数后都需要调用<code>moveToNextTask</code>函数，因为下一行的解析的参数<code>arg_idx</code>的位置需要由<code>moveToNextTask</code>来确定。</p>
<p><code>processAggregateItem</code>函数的执行流程如下：</p>
<ul>
<li>在读取数据之前，先判断当前递归层数<code>r-&gt;ridx</code>，<code>r-&gt;ridx</code>不能大于8</li>
<li>解析元素个数<code>elements</code>，判断<code>elemengts</code>是否合理</li>
<li><code>elements &gt;0</code>则需要创建容器。并且由于是复合类型，需要为递归进行准备</li>
</ul>
<p>整个流程如只有在这个复合数据类型解析完毕后，才会返回<code>REDSI_OK</code>，否则返回的是<code>REDIS_ERR</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">processAggregateItem</span><span class="params">(redisReader *r)</span> &#123;</span><br><span class="line">    redisReadTask *cur = &amp;(r-&gt;rstack[r-&gt;ridx]);</span><br><span class="line">    <span class="type">void</span> *obj;</span><br><span class="line">    <span class="type">char</span> *p;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> elements;</span><br><span class="line">    <span class="type">int</span> root = <span class="number">0</span>, len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归到第9层，报错</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;ridx == <span class="number">8</span>) &#123;</span><br><span class="line">        __redisReaderSetError(r,</span><br><span class="line">                              REDIS_ERR_PROTOCOL,</span><br><span class="line">                              <span class="string">&quot;No support for nested multi bulk replies with depth &gt; 7&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 下面要调用 createArrayObject 函数来创建容器 ****/</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((p = readLine(r,&amp;len)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 1) 先读取array/map/set中的元素个数 elements</span></span><br><span class="line">        <span class="keyword">if</span> (string2ll(p, len, &amp;elements) == REDIS_ERR) &#123;</span><br><span class="line">            __redisReaderSetError(r, REDIS_ERR_PROTOCOL, <span class="string">&quot;Bad multi-bulk length&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用于递归解析：当前是不是最顶层</span></span><br><span class="line">        root = (r-&gt;ridx == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 元素个数越界</span></span><br><span class="line">        <span class="keyword">if</span> (elements &lt; <span class="number">-1</span> || (LLONG_MAX &gt; SIZE_MAX &amp;&amp; elements &gt; SIZE_MAX)) &#123;</span><br><span class="line">            __redisReaderSetError(r,REDIS_ERR_PROTOCOL,<span class="string">&quot;Multi-bulk length out of range&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果元素，则设置 NULL</span></span><br><span class="line">        <span class="keyword">if</span> (elements == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r-&gt;fn &amp;&amp; r-&gt;fn-&gt;createNil)</span><br><span class="line">                obj = r-&gt;fn-&gt;createNil(cur);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                obj = (<span class="type">void</span>*)REDIS_REPLY_NIL;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内存不足</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                __redisReaderSetErrorOOM(r);</span><br><span class="line">                <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动到下一个任务</span></span><br><span class="line">            moveToNextTask(r);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 多个元素</span></span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;type == REDIS_REPLY_MAP) elements *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2) 创建容器</span></span><br><span class="line">            <span class="keyword">if</span> (r-&gt;fn &amp;&amp; r-&gt;fn-&gt;createArray)</span><br><span class="line">                obj = r-&gt;fn-&gt;createArray(cur,elements);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                obj = (<span class="type">void</span>*)(<span class="type">long</span>)cur-&gt;type;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 内存不足</span></span><br><span class="line">            <span class="keyword">if</span> (obj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                __redisReaderSetErrorOOM(r);</span><br><span class="line">                <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3) 为递归准备</span></span><br><span class="line">            <span class="comment">/* Modify task stack when there are more than 0 elements. */</span></span><br><span class="line">            <span class="keyword">if</span> (elements &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                cur-&gt;elements = elements;       <span class="comment">// 当前层的元素个数</span></span><br><span class="line">                cur-&gt;obj = obj;                 <span class="comment">// 当前层的值：此时仅是个容器，里面还没有值</span></span><br><span class="line">                r-&gt;ridx++;                      <span class="comment">// 递归，进入下一层：来填充容器obj</span></span><br><span class="line">            </span><br><span class="line">                <span class="comment">// 初始化下一层</span></span><br><span class="line">                r-&gt;rstack[r-&gt;ridx].type = <span class="number">-1</span>;   <span class="comment">// 强迫：每次调用 processItem 前都先读取reply类型</span></span><br><span class="line">                r-&gt;rstack[r-&gt;ridx].elements = <span class="number">-1</span>;</span><br><span class="line">                r-&gt;rstack[r-&gt;ridx].idx = <span class="number">0</span>;</span><br><span class="line">                r-&gt;rstack[r-&gt;ridx].obj = <span class="literal">NULL</span>;</span><br><span class="line">                r-&gt;rstack[r-&gt;ridx].parent = cur;    <span class="comment">// parent 指针指向上一层</span></span><br><span class="line">                r-&gt;rstack[r-&gt;ridx].privdata = r-&gt;privdata;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                moveToNextTask(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set reply if this is the root object. */</span></span><br><span class="line">        <span class="comment">// 如果 root ==1，则说明 r 已全部解析完毕</span></span><br><span class="line">        <span class="comment">// 将结构存储在 r-&gt;reply</span></span><br><span class="line">        <span class="keyword">if</span> (root) r-&gt;reply = obj; </span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="redisReaderGetReply"><a href="#redisReaderGetReply" class="headerlink" title="redisReaderGetReply"></a>redisReaderGetReply</h4><p>上面讲解了解析<code>r-&gt;buf</code>并将结果存储至<code>r-&gt;reply</code>的过程：</p>
<ol>
<li>如果 <code>redisBufferRead</code> 函数将对端数据存储至<code>r-&gt;buf</code>发生错误，无法继续执行</li>
<li>如果<code>r-&gt;len==0</code>，说明没有接收到数据、无法解析，则直接返回。</li>
<li>对<code>r-&gt;rstack[0]</code>进行初始化</li>
<li>调用<code>processItem</code>函数，对<code>r-&gt;buf</code>进行解析</li>
<li>对解析结果进行判断及处理，如果解析正确，则将解析结果设置到传入的参数 <code>reply</code> 中</li>
</ol>
<p>整个流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">redisReaderGetReply</span><span class="params">(redisReader *r, <span class="type">void</span> **reply)</span> &#123;</span><br><span class="line">    <span class="comment">/* Default target pointer to NULL. */</span></span><br><span class="line">    <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) *reply = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;err) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the buffer is empty, there will never be a reply. */</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> REDIS_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set first item to process when the stack is empty. */</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;ridx == <span class="number">-1</span>) &#123;</span><br><span class="line">        r-&gt;rstack[<span class="number">0</span>].type       = <span class="number">-1</span>;	<span class="comment">// 强迫 processItem() 函数中先读取类型数据</span></span><br><span class="line">        r-&gt;rstack[<span class="number">0</span>].elements   = <span class="number">-1</span>;</span><br><span class="line">        r-&gt;rstack[<span class="number">0</span>].idx        = <span class="number">-1</span>;</span><br><span class="line">        r-&gt;rstack[<span class="number">0</span>].obj        = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;rstack[<span class="number">0</span>].parent     = <span class="literal">NULL</span>;</span><br><span class="line">        r-&gt;rstack[<span class="number">0</span>].privdata   = r-&gt;privdata;</span><br><span class="line">        r-&gt;ridx                 = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 此次reply读取成功时， processItem 返回 REDIS_OK</span></span><br><span class="line">    <span class="comment">// processItem(r) 成功解析，返回 REDIS_OK，</span></span><br><span class="line">    <span class="comment">// 并且 r-&gt;ridx==-1</span></span><br><span class="line">    <span class="keyword">while</span> (r-&gt;ridx &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span> (processItem(r) != REDIS_OK)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">	<span class="comment">// 发生错误</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;err) <span class="keyword">return</span> REDIS_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果 processItem() 函数中对 r-&gt;buf 解析的字节数超过 1K,</span></span><br><span class="line"><span class="comment">     * 则丢弃已解析数据，将 r-&gt;pos 设置到未解析的起始数据位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;pos &gt;= <span class="number">1024</span>) &#123;</span><br><span class="line">        sdsrange(r-&gt;buf,r-&gt;pos,<span class="number">-1</span>);</span><br><span class="line">        r-&gt;pos = <span class="number">0</span>;</span><br><span class="line">        r-&gt;len = sdslen(r-&gt;buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成功解析完毕，assert(r-&gt;ridx == -1);</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;ridx == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 将 reply 传递给输入参数</span></span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            *reply = r-&gt;reply;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r-&gt;reply != <span class="literal">NULL</span> &amp;&amp; r-&gt;fn &amp;&amp; r-&gt;fn-&gt;freeObject) &#123;</span><br><span class="line">            <span class="comment">// 如果 reply ==NULL，即不需要解析结果 r-&gt;reply</span></span><br><span class="line">            <span class="comment">// 则释放 r-reply </span></span><br><span class="line">            r-&gt;fn-&gt;freeObject(r-&gt;reply);</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;reply = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> REDIS_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redisProcessCallbacks"><a href="#redisProcessCallbacks" class="headerlink" title="redisProcessCallbacks"></a>redisProcessCallbacks</h3><p>再将视线拉回到<code>redisAsyncRead</code>函数，下面可以调用<code>redisProcessCallbacks</code>函数处理对端请求了。</p>
<ol>
<li>调用<code>redisGetReply</code>函数，对<code>ac-&gt;c-&gt;reader-&gt;buf</code>进行解析获得<code>reply</code></li>
<li>如果<code>reply ==NULL</code>，有几种可能<ul>
<li><code>ac</code>即将要关闭，则关闭连接再return</li>
<li>处于监视模式</li>
<li>确实没有数据，则等待下次调用<code>redisProcessCallbacks</code></li>
</ul>
</li>
<li>从<code>ac-&gt;replies</code>中取出回调函数节点至<code>cb</code>并执行</li>
</ol>
<p>任务队列<code>ac-&gt;replies</code>和<code>ac-&gt;pubsubs/channels</code>都是先来先服务，<code>eventloop</code>线程又是个单线程，因此不会发生错乱。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">redisProcessCallbacks</span><span class="params">(redisAsyncContext *ac)</span> &#123;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line">    redisCallback cb = &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="type">void</span> *reply = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐次从输入缓冲区中读取reply</span></span><br><span class="line">    <span class="keyword">while</span>((status = redisGetReply(c,&amp;reply)) == REDIS_OK) &#123;</span><br><span class="line">        <span class="comment">/******* 1 没有回复 ************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可能是reply读取完毕，则直接break</span></span><br><span class="line">        <span class="keyword">if</span> (reply == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果客户端正在与服务器处理断开连接的状态，</span></span><br><span class="line">            <span class="comment">// 那么就直接开始断开 </span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_DISCONNECTING &amp;&amp; </span><br><span class="line">                sdslen(c-&gt;obuf) == <span class="number">0</span> &amp;&amp; </span><br><span class="line">                ac-&gt;replies.head == <span class="literal">NULL</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                __redisAsyncDisconnect(ac);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 监视模式，则将 cb 放入队列</span></span><br><span class="line">            <span class="keyword">if</span>(c-&gt;flags &amp; REDIS_MONITORING) &#123;</span><br><span class="line">                __redisPushCallback(&amp;ac-&gt;replies, &amp;cb);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果没有获取到reply，则等待下一次</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">/******* 2  取出任务节点 ************/</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1) 先尝试从待执行的任务列表ac-replies,取出任务至 cb</span></span><br><span class="line">        <span class="keyword">if</span> (__redisShiftCallback(&amp;ac-&gt;replies, &amp;cb) != REDIS_OK) &#123;</span><br><span class="line">           	<span class="comment">// 解析错误</span></span><br><span class="line">            <span class="keyword">if</span> (((redisReply*)reply)-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">                c-&gt;err = REDIS_ERR_OTHER;</span><br><span class="line">                <span class="built_in">snprintf</span>(c-&gt;errstr, <span class="keyword">sizeof</span>(c-&gt;errstr), <span class="string">&quot;%s&quot;</span>,((redisReply*)reply)-&gt;str);</span><br><span class="line">                c-&gt;reader-&gt;fn-&gt;freeObject(reply); <span class="comment">// 释放此次回应</span></span><br><span class="line">                __redisAsyncDisconnect(ac);       <span class="comment">// 断开连接</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.2) 从 ac-&gt;replies 没有取出任务，可能是在订阅任务队列中</span></span><br><span class="line">            assert((c-&gt;flags &amp; REDIS_SUBSCRIBED || c-&gt;flags &amp; REDIS_MONITORING));</span><br><span class="line">            <span class="comment">// 从 订阅任务列表中取出任务至 cb</span></span><br><span class="line">            <span class="keyword">if</span>(c-&gt;flags &amp; REDIS_SUBSCRIBED)</span><br><span class="line">                __redisGetSubscribeCallback(ac, reply, &amp;cb);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/******* 3 执行回调函数并free(reply) ************/</span></span><br><span class="line">        <span class="keyword">if</span> (cb.fn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            __redisRunCallback(ac,&amp;cb,reply);</span><br><span class="line">            c-&gt;reader-&gt;fn-&gt;freeObject(reply);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 由于回调函数 cb 已经执行，那么之前待释放的ac</span></span><br><span class="line">            <span class="comment">// 此刻可以安全地free&#x27;d</span></span><br><span class="line">            <span class="comment">// 更多信息，可以参考后面的断开连接介绍</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_FREEING) &#123;</span><br><span class="line">                __redisAsyncFree(ac);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有回调函数，则直接忽略此次reply</span></span><br><span class="line">            c-&gt;reader-&gt;fn-&gt;freeObject(reply);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发生读取错误则断开连接</span></span><br><span class="line">    <span class="keyword">if</span> (status != REDIS_OK)</span><br><span class="line">        __redisAsyncDisconnect(ac);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此，整个可读事件的处理过程完结。下面再介绍下上面提到但是没有使用的断开连接操作。</p>
<h2 id="redisAsyncDisconnect"><a href="#redisAsyncDisconnect" class="headerlink" title="__redisAsyncDisconnect"></a>__redisAsyncDisconnect</h2><p>详见代码注释。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __redisAsyncDisconnect(redisAsyncContext *ac) &#123;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line">	<span class="comment">// 将 c-&gt;err 复制到 ac-&gt;err，便于直接使用</span></span><br><span class="line">    __redisAsyncCopyError(ac);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ac-&gt;err == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果这个断开连接操作，不是错误导致，而是主动清除连接</span></span><br><span class="line">        <span class="comment">// 得确保没有回调函数节点了</span></span><br><span class="line">        <span class="type">int</span> ret = __redisShiftCallback(&amp;ac-&gt;replies, <span class="literal">NULL</span>);</span><br><span class="line">        assert(ret == REDIS_ERR);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果调用此函数是由于发生错误导致的，</span></span><br><span class="line">        <span class="comment">// 加上 REDIS_DISCONNECTING 标志</span></span><br><span class="line">        <span class="comment">// 是为了不再接受对端的新指令</span></span><br><span class="line">        c-&gt;flags |= REDIS_DISCONNECTING;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理所有的可读可写事件</span></span><br><span class="line">    _EL_CLEANUP(ac);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 释放</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_NO_AUTO_FREE)) &#123;</span><br><span class="line">      __redisAsyncFree(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redisAsyncFree"><a href="#redisAsyncFree" class="headerlink" title="__redisAsyncFree"></a>__redisAsyncFree</h3><p>在完成<code>redisFree(ac)</code>之前，需要执行完<code>ac</code>的四个任务队列中的回调函数节点。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __redisAsyncFree(redisAsyncContext *ac) &#123;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line">    redisCallback cb;</span><br><span class="line">    dictIterator *it;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将回调函数中的 reply参数传入 NULL</span></span><br><span class="line">    <span class="comment">// 再执行 ac-&gt;replies 中所有的回调函数</span></span><br><span class="line">    <span class="keyword">while</span> (__redisShiftCallback(&amp;ac-&gt;replies,&amp;cb) == REDIS_OK)</span><br><span class="line">        __redisRunCallback(ac,&amp;cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再执行所有无效指令 &amp;ac-&gt;sub.invalid 中所有的回调函数</span></span><br><span class="line">    <span class="keyword">while</span> (__redisShiftCallback(&amp;ac-&gt;sub.invalid,&amp;cb) == REDIS_OK)</span><br><span class="line">        __redisRunCallback(ac,&amp;cb,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以 reply=NULL 的方式</span></span><br><span class="line">    <span class="comment">// 执行订阅的所有回调函数 ac-&gt;sub.channels</span></span><br><span class="line">    it = dictGetIterator(ac-&gt;sub.channels);</span><br><span class="line">    <span class="keyword">while</span> ((de = dictNext(it)) != <span class="literal">NULL</span>)</span><br><span class="line">        __redisRunCallback(ac, dictGetEntryVal(de), <span class="literal">NULL</span>);</span><br><span class="line">    dictReleaseIterator(it);</span><br><span class="line">    dictRelease(ac-&gt;sub.channels);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 以 reply=NULL 的方式</span></span><br><span class="line">    <span class="comment">// 执行订阅模式的所有回调函数 ac-&gt;sub.pattern</span></span><br><span class="line">    it = dictGetIterator(ac-&gt;sub.patterns);</span><br><span class="line">    <span class="keyword">while</span> ((de = dictNext(it)) != <span class="literal">NULL</span>)</span><br><span class="line">        __redisRunCallback(ac,dictGetEntryVal(de),<span class="literal">NULL</span>);</span><br><span class="line">    dictReleaseIterator(it);</span><br><span class="line">    dictRelease(ac-&gt;sub.patterns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清理所有的可读可写事件</span></span><br><span class="line">    _EL_CLEANUP(ac);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行断开连接回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (ac-&gt;onDisconnect &amp;&amp; (c-&gt;flags &amp; REDIS_CONNECTED)) &#123;</span><br><span class="line">        <span class="comment">// 如果 redisAsyncFree() 中设置了 REDIS_FREEING 标志位</span></span><br><span class="line">        <span class="comment">// 则 ac-&gt;onDisconnect 第二个参数传入 REDIS_OK</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_FREEING) &#123;</span><br><span class="line">            ac-&gt;onDisconnect(ac,REDIS_OK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ac-&gt;onDisconnect(ac,(ac-&gt;err == <span class="number">0</span>) ? REDIS_OK : REDIS_ERR);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleanup self */</span></span><br><span class="line">    redisFree(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sentinelDisconnectCallback"><a href="#sentinelDisconnectCallback" class="headerlink" title="sentinelDisconnectCallback"></a>sentinelDisconnectCallback</h3><p>在 <code>__redisAsyncFree</code> 函数的最后几步，对断开连接回调函数的第二个参数有判断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (ac-&gt;onDisconnect &amp;&amp; (c-&gt;flags &amp; REDIS_CONNECTED)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; REDIS_FREEING) &#123;</span><br><span class="line">        ac-&gt;onDisconnect(ac,REDIS_OK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ac-&gt;onDisconnect(ac,(ac-&gt;err == <span class="number">0</span>) ? REDIS_OK : REDIS_ERR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在<code>sentinel.c</code>中设置的断开连接回调<code>sentinelDisconnectCallback</code>，并没有使用<code>status</code>，最终都是直接调用<code>instanceLinkConnectionError</code>函数，这和建立连接失败时的行为一致。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelDisconnectCallback</span><span class="params">(<span class="type">const</span> redisAsyncContext *c, <span class="type">int</span> status)</span> &#123;</span><br><span class="line">    UNUSED(status);</span><br><span class="line">    instanceLinkConnectionError(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="redisAsyncFree-1"><a href="#redisAsyncFree-1" class="headerlink" title="redisAsyncFree"></a>redisAsyncFree</h3><p>在<code>sentinel.c/instanceLinkCloseConnection</code>函数中调用，用于异步关闭连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">redisAsyncFree</span><span class="params">(redisAsyncContext *ac)</span> &#123;</span><br><span class="line">    redisContext *c = &amp;(ac-&gt;c);</span><br><span class="line">    c-&gt;flags |= REDIS_FREEING;				<span class="comment">// 表示正在freeing</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; REDIS_IN_CALLBACK))		<span class="comment">// 目前正在执行某个回调函数，那么不能此刻free</span></span><br><span class="line">        __redisAsyncFree(ac);				<span class="comment">// 不然怎么通信，只能等此次通信结束再free&#x27;d</span></span><br><span class="line">    							<span class="comment">// 可以看看 redisProcessCallbacks 函数</span></span><br><span class="line">    							<span class="comment">// 在执行完callback之后，发现如果有 REDIS_FREEING</span></span><br><span class="line">    							<span class="comment">// 则立马调用 __redisAsyncFree 函数释放 ac</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#redisAsyncContext"><span class="toc-number">1.</span> <span class="toc-text">redisAsyncContext</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAsyncConnectBind"><span class="toc-number">1.1.</span> <span class="toc-text">redisAsyncConnectBind</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncConnectWithOptions"><span class="toc-number">1.1.1.</span> <span class="toc-text">redisAsyncConnectWithOptions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisConnectWithOptions"><span class="toc-number">1.1.2.</span> <span class="toc-text">redisConnectWithOptions</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncInitialize"><span class="toc-number">1.1.3.</span> <span class="toc-text">redisAsyncInitialize</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncSetConnectCallback"><span class="toc-number">1.1.4.</span> <span class="toc-text">redisAsyncSetConnectCallback</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAeAttach"><span class="toc-number">1.2.</span> <span class="toc-text">redisAeAttach</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EL-ADD-WRITE-ac"><span class="toc-number">2.</span> <span class="toc-text">_EL_ADD_WRITE(ac)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAsyncHandleWrite"><span class="toc-number">2.1.</span> <span class="toc-text">redisAsyncHandleWrite</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncHandleConnect"><span class="toc-number">2.1.1.</span> <span class="toc-text">__redisAsyncHandleConnect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncWrite"><span class="toc-number">2.1.2.</span> <span class="toc-text">redisAsyncWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisBufferWrite"><span class="toc-number">2.1.3.</span> <span class="toc-text">redisBufferWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisNetWrite"><span class="toc-number">2.1.4.</span> <span class="toc-text">redisNetWrite</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisvAsyncCommand"><span class="toc-number">2.2.</span> <span class="toc-text">redisvAsyncCommand</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisPushCallback"><span class="toc-number">2.2.1.</span> <span class="toc-text">__redisPushCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisShiftCallback"><span class="toc-number">2.2.2.</span> <span class="toc-text">__redisShiftCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisRunCallback"><span class="toc-number">2.2.3.</span> <span class="toc-text">__redisRunCallback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisAsyncCommand"><span class="toc-number">2.2.4.</span> <span class="toc-text">__redisAsyncCommand</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EL-ADD-READ-ac"><span class="toc-number">3.</span> <span class="toc-text">_EL_ADD_READ(ac)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAsyncRead"><span class="toc-number">3.1.</span> <span class="toc-text">redisAsyncRead</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisBufferRead"><span class="toc-number">3.1.1.</span> <span class="toc-text">redisBufferRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisNetRead"><span class="toc-number">3.1.2.</span> <span class="toc-text">redisNetRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisReaderFeed"><span class="toc-number">3.1.3.</span> <span class="toc-text">redisReaderFeed</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisGetReply"><span class="toc-number">3.2.</span> <span class="toc-text">redisGetReply</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#redisGetReplyFromReader"><span class="toc-number">3.2.1.</span> <span class="toc-text">redisGetReplyFromReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createArrayObject"><span class="toc-number">3.2.2.</span> <span class="toc-text">createArrayObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createIntegerObject"><span class="toc-number">3.2.3.</span> <span class="toc-text">createIntegerObject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#processItem"><span class="toc-number">3.2.4.</span> <span class="toc-text">processItem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#processLineItem"><span class="toc-number">3.2.5.</span> <span class="toc-text">processLineItem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#moveToNextTask"><span class="toc-number">3.2.6.</span> <span class="toc-text">moveToNextTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#processAggregateItem"><span class="toc-number">3.2.7.</span> <span class="toc-text">processAggregateItem</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redisReaderGetReply"><span class="toc-number">3.2.8.</span> <span class="toc-text">redisReaderGetReply</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisProcessCallbacks"><span class="toc-number">3.3.</span> <span class="toc-text">redisProcessCallbacks</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redisAsyncDisconnect"><span class="toc-number">4.</span> <span class="toc-text">__redisAsyncDisconnect</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAsyncFree"><span class="toc-number">4.1.</span> <span class="toc-text">__redisAsyncFree</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelDisconnectCallback"><span class="toc-number">4.2.</span> <span class="toc-text">sentinelDisconnectCallback</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redisAsyncFree-1"><span class="toc-number">4.3.</span> <span class="toc-text">redisAsyncFree</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&text=剖析REDIS的 hiredis"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&title=剖析REDIS的 hiredis"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&is_video=false&description=剖析REDIS的 hiredis"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS的 hiredis&body=Check out this article: https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&title=剖析REDIS的 hiredis"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&title=剖析REDIS的 hiredis"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&title=剖析REDIS的 hiredis"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&title=剖析REDIS的 hiredis"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&name=剖析REDIS的 hiredis&description=&lt;p&gt;hiredis是为客户端&lt;code&gt;redis-cli&lt;/code&gt;设计的。在sentinel中，也是使用的是hiredis中的 &lt;code&gt;redisAsyncContext&lt;/code&gt; 来创建连接、建立通信，而不是普通的&lt;code&gt;client&lt;/code&gt;对象。因此在介绍&lt;code&gt;sentinel&lt;/code&gt;的工作原理之前，先介绍hiredis设计。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/&t=剖析REDIS的 hiredis"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
