<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="replication中解决了主从同步的问题，sentinel解决两个问题  当前各个主从服务器运行状态 如果主服务器出现故障，怎么转移故障">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析REDIS的sentinel">
<meta property="og:url" content="https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="replication中解决了主从同步的问题，sentinel解决两个问题  当前各个主从服务器运行状态 如果主服务器出现故障，怎么转移故障">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-02-05T15:20:18.000Z">
<meta property="article:modified_time" content="2021-03-01T07:26:14.000Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Redis6.0">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>剖析REDIS的sentinel</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/03/01/C++/1_/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&text=剖析REDIS的sentinel"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&title=剖析REDIS的sentinel"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&is_video=false&description=剖析REDIS的sentinel"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS的sentinel&body=Check out this article: https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&title=剖析REDIS的sentinel"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&title=剖析REDIS的sentinel"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&title=剖析REDIS的sentinel"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&title=剖析REDIS的sentinel"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&name=剖析REDIS的sentinel&description=&lt;p&gt;replication中解决了主从同步的问题，sentinel解决两个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前各个主从服务器运行状态&lt;/li&gt;
&lt;li&gt;如果主服务器出现故障，怎么转移故障&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&t=剖析REDIS的sentinel"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E7%8A%B6%E6%80%81"><span class="toc-number">1.</span> <span class="toc-text">监视状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelRedisInstance"><span class="toc-number">1.1.</span> <span class="toc-text">sentinelRedisInstance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelReconnectInstance"><span class="toc-number">1.2.</span> <span class="toc-text">sentinelReconnectInstance</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelSetClientName"><span class="toc-number">1.2.1.</span> <span class="toc-text">sentinelSetClientName</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelSendPing"><span class="toc-number">1.2.2.</span> <span class="toc-text">sentinelSendPing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelPingReplyCallback"><span class="toc-number">1.2.3.</span> <span class="toc-text">sentinelPingReplyCallback</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelSendPeriodicCommands"><span class="toc-number">1.3.</span> <span class="toc-text">sentinelSendPeriodicCommands</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PING"><span class="toc-number">1.3.1.</span> <span class="toc-text">PING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#INFO"><span class="toc-number">1.3.2.</span> <span class="toc-text">INFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUB-SUB"><span class="toc-number">1.3.3.</span> <span class="toc-text">PUB&#x2F;SUB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">2.</span> <span class="toc-text">故障转移</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelCheckSubjectivelyDown"><span class="toc-number">2.1.</span> <span class="toc-text">sentinelCheckSubjectivelyDown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelCheckObjectivelyDown"><span class="toc-number">2.2.</span> <span class="toc-text">sentinelCheckObjectivelyDown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelStartFailoverIfNeeded"><span class="toc-number">2.3.</span> <span class="toc-text">sentinelStartFailoverIfNeeded</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelAskMasterStateToOtherSentinels"><span class="toc-number">2.3.1.</span> <span class="toc-text">sentinelAskMasterStateToOtherSentinels</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelReceiveIsMasterDownReply"><span class="toc-number">2.3.2.</span> <span class="toc-text">sentinelReceiveIsMasterDownReply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelVoteLeader"><span class="toc-number">2.3.3.</span> <span class="toc-text">sentinelVoteLeader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelFailoverStateMachine"><span class="toc-number">2.4.</span> <span class="toc-text">sentinelFailoverStateMachine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SENTINEL-FAILOVER-STATE-WAIT-START"><span class="toc-number">2.4.1.</span> <span class="toc-text">SENTINEL_FAILOVER_STATE_WAIT_START</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SENTINEL-FAILOVER-STATE-SELECT-SLAVE"><span class="toc-number">2.4.2.</span> <span class="toc-text">SENTINEL_FAILOVER_STATE_SELECT_SLAVE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SENTINEL-FAILOVER-STATE-SEND-SLAVEOF-NOONE"><span class="toc-number">2.4.3.</span> <span class="toc-text">SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SENTINEL-FAILOVER-STATE-WAIT-PROMOTION"><span class="toc-number">2.4.4.</span> <span class="toc-text">SENTINEL_FAILOVER_STATE_WAIT_PROMOTION</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SENTINEL-FAILOVER-STATE-RECONF-SLAVES"><span class="toc-number">2.4.5.</span> <span class="toc-text">SENTINEL_FAILOVER_STATE_RECONF_SLAVES</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sentinelHandleRedisInstance"><span class="toc-number">3.</span> <span class="toc-text">sentinelHandleRedisInstance</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        剖析REDIS的sentinel
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-02-05T15:20:18.000Z" itemprop="datePublished">2021-02-05</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Redis6-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Redis6.0 源码解析</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Redis6-0/" rel="tag">Redis6.0</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>replication中解决了主从同步的问题，sentinel解决两个问题</p>
<ul>
<li>当前各个主从服务器运行状态</li>
<li>如果主服务器出现故障，怎么转移故障</li>
</ul>
<span id="more"></span>

<h2 id="监视状态"><a href="#监视状态" class="headerlink" title="监视状态"></a>监视状态</h2><h3 id="sentinelRedisInstance"><a href="#sentinelRedisInstance" class="headerlink" title="sentinelRedisInstance"></a>sentinelRedisInstance</h3><p>每个sentinel实例都被封装成 <em>sentinelRedisInstance</em> d对象，每个<em>sentinelRedisInstance</em>创建后，<em>sentinelRedisInstance</em>要向监视的主服务器master发起连接请求，成为master的客户端。这里使用前面所述的 <code>hiredis.c/redisAsyncContext</code> 结构体来创建客户端。</p>
<p>每个sentinel都会向监视的主服务器master发起两个异步连接，即创建两个<code>redisAsyncContext</code>对象来和master进行通信：</p>
<ul>
<li>命令连接：即专门用于sentinel向master发送普通命令，并接受master对这些命令的reply</li>
<li>订阅连接：即专门用于订阅主服务的 <strong><code>__sentinel__:hello</code></strong> 通道</li>
</ul>
<p><em>sentinelRedisInstance</em>内部结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> flags;                  <span class="comment">/* 标志着 sentinelRedisInstance 的类型*/</span></span><br><span class="line">    <span class="type">char</span> *name;                 <span class="comment">/* 监视的master名字，格式是 IP:PORT */</span></span><br><span class="line">    <span class="type">char</span> *runid;                <span class="comment">/* 这个sentinel的runid */</span></span><br><span class="line">    <span class="type">uint64_t</span> config_epoch;      </span><br><span class="line">    sentinelAddr *addr;         <span class="comment">/* master的ip地址 */</span></span><br><span class="line">    instanceLink *link;         <span class="comment">/* 与主服务的通信接口 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下面是一些时间，用于判断所监视的master状态</span></span><br><span class="line">    <span class="type">mstime_t</span> last_pub_time;     		 <span class="comment">/* 上一次向 __sentinel__:hello 发送数据的时间*/</span></span><br><span class="line">    <span class="type">mstime_t</span> last_hello_time;   		 <span class="comment">/* flags==SRI_SENTINEL, 上次收到 hello 数据的时间*/</span></span><br><span class="line">    <span class="type">mstime_t</span> last_master_down_reply_time; <span class="comment">/* 上次回应 SENTINEL is-master-down 指令的时间 */</span></span><br><span class="line">    <span class="type">mstime_t</span> s_down_since_time; 		 <span class="comment">/* master 的主观下线时间 */</span></span><br><span class="line">    <span class="type">mstime_t</span> o_down_since_time; 		 <span class="comment">/* master 的客观下线时间 */</span></span><br><span class="line">    <span class="type">mstime_t</span> down_after_period; 		 <span class="comment">/* 下线时间阈值：超过这个时间就认为master下线 */</span></span><br><span class="line">    <span class="type">mstime_t</span> info_refresh;      		 <span class="comment">/* 接收到INFO指令的时间 */</span></span><br><span class="line">    dict *renamed_commands;     		 <span class="comment">/* sentinel 支持的指令 */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> role_reported;</span><br><span class="line">    <span class="type">mstime_t</span> role_reported_time;</span><br><span class="line">    <span class="type">mstime_t</span> slave_conf_change_time; </span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Master specific. */</span></span><br><span class="line">    dict *sentinels;    <span class="comment">/* 监视同一个master的所有sentinels */</span></span><br><span class="line">    dict *slaves;       <span class="comment">/* 所监视的master所属的slaves */</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> quorum;<span class="comment">/* Number of sentinels that need to agree on failure. */</span></span><br><span class="line">    <span class="type">int</span> parallel_syncs; <span class="comment">/* How many slaves to reconfigure at same time. */</span></span><br><span class="line">    <span class="type">char</span> *auth_pass;    <span class="comment">/* Password to use for AUTH against master &amp; replica. */</span></span><br><span class="line">    <span class="type">char</span> *auth_user;    <span class="comment">/* Username for ACLs AUTH against master &amp; replica. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Slave specific. */</span></span><br><span class="line">    <span class="type">mstime_t</span> master_link_down_time;  <span class="comment">/* Slave replication link down time. */</span></span><br><span class="line">    <span class="type">int</span> slave_priority; 			<span class="comment">/* Slave priority according to its INFO output. */</span></span><br><span class="line">    <span class="type">mstime_t</span> slave_reconf_sent_time; <span class="comment">/* Time at which we sent SLAVE OF &lt;new&gt; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> *<span class="title">master</span>;</span> <span class="comment">// slave对应的master</span></span><br><span class="line">    <span class="type">char</span> *slave_master_host;    		   </span><br><span class="line">    <span class="type">int</span> slave_master_port;      		   </span><br><span class="line">    <span class="type">int</span> slave_master_link_status; 		 </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> slave_repl_offset; 	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Failover */</span></span><br><span class="line">    <span class="type">char</span> *leader;       	<span class="comment">// 执行故障转移的 sentinel 的 runid</span></span><br><span class="line">    <span class="type">uint64_t</span> leader_epoch;   <span class="comment">/* Epoch of the &#x27;leader&#x27; field. */</span></span><br><span class="line">    <span class="type">uint64_t</span> failover_epoch; <span class="comment">/* Epoch of the currently started failover. */</span></span><br><span class="line">    <span class="type">int</span> failover_state;  	<span class="comment">/* See SENTINEL_FAILOVER_STATE_* defines. */</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_state_change_time;</span><br><span class="line">    <span class="type">mstime_t</span> failover_start_time;   <span class="comment">/* Last failover attempt start time. */</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_timeout;      <span class="comment">/* Max time to refresh failover state. */</span></span><br><span class="line">    <span class="type">mstime_t</span> failover_delay_logged; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> *<span class="title">promoted_slave</span>;</span> <span class="comment">/* Promoted slave instance. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Scripts executed to notify admin or reconfigure clients: when they</span></span><br><span class="line"><span class="comment">     * are set to NULL no script is executed. */</span></span><br><span class="line">    <span class="type">char</span> *notification_script;</span><br><span class="line">    <span class="type">char</span> *client_reconfig_script;</span><br><span class="line">    sds info; <span class="comment">/* cached INFO output */</span></span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure>

<p><strong>instanceLink</strong></p>
<p>sentinel要向master发起连接，是通过<code>instanceLink</code>对象来完成。在<em>instanceLink</em>内部，封装了两个连接<code>cc</code>和<code>pc</code>，用于和监视的主服务进行通信，同时设置了一些关于<code>PING</code>和<code>PONG</code>的字段来记录连接状态。而<code>sentinelRedisInstance</code>中时间字段监视的是主服务的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">instanceLink</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> refcount;          </span><br><span class="line">    <span class="type">int</span> disconnected;      		<span class="comment">/* 0表示没有断开，1表示断开 */</span></span><br><span class="line">    <span class="type">int</span> pending_commands;  		<span class="comment">/* 已发送且正等待答复的命令数。 */</span></span><br><span class="line">    <span class="comment">// 两个连接</span></span><br><span class="line">    redisAsyncContext *cc; 		<span class="comment">/* Hiredis context for commands. */</span></span><br><span class="line">    redisAsyncContext *pc; 		<span class="comment">/* Hiredis context for Pub / Sub. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 以下都是时间</span></span><br><span class="line">    <span class="type">mstime_t</span> cc_conn_time; 		<span class="comment">/* 普通指令建立连接时间. */</span></span><br><span class="line">    <span class="type">mstime_t</span> pc_conn_time; 		<span class="comment">/* 订阅指令建立连接的时间. */</span></span><br><span class="line">    <span class="type">mstime_t</span> pc_last_activity; 	<span class="comment">/* 最近一次接收到__sentinel__:hello通道数据的时间 */</span></span><br><span class="line">    <span class="type">mstime_t</span> last_avail_time; 	<span class="comment">/* 最近一次有效回应 PING 的时间 */</span></span><br><span class="line">    <span class="type">mstime_t</span> act_ping_time;   	<span class="comment">/* 上次发送PING但是无PONG回应的时间. */</span></span><br><span class="line">    <span class="type">mstime_t</span> last_ping_time;  	<span class="comment">/* 上次发送PING的时间*/</span></span><br><span class="line">    <span class="type">mstime_t</span> last_pong_time;  	<span class="comment">/* 上次回应PING的时间 */</span></span><br><span class="line">    <span class="type">mstime_t</span> last_reconn_time;  <span class="comment">/* 上一次重新连接的时间 */</span></span><br><span class="line">&#125; instanceLink;</span><br></pre></td></tr></table></figure>

<p><strong>createInstanceLink</strong></p>
<p><code>createInstanceLink</code>函数用于创建一个<code>instanceLink</code>对象，其中初始化值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">instanceLink* <span class="title function_">createInstanceLink</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    instanceLink *link = zmalloc(<span class="keyword">sizeof</span>(*link));</span><br><span class="line"></span><br><span class="line">    link-&gt;refcount = <span class="number">1</span>;</span><br><span class="line">    link-&gt;disconnected = <span class="number">1</span>;     <span class="comment">// 默认是断开连接的</span></span><br><span class="line">    link-&gt;pending_commands = <span class="number">0</span>;</span><br><span class="line">    link-&gt;cc = <span class="literal">NULL</span>;            <span class="comment">// 未建立连接</span></span><br><span class="line">    link-&gt;pc = <span class="literal">NULL</span>;</span><br><span class="line">    link-&gt;cc_conn_time = <span class="number">0</span>;</span><br><span class="line">    link-&gt;pc_conn_time = <span class="number">0</span>;</span><br><span class="line">    link-&gt;last_reconn_time = <span class="number">0</span>; <span class="comment">// 初始化为 0</span></span><br><span class="line">    link-&gt;pc_last_activity = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    link-&gt;act_ping_time = mstime();	<span class="comment">// 这对于检测超时非常有用，以防我们根本无法连接到节点</span></span><br><span class="line">    link-&gt;last_ping_time = <span class="number">0</span>;</span><br><span class="line">    link-&gt;last_avail_time = mstime();</span><br><span class="line">    link-&gt;last_pong_time = mstime();</span><br><span class="line">    <span class="keyword">return</span> link;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sentinelReconnectInstance"><a href="#sentinelReconnectInstance" class="headerlink" title="sentinelReconnectInstance"></a>sentinelReconnectInstance</h3><p><code>sentinelReconnectInstance</code>函数，用于建立连接、断开后重新连接。<em>sentinelRedisInstance</em>类似于<code>client</code>，负责和对端通信。此时，乙方是<code>server</code>，对端被封装成<em>sentinelRedisInstance</em>对象<code>ri</code>，对端的类型<code>ri-&gt;flags</code>表征：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SRI_MASTER  (1&lt;&lt;0)		<span class="comment">// 对端是 master</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRI_SLAVE   (1&lt;&lt;1) 		<span class="comment">// 对端是 slave</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRI_SENTINEL (1&lt;&lt;2) 	<span class="comment">// 对端是 sentinel</span></span></span><br></pre></td></tr></table></figure>

<p>sentinel服务器要和 <code>(ri-&gt;adder-&gt;ip, ri-&gt;addr-&gt;port)</code>建立指令连接<code>link-&gt;cc</code>和订阅连接<code>link-&gt;pc</code>。过程如下：</p>
<ol>
<li><p>确认<code>ri-&gt;link-&gt;disconnected ==1</code>。只有<code>link-&gt;cc</code> 和 <code>link-&gt;pc</code>有一个没有连接成功<code>ri-&gt;link-&gt;disconnected ==1</code></p>
</li>
<li><p>调用<code>redisAsyncConnectBind</code>函数和 <code>(ri-&gt;adder-&gt;ip, ri-&gt;addr-&gt;port)</code>建立连接，获得<code>redisAsyncContext</code>对象<br><font color="red"> 注意：</font> sentinel与另一个sentinel之间没有订阅连接<code>link-&gt;pc</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只能与主从服务器之间连接</span></span><br><span class="line"><span class="keyword">if</span> ((ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) &amp;&amp; link-&gt;pc == <span class="literal">NULL</span>) &#123; </span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure></li>
<li><p>成功建立连接后，调用<code>redisAeAttach</code>函数将<code>link-&gt;cc</code>加入到<code>server.el</code>事件循环中，让当<code>server</code>的事件循环也能处理 <code>redisAsyncContext</code>的可读可写事件</p>
</li>
<li><p>设置连接和断开连接的回调函数</p>
</li>
<li><p>对于<code>link-&gt;pc</code>，此次还需要订阅<code>__sentinel__:hello</code>通道</p>
</li>
<li><p><code>link-&gt;cc</code>和<code>link-&gt;pc</code>成功连接后，才将<code>link-&gt;disconnected </code>设置为0。但是如果对端<code>ri</code>也是个sentinel，那么就不需要建立<code>link-&gt;pc</code>，也能<code>link-&gt;disconnected =0</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (link-&gt;cc &amp;&amp; (ri-&gt;flags &amp; SRI_SENTINEL || link-&gt;pc))</span><br><span class="line">    link-&gt;disconnected = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>整个过程详细如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelReconnectInstance</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;addr-&gt;port == <span class="number">0</span>) <span class="keyword">return</span>; 	<span class="comment">/* port == 0 means invalid address. */</span></span><br><span class="line">    instanceLink *link = ri-&gt;link;</span><br><span class="line">    <span class="type">mstime_t</span> now = mstime();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1) 两次重连接时间必须不小于  SENTINEL_PING_PERIOD 毫秒</span></span><br><span class="line">    <span class="keyword">if</span> (now - ri-&gt;link-&gt;last_reconn_time &lt; SENTINEL_PING_PERIOD) <span class="keyword">return</span>;</span><br><span class="line">    ri-&gt;link-&gt;last_reconn_time = now;	<span class="comment">// 更改重新连接字段字段</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 建立普通指令连接</span></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;cc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        link-&gt;cc = redisAsyncConnectBind(ri-&gt;addr-&gt;ip, </span><br><span class="line">                                         ri-&gt;addr-&gt;port, </span><br><span class="line">                                         NET_FIRST_BIND_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (!link-&gt;cc-&gt;err &amp;&amp; </span><br><span class="line">            server.tls_replication &amp;&amp;</span><br><span class="line">            (instanceLinkNegotiateTLS(link-&gt;cc) == C_ERR)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// TLS连接错误</span></span><br><span class="line">            sentinelEvent(LL_DEBUG,</span><br><span class="line">                          <span class="string">&quot;-cmd-link-reconnection&quot;</span>,</span><br><span class="line">                          ri,</span><br><span class="line">                          <span class="string">&quot;%@ #Failed to initialize TLS&quot;</span>);</span><br><span class="line">            instanceLinkCloseConnection(link,link-&gt;cc);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (link-&gt;cc-&gt;err) &#123;</span><br><span class="line">            <span class="comment">// 重连接错误</span></span><br><span class="line">            sentinelEvent(LL_DEBUG,</span><br><span class="line">                          <span class="string">&quot;-cmd-link-reconnection&quot;</span>,</span><br><span class="line">                          ri,</span><br><span class="line">                          <span class="string">&quot;%@ #%s&quot;</span>,</span><br><span class="line">                          link-&gt;cc-&gt;errstr);</span><br><span class="line">            <span class="comment">// 断开连接</span></span><br><span class="line">            instanceLinkCloseConnection(link,link-&gt;cc);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 正常连接</span></span><br><span class="line">            </span><br><span class="line">            link-&gt;pending_commands = <span class="number">0</span>;    </span><br><span class="line">            link-&gt;cc_conn_time = mstime();</span><br><span class="line">            link-&gt;cc-&gt;data = link;			<span class="comment">// privdata</span></span><br><span class="line">            <span class="comment">// 将 link-&gt;cc 加入 server.el 事件循环中</span></span><br><span class="line">            redisAeAttach(server.el,link-&gt;cc);</span><br><span class="line">            <span class="comment">// 设置连接回调函数</span></span><br><span class="line">            redisAsyncSetConnectCallback(link-&gt;cc,sentinelLinkEstablishedCallback);</span><br><span class="line">            <span class="comment">// 设置断开连接的回调函数</span></span><br><span class="line">            redisAsyncSetDisconnectCallback(link-&gt;cc,sentinelDisconnectCallback);</span><br><span class="line">            <span class="comment">// 看是否有必要设置AUTH</span></span><br><span class="line">            sentinelSendAuthIfNeeded(ri,link-&gt;cc);</span><br><span class="line">            <span class="comment">// 设置客户端名</span></span><br><span class="line">            sentinelSetClientName(ri,link-&gt;cc,<span class="string">&quot;cmd&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 连接上时，立即发送 PING</span></span><br><span class="line">            sentinelSendPing(ri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3) 建立订阅连接 （sentinel和sentinel之间没有订阅）</span></span><br><span class="line">    <span class="keyword">if</span> ((ri-&gt;flags &amp; (SRI_MASTER|SRI_SLAVE)) &amp;&amp; link-&gt;pc == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果这个实例 主、从服务器</span></span><br><span class="line">        link-&gt;pc = redisAsyncConnectBind(ri-&gt;addr-&gt;ip, </span><br><span class="line">                                         ri-&gt;addr-&gt;port, </span><br><span class="line">                                         NET_FIRST_BIND_ADDR);</span><br><span class="line">        <span class="keyword">if</span> (!link-&gt;pc-&gt;err &amp;&amp; </span><br><span class="line">            server.tls_replication &amp;&amp;</span><br><span class="line">            (instanceLinkNegotiateTLS(link-&gt;pc) == C_ERR)) </span><br><span class="line">        &#123;</span><br><span class="line">            sentinelEvent(LL_DEBUG,</span><br><span class="line">                          <span class="string">&quot;-pubsub-link-reconnection&quot;</span>,</span><br><span class="line">                          ri,</span><br><span class="line">                          <span class="string">&quot;%@ #Failed to initialize TLS&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (link-&gt;pc-&gt;err) &#123;</span><br><span class="line">            sentinelEvent(LL_DEBUG,</span><br><span class="line">                          <span class="string">&quot;-pubsub-link-reconnection&quot;</span>,</span><br><span class="line">                          ri,</span><br><span class="line">                          <span class="string">&quot;%@ #%s&quot;</span>, </span><br><span class="line">                          link-&gt;pc-&gt;errstr);</span><br><span class="line">            <span class="comment">// 断开连接</span></span><br><span class="line">            instanceLinkCloseConnection(link,link-&gt;pc);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 成功建立订阅连接</span></span><br><span class="line">            <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">            link-&gt;pc_conn_time = mstime();</span><br><span class="line">            link-&gt;pc-&gt;data = link;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将 link-&gt;pc 也加入 server.el 事件循环中</span></span><br><span class="line">            redisAeAttach(server.el, link-&gt;pc);</span><br><span class="line">            <span class="comment">// 设置建立连接回调函数</span></span><br><span class="line">            redisAsyncSetConnectCallback(link-&gt;pc,sentinelLinkEstablishedCallback);</span><br><span class="line">            <span class="comment">// 设置断开连接回调函数</span></span><br><span class="line">            redisAsyncSetDisconnectCallback(link-&gt;pc,sentinelDisconnectCallback);</span><br><span class="line">            <span class="comment">// 是否需要密码认证</span></span><br><span class="line">            sentinelSendAuthIfNeeded(ri,link-&gt;pc);</span><br><span class="line">            <span class="comment">// 设置客户端名字</span></span><br><span class="line">            sentinelSetClientName(ri,link-&gt;pc,<span class="string">&quot;pubsub&quot;</span>);</span><br><span class="line">            <span class="comment">// 订阅 __sentinel__:hello 通道</span></span><br><span class="line">            retval = redisAsyncCommand(link-&gt;pc,</span><br><span class="line">                                       sentinelReceiveHelloMessages, </span><br><span class="line">                                       ri, </span><br><span class="line">                                       <span class="string">&quot;%s %s&quot;</span>,</span><br><span class="line">                                       sentinelInstanceMapCommand(ri,<span class="string">&quot;SUBSCRIBE&quot;</span>),</span><br><span class="line">                                       SENTINEL_HELLO_CHANNEL);</span><br><span class="line">            <span class="keyword">if</span> (retval != C_OK) &#123;</span><br><span class="line">                <span class="comment">// 如果没有订阅成功，那么这个 link-&gt;pc 是没有用的</span></span><br><span class="line">                <span class="comment">// 需要下次定时事件中再重新建立link-&gt;pc</span></span><br><span class="line">                instanceLinkCloseConnection(link,link-&gt;pc);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前 ri 标志的是sentinel，那么就</span></span><br><span class="line">    <span class="comment">// 清除断开连接的状态</span></span><br><span class="line">    <span class="keyword">if</span> (link-&gt;cc &amp;&amp; (ri-&gt;flags &amp; SRI_SENTINEL || link-&gt;pc))</span><br><span class="line">        link-&gt;disconnected = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="sentinelSetClientName"><a href="#sentinelSetClientName" class="headerlink" title="sentinelSetClientName"></a>sentinelSetClientName</h4><p>向对端发送 <code>CLIENT SETNAME name</code>指令，即告诉对端自己的名字：</p>
<ul>
<li>如果建立的连接是<code>link-cc</code>，则名字是<code>sentinel-runid-cmd</code>，其中runid是前8个字符。</li>
<li>如果建立的连接是<code>link-pc</code>，则名字是<code>sentinel-runid-pubsub</code></li>
</ul>
<p>这个可以通过<code>CLIENT LIST</code>指令查看自己的客户端列表：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; CLIENT LIST</span><br><span class="line">id=272 addr=127.0.0.1:11453 name=sentinel-e5d1f1a9-cmd // link-cc 其余参数省略... </span><br><span class="line">id=450 addr=127.0.0.1:11687 name=szz 				 // 这个是自己的客户端 其余参数省略...</span><br></pre></td></tr></table></figure>

<p>对端对<code>CLIENT SETNAME name</code>指令的回复sentinel不在乎，因此设置回调函数是 <code>sentinelDiscardReplyCallback</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelSetClientName</span><span class="params">(sentinelRedisInstance *ri, redisAsyncContext *c, <span class="type">char</span> *type)</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(name,<span class="keyword">sizeof</span>(name),<span class="string">&quot;sentinel-%.8s-%s&quot;</span>, sentinel.myid, type);</span><br><span class="line">    <span class="keyword">if</span> (redisAsyncCommand(c, </span><br><span class="line">                          sentinelDiscardReplyCallback, </span><br><span class="line">                          ri,</span><br><span class="line">                          <span class="string">&quot;%s SETNAME %s&quot;</span>,</span><br><span class="line">                          sentinelInstanceMapCommand(ri,<span class="string">&quot;CLIENT&quot;</span>),</span><br><span class="line">                          name) == C_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sentinelSendPing"><a href="#sentinelSendPing" class="headerlink" title="sentinelSendPing"></a>sentinelSendPing</h4><p>在成功建立<code>link-&gt;cc</code>时，会向对端发送<code>PING</code>指令。<code>redisAsyncCommand</code>函数返回<code>C_OK</code>，则更新相关时间字段:</p>
<ul>
<li><code>ri-&gt;link-&gt;last_ping_time</code>：表示最近一次发送PING时间</li>
<li><code>ri-&gt;link-&gt;act_ping_time</code>：表示当前上次发送PING后是否接受到对端回复PONG。如果回复了则此时<code>ri-&gt;link-&gt;act_ping_time</code>的值是0，并将 <code>ri-&gt;link-&gt;act_ping_time</code>设置为此时发送PING的时间，否则就保持上次发送PING的时间。</li>
</ul>
<p>对于PING回复回调函数是 <code>sentinelPingReplyCallback</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sentinelSendPing</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="comment">// 发送 PING 请求</span></span><br><span class="line">    <span class="type">int</span> retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">                                   sentinelPingReplyCallback, </span><br><span class="line">                                   ri, </span><br><span class="line">                                   <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                                   sentinelInstanceMapCommand(ri,<span class="string">&quot;PING&quot;</span>));</span><br><span class="line">    <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">        ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">        ri-&gt;link-&gt;last_ping_time = mstime();  <span class="comment">// 更新最后一次发送 PING 时间</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* 仅当接受到 PING 的回复(即 PONG)时才再次更新 ri-&gt;link-&gt;act_ping_time，</span></span><br><span class="line"><span class="comment">         * 否则 ri-&gt;link-&gt;act_ping_time 将一直以上次发送PING的时间</span></span><br><span class="line"><span class="comment">         * 来阻塞等待PING的时间值</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;link-&gt;act_ping_time == <span class="number">0</span>)</span><br><span class="line">            ri-&gt;link-&gt;act_ping_time = ri-&gt;link-&gt;last_ping_time; <span class="comment">// 更新发送PING时间</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sentinelPingReplyCallback"><a href="#sentinelPingReplyCallback" class="headerlink" title="sentinelPingReplyCallback"></a>sentinelPingReplyCallback</h4><p>对端对<code>PING</code>指令的有效恢复只有三种：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+PONG 		 // r-&gt;type == REDIS_REPLY_STATUS</span><br><span class="line">-LOADING 	 // r-&gt;type == REDIS_REPLY_ERROR</span><br><span class="line">-MASTERDOWN	 // r-&gt;type == REDIS_REPLY_ERROR</span><br></pre></td></tr></table></figure>

<p>因此在这三种情况下，是可以将<code>link-&gt;act_ping_time</code>设置为0，表示接受到对端的有效回复。如果对端回复的<code>BUSY</code>，表示对端忙于脚本任务，那么sentinel就向对端发送<code>KILL SCRIPT </code>命令，杀死脚本，解析对端忙碌状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelPingReplyCallback</span><span class="params">(redisAsyncContext *c, <span class="type">void</span> *reply, <span class="type">void</span> *privdata)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *ri = privdata;</span><br><span class="line">    instanceLink *link = c-&gt;data;</span><br><span class="line">    redisReply *r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply || !link) <span class="keyword">return</span>;</span><br><span class="line">    link-&gt;pending_commands--;</span><br><span class="line">    r = reply;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;type == REDIS_REPLY_STATUS || r-&gt;type == REDIS_REPLY_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(r-&gt;str,<span class="string">&quot;PONG&quot;</span>,<span class="number">4</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strncmp</span>(r-&gt;str,<span class="string">&quot;LOADING&quot;</span>,<span class="number">7</span>) == <span class="number">0</span> ||</span><br><span class="line">            <span class="built_in">strncmp</span>(r-&gt;str,<span class="string">&quot;MASTERDOWN&quot;</span>,<span class="number">10</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不是错误</span></span><br><span class="line">            link-&gt;last_avail_time = mstime();	<span class="comment">// 有效回复的时间</span></span><br><span class="line">            link-&gt;act_ping_time = <span class="number">0</span>; 			<span class="comment">/* Flag the pong as received. */</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果是因为一个耗时脚步导致实例主观下线，则 KILL SCRIPT</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strncmp</span>(r-&gt;str,<span class="string">&quot;BUSY&quot;</span>,<span class="number">4</span>) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                (ri-&gt;flags &amp; SRI_S_DOWN) &amp;&amp;</span><br><span class="line">                !(ri-&gt;flags &amp; SRI_SCRIPT_KILL_SENT))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">                                     sentinelDiscardReplyCallback, </span><br><span class="line">                                     ri,</span><br><span class="line">                                     <span class="string">&quot;%s KILL&quot;</span>,</span><br><span class="line">                                     sentinelInstanceMapCommand(ri,<span class="string">&quot;SCRIPT&quot;</span>)) == C_OK)</span><br><span class="line">                &#123;</span><br><span class="line">                    ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">                &#125;</span><br><span class="line">                ri-&gt;flags |= SRI_SCRIPT_KILL_SENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    link-&gt;last_pong_time = mstime(); <span class="comment">// 最近一次的PONG时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sentinelSendPeriodicCommands"><a href="#sentinelSendPeriodicCommands" class="headerlink" title="sentinelSendPeriodicCommands"></a>sentinelSendPeriodicCommands</h3><p>既然sentinel要监视master，那是怎么监视的呢? </p>
<ol>
<li>sentinel定时的发送PING</li>
<li>sentinel定时向监视的主服务器master及master的slaves发送INFO指令，查看他们的状态</li>
<li>sentinel定时向<code>__sentinel__:hello</code>通道发送<code>hello</code>信息</li>
</ol>
<p>通过这种方式来监视整个网络。</p>
<h4 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h4><p>在发送PING之前，会先计算下发送PING的频率。<code>ri-&gt;down_after_period</code>的默认值是由<code>sentinel.conf</code>中的<code>down-after-milliseconds</code>参数设置的，但是如果<code>ri-&gt;down_after_period &gt; SENTINEL_PING_PERIOD</code>，则以<code>SENTINEL_PING_PERIOD</code>为频率发送，即每秒发送一次。</p>
<p>因此，PING指针默认是1s一次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_PING_PERIOD 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelSendPeriodicCommands</span><span class="params">(redisAsyncContext* c, <span class="type">void</span>* reply, <span class="type">void</span>* privdata)</span> &#123; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 确定发送PING的频率</span></span><br><span class="line">    ping_period = ri-&gt;down_after_period;</span><br><span class="line">    <span class="keyword">if</span> (ping_period &gt; SENTINEL_PING_PERIOD) </span><br><span class="line">        ping_period = SENTINEL_PING_PERIOD;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送 PING 给监视的master及其slave、所有其他 sentinels </span></span><br><span class="line">    <span class="keyword">if</span> ((now - ri-&gt;link-&gt;last_pong_time) &gt; ping_period &amp;&amp;   <span class="comment">// 距离上次接受到pong的时间 &gt; ping_period</span></span><br><span class="line">        (now - ri-&gt;link-&gt;last_ping_time) &gt; ping_period/<span class="number">2</span>)   <span class="comment">// 距离上次发送ping的时间要 &gt; ping_period/2</span></span><br><span class="line">    &#123;</span><br><span class="line">        sentinelSendPing(ri);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="INFO"><a href="#INFO" class="headerlink" title="INFO"></a>INFO</h4><p>sentinel默认是10s发送一次<code>INFO</code>命令。但<strong>如果<code>ri</code>是从服务器</strong>，那么有两种情况会加快发送<code>INFO</code>命令的频率：</p>
<ul>
<li><code>ri-&gt;master</code> 处于 <code>O_DOWN</code> 状态：即<code>r-&gt;master</code>处于主观下线状态，那么需要加快发送 INFO 的频率，来密切监视<code>ri</code>的状态，因为它有可能被另一个sentinel从slave变成master</li>
<li><code>ri</code>下线了，那么也需要加快INFO的频率，来获得一个更加准确的重新连接时间 </li>
</ul>
<p>INFO指令的回调函数<code>sentinelInfoReplyCallback</code>，在回调函数中对其监视的服务器进行分析。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelSendPeriodicCommands</span><span class="params">(sentinelRedisInstance* ri)</span> &#123; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 发送频率</span></span><br><span class="line">    <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_SLAVE) &amp;&amp;</span><br><span class="line">    ((ri-&gt;master-&gt;flags &amp; (SRI_O_DOWN|SRI_FAILOVER_IN_PROGRESS)) ||</span><br><span class="line">     (ri-&gt;master_link_down_time != <span class="number">0</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        info_period = <span class="number">1000</span>;	<span class="comment">// 1 s</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        info_period = SENTINEL_INFO_PERIOD; <span class="comment">// 10 s</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sentinel 发送 INFO 给 master及master的slave </span></span><br><span class="line">    <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_SENTINEL) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (ri-&gt;info_refresh == <span class="number">0</span> ||</span><br><span class="line">        (now - ri-&gt;info_refresh) &gt; info_period)) <span class="comment">// 两次时间差：默认10s，主服务器故障时为1s</span></span><br><span class="line">    &#123;</span><br><span class="line">        retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">                                   sentinelInfoReplyCallback, </span><br><span class="line">                                   ri, </span><br><span class="line">                                   <span class="string">&quot;%s&quot;</span>,</span><br><span class="line">                                   sentinelInstanceMapCommand(ri,<span class="string">&quot;INFO&quot;</span>));</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) </span><br><span class="line">            ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sentinelInfoReplyCallback</strong></p>
<p>在<em>INFO</em>指令的回复回调函数中，会调用<code>sentinelRefreshInstanceInfo</code>函数，对当前主从服务器的状态进行判断：</p>
<ul>
<li>在INFO指令的回应中，发现了监视的master有新的从服务器后，sentient也会和slaves之间建立命令和订阅两个连接。下次sentinel的INFO命令将发送给master及其slaves</li>
<li>master是否发送故障，那么就需要故障转移</li>
</ul>
<p><code>sentinelRefreshInstanceInfo</code>函数留到后面章节讲述。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelInfoReplyCallback</span><span class="params">(redisAsyncContext* c, <span class="type">void</span>* reply, <span class="type">void</span>* privdata)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *ri = privdata;</span><br><span class="line">    instanceLink *link = c-&gt;data;</span><br><span class="line">    redisReply *r;</span><br><span class="line">	<span class="comment">// reply已解析好, link也没有断开</span></span><br><span class="line">    <span class="keyword">if</span> (!reply || !link) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    link-&gt;pending_commands--;</span><br><span class="line">    r = reply;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对于INFO指令的回复类型应该是字符串</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;type == REDIS_REPLY_STRING)</span><br><span class="line">        sentinelRefreshInstanceInfo(ri,r-&gt;str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PUB-SUB"><a href="#PUB-SUB" class="headerlink" title="PUB/SUB"></a>PUB/SUB</h4><p>默认情况下，sentinel每2s一次向监视的主服务器及其从服务器的<code>link-&gt;cc</code>发送<code>PUBLISH</code>指令，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello  &quot;s_ip,s_port,s_runid,s_epoch,m_name,m_ip,m_port,m_epoch&quot; </span><br></pre></td></tr></table></figure>

<p>即，向各个服务器的<code>__sentinel__:hellow</code>通道发送了一条信息，那么订阅这个通道的所有服务器都会接受到这条信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_PUBLISH_PERIOD 2000</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelInfoReplyCallback</span><span class="params">(redisAsyncContext* c, <span class="type">void</span>* reply, <span class="type">void</span>* privdata)</span> &#123; </span><br><span class="line">  	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 向master、master的slave，发送Hello</span></span><br><span class="line">    <span class="keyword">if</span> ((now - ri-&gt;last_pub_time) &gt; SENTINEL_PUBLISH_PERIOD) &#123;</span><br><span class="line">        sentinelSendHello(ri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sentinelSendHello</strong></p>
<p><code>sentinelSendHello</code>函数，主要就是格式化待发送数据，然后通过<code>link-&gt;cc</code>发送PUBLISH指令。设置回调函数<code>sentinelPublishReplyCallback</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sentinelSendHello</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="type">char</span> ip[NET_IP_STR_LEN];</span><br><span class="line">    <span class="type">char</span> payload[NET_IP_STR_LEN+<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line">    <span class="type">char</span> *announce_ip;</span><br><span class="line">    <span class="type">int</span> announce_port;</span><br><span class="line">    <span class="comment">// 当前实例的主服务器</span></span><br><span class="line">    sentinelRedisInstance *master = (ri-&gt;flags &amp; SRI_MASTER) ? ri : ri-&gt;master;</span><br><span class="line">    <span class="comment">// 主服务器的地址</span></span><br><span class="line">    sentinelAddr *master_addr = sentinelGetCurrentMasterAddress(master);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经断开连接，则return</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取当前sentinel的信息</span></span><br><span class="line">    <span class="keyword">if</span> (sentinel.announce_ip) &#123;</span><br><span class="line">        announce_ip = sentinel.announce_ip;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (anetSockName(ri-&gt;link-&gt;cc-&gt;c.fd, ip, <span class="keyword">sizeof</span>(ip),<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        announce_ip = ip;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sentinel.announce_port) announce_port = sentinel.announce_port;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.tls_replication &amp;&amp; server.tls_port) announce_port = server.tls_port;</span><br><span class="line">    <span class="keyword">else</span> announce_port = server.port; <span class="comment">// sentinel : 26379</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 格式化待发送的信息</span></span><br><span class="line">    <span class="built_in">snprintf</span>(payload,</span><br><span class="line">             <span class="keyword">sizeof</span>(payload),</span><br><span class="line">             <span class="string">&quot;%s,%d,%s,%llu,&quot;</span>    <span class="comment">/* 当前 sentinel 的信息 */</span></span><br><span class="line">             <span class="string">&quot;%s,%s,%d,%llu&quot;</span>,    <span class="comment">/* 当前 sentinel 监视的 master信息 */</span></span><br><span class="line">             announce_ip, </span><br><span class="line">             announce_port, </span><br><span class="line">             sentinel.myid,</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) sentinel.current_epoch,</span><br><span class="line">             master-&gt;name,</span><br><span class="line">             master_addr-&gt;ip,</span><br><span class="line">             master_addr-&gt;port,</span><br><span class="line">             (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) master-&gt;config_epoch);</span><br><span class="line">	<span class="comment">// 通过 link-&gt;cc 通道发布 PUBLISH __sentinel__:hello XXX</span></span><br><span class="line">    retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">                               sentinelPublishReplyCallback, </span><br><span class="line">                               ri, </span><br><span class="line">                               <span class="string">&quot;%s %s %s&quot;</span>,</span><br><span class="line">                               sentinelInstanceMapCommand(ri,<span class="string">&quot;PUBLISH&quot;</span>),</span><br><span class="line">                               SENTINEL_HELLO_CHANNEL,	<span class="comment">// __sentinel__:hello</span></span><br><span class="line">                               payload);</span><br><span class="line">    <span class="keyword">if</span> (retval != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sentinelPublishReplyCallback</strong></p>
<p>sentinel在接收到对端对于<code>hello</code>的回应后，主要更新下<code>  ri-&gt;last_pub_time</code>时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelPublishReplyCallback</span><span class="params">(redisAsyncContext *c, <span class="type">void</span> *reply, <span class="type">void</span> *privdata)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *ri = privdata;</span><br><span class="line">    instanceLink *link = c-&gt;data;</span><br><span class="line">    redisReply *r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply || !link) <span class="keyword">return</span>;</span><br><span class="line">    link-&gt;pending_commands--;</span><br><span class="line">    r = reply;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;type != REDIS_REPLY_ERROR)</span><br><span class="line">        ri-&gt;last_pub_time = mstime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>sentinelReceiveHelloMessages</strong></p>
<p>那么其他sentinel接收到<code>hello</code>通道的信息怎么处理???</p>
<p>在<code>sentinelReconnectInstance</code>函数中，创建<code>sentinelRedisInstance</code>实例时，就已订阅了<code>hello</code>通道，并设置回调函数为<code>sentinelReceiveHelloMessages</code>函数。当其他<em>sentinelRedisInstance</em>实例向<code>__sentinel__:hello</code>通道发送消息时，就能接受到如下格式的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="number">2</span>) __sentinel__:hello</span><br><span class="line"><span class="number">3</span>) <span class="string">&quot;s_ip,s_port,s_runid,s_epoch,m_name,m_ip,m_port,m_epoch&quot;</span> </span><br></pre></td></tr></table></figure>
<p><code>sentinelReceiveHelloMessages</code>函数，主要完成以下几个任务：</p>
<ul>
<li>更新<code>link-&gt;pc_last_activity </code>时间后</li>
<li>判断接受到数据格式正确</li>
<li><code>hello</code>通道的数据不是自己发送</li>
<li>如果以上都满足，才调用 <code>sentinelProcessHelloMessage</code> 函数来处理hello通道传递来的数据。</li>
</ul>
<p>整个流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelReceiveHelloMessages</span><span class="params">(redisAsyncContext *c, <span class="type">void</span> *reply, <span class="type">void</span> *privdata)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *ri = privdata;</span><br><span class="line">    redisReply *r;</span><br><span class="line">    UNUSED(c);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply || !ri) <span class="keyword">return</span>;</span><br><span class="line">    r = reply;</span><br><span class="line"></span><br><span class="line">    ri-&gt;link-&gt;pc_last_activity = mstime();	<span class="comment">// 更新时间</span></span><br><span class="line">	<span class="comment">// 类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;type != REDIS_REPLY_ARRAY              ||</span><br><span class="line">        r-&gt;elements != <span class="number">3</span>                          ||</span><br><span class="line">        r-&gt;element[<span class="number">0</span>]-&gt;type != REDIS_REPLY_STRING ||</span><br><span class="line">        r-&gt;element[<span class="number">1</span>]-&gt;type != REDIS_REPLY_STRING ||</span><br><span class="line">        r-&gt;element[<span class="number">2</span>]-&gt;type != REDIS_REPLY_STRING ||</span><br><span class="line">        <span class="built_in">strcmp</span>(r-&gt;element[<span class="number">0</span>]-&gt;str,<span class="string">&quot;message&quot;</span>) != <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果能找到自己id，则消息就是自己发送的，则忽略</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(r-&gt;element[<span class="number">2</span>]-&gt;str, sentinel.myid) != <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理来自其他sentinel的消息</span></span><br><span class="line">    sentinelProcessHelloMessage(r-&gt;element[<span class="number">2</span>]-&gt;str, r-&gt;element[<span class="number">2</span>]-&gt;len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h2><h3 id="sentinelCheckSubjectivelyDown"><a href="#sentinelCheckSubjectivelyDown" class="headerlink" title="sentinelCheckSubjectivelyDown"></a>sentinelCheckSubjectivelyDown</h3><p>当前sentinel会调用<code>sentinelCheckSubjectivelyDown</code>函数， 以<code>1ms</code>的频率来检测监视的服务器是否下线。<code>ri</code>可能是slave也可能是个master。</p>
<ol>
<li><p>如果当前sentinel之前发送的PING有没有PONG回应，计算距离上次该PING的时间。否则计算距离最近一次收到PONG的时间<code>elapsed</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">mstime_t</span> last_avail_time; <span class="comment">/*最近一次接收到PING的回复(PONG)的时间 */</span></span><br><span class="line"><span class="comment">// act_ping_time 记录上次发出的 PING 是否有回应</span></span><br><span class="line"><span class="comment">// 有，则 act_ping_time ==0，接收PONG的时间由 last_avail_time 记录</span></span><br><span class="line"><span class="comment">// 没有，则 act_ping_time 的值就是上次发送PING的时间</span></span><br><span class="line"><span class="type">mstime_t</span> act_ping_time; </span><br></pre></td></tr></table></figure></li>
<li><p>是否有必要关闭<code>link-&gt;cc</code>：如果sentinel和对端建立<code>link-&gt;cc</code>的时间超过了<code>SENTINEL_MIN_LINK_RECONNECT_PERIOD</code>，说明没有接受到PONG不是因为刚刚建立、网络不稳导致的。那么发送的PING在<code>down_after_period</code>时段内没有回应，那么对端可能发生故障，直接关闭与对端的连接。</p>
</li>
<li><p>是否有必要关闭<code>link-&gt;pc</code>：处理<code>__sentinel__:hello</code>超时，也关闭<code>link-&gt;pc</code>连接</p>
</li>
<li><p>判断监视的服务器ri是否主观下线：</p>
<ul>
<li>如果没有回复PING的时间超过<code>ri-&gt;down_after_period</code>，就视为主观下线，加上<code>ri-&gt;flags |= SRI_S_DOWN</code>标志</li>
<li>如果<code>ri</code>是主服务器，但在INFO的回应中<code>ri</code>被报告为slave，发生了主从切换，也视为主观下线</li>
</ul>
<p>如果不满足上面两个中的任何一条件，则不视为主观下线，如果之前设置为主观下线，现在取消<code>SRI_S_DOWN</code>标志位。</p>
</li>
</ol>
<p>下一步就是判断是否真的下线了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelCheckSubjectivelyDown</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="type">mstime_t</span> elapsed = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 1) </span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;act_ping_time)</span><br><span class="line">        elapsed = mstime() - ri-&gt;link-&gt;act_ping_time; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected)</span><br><span class="line">        elapsed = mstime() - ri-&gt;link-&gt;last_avail_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2) 是否有必要关闭不活跃的命令连接 link-&gt;cc</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;cc &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;cc_conn_time) &gt; SENTINEL_MIN_LINK_RECONNECT_PERIOD &amp;&amp;</span><br><span class="line">        ri-&gt;link-&gt;act_ping_time != <span class="number">0</span> &amp;&amp;                                         <span class="comment">// 对端一致没有回应PING</span></span><br><span class="line">        (mstime() - ri-&gt;link-&gt;act_ping_time)  &gt; (ri-&gt;down_after_period/<span class="number">2</span>) &amp;&amp;    <span class="comment">// 发出去的PING</span></span><br><span class="line">        (mstime() - ri-&gt;link-&gt;last_pong_time) &gt; (ri-&gt;down_after_period/<span class="number">2</span>))      <span class="comment">// 没有收到回应</span></span><br><span class="line">    &#123;</span><br><span class="line">        instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;cc);	<span class="comment">// 关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3) 是否有必要关闭不活跃的订阅连接 link-&gt;pc</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;pc &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;pc_conn_time) &gt; SENTINEL_MIN_LINK_RECONNECT_PERIOD &amp;&amp; </span><br><span class="line">        (mstime() - ri-&gt;link-&gt;pc_last_activity) &gt; (SENTINEL_PUBLISH_PERIOD*<span class="number">3</span>)) <span class="comment">// 处理hello的时间超时</span></span><br><span class="line">    &#123;</span><br><span class="line">        instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;pc); <span class="comment">// 关闭连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 导致sentinel认为master主观下线的条件，有两种可能：</span></span><br><span class="line"><span class="comment">     * 1) elapsed &gt; ri-&gt;down_after_period ，即长时间没有回复</span></span><br><span class="line"><span class="comment">     * 2）ri之前是master,现在变成slave,并且时间较长</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 不满足两者之一，则不是主观下线 */</span></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; ri-&gt;down_after_period ||	<span class="comment">// 不是主服务器类型</span></span><br><span class="line">        (ri-&gt;flags &amp; SRI_MASTER &amp;&amp;</span><br><span class="line">         ri-&gt;role_reported == SRI_SLAVE &amp;&amp;</span><br><span class="line">         mstime() - ri-&gt;role_reported_time &gt; (ri-&gt;down_after_period+SENTINEL_INFO_PERIOD*<span class="number">2</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 加上标志位 SRI_S_DOWN，设置为主观下线</span></span><br><span class="line">        <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_S_DOWN) == <span class="number">0</span>) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;+sdown&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">            ri-&gt;s_down_since_time = mstime();</span><br><span class="line">            ri-&gt;flags |= SRI_S_DOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 取消主观下线标志位 SRI_S_DOWN</span></span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_S_DOWN) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;-sdown&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">            ri-&gt;flags &amp;= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sentinelCheckObjectivelyDown"><a href="#sentinelCheckObjectivelyDown" class="headerlink" title="sentinelCheckObjectivelyDown"></a>sentinelCheckObjectivelyDown</h3><p><code>sentinelCheckObjectivelyDown</code> 函数，仅对主服务器适用，进一步判断是不是真的下线了。</p>
<ol>
<li>监视主服务master的其他sentinel中<code>master-&gt;sentinel</code>，超过<code>master-&gt;quorum</code>个也认为master下线了，则当前sentinel将master视为真的下线了，即客观下线了</li>
<li>客观下线，加上<code>SRI_O_DOWN</code>标志，否则取消该标志</li>
</ol>
<p>详细过程如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelCheckObjectivelyDown</span><span class="params">(sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> quorum = <span class="number">0</span>, odown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;flags &amp; SRI_S_DOWN) &#123;</span><br><span class="line">        quorum = <span class="number">1</span>; <span class="comment">// 自己sentinel认为master已经下线</span></span><br><span class="line">        <span class="comment">// 下面要计算 maseter-&gt;sentinel 中也认为master下线sentinel个数</span></span><br><span class="line">        di = dictGetIterator(master-&gt;sentinels);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line">		   <span class="comment">// 下线</span></span><br><span class="line">            <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER_DOWN) quorum++;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        <span class="comment">// 超过阈值 master-&gt;quorum，则判断master处于客观下线</span></span><br><span class="line">        <span class="keyword">if</span> (quorum &gt;= master-&gt;quorum) odown = <span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果真的下线了，则加上 SRI_O_DOWN 标志位</span></span><br><span class="line">    <span class="keyword">if</span> (odown) &#123;</span><br><span class="line">        <span class="comment">// 加上 SRI_O_DOWN 标志</span></span><br><span class="line">        <span class="keyword">if</span> ((master-&gt;flags &amp; SRI_O_DOWN) == <span class="number">0</span>) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,</span><br><span class="line">                          <span class="string">&quot;+odown&quot;</span>,</span><br><span class="line">                          master,</span><br><span class="line">                          <span class="string">&quot;%@ #quorum %d/%d&quot;</span>,</span><br><span class="line">                          quorum, </span><br><span class="line">                          master-&gt;quorum);</span><br><span class="line">            master-&gt;flags |= SRI_O_DOWN;</span><br><span class="line">            master-&gt;o_down_since_time = mstime();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则取消 SRI_O_DOWN 标志</span></span><br><span class="line">        <span class="keyword">if</span> (master-&gt;flags &amp; SRI_O_DOWN) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;-odown&quot;</span>,master,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">            master-&gt;flags &amp;= ~SRI_O_DOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sentinelStartFailoverIfNeeded"><a href="#sentinelStartFailoverIfNeeded" class="headerlink" title="sentinelStartFailoverIfNeeded"></a>sentinelStartFailoverIfNeeded</h3><p><code>sentinelStartFailoverIfNeeded</code>函数，判断主服务master是否需要转故障转移：</p>
<ol>
<li>master必须处于<code>SRI_O_DOWN</code>状态，即已客观下线</li>
<li>maste不能已经处于故障转移中，</li>
<li>master距离上次故障转移的时间不能太短，太短则在上次的启动时间后延迟<code> master-&gt;failover_timeout*2</code></li>
</ol>
<p>如果上述条件都满足，则开启故障转移</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sentinelStartFailoverIfNeeded</span><span class="params">(sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    <span class="comment">// 客观下线</span></span><br><span class="line">    <span class="keyword">if</span> (!(master-&gt;flags &amp; SRI_O_DOWN)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有正在处理故障转移</span></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last attempt started too little time ago? */</span></span><br><span class="line">    <span class="comment">// 距离上次故障转移时间要大于  master-&gt;failover_timeout*2 才可以</span></span><br><span class="line">    <span class="comment">// 否则，将此作为下次故障转移的时间</span></span><br><span class="line">    <span class="keyword">if</span> (mstime() - master-&gt;failover_start_time &lt; master-&gt;failover_timeout*<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (master-&gt;failover_delay_logged != master-&gt;failover_start_time) &#123;</span><br><span class="line">            <span class="type">time_t</span> clock = (master-&gt;failover_start_time + master-&gt;failover_timeout*<span class="number">2</span>) / <span class="number">1000</span>;</span><br><span class="line">            <span class="type">char</span> ctimebuf[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">            ctime_r(&amp;clock, ctimebuf);</span><br><span class="line">            ctimebuf[<span class="number">24</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">/* Remove newline. */</span></span><br><span class="line">            master-&gt;failover_delay_logged = master-&gt;failover_start_time;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Next failover delay: I will not start a failover before %s&quot;</span>,</span><br><span class="line">                      ctimebuf);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 那么可以进行故障转移</span></span><br><span class="line">    sentinelStartFailover(master);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sentinelAskMasterStateToOtherSentinels"><a href="#sentinelAskMasterStateToOtherSentinels" class="headerlink" title="sentinelAskMasterStateToOtherSentinels"></a>sentinelAskMasterStateToOtherSentinels</h4><p>当监视的主服务发生故障，那么sentinel要从slaves中选出一个提升为主服务器，被选中的slave叫做<em>promoted_slave</em>。但是在此之前，要先投票决定由哪个sentinel来执行这个过程。</p>
<p><code>sentinelAskMasterStateToOtherSentinels</code>函数， 当sentinel向<code>master-&gt;sentinels</code>中其他sentinels发送如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL is-master-down-by-addr  master_ip master_port sentinel.current_epoch sentinel.runid</span><br></pre></td></tr></table></figure>

<p>上述信息：告诉接受到此信息的<code>dst_sentinel</code>，地址是 <code>(master_ip, master_port)</code> 的主服务宕机了，请把<code>(s_epoch, s_runid)</code>的sentinel设置为leader，由这个leader来完成故障转移的过程。</p>
<p>在发送该指令之前，先判断是否能发送：</p>
<ol>
<li>master必须处于客观下线状态</li>
<li>当前sentinel与<code>master-&gt;sentinels</code>之间的连接<code>link-&gt;cc</code>没有断开</li>
<li>当前sentinel与<code>master-&gt;sentinels</code>之间，没有设置<code>SENTINEL_ASK_FORCED</code>标志 <strong>或者</strong> 距离上次此指令的回复时间大于<code>SENTINEL_ASK_PERIOD</code></li>
</ol>
<p>同时满足上面的条件，才能发送此次的<code>is-master-down-by-addr </code>指令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_ASK_FORCED (1&lt;&lt;0)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sentinelAskMasterStateToOtherSentinels</span><span class="params">(sentinelRedisInstance* master, <span class="type">int</span> flags)</span> &#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    di = dictGetIterator(master-&gt;sentinels);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelRedisInstance* ri = dictGetVal(de);</span><br><span class="line">        <span class="comment">//  其他sentinel实例 ri 距离上次回应 SENTINEL is-master-down 指令的时间</span></span><br><span class="line">        <span class="type">mstime_t</span> elapsed = mstime() - ri-&gt;last_master_down_reply_time; </span><br><span class="line">        <span class="type">char</span> port[<span class="number">32</span>];</span><br><span class="line">        <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果时间太久，则清除之前关于master的状态，以及当时选择的leader</span></span><br><span class="line">        <span class="keyword">if</span> (elapsed &gt; SENTINEL_ASK_PERIOD*<span class="number">5</span>) &#123;</span><br><span class="line">            ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;</span><br><span class="line">            sdsfree(ri-&gt;leader);</span><br><span class="line">            ri-&gt;leader = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断能不能发送</span></span><br><span class="line">        <span class="keyword">if</span> ((master-&gt;flags &amp; SRI_S_DOWN) == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; SENTINEL_ASK_FORCED) &amp;&amp;  </span><br><span class="line">            mstime() - ri-&gt;last_master_down_reply_time &lt; SENTINEL_ASK_PERIOD)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Ask */</span></span><br><span class="line">        ll2string(port,<span class="keyword">sizeof</span>(port),master-&gt;addr-&gt;port);</span><br><span class="line">        <span class="comment">// 向监视master的其他sentinel，发送指令 : </span></span><br><span class="line">        <span class="comment">// SENTINEL is-master-down-by-addr m_ip m_port s_epoch s_runid</span></span><br><span class="line">        retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">                                   sentinelReceiveIsMasterDownReply, </span><br><span class="line">                                   ri,</span><br><span class="line">                                   <span class="string">&quot;%s is-master-down-by-addr %s %s %llu %s&quot;</span>,</span><br><span class="line">                                   sentinelInstanceMapCommand(ri,<span class="string">&quot;SENTINEL&quot;</span>),</span><br><span class="line">                                   master-&gt;addr-&gt;ip, </span><br><span class="line">                                   port,</span><br><span class="line">                                   sentinel.current_epoch,</span><br><span class="line">                                   (master-&gt;failover_state &gt; SENTINEL_FAILOVER_STATE_NONE) ?</span><br><span class="line">                                               sentinel.myid : </span><br><span class="line">                                               <span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) </span><br><span class="line">            ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>master-&gt;sentinel</code>中的sentinel在收到指令后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL IS-MASTER-DOWN-BY-ADDR &lt;ip&gt; &lt;port&gt; &lt;current-epoch&gt; &lt;runid&gt;</span><br></pre></td></tr></table></figure>

<p>先在自己的<code>sentinel.masters</code>中查找是否有地址为 <code>(ip, port)</code>的主服务器<code>ri</code>，并且该 <code>ri</code> 也确实处于<code>SRI_S_DOWN</code>状态，则回复消息。不过回复有三行数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdown   	// 接受到指令的sentinel中master是否也主观下线</span><br><span class="line">leader		// 选出的leader</span><br><span class="line">epoch		// 该leader的epoch</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果<code>IS-MASTER-DOWN-BY-ADDR</code>指令中的<code>runid ==*</code>，则发送指令的<code>src_sentinel</code>不要求接受到此消息的<code>dst_sentinel</code>投自己票，只想知道在<code>dst_sentinel</code>中<code>master</code>的是否也<code>SRI_S_DOWN</code>状态。此时回复如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdown	// 是否下线</span><br><span class="line">*		</span><br><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rund != *</code>：则说明<code>src_dentinel</code>希望自己成为leader来完成master的故障转移过程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sdown</span><br><span class="line">runid	// vote_runid</span><br><span class="line">epoch 	// vote_epoch</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>其他sentinel在接受到 <code>IS-MASTER-DOWN-BY-ADDR</code>后，处理过程如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;is-master-down-by-addr&quot;</span>)) &#123;</span><br><span class="line">    <span class="comment">/* SENTINEL IS-MASTER-DOWN-BY-ADDR &lt;ip&gt; &lt;port&gt; &lt;current-epoch&gt; &lt;runid&gt; */</span></span><br><span class="line">    sentinelRedisInstance *ri;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> req_epoch;</span><br><span class="line">    <span class="type">uint64_t</span> leader_epoch = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> *leader = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">long</span> port;</span><br><span class="line">    <span class="type">int</span> isdown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;argc != <span class="number">6</span>) <span class="keyword">goto</span> numargserr;</span><br><span class="line">    <span class="keyword">if</span> (getLongFromObjectOrReply(c,c-&gt;argv[<span class="number">3</span>],&amp;port,<span class="literal">NULL</span>) != C_OK ||</span><br><span class="line">        getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">4</span>],&amp;req_epoch,<span class="literal">NULL</span>) != C_OK)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 在 sentinel.master 中查找地址是 (m_ip, m_port) 的主服务器</span></span><br><span class="line">    ri = getSentinelRedisInstanceByAddrAndRunID(sentinel.masters,</span><br><span class="line">                                                c-&gt;argv[<span class="number">2</span>]-&gt;ptr,    <span class="comment">// m_ip</span></span><br><span class="line">                                                port,               <span class="comment">// m_port</span></span><br><span class="line">                                                <span class="literal">NULL</span>);</span><br><span class="line">     <span class="comment">// 如果存在，</span></span><br><span class="line">     <span class="comment">// 并且也是处于 SRI_S_DOWN 状态，即主观下线状态， </span></span><br><span class="line">     <span class="comment">// 设置 isdown = 1;</span></span><br><span class="line">    <span class="keyword">if</span> (!sentinel.tilt &amp;&amp; </span><br><span class="line">        ri &amp;&amp; </span><br><span class="line">        (ri-&gt;flags &amp; SRI_S_DOWN) &amp;&amp;</span><br><span class="line">        (ri-&gt;flags &amp; SRI_MASTER))</span><br><span class="line">        isdown = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  如果指令参数中 s_runid 不是 &#x27;*&#x27;，尝试将 s_runid 的sentinel 设置为leader </span></span><br><span class="line">    <span class="keyword">if</span> (ri &amp;&amp; ri-&gt;flags &amp; SRI_MASTER &amp;&amp; strcasecmp(c-&gt;argv[<span class="number">5</span>]-&gt;ptr,<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">        leader = sentinelVoteLeader(ri,</span><br><span class="line">                                    (<span class="type">uint64_t</span>)req_epoch,    <span class="comment">// req_epoch</span></span><br><span class="line">                                    c-&gt;argv[<span class="number">5</span>]-&gt;ptr,        <span class="comment">// runid</span></span><br><span class="line">                                    &amp;leader_epoch);         <span class="comment">// </span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 回复客户端</span></span><br><span class="line">    addReplyArrayLen(c,<span class="number">3</span>);</span><br><span class="line">    addReply(c, isdown ? shared.cone : shared.czero);</span><br><span class="line">    addReplyBulkCString(c, leader ? leader : <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    addReplyLongLong(c, (<span class="type">long</span> <span class="type">long</span>)leader_epoch);</span><br><span class="line">    <span class="keyword">if</span> (leader) sdsfree(leader);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="sentinelReceiveIsMasterDownReply"><a href="#sentinelReceiveIsMasterDownReply" class="headerlink" title="sentinelReceiveIsMasterDownReply"></a>sentinelReceiveIsMasterDownReply</h4><p><code>sentinelReceiveIsMasterDownReply</code>函数，是<code>src_sentinel</code>发送  <code>IS-MASTER-DOWN-BY-ADDR</code> 指令的回复回调函数。当接收到对端对<code>IS-MASTER-DOWN-BY-ADDR</code>指令回复后调用。</p>
<p>在 <code>IS-MASTER-DOWN-BY-ADDR</code>指令的回复中，如果<code>runid != *</code>，则<code>runid</code>是<code>dst_sentinel</code>选出来的<code>leader</code>，那么就将<code>dst_sentinel</code>的leader更改为<code>runid</code>。</p>
<p><font color="red"> 注意：</font> <code>sentinelReceiveIsMasterDownReply</code>函数中的 <code>privdata</code> 就是<code>dst_sentinel</code>，因此在接收到<code>dst_sentinel</code>的回复后，对<code>dst_sentinel</code>的参数做一些修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelReceiveIsMasterDownReply</span><span class="params">(redisAsyncContext* c, <span class="type">void</span>* reply, <span class="type">void</span>* privdata)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *ri = privdata;	<span class="comment">// master-&gt;sentinels 中的实例对象</span></span><br><span class="line">    instanceLink *link = c-&gt;data;</span><br><span class="line">    redisReply *r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply || !link) <span class="keyword">return</span>;</span><br><span class="line">    link-&gt;pending_commands--;</span><br><span class="line">    r = reply;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 回复格式</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; r-&gt;elements == <span class="number">3</span> &amp;&amp;</span><br><span class="line">        r-&gt;element[<span class="number">0</span>]-&gt;type == REDIS_REPLY_INTEGER &amp;&amp;</span><br><span class="line">        r-&gt;element[<span class="number">1</span>]-&gt;type == REDIS_REPLY_STRING  &amp;&amp;</span><br><span class="line">        r-&gt;element[<span class="number">2</span>]-&gt;type == REDIS_REPLY_INTEGER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 更新is-master-down-by-addr 指令的回复时间</span></span><br><span class="line">        ri-&gt;last_master_down_reply_time = mstime(); </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (r-&gt;element[<span class="number">0</span>]-&gt;integer == <span class="number">1</span>) </span><br><span class="line">            ri-&gt;flags |= SRI_MASTER_DOWN;   <span class="comment">// 加上 SRI_MASTER_DOWN 标志，同意主服务下线 </span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 runid 回复不是 &#x27;*&#x27;，表示选出的局部 leader</span></span><br><span class="line">        <span class="comment">// 将当前主服务的 ri 设置为返回的 leader</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(r-&gt;element[<span class="number">1</span>]-&gt;str,<span class="string">&quot;*&quot;</span>)) &#123;</span><br><span class="line">            sdsfree(ri-&gt;leader); 			<span class="comment">// 释放自己的原 leader</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">long</span> <span class="type">long</span>)ri-&gt;leader_epoch != r-&gt;element[<span class="number">2</span>]-&gt;integer)</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                          <span class="string">&quot;%s voted for %s %llu&quot;</span>, </span><br><span class="line">                          ri-&gt;name,</span><br><span class="line">                          r-&gt;element[<span class="number">1</span>]-&gt;str,</span><br><span class="line">                          (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) r-&gt;element[<span class="number">2</span>]-&gt;integer);</span><br><span class="line">            <span class="comment">// 更替dst_sentinel的leader</span></span><br><span class="line">            ri-&gt;leader = sdsnew(r-&gt;element[<span class="number">1</span>]-&gt;str);</span><br><span class="line">            ri-&gt;leader_epoch = r-&gt;element[<span class="number">2</span>]-&gt;integer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="sentinelVoteLeader"><a href="#sentinelVoteLeader" class="headerlink" title="sentinelVoteLeader"></a>sentinelVoteLeader</h4><p>下面来讲述下，选择leader的过程。</p>
<p>要能成为leader，必须要使得<code>req_epoch &gt; sentinel.current_epoch</code>，因为当前sentinel也有可能负责master的故障转移。这个条件都不满足，则不可能成为leader。</p>
<p>此外，还需要大于<code>master-&gt;leader_epoch</code>。如果都满足则将<code>req_runid</code>设置为<code>master</code>的<code>leader</code>，后期负责<code>master</code>的故障转移。<code>src_sentinel</code>在接受到<code> add</code>回复后，在<code>sentinelReceiveIsMasterDownReply</code>函数中，还会将<code>req_runid</code>设置为<code>dst_Sentinel</code>的leader。</p>
<p>如果不满足，则在<code>sentinelReceiveIsMasterDownReply</code>函数中，<code>dst_sentinel</code>的<code>leader</code>是<code>master-&gt;leader</code></p>
<p>其中,<code>req_runid</code>和<code>req_epoch</code>即<code>src_sentinel</code>的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span>* <span class="title function_">sentinelVoteLeader</span><span class="params">(sentinelRedisInstance* master, </span></span><br><span class="line"><span class="params">                         <span class="type">uint64_t</span>   req_epoch, </span></span><br><span class="line"><span class="params">                         <span class="type">char</span>*      req_runid, </span></span><br><span class="line"><span class="params">                         <span class="type">uint64_t</span>*  leader_epoch)</span> </span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// src_sentinel.epoch &gt; dst_sentinel.epoch</span></span><br><span class="line">    <span class="comment">// 则更新当前 dst_sentinel.epoch</span></span><br><span class="line">    <span class="comment">// !!! 每次接收到这个指令，满足这个条件都会更改一次</span></span><br><span class="line">    <span class="keyword">if</span> (req_epoch &gt; sentinel.current_epoch) &#123;</span><br><span class="line">        sentinel.current_epoch = req_epoch;</span><br><span class="line">        sentinelFlushConfig(); <span class="comment">// 重写当前sentinel的配置文件</span></span><br><span class="line">        sentinelEvent(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;+new-epoch&quot;</span>,</span><br><span class="line">                      master,</span><br><span class="line">                      <span class="string">&quot;%llu&quot;</span>,</span><br><span class="line">                      (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) sentinel.current_epoch);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 是否要更新负责对 master 进行故障转移的 leader</span></span><br><span class="line">    <span class="comment">// 条件是：req_epoch 要大于 master-&gt;leader_epoch</span></span><br><span class="line">    <span class="keyword">if</span> (req_epoch &gt; master-&gt;leader_epoch &amp;&amp; req_epoch &gt;= sentinel.current_epoch) &#123;</span><br><span class="line">        sdsfree(master-&gt;leader);</span><br><span class="line">        <span class="comment">// 那么就将master-&gt;leader更改为 src_sentinel</span></span><br><span class="line">        <span class="comment">// 后期由 src_sentinel 来完成故障转移</span></span><br><span class="line">        master-&gt;leader = sdsnew(req_runid);</span><br><span class="line">        master-&gt;leader_epoch = sentinel.current_epoch;</span><br><span class="line">        sentinelFlushConfig();</span><br><span class="line">        sentinelEvent(LL_WARNING,</span><br><span class="line">                     <span class="string">&quot;+vote-for-leader&quot;</span>,</span><br><span class="line">                     master,</span><br><span class="line">                     <span class="string">&quot;%s %llu&quot;</span>,</span><br><span class="line">                     master-&gt;leader, </span><br><span class="line">                     (<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>) master-&gt;leader_epoch);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* If we did not voted for ourselves, set the master failover start</span></span><br><span class="line"><span class="comment">         * time to now, in order to force a delay before we can start a</span></span><br><span class="line"><span class="comment">         * failover for the same master. */</span></span><br><span class="line">        <span class="keyword">if</span> (strcasecmp(master-&gt;leader, sentinel.myid))</span><br><span class="line">            master-&gt;failover_start_time = mstime()+rand()%SENTINEL_MAX_DESYNC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *leader_epoch = master-&gt;leader_epoch;</span><br><span class="line">    <span class="keyword">return</span> master-&gt;leader ? sdsnew(master-&gt;leader) : <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="sentinelFailoverStateMachine"><a href="#sentinelFailoverStateMachine" class="headerlink" title="sentinelFailoverStateMachine"></a>sentinelFailoverStateMachine</h3><p><code>sentinelFailoverStateMachine</code>函数， 是用于控制故障转移流程。</p>
<p>故障转移的状态如下， <code>SENTINEL_FAILOVER_STATE_WAIT_START</code> 到  <code>SENTINEL_FAILOVER_STATE_UPDATE_CONFIG</code> ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Failover machine different states. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_FAILOVER_STATE_NONE 0               <span class="comment">/* No failover in progress. */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_FAILOVER_STATE_WAIT_START 1         <span class="comment">/* Wait for failover_start_time*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE 2       <span class="comment">/* Select slave to promote */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE 3 <span class="comment">/* Slave -&gt; Master */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_FAILOVER_STATE_WAIT_PROMOTION 4     <span class="comment">/* Wait slave to change role */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES 5      <span class="comment">/* SLAVEOF newmaster */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENTINEL_FAILOVER_STATE_UPDATE_CONFIG 6      <span class="comment">/* Monitor promoted slave. */</span></span></span><br></pre></td></tr></table></figure>

<p>下面按照<code>ri-&gt;failover_state</code>状态的流程来介绍故障转移的流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverStateMachine</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    serverAssert(ri-&gt;flags &amp; SRI_MASTER);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此时应该处于故障转移中</span></span><br><span class="line">    <span class="keyword">if</span> (!(ri-&gt;flags &amp; SRI_FAILOVER_IN_PROGRESS)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 故障转移的状态</span></span><br><span class="line">    <span class="keyword">switch</span>(ri-&gt;failover_state) &#123;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_WAIT_START:</span><br><span class="line">            sentinelFailoverWaitStart(ri);  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_SELECT_SLAVE:</span><br><span class="line">            sentinelFailoverSelectSlave(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE:</span><br><span class="line">            sentinelFailoverSendSlaveOfNoOne(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_WAIT_PROMOTION:</span><br><span class="line">            sentinelFailoverWaitPromotion(ri);  </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENTINEL_FAILOVER_STATE_RECONF_SLAVES:</span><br><span class="line">            sentinelFailoverReconfNextSlave(ri);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SENTINEL-FAILOVER-STATE-WAIT-START"><a href="#SENTINEL-FAILOVER-STATE-WAIT-START" class="headerlink" title="SENTINEL_FAILOVER_STATE_WAIT_START"></a>SENTINEL_FAILOVER_STATE_WAIT_START</h4><p>状态是<code>SENTINEL_FAILOVER_STATE_WAIT_START</code>时，由 <code>sentinelFailoverWaitStart</code>函数转移到下一阶段。流程如下：</p>
<ol>
<li>在正式的故障转移之前，要先从当sentinel及<code>master-&gt;sentinels</code>中选出一个leader，负责master的故障转移</li>
<li>判断是否满足开启故障转移的条件</li>
<li>满足，则进入故障转移的下一阶段<code>SENTINEL_FAILOVER_STATE_SELECT_SLAVE</code>。</li>
</ol>
<p>这个阶段主要任务就是选出leader。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverWaitStart</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="type">char</span> *leader;</span><br><span class="line">    <span class="type">int</span> isleader;</span><br><span class="line">	<span class="comment">// 1) 选出leader</span></span><br><span class="line">    leader = sentinelGetLeader(ri, ri-&gt;failover_epoch);</span><br><span class="line">    <span class="comment">// 当前sentinel是leader?</span></span><br><span class="line">    isleader = leader &amp;&amp; strcasecmp(leader,sentinel.myid) == <span class="number">0</span>;</span><br><span class="line">    sdsfree(leader);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">/* 如果当前 sentinel 既不是leader, 也没有 SRI_FORCE_FAILOVER 字段,</span></span><br><span class="line"><span class="comment">       那么自己不需要执行故障转移，</span></span><br><span class="line"><span class="comment">       将故障转移任务留给leader执行 */</span></span><br><span class="line">    <span class="keyword">if</span> (!isleader &amp;&amp; !(ri-&gt;flags &amp; SRI_FORCE_FAILOVER)) &#123;</span><br><span class="line">        <span class="comment">// 在 SENTINEL_ELECTION_TIMEOUT 和  ri-&gt;failover_timeout 之间取最小值</span></span><br><span class="line">        <span class="type">int</span> election_timeout = SENTINEL_ELECTION_TIMEOUT;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (election_timeout &gt; ri-&gt;failover_timeout)</span><br><span class="line">            election_timeout = ri-&gt;failover_timeout;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 既然自己不是leader，超过选举时间，则应该中断自己的故障转移行为</span></span><br><span class="line">        <span class="keyword">if</span> (mstime() - ri-&gt;failover_start_time &gt; election_timeout) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;-failover-abort-not-elected&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">            sentinelAbortFailover(ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 成为leader的sentinel, 需要负责故障转移 ***/</span></span><br><span class="line">    </span><br><span class="line">    sentinelEvent(LL_WARNING,<span class="string">&quot;+elected-leader&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (sentinel.simfailure_flags &amp; SENTINEL_SIMFAILURE_CRASH_AFTER_ELECTION)</span><br><span class="line">        sentinelSimFailureCrash();</span><br><span class="line">    <span class="comment">// 故障转移进入下一个状态</span></span><br><span class="line">    ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_SELECT_SLAVE;</span><br><span class="line">    <span class="comment">// 更新故障转移状态改变时间</span></span><br><span class="line">    ri-&gt;failover_state_change_time = mstime();</span><br><span class="line">    sentinelEvent(LL_WARNING,<span class="string">&quot;+failover-state-select-slave&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="SENTINEL-FAILOVER-STATE-SELECT-SLAVE"><a href="#SENTINEL-FAILOVER-STATE-SELECT-SLAVE" class="headerlink" title="SENTINEL_FAILOVER_STATE_SELECT_SLAVE"></a>SENTINEL_FAILOVER_STATE_SELECT_SLAVE</h4><p>调用<code>sentinelSelectSlave</code>函数，从<code>master-&gt;slaves</code>中选出<code>promoted_slave</code>，为其加上<code>SRI_PROMOTED</code>标志位。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverSelectSlave</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    sentinelRedisInstance *slave = sentinelSelectSlave(ri);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slave == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">&quot;-failover-abort-no-good-slave&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">        sentinelAbortFailover(ri);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">&quot;+selected-slave&quot;</span>,slave,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">        slave-&gt;flags |= SRI_PROMOTED;</span><br><span class="line">        ri-&gt;promoted_slave = slave; <span class="comment">// 被提升为主服务的slave</span></span><br><span class="line">        <span class="comment">// 更新状态及时间</span></span><br><span class="line">        ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE;</span><br><span class="line">        ri-&gt;failover_state_change_time = mstime();</span><br><span class="line">        sentinelEvent(LL_NOTICE,</span><br><span class="line">                      <span class="string">&quot;+failover-state-send-slaveof-noone&quot;</span>,</span><br><span class="line">                      slave, </span><br><span class="line">                      <span class="string">&quot;%@&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SENTINEL-FAILOVER-STATE-SEND-SLAVEOF-NOONE"><a href="#SENTINEL-FAILOVER-STATE-SEND-SLAVEOF-NOONE" class="headerlink" title="SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE"></a>SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE</h4><p>选出<code>promoted_slave</code>之后，需要将<code>promoted_slave</code>变成master，因此要对其执行 <code>SLAVEOF NO ONE</code>命令。不过此处发送<code>SLAVEOF</code>命令的函数是 <code>sentinelSendSlaveOf</code>，不需要设置回调函数。至于具体<code>promoted_slave</code>是否成功变成master，通过<code>INFO</code>信息的回调函数查看。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverSendSlaveOfNoOne</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果 sentinel 与 promoted_slave 断开了连接，则一直阻塞到故障转移超时时间。</span></span><br><span class="line"><span class="comment">     * 超时还没重新连接，则中止故障转移 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;promoted_slave-&gt;link-&gt;disconnected) &#123;</span><br><span class="line">        <span class="comment">// 超时则中断</span></span><br><span class="line">        <span class="keyword">if</span> (mstime() - ri-&gt;failover_state_change_time &gt; ri-&gt;failover_timeout) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">&quot;-failover-abort-slave-timeout&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">            sentinelAbortFailover(ri);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 发送SLAVEOF NO ONE</span></span><br><span class="line">    retval = sentinelSendSlaveOf(ri-&gt;promoted_slave, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (retval != C_OK) <span class="keyword">return</span>;</span><br><span class="line">    sentinelEvent(LL_NOTICE, </span><br><span class="line">                  <span class="string">&quot;+failover-state-wait-promotion&quot;</span>,</span><br><span class="line">                  ri-&gt;promoted_slave,</span><br><span class="line">                  <span class="string">&quot;%@&quot;</span>);</span><br><span class="line">    <span class="comment">// 更改状态，更新时间</span></span><br><span class="line">    ri-&gt;failover_state = SENTINEL_FAILOVER_STATE_WAIT_PROMOTION;</span><br><span class="line">    ri-&gt;failover_state_change_time = mstime();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SENTINEL-FAILOVER-STATE-WAIT-PROMOTION"><a href="#SENTINEL-FAILOVER-STATE-WAIT-PROMOTION" class="headerlink" title="SENTINEL_FAILOVER_STATE_WAIT_PROMOTION"></a>SENTINEL_FAILOVER_STATE_WAIT_PROMOTION</h4><p><code>sentinelFailoverWaitPromotion</code> 函数用于leader在<code>ri-&gt;failover_timeout</code>时间内是否将<code>promoted_slave</code>提升为master。如果，超时则中断故障转移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverWaitPromotion</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="comment">/* Just handle the timeout. Switching to the next state is handled</span></span><br><span class="line"><span class="comment">     * by the function parsing the INFO command of the promoted slave. */</span></span><br><span class="line">    <span class="keyword">if</span> (mstime() - ri-&gt;failover_state_change_time &gt; ri-&gt;failover_timeout) &#123;</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">&quot;-failover-abort-slave-timeout&quot;</span>,ri,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">        sentinelAbortFailover(ri);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="SENTINEL-FAILOVER-STATE-RECONF-SLAVES"><a href="#SENTINEL-FAILOVER-STATE-RECONF-SLAVES" class="headerlink" title="SENTINEL_FAILOVER_STATE_RECONF_SLAVES"></a>SENTINEL_FAILOVER_STATE_RECONF_SLAVES</h4><p>从<code>SENTINEL_FAILOVER_STATE_WAIT_PROMOTION</code>状态转移至<code>SENTINEL_FAILOVER_STATE_RECONF_SLAVES</code> 是在INFO的回复回调函数中完成的。</p>
<p>当<code>promoted_slave</code>变成master，那么剩下的就是将<code>master-&gt;slaves</code>中的其他slaves变成<code>promoted_slave</code>的slave。即更改<code>master-&gt;slaves</code>的主服务器。因此要再次执行<code>SLAVEOF</code>命令。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SRI_PROMOTED (1&lt;&lt;7)         <span class="comment">/* 表示 promoted_slave*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRI_RECONF_SENT (1<span class="string">&lt;&lt;8)      /* 已向该slave发送了 SLAVEOF &lt;promoted_slave&gt;</span> . */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRI_RECONF_INPROG (1&lt;&lt;9)    <span class="comment">/* slave正在与promoted_slave进行同步 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SRI_RECONF_DONE (1&lt;&lt;10)     <span class="comment">/* slave与promoted_slave的同步行为已经完成. */</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>对于超时的slave强制设置为 <code>SRI_RECONF_DONE</code> 状态</li>
<li>对于未完成的slave的发送SLAVEOF 命令，</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelFailoverDetectEnd</span><span class="params">(sentinelRedisInstance *master)</span> &#123;</span><br><span class="line">    <span class="type">int</span> not_reconfigured = <span class="number">0</span>, timeout = <span class="number">0</span>;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="type">mstime_t</span> elapsed = mstime() - master-&gt;failover_state_change_time;  <span class="comment">// 距离上次故障转移状态改变的时间</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 如果当前 promoted_slave 的状态还没完成，或者 promoted_slave 已经下线，直接返回*/</span></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;promoted_slave == <span class="literal">NULL</span> ||</span><br><span class="line">        master-&gt;promoted_slave-&gt;flags &amp; SRI_S_DOWN) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算切换未完成slave的个数</span></span><br><span class="line">    di = dictGetIterator(master-&gt;slaves);</span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelRedisInstance *slave = dictGetVal(de);</span><br><span class="line">		<span class="comment">// 忽略 promoted_slave 、切换完成的slave</span></span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;flags &amp; (SRI_PROMOTED|SRI_RECONF_DONE)) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;flags &amp; SRI_S_DOWN) </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 未配置完成</span></span><br><span class="line">        not_reconfigured++;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 故障转移已超时，强制结束这个过程</span></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; master-&gt;failover_timeout) &#123;</span><br><span class="line">        not_reconfigured = <span class="number">0</span>;</span><br><span class="line">        timeout = <span class="number">1</span>;</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">&quot;+failover-end-for-timeout&quot;</span>,master,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (not_reconfigured == <span class="number">0</span>) &#123;</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">&quot;+failover-end&quot;</span>,master,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">        <span class="comment">// 更新状态、时间</span></span><br><span class="line">        master-&gt;failover_state = SENTINEL_FAILOVER_STATE_UPDATE_CONFIG;</span><br><span class="line">        master-&gt;failover_state_change_time = mstime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 作为leader的 sentinel 向没有成功将主服务器切换到 promoted_slave 的slave </span></span><br><span class="line"><span class="comment">     * 发送 SLAVOF 命令 */</span></span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">        dictIterator *di;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        di = dictGetIterator(master-&gt;slaves);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sentinelRedisInstance *slave = dictGetVal(de);</span><br><span class="line">            <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 忽略promoted_slave、成功配置的以及断开连接的slave</span></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;flags &amp; (SRI_PROMOTED|SRI_RECONF_DONE|SRI_RECONF_SENT)) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 忽略断开连接的</span></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;link-&gt;disconnected) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 向切换失败的slave发送 SLAVEOF 指令</span></span><br><span class="line">            retval = sentinelSendSlaveOf(slave,</span><br><span class="line">                                         master-&gt;promoted_slave-&gt;addr-&gt;ip,</span><br><span class="line">                                         master-&gt;promoted_slave-&gt;addr-&gt;port);</span><br><span class="line">            <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">                sentinelEvent(LL_NOTICE,<span class="string">&quot;+slave-reconf-sent-be&quot;</span>,slave,<span class="string">&quot;%@&quot;</span>);</span><br><span class="line">                slave-&gt;flags |= SRI_RECONF_SENT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="sentinelHandleRedisInstance"><a href="#sentinelHandleRedisInstance" class="headerlink" title="sentinelHandleRedisInstance"></a>sentinelHandleRedisInstance</h2><p><code>sentinelHandleRedisInstance</code> 函数，主要有两个功能：</p>
<ul>
<li>监视着<code>ri</code>的状态</li>
<li>如果<code>ri</code>是master，则还为其负责故障转移。</li>
</ul>
<p><code>sentinelHandleRedisInstance</code>函数的传入参数，可能是master、slave及sentinel，但是只有对master实例执行故障转移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sentinelHandleRedisInstance</span><span class="params">(sentinelRedisInstance *ri)</span> &#123;</span><br><span class="line">    <span class="comment">/* ========== 监视行为 ============ */</span></span><br><span class="line">    <span class="comment">// 对于每种实例(master, slave, sentinels) </span></span><br><span class="line">    sentinelReconnectInstance(ri);       <span class="comment">// sentinel和ri之间建立连接</span></span><br><span class="line">    sentinelSendPeriodicCommands(ri);    <span class="comment">// 发送周期指令</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sentinel.tilt) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mstime()-sentinel.tilt_start_time &lt; SENTINEL_TILT_PERIOD) <span class="keyword">return</span>;</span><br><span class="line">        sentinel.tilt = <span class="number">0</span>;</span><br><span class="line">        sentinelEvent(LL_WARNING,<span class="string">&quot;-tilt&quot;</span>,<span class="literal">NULL</span>,<span class="string">&quot;#tilt mode exited&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于每种实例(master, slave, sentinels)，检测是否主观下线</span></span><br><span class="line">    sentinelCheckSubjectivelyDown(ri);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/* ========== 故障转移行为 ============ */</span></span><br><span class="line">    <span class="comment">// 仅针对master实例</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER) &#123;</span><br><span class="line">        <span class="comment">// 是否客观下线</span></span><br><span class="line">        sentinelCheckObjectivelyDown(ri);</span><br><span class="line">        <span class="comment">// 是否需要开始故障转移。如果需要，则返回1</span></span><br><span class="line">        <span class="keyword">if</span> (sentinelStartFailoverIfNeeded(ri))</span><br><span class="line">            <span class="comment">// 向ri-&gt;sentinels 发送 &#x27;SENTINEL IS-MASTER-DOWN-BY-ADDR&#x27; 指令</span></span><br><span class="line">            sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_ASK_FORCED);</span><br><span class="line">        <span class="comment">// 控制故障转移流程</span></span><br><span class="line">        sentinelFailoverStateMachine(ri);</span><br><span class="line">        <span class="comment">// 再发送一次</span></span><br><span class="line">        sentinelAskMasterStateToOtherSentinels(ri,SENTINEL_NO_FLAGS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E8%A7%86%E7%8A%B6%E6%80%81"><span class="toc-number">1.</span> <span class="toc-text">监视状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelRedisInstance"><span class="toc-number">1.1.</span> <span class="toc-text">sentinelRedisInstance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelReconnectInstance"><span class="toc-number">1.2.</span> <span class="toc-text">sentinelReconnectInstance</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelSetClientName"><span class="toc-number">1.2.1.</span> <span class="toc-text">sentinelSetClientName</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelSendPing"><span class="toc-number">1.2.2.</span> <span class="toc-text">sentinelSendPing</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelPingReplyCallback"><span class="toc-number">1.2.3.</span> <span class="toc-text">sentinelPingReplyCallback</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelSendPeriodicCommands"><span class="toc-number">1.3.</span> <span class="toc-text">sentinelSendPeriodicCommands</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PING"><span class="toc-number">1.3.1.</span> <span class="toc-text">PING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#INFO"><span class="toc-number">1.3.2.</span> <span class="toc-text">INFO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PUB-SUB"><span class="toc-number">1.3.3.</span> <span class="toc-text">PUB&#x2F;SUB</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">2.</span> <span class="toc-text">故障转移</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelCheckSubjectivelyDown"><span class="toc-number">2.1.</span> <span class="toc-text">sentinelCheckSubjectivelyDown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelCheckObjectivelyDown"><span class="toc-number">2.2.</span> <span class="toc-text">sentinelCheckObjectivelyDown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelStartFailoverIfNeeded"><span class="toc-number">2.3.</span> <span class="toc-text">sentinelStartFailoverIfNeeded</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelAskMasterStateToOtherSentinels"><span class="toc-number">2.3.1.</span> <span class="toc-text">sentinelAskMasterStateToOtherSentinels</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelReceiveIsMasterDownReply"><span class="toc-number">2.3.2.</span> <span class="toc-text">sentinelReceiveIsMasterDownReply</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinelVoteLeader"><span class="toc-number">2.3.3.</span> <span class="toc-text">sentinelVoteLeader</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sentinelFailoverStateMachine"><span class="toc-number">2.4.</span> <span class="toc-text">sentinelFailoverStateMachine</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SENTINEL-FAILOVER-STATE-WAIT-START"><span class="toc-number">2.4.1.</span> <span class="toc-text">SENTINEL_FAILOVER_STATE_WAIT_START</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SENTINEL-FAILOVER-STATE-SELECT-SLAVE"><span class="toc-number">2.4.2.</span> <span class="toc-text">SENTINEL_FAILOVER_STATE_SELECT_SLAVE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SENTINEL-FAILOVER-STATE-SEND-SLAVEOF-NOONE"><span class="toc-number">2.4.3.</span> <span class="toc-text">SENTINEL_FAILOVER_STATE_SEND_SLAVEOF_NOONE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SENTINEL-FAILOVER-STATE-WAIT-PROMOTION"><span class="toc-number">2.4.4.</span> <span class="toc-text">SENTINEL_FAILOVER_STATE_WAIT_PROMOTION</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SENTINEL-FAILOVER-STATE-RECONF-SLAVES"><span class="toc-number">2.4.5.</span> <span class="toc-text">SENTINEL_FAILOVER_STATE_RECONF_SLAVES</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sentinelHandleRedisInstance"><span class="toc-number">3.</span> <span class="toc-text">sentinelHandleRedisInstance</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&text=剖析REDIS的sentinel"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&title=剖析REDIS的sentinel"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&is_video=false&description=剖析REDIS的sentinel"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS的sentinel&body=Check out this article: https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&title=剖析REDIS的sentinel"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&title=剖析REDIS的sentinel"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&title=剖析REDIS的sentinel"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&title=剖析REDIS的sentinel"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&name=剖析REDIS的sentinel&description=&lt;p&gt;replication中解决了主从同步的问题，sentinel解决两个问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当前各个主从服务器运行状态&lt;/li&gt;
&lt;li&gt;如果主服务器出现故障，怎么转移故障&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/02/05/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/sentinel/&t=剖析REDIS的sentinel"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
