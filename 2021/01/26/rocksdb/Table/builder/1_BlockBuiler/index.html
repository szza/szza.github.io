<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="TableBlockBased Table Format在 Rocksdb 中，BlockBased Table 是 SST 默认的 table 格式。SST文件默认的格式如下： 123456789101112131415&lt;beginning_of_file&gt;[data block 1][data block 2]...[data block N][meta block 1: filt">
<meta property="og:type" content="article">
<meta property="og:title" content="DataBlock 源码剖析">
<meta property="og:url" content="https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="TableBlockBased Table Format在 Rocksdb 中，BlockBased Table 是 SST 默认的 table 格式。SST文件默认的格式如下： 123456789101112131415&lt;beginning_of_file&gt;[data block 1][data block 2]...[data block N][meta block 1: filt">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-01-26T06:15:35.000Z">
<meta property="article:modified_time" content="2023-07-31T14:33:38.000Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="RocksDB">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>DataBlock 源码剖析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/01/26/Redis/InputBuffer/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/01/26/Redis/Networking/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&text=DataBlock 源码剖析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&title=DataBlock 源码剖析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&is_video=false&description=DataBlock 源码剖析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=DataBlock 源码剖析&body=Check out this article: https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&title=DataBlock 源码剖析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&title=DataBlock 源码剖析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&title=DataBlock 源码剖析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&title=DataBlock 源码剖析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&name=DataBlock 源码剖析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&t=DataBlock 源码剖析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Table"><span class="toc-number">1.</span> <span class="toc-text">Table</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockBased-Table-Format"><span class="toc-number">1.1.</span> <span class="toc-text">BlockBased Table Format</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DataBlock"><span class="toc-number">1.3.</span> <span class="toc-text">DataBlock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataBlockHashIndexBuilder"><span class="toc-number">1.3.1.</span> <span class="toc-text">DataBlockHashIndexBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#store-amp-query"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">store &amp; query</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DataBlockHashIndexBuilder-Add"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">DataBlockHashIndexBuilder::Add</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DataBlockHashIndexBuilder-Finish"><span class="toc-number">1.3.1.2.2.</span> <span class="toc-text">DataBlockHashIndexBuilder::Finish</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockBuilder"><span class="toc-number">1.3.2.</span> <span class="toc-text">BlockBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockBuilder-BlockBuilder"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">BlockBuilder::BlockBuilder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockBuilder-Add"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">BlockBuilder::Add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockBuilder-EstimateSizeAfterKV"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">BlockBuilder::EstimateSizeAfterKV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockBuilder-Finish"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">BlockBuilder::Finish</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockHandle"><span class="toc-number">1.3.3.</span> <span class="toc-text">BlockHandle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Refernce"><span class="toc-number">1.4.</span> <span class="toc-text">Refernce</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        DataBlock 源码剖析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-01-26T06:15:35.000Z" itemprop="datePublished">2021-01-26</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/RocksDB-%E5%89%96%E6%9E%90/">RocksDB 剖析</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/RocksDB/" rel="tag">RocksDB</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h1><h2 id="BlockBased-Table-Format"><a href="#BlockBased-Table-Format" class="headerlink" title="BlockBased Table Format"></a>BlockBased Table Format</h2><p>在 Rocksdb 中，BlockBased Table 是 SST 默认的 table 格式。SST文件默认的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beginning_of_file&gt;</span><br><span class="line">[data block 1]</span><br><span class="line">[data block 2]</span><br><span class="line">...</span><br><span class="line">[data block N]</span><br><span class="line">[meta block 1: filter block]                 </span><br><span class="line">[meta block 2: index block]</span><br><span class="line">[meta block 3: compression dictionary block]</span><br><span class="line">[meta block 4: range deletion block]        </span><br><span class="line">[meta block 5: stats block]</span><br><span class="line">...</span><br><span class="line">[meta block K: future extended block]</span><br><span class="line">[metaindex block]</span><br><span class="line">[Footer]</span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure>
<p>[1]  <strong><code>data block</code></strong> : SST文件中的 {key, value} 键值对是按照key有序的存储，并且将key划分到不同 data blocks。这些 data blocks ，从SST文件头部开始并连续存储，每个数据 date block 的格式后面再讲解。</p>
<p>[2 ] <strong><code>meta block</code></strong> : 在 data block 之后 。所谓<code>meta</code>，即信息的信息，用于记录 data block 的相关信息。目前支持的meta block类型如上面的所述。</p>
<p>[3] <strong><code>metaindex block</code></strong> : 用于索引上面的每个<code>meta block</code>，即针对每个meta block， 都有一个 entry 来记录这些 meta block的信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key: meta block name	<span class="comment">// 该meta block 的名字</span></span><br><span class="line">value: BlockHandle*   <span class="comment">// 指向该 meta block</span></span><br></pre></td></tr></table></figure>
<p>[4]  **<code>footer</code> **  :  在SST文件末尾有一个固定长度的footer，主要有三个部分：</p>
<ul>
<li><code>metaindex_hanle</code>：指向 metaindex_handle</li>
<li><code>index_handle</code> : 指向 idnex</li>
<li>Magic number</li>
</ul>
<p>格式如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">metaindex_handle: char[p];      &#x2F;&#x2F; Block handle for metaindex</span><br><span class="line">index_handle:     char[q];      &#x2F;&#x2F; Block handle for index</span><br><span class="line">padding:          char[40-p-q]; &#x2F;&#x2F; zeroed bytes to make fixed length</span><br><span class="line">                                &#x2F;&#x2F; (40&#x3D;&#x3D;2*BlockHandle::kMaxEncodedLength)</span><br><span class="line">magic:            fixed64;      &#x2F;&#x2F; 0x88e241b785f4cff7 (little-endian)</span><br></pre></td></tr></table></figure>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h2 id="DataBlock"><a href="#DataBlock" class="headerlink" title="DataBlock"></a>DataBlock</h2><h3 id="DataBlockHashIndexBuilder"><a href="#DataBlockHashIndexBuilder" class="headerlink" title="DataBlockHashIndexBuilder"></a>DataBlockHashIndexBuilder</h3><p>先来讲解下 DataBlockHashIndexBuilder。</p>
<p>为了降低在一个 DataBlock查询时的 CPU 利用率，Rocksdb 专门为 DataBlock 设计了一个 <code>DataBlockHashIndexBuilder</code> 类，仅支持 <code>BlockBasedTable::Get()</code>  操作时使用。</p>
<blockquote>
<p>图</p>
</blockquote>
<h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><p>现在的 <code>DataBlock</code> 格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DATA_BLOCK: [RI RI RI ... RI RI_IDX HASH_IDX FOOTER]</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li><p><code>RI</code>：<strong>R</strong>estart <strong>I</strong>nterval</p>
</li>
<li><p><code>RD_IDX</code> : <strong>R</strong>estart <strong>I</strong>nterval <strong>I</strong>ndex</p>
</li>
<li><p><code>HASH_IDX</code> : 新的 data-block index 特征</p>
<p>Data-block hash index 的格式如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> HASH_IDX: [B B B ... B NUM_BUCK]</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; B : bucket, 存放 restart index，类型是 uint8_t</span><br><span class="line">&#x2F;&#x2F; NUM_BUCK : bucket 的数量</span><br></pre></td></tr></table></figure>
<p>由于已经使用了两个特殊的 flag ：</p>
<ul>
<li><code>kNoEntry=255</code></li>
<li><code>kCollision=254</code></li>
</ul>
<p>因为，restart interval 的最大数量只有253个。每个bucket的初始化值是 <code>kNoEntry</code> 。</p>
</li>
<li><p> <code>FOOTER </code>: 32 位</p>
</li>
</ul>
<h4 id="store-amp-query"><a href="#store-amp-query" class="headerlink" title="store &amp; query"></a>store &amp; query</h4><p><strong>stroe</strong> : 当在<code>hash index</code> 中存储一个key时，首先将这个key hash 到一个bucket中：</p>
<ul>
<li>如果这个bucket是空的，即 <code>kNoEntry</code>，那么这个<code>key</code>所属的 <code>RI</code> 则存储在这个bucket中；</li>
<li>如果这个bucket已经有元素了，则将已经存在的 <code>RI</code> 更新为 <code>kCollision</code> 标志位，并不会存储 <code>RI</code>。</li>
</ul>
<p><strong>query</strong> : 当查询一个key时，也会先计算这个key经过hash后会落到哪一个bucket。然后检查该 bucket 存储的值，是 <code>kNoEntry</code> 还是  <code>kCollision</code>，如果都不是，则存储的就是该 key 的 <code>RI</code>，直接获取该 <code>RI</code>，那么就可以直接去 <code>RI</code> 并搜索 key。</p>
<blockquote>
<p> <strong>Note</strong>： hash index 中的 <code>RI</code> 的数量必须小于 254，超过的不会创建。</p>
</blockquote>
<p>即，尝试记录每个<code>key</code>所属的<code>restart index</code>，加速查询。</p>
<p>现在我就来看看这个类 <code>DataBlockHashIndexBuilder</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> kNoEntry = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> kCollision = <span class="number">254</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">uint8_t</span> kMaxRestartSupportedByHashIndex = <span class="number">253</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Because we use uint16_t address, we only support block no more than 64KB</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> kMaxBlockSizeSupportedByHashIndex = <span class="number">1u</span> &lt;&lt; <span class="number">16</span>;</span><br><span class="line"><span class="comment">// 此哈希表的默认负载因子</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> kDefaultUtilRatio = <span class="number">0.75</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataBlockHashIndexBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  DataBlockHashIndexBuilder()</span><br><span class="line">      : bucket_per_key_(<span class="number">-1</span> <span class="comment">/*uninitialized marker*/</span>),</span><br><span class="line">        estimated_num_buckets_(<span class="number">0</span>),</span><br><span class="line">        valid_(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Initialize</span><span class="params">(<span class="keyword">double</span> util_ratio)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (util_ratio &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">      util_ratio = kDefaultUtilRatio;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每个 bucket 能容纳的 key 数量</span></span><br><span class="line">    bucket_per_key_ = <span class="number">1</span> / util_ratio;</span><br><span class="line">    valid_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/// 这个 HashIndexBuilder 是否可用</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Valid</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> valid_ &amp;&amp; bucket_per_key_ &gt; <span class="number">0</span>; &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/// 这个 HashIndexBuilder 的大致大小</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">EstimateSize</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint16_t</span> estimated_num_buckets = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint16_t</span>&gt;( estimated_num_buckets_);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Maching the num_buckets number in DataBlockHashIndexBuilder::Finish.</span></span><br><span class="line">    estimated_num_buckets |= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>) +</span><br><span class="line">           <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(estimated_num_buckets * <span class="keyword">sizeof</span>(<span class="keyword">uint8_t</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 向缓存 hash_and_restart_pairs_ 中添加 &#123;hash_value, ri&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> <span class="keyword">size_t</span> restart_index)</span></span>;</span><br><span class="line">  <span class="comment">/// 将 @c hash_and_restart_pairs_ 中数据 dump 到 buffer 中</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Finish</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; buffer)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> bucket_per_key_;        <span class="comment">// util_ratio_ 的逆</span></span><br><span class="line">  <span class="keyword">double</span> estimated_num_buckets_; <span class="comment">// 添加的key个数 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加的 RI 是否超过 253。如果超过，则此 HashIndex 就不可用了</span></span><br><span class="line">  <span class="keyword">bool</span> valid_;</span><br><span class="line">  <span class="comment">// buckets</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">uint32_t</span>, <span class="keyword">uint8_t</span>&gt;&gt; hash_and_restart_pairs_;</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBlockHashIndex_DataBlockHashTestSmall_Test</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要来看两个函数。</p>
<p><code>Add</code>函数，是先计算出待添加 <code>&#123;key, ri&#125;</code> 中key的 <code>hash_value</code>，然后将<code>&#123;hash_value, ri&#125;</code> 添加到 <code>hash_and_restart_pairs_</code> 中。</p>
<p>在此，可以将<code>hash_and_restart_pairs_</code>理解为缓存。在调用<code>Finish</code>函数时，再将 <code>hash_and_restart_pairs_</code> 的内容给dump到buffer中，供给调用者使用。</p>
<h5 id="DataBlockHashIndexBuilder-Add"><a href="#DataBlockHashIndexBuilder-Add" class="headerlink" title="DataBlockHashIndexBuilder::Add"></a>DataBlockHashIndexBuilder::Add</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DataBlockHashIndexBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> <span class="keyword">size_t</span> restart_index)</span> </span>&#123;</span><br><span class="line">  assert(Valid());</span><br><span class="line">  <span class="comment">// restart_index 不能超过 253</span></span><br><span class="line">  <span class="keyword">if</span> (restart_index &gt; kMaxRestartSupportedByHashIndex) &#123;</span><br><span class="line">    valid_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 计算 key 的hash值</span></span><br><span class="line">  <span class="keyword">uint32_t</span> hash_value = GetSliceHash(key);</span><br><span class="line">  <span class="comment">// 添加一个bucket : &#123;hash_value, RI&#125;</span></span><br><span class="line">  hash_and_restart_pairs_.emplace_back(hash_value, <span class="keyword">static_cast</span>&lt;<span class="keyword">uint8_t</span>&gt;(restart_index));</span><br><span class="line">  estimated_num_buckets_ += bucket_per_key_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="DataBlockHashIndexBuilder-Finish"><a href="#DataBlockHashIndexBuilder-Finish" class="headerlink" title="DataBlockHashIndexBuilder::Finish"></a>DataBlockHashIndexBuilder::Finish</h5><p>输出参数  <code>buffer</code> 最后的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HASH_IDX: [B B B ... B NUM_BUCK]</span><br></pre></td></tr></table></figure>
<p>整个序列有两步：</p>
<ol>
<li>先将 <code>hash_and_restart_pairs_</code> 通过处理，转换到 <code>buckets</code></li>
<li>再将<code>buckets</code> 给序列化到输出参数 <code>buffer</code> 中。</li>
</ol>
<p>代码解释如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DataBlockHashIndexBuilder::Finish</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; buffer)</span> </span>&#123;</span><br><span class="line">  assert(Valid());</span><br><span class="line">  <span class="keyword">uint16_t</span> num_buckets = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint16_t</span>&gt;(estimated_num_buckets_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (num_buckets == <span class="number">0</span>) &#123;</span><br><span class="line">    num_buckets = <span class="number">1</span>;  <span class="comment">// sanity check</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当 num_buckets 是偶数时，内置的 hash 函数不能很好地将不同的key散列到不同的buckets中</span></span><br><span class="line">  <span class="comment">// 因此，将 num_buckets 变为奇数，来避免这个问题</span></span><br><span class="line">  num_buckets |= <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 1. 先将 hash_and_restart_pairs_ 中的record存储到 buckets 中</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; <span class="title">buckets</span><span class="params">(num_buckets, kNoEntry)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : hash_and_restart_pairs_) &#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> hash_value = entry.first;</span><br><span class="line">    <span class="keyword">uint8_t</span> restart_index = entry.second;</span><br><span class="line">    <span class="comment">// 通过 hash_value 计算该 key 在 buckets 中的 index</span></span><br><span class="line">    <span class="keyword">uint16_t</span> buck_idx = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint16_t</span>&gt;(hash_value % num_buckets);</span><br><span class="line">    <span class="keyword">if</span> (buckets[buck_idx] == kNoEntry) &#123;</span><br><span class="line">      <span class="comment">// 如果该 bucket 之前是空的，则存储 RI</span></span><br><span class="line">      buckets[buck_idx] = restart_index;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buckets[buck_idx] != restart_index) &#123;</span><br><span class="line">      <span class="comment">// 否则发生了hash冲突，则标记为 kCollision</span></span><br><span class="line">      buckets[buck_idx] = kCollision;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 再将 buckets 中的数据序列化到 buffer 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint8_t</span> restart_index : buckets) &#123;</span><br><span class="line">    buffer.append(<span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(&amp;restart_index)),</span><br><span class="line">                  <span class="keyword">sizeof</span>(restart_index));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 以 NUM_BUCK 结尾</span></span><br><span class="line">  PutFixed16(&amp;buffer, num_buckets);</span><br><span class="line"></span><br><span class="line">  assert(buffer.size() &lt;= kMaxBlockSizeSupportedByHashIndex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们再来看看 BlockBuilder，用于构建data-block。</p>
<h3 id="BlockBuilder"><a href="#BlockBuilder" class="headerlink" title="BlockBuilder"></a>BlockBuilder</h3><p><code>BlockBuilder</code> 用于构建 data-block 。</p>
<p>每一对<code>&#123;key, value&#125;</code> 即一个<code>entry</code>，一个entry的存储格式如下：</p>
<p>先看下基本的注释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BlockBuilder(<span class="keyword">const</span> BlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> BlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BlockBuilder</span><span class="params">(<span class="keyword">int</span> block_restart_interval,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">bool</span> use_delta_encoding = <span class="literal">true</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">bool</span> use_value_delta_encoding = <span class="literal">false</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                        BlockBasedTableOptions::DataBlockIndexType index_type =</span></span></span><br><span class="line"><span class="function"><span class="params">                            BlockBasedTableOptions::kDataBlockBinarySearch,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">double</span> data_block_hash_table_util_ratio = <span class="number">0.75</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Reset the contents as if the BlockBuilder was just constructed.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    buffer_.clear();</span><br><span class="line">    restarts_.clear();</span><br><span class="line">    restarts_.push_back(<span class="number">0</span>);  <span class="comment">// First restart point is at offset 0</span></span><br><span class="line">    estimate_ = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) + <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    counter_ = <span class="number">0</span>;</span><br><span class="line">    finished_ = <span class="literal">false</span>;</span><br><span class="line">    last_key_.clear();</span><br><span class="line">    <span class="keyword">if</span> (data_block_hash_index_builder_.Valid()) &#123;</span><br><span class="line">      data_block_hash_index_builder_.Reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> buffer_.empty(); &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 将 BlockBuild 中的内容与 buffer 交换</span></span><br><span class="line">  <span class="comment">/// 再 Reset BlockBuilder</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SwapAndReset</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; buffer)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(buffer_, buffer);</span><br><span class="line">    Reset();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 返回当前data-block的近似大小</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">size_t</span> <span class="title">CurrentSizeEstimate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前大小 + 正在创建的 data_block_hash_index_builder_ 大小</span></span><br><span class="line">    <span class="keyword">return</span> estimate_ + (data_block_hash_index_builder_.Valid()</span><br><span class="line">                            ? data_block_hash_index_builder_.EstimateSize()</span><br><span class="line">                            : <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 返回添加了 &#123;key,value&#125; 后此data-block的近似大小</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">EstimateSizeAfterKV</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> <span class="keyword">const</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 添加 &#123;key, value&#125;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">const</span> Slice* <span class="keyword">const</span> delta_value = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将 data-block 序列化到 buffer中，并返回 buffer 的 slice</span></span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span></span>;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> block_restart_interval_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> use_delta_encoding_;		    <span class="comment">//  key 是否使用共享前缀的编码方式</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> use_value_delta_encoding_; <span class="comment">//  value 是否使用共享前缀的编码方式</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> buffer_;              <span class="comment">// 存储这个data-block的数据</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; restarts_;  <span class="comment">// 记录所有的 Restart points (rp) 在 buffer 中偏移量</span></span><br><span class="line">  <span class="keyword">size_t</span> estimate_;									<span class="comment">// restarts_ 的大小</span></span><br><span class="line">  <span class="keyword">int</span> counter_;                     <span class="comment">// 当前 rp 添加的 key 数</span></span><br><span class="line">  <span class="keyword">bool</span> finished_;                   <span class="comment">// Has Finish() been called?</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> last_key_;					  <span class="comment">// 当前 rp 最后添加的 key</span></span><br><span class="line">  DataBlockHashIndexBuilder data_block_hash_index_builder_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="BlockBuilder-BlockBuilder"><a href="#BlockBuilder-BlockBuilder" class="headerlink" title="BlockBuilder::BlockBuilder"></a>BlockBuilder::BlockBuilder</h4><p>在 <code>BlockBuilder</code> 的构造函数里，可以通过<code>index_type</code>来选择是否开启<code>DataBlockHashIndexBuilder</code>，来降低 CPU 利用率。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BlockBuilder::BlockBuilder(<span class="keyword">int</span> block_restart_interval, </span><br><span class="line">                           <span class="keyword">bool</span> use_delta_encoding,</span><br><span class="line">                           <span class="keyword">bool</span> use_value_delta_encoding,</span><br><span class="line">                           BlockBasedTableOptions::DataBlockIndexType index_type,</span><br><span class="line">                           <span class="keyword">double</span> data_block_hash_table_util_ratio)</span><br><span class="line">    : block_restart_interval_(block_restart_interval),</span><br><span class="line">      use_delta_encoding_(use_delta_encoding),</span><br><span class="line">      use_value_delta_encoding_(use_value_delta_encoding),</span><br><span class="line">      restarts_(),</span><br><span class="line">      counter_(<span class="number">0</span>),</span><br><span class="line">      finished_(<span class="literal">false</span>) &#123;</span><br><span class="line">  <span class="keyword">switch</span> (index_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> BlockBasedTableOptions::kDataBlockBinarySearch:  <span class="comment">// 传统的二分查找key</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> BlockBasedTableOptions::kDataBlockBinaryAndHash: <span class="comment">// hash + 二分查找</span></span><br><span class="line">      data_block_hash_index_builder_.Initialize(data_block_hash_table_util_ratio);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      assert(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert(block_restart_interval_ &gt;= <span class="number">1</span>);</span><br><span class="line">  restarts_.push_back(<span class="number">0</span>);  <span class="comment">// First restart point is at offset 0</span></span><br><span class="line">  estimate_ = <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>) + <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BlockBuilder-Add"><a href="#BlockBuilder-Add" class="headerlink" title="BlockBuilder::Add"></a>BlockBuilder::Add</h4><p>向这个 data-block 中添加一对 <code>&#123;key, value&#125;</code>时，为了降低内存使用率，rocksb会<strong>压缩前缀</strong>：如果当前<code>key</code> 与前一个<code>last_key</code>存在公共前缀，设公共前缀大小为 <code>shared</code>，那么rocksdb 将不会存储这个<code>shared</code>个字节。</p>
<p>但是有两种情况，rocksdb会完整地存储一个<code>key</code>：</p>
<ol>
<li><code>shared == 0</code>：即当前<code>key</code>与前一个<code>last_key</code>不存在公共部门。很自然，要全部完全地存储<code>key</code>；</li>
<li><code>counter_ &gt;= block_restart_interval_</code>：其中<code>block_restart_interval_</code>是能连续压缩前缀的最大key数， <code>counter_</code> 是当前已经以压缩前缀存储的key的数量，如果<code>counter_</code> 超过阈值，则下一个<code>next_key</code> 即便与<code>key</code>存在公共前缀，也不会压缩<code>next_key</code>前缀的方式来存储。</li>
</ol>
<p>在rocksdb里，把这种压缩前缀的存储方式叫做<code>delta encoding</code>，把要完整存储一个key的地址叫做 <code>restart point</code>。这样，在查询这个key时，先定位到这个key所属的<code>restart point</code>，然后线性搜索该key，可以降低时间复杂度。</p>
<blockquote>
<p>由于存在线性搜索，因此要设计一个 <code>block_restart_interval_</code>。</p>
</blockquote>
<p>当key使用<code>delta encoding</code>时，即 <code>used_delta_encoding_ == true</code>，一对<code>&#123;key, value&#125;</code>的存储格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;An entry for a particular key-value pair has the form:</span><br><span class="line">&#x2F;&#x2F;     shared_bytes: varint32</span><br><span class="line">&#x2F;&#x2F;     unshared_bytes: varint32</span><br><span class="line">&#x2F;&#x2F;     value_length: varint32</span><br><span class="line">&#x2F;&#x2F;     key_delta: char[unshared_bytes]</span><br><span class="line">&#x2F;&#x2F;     value: char[value_length]</span><br><span class="line">&#x2F;&#x2F; shared_bytes &#x3D;&#x3D; 0 for restart points.</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; The trailer of the block has the form:</span><br><span class="line">&#x2F;&#x2F;     restarts: uint32[num_restarts]</span><br><span class="line">&#x2F;&#x2F;     num_restarts: uint32</span><br><span class="line">&#x2F;&#x2F; restarts[i] contains the offset within the block of the ith restart point.</span><br></pre></td></tr></table></figure>
<p>当对<code>value</code>也使用<code>delta encoding</code>时，即 <code>use_value_delta_encoding_ == true</code>，此时必须存储格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;An entry for a particular key-value pair has the form:</span><br><span class="line">&#x2F;&#x2F; if shared !&#x3D; 0:</span><br><span class="line">&#x2F;&#x2F;     shared_bytes: varint32</span><br><span class="line">&#x2F;&#x2F;     unshared_bytes: varint32</span><br><span class="line">&#x2F;&#x2F;     key_delta: char[unshared_bytes]</span><br><span class="line">&#x2F;&#x2F;     delta_value: char[]</span><br><span class="line">&#x2F;&#x2F; else:</span><br><span class="line">&#x2F;&#x2F;     0: varint32</span><br><span class="line">&#x2F;&#x2F;     key_length: varint32</span><br><span class="line">&#x2F;&#x2F;     key: char[key_length]</span><br><span class="line">&#x2F;&#x2F;     value: char[]</span><br></pre></td></tr></table></figure>
<p>因此在<code>use_value_delta_encoding_ == true</code> 时，可以通过 <code>shared == 0</code> 来判断当前key的编码方式：</p>
<ul>
<li><code>shared != 0</code>：说明是<code>delta encoding</code>；</li>
<li><code>shared == 0</code>：说明是个<code>restart point</code>，此时 <code>value</code> 也不必使用<code>delta encoding</code>。</li>
</ul>
<blockquote>
<p>TODO：关注下读取的时候</p>
</blockquote>
<p>最后，通过 <code>data_block_hash_index_builder_</code> 来加速索引，将每个 <code>key</code> 映射到所属的 <code>rp</code>。</p>
<p>下面通过代码注释来理解上面的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> Slice* <span class="keyword">const</span> delta_value)</span> </span>&#123;</span><br><span class="line">  assert(!finished_);</span><br><span class="line">  assert(counter_ &lt;= block_restart_interval_);</span><br><span class="line">  assert(!use_value_delta_encoding_ || delta_value);</span><br><span class="line">  <span class="keyword">size_t</span> shared = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 超过阈值：当前rp下不能继续添加 key</span></span><br><span class="line">  <span class="keyword">if</span> (counter_ &gt;= block_restart_interval_) &#123;</span><br><span class="line">    <span class="comment">// Restart compression</span></span><br><span class="line">    restarts_.push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(buffer_.size())); <span class="comment">// 新的rp在 buffer 中的起始偏移量</span></span><br><span class="line">    estimate_ += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line">    counter_ = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">    <span class="keyword">if</span> (use_delta_encoding_) &#123;</span><br><span class="line">      last_key_.assign(key.data(), key.size()); <span class="comment">// 记录当前rp的第一个key</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (use_delta_encoding_) &#123; </span><br><span class="line">    Slice last_key_piece(last_key_);</span><br><span class="line">    <span class="comment">// 计算当前 key 和当前 rp 最后一个key的公共前缀</span></span><br><span class="line">    shared = key.difference_offset(last_key_piece);</span><br><span class="line"></span><br><span class="line">	  <span class="comment">// 更新当前rp最后的key</span></span><br><span class="line">    last_key_.assign(key.data(), key.size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> non_shared = key.size() - shared;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> curr_size = buffer_.size();</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">if</span> (use_value_delta_encoding_) &#123;</span><br><span class="line">    <span class="comment">// Add &quot;&lt;shared&gt;&lt;non_shared&gt;&quot; to buffer_</span></span><br><span class="line">    PutVarint32Varint32(&amp;buffer_, </span><br><span class="line">                        <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(shared),</span><br><span class="line">                        <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(non_shared));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Add &quot;&lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&quot; to buffer_</span></span><br><span class="line">    PutVarint32Varint32Varint32(&amp;buffer_, </span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(shared),</span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(non_shared),</span><br><span class="line">                                <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(value.size()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  buffer_.append(key.data() + shared, non_shared);</span><br><span class="line">  <span class="comment">// 只有在 shared !=0 时，才使用 value delta encoding；</span></span><br><span class="line">  <span class="comment">// 因为对 restart point 使用 delta_encoding 无意义</span></span><br><span class="line">  <span class="keyword">if</span> (shared != <span class="number">0</span> &amp;&amp; use_value_delta_encoding_) &#123;</span><br><span class="line">    <span class="comment">// &lt;shared&gt;&lt;non_shared&gt;&lt;delta_key&gt;&lt;delta_value&gt;</span></span><br><span class="line">    buffer_.append(delta_value-&gt;data(), delta_value-&gt;size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// &lt;shared&gt;&lt;non_shared&gt;&lt;value_size&gt;&lt;key&gt;&lt;value&gt;</span></span><br><span class="line">    buffer_.append(value.data(), value.size());</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 为key建立hash索引</span></span><br><span class="line">  <span class="keyword">if</span> (data_block_hash_index_builder_.Valid()) &#123;</span><br><span class="line">    data_block_hash_index_builder_.Add(ExtractUserKey(key), restarts_.size() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  counter_++;</span><br><span class="line">  estimate_ += buffer_.size() - curr_size; <span class="comment">// 增加了 &#123;k, v&#125; 序列化后的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BlockBuilder-EstimateSizeAfterKV"><a href="#BlockBuilder-EstimateSizeAfterKV" class="headerlink" title="BlockBuilder::EstimateSizeAfterKV"></a>BlockBuilder::EstimateSizeAfterKV</h4><p><code>EstimateSizeAfterKV</code> 函数，计算添加<code>&#123;k, v&#125;</code>之后的大小，但是这个计算结果是偏大的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">BlockBuilder::EstimateSizeAfterKV</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> estimate = CurrentSizeEstimate(); </span><br><span class="line">  <span class="comment">// 计算的是key的大小，而不是non-shared，因此 estimate 是近似的</span></span><br><span class="line">  estimate += key.size();</span><br><span class="line">  <span class="comment">// 传入的 value 是 BlockHandle 的序列化表示</span></span><br><span class="line">  <span class="comment">// 在 use_value_delta_encoding_ 为 true 时，只有 BlockHandle 的 size 字段被编码了</span></span><br><span class="line">  <span class="comment">// 刚好是一半 ？？？</span></span><br><span class="line">  estimate +=</span><br><span class="line">      !use_value_delta_encoding_ || (counter_ &gt;= block_restart_interval_)</span><br><span class="line">          ? value.size()</span><br><span class="line">          : value.size() / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (counter_ &gt;= block_restart_interval_) &#123;</span><br><span class="line">    estimate += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);  <span class="comment">// a new restart entry.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  estimate += <span class="keyword">sizeof</span>(<span class="keyword">int32_t</span>);   <span class="comment">// varint for shared prefix length.</span></span><br><span class="line">  <span class="comment">// Note: this is an imprecise estimate as we will have to encoded size, one</span></span><br><span class="line">  <span class="comment">// for shared key and one for non-shared key.</span></span><br><span class="line">  estimate += VarintLength(key.size());  <span class="comment">// varint for key length.</span></span><br><span class="line">  <span class="keyword">if</span> (!use_value_delta_encoding_ || (counter_ &gt;= block_restart_interval_)) &#123;</span><br><span class="line">    estimate += VarintLength(value.size());  <span class="comment">// varint for value length.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> estimate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BlockBuilder-Finish"><a href="#BlockBuilder-Finish" class="headerlink" title="BlockBuilder::Finish"></a>BlockBuilder::Finish</h4><p>由于调用 <code>BlockBuilder::Add</code> 时，已经将 <code>&#123;key, value&#125;</code> 都序列化完毕，到调用 <code>Finsh</code> 函数时，只需要在<code>buffer</code> 中添加一些<code>meta info</code>：</p>
<ul>
<li>需要将<code>restarts_</code> 中的记录的 <code>rp</code> 都序列化到 <code>buffer_</code> 中；</li>
<li>如果<code>data_block_hash_index_builder_</code>有效，则将其数据也序列化到 <code>buffer_</code>中；</li>
<li>最后，将<code>&#123;index_type, num_restarts&#125;</code> 序列化到<code>buffer</code>中</li>
</ul>
<p>因此，整个data-block的序列化图如下所示。</p>
<blockquote>
<p>图 </p>
</blockquote>
<p>代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 返回的是这个DataBlock的序列化结果</span></span><br><span class="line"><span class="function">Slice <span class="title">BlockBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将 rp 序列化到 buffer 中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; restarts_.size(); i++) &#123;</span><br><span class="line">    PutFixed32(&amp;buffer_, restarts_[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> num_restarts = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(restarts_.size());</span><br><span class="line">  BlockBasedTableOptions::DataBlockIndexType index_type =</span><br><span class="line">      BlockBasedTableOptions::kDataBlockBinarySearch;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果 开启了 kDataBlockBinaryAndHash</span></span><br><span class="line">  <span class="comment">// 并且 rp 的个数没有超过 kMaxBlockSizeSupportedByHashIndex</span></span><br><span class="line">  <span class="comment">// 则建立 HashIndex</span></span><br><span class="line">  <span class="keyword">if</span> (data_block_hash_index_builder_.Valid() &amp;&amp;</span><br><span class="line">      CurrentSizeEstimate() &lt;= kMaxBlockSizeSupportedByHashIndex) &#123;</span><br><span class="line">    data_block_hash_index_builder_.Finish(buffer_);</span><br><span class="line">    index_type = BlockBasedTableOptions::kDataBlockBinaryAndHash;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成footer</span></span><br><span class="line">  <span class="keyword">uint32_t</span> block_footer = PackIndexTypeAndNumRestarts(index_type, num_restarts);</span><br><span class="line"></span><br><span class="line">  PutFixed32(&amp;buffer_, block_footer);</span><br><span class="line">  finished_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> Slice(buffer_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BlockHandle"><a href="#BlockHandle" class="headerlink" title="BlockHandle"></a>BlockHandle</h3><p><code>BlockHandle</code> 对象<code>block_handle</code>，用于记录一个block的大小及其在SST中的存储的位置。</p>
<p><code>BlockBuilder</code> 存储<code>&#123;k, v&#125;</code>时，其中<code>v</code>即 <code>block_handle</code> 序列化为字符串后的形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockHandle</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BlockHandle()</span><br><span class="line">    : BlockHandle(~<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="number">0</span>), ~<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="number">0</span>)) &#123;&#125;</span><br><span class="line">  BlockHandle(<span class="keyword">uint64_t</span> offset, <span class="keyword">uint64_t</span> size)</span><br><span class="line">    : offset_(_offset), size_(_size) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">offset</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> offset_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">size</span><span class="params">()</span>   <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span>     <span class="title">IsNull</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> offset_ == <span class="number">0</span> &amp;&amp; size_ == <span class="number">0</span>; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_offset</span><span class="params">(<span class="keyword">uint64_t</span> _offset)</span> </span>&#123; offset_ = _offset; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_size</span><span class="params">(<span class="keyword">uint64_t</span> _size)</span> </span>&#123; size_ = _size; &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/// 将这个block的两个字段 &#123;offset, size&#125; 序列化成字符串，</span></span><br><span class="line">  <span class="comment">/// 并保存至 @c dst 中</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EncodeTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    assert(offset_ != ~<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="number">0</span>));</span><br><span class="line">    assert(size_ != ~<span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(<span class="number">0</span>));</span><br><span class="line">    PutVarint64Varint64(dst, offset_, size_);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 这个block的两个字段&#123;offset, size&#125; 内容从 @c input 中获取</span></span><br><span class="line">  <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(Slice* input)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (GetVarint64(input, &amp;offset_) &amp;&amp; GetVarint64(input, &amp;size_)) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status::OK();</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 解析失败</span></span><br><span class="line">    offset_ = <span class="number">0</span>;</span><br><span class="line">    size_ = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Status::Corruption(<span class="string">&quot;bad block handle&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> BlockHandle&amp; <span class="title">NullBlockHandle</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> kNullBlockHandle; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Maximum encoding length of a BlockHandle</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span> kMaxEncodedLength = <span class="number">10</span> + <span class="number">10</span> &#125;;</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> BlockHandle&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> offset_ == rhs.offset_ &amp;&amp; size_ == rhs.size_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> BlockHandle&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !(*<span class="keyword">this</span> == rhs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uint64_t</span> offset_;	<span class="comment">// 该 block 在文件中的起始偏移量</span></span><br><span class="line">  <span class="keyword">uint64_t</span> size_;   <span class="comment">// 该 block 的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> BlockHandle kNullBlockHandle;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> BlockHandle <span class="title">BlockHandle::kNullBlockHandle</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="Refernce"><a href="#Refernce" class="headerlink" title="Refernce"></a>Refernce</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/facebook/rocksdb/wiki/Rocksdb-BlockBasedTable-Format#filter-meta-block">Rocksdb BlockBased Table Format </a></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Table"><span class="toc-number">1.</span> <span class="toc-text">Table</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockBased-Table-Format"><span class="toc-number">1.1.</span> <span class="toc-text">BlockBased Table Format</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.2.</span> <span class="toc-text">源码分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DataBlock"><span class="toc-number">1.3.</span> <span class="toc-text">DataBlock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataBlockHashIndexBuilder"><span class="toc-number">1.3.1.</span> <span class="toc-text">DataBlockHashIndexBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#store-amp-query"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">store &amp; query</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#DataBlockHashIndexBuilder-Add"><span class="toc-number">1.3.1.2.1.</span> <span class="toc-text">DataBlockHashIndexBuilder::Add</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#DataBlockHashIndexBuilder-Finish"><span class="toc-number">1.3.1.2.2.</span> <span class="toc-text">DataBlockHashIndexBuilder::Finish</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockBuilder"><span class="toc-number">1.3.2.</span> <span class="toc-text">BlockBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockBuilder-BlockBuilder"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">BlockBuilder::BlockBuilder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockBuilder-Add"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">BlockBuilder::Add</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockBuilder-EstimateSizeAfterKV"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">BlockBuilder::EstimateSizeAfterKV</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BlockBuilder-Finish"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">BlockBuilder::Finish</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockHandle"><span class="toc-number">1.3.3.</span> <span class="toc-text">BlockHandle</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Refernce"><span class="toc-number">1.4.</span> <span class="toc-text">Refernce</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&text=DataBlock 源码剖析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&title=DataBlock 源码剖析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&is_video=false&description=DataBlock 源码剖析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=DataBlock 源码剖析&body=Check out this article: https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&title=DataBlock 源码剖析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&title=DataBlock 源码剖析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&title=DataBlock 源码剖析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&title=DataBlock 源码剖析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&name=DataBlock 源码剖析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/&t=DataBlock 源码剖析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
