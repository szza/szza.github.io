<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本节分析服务端的发送缓存区 OutputBUffer 设计  将回复客户端的数据添加到 Outputbuffer 发送数据">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析REDIS的输出缓冲区">
<meta property="og:url" content="https://szza.github.io/2021/01/26/Redis/OutputBuffer/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="本节分析服务端的发送缓存区 OutputBUffer 设计  将回复客户端的数据添加到 Outputbuffer 发送数据">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-01-26T06:18:24.000Z">
<meta property="article:modified_time" content="2023-08-26T17:48:00.000Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Redis6.0">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>剖析REDIS的输出缓冲区</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/01/26/Redis/Threads/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/01/26/Redis/InputBuffer/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/01/26/Redis/OutputBuffer/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&text=剖析REDIS的输出缓冲区"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&title=剖析REDIS的输出缓冲区"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&is_video=false&description=剖析REDIS的输出缓冲区"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS的输出缓冲区&body=Check out this article: https://szza.github.io/2021/01/26/Redis/OutputBuffer/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&title=剖析REDIS的输出缓冲区"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&title=剖析REDIS的输出缓冲区"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&title=剖析REDIS的输出缓冲区"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&title=剖析REDIS的输出缓冲区"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&name=剖析REDIS的输出缓冲区&description=&lt;p&gt;本节分析服务端的发送缓存区 &lt;code&gt;OutputBUffer&lt;/code&gt; 设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将回复客户端的数据添加到 &lt;code&gt;Outputbuffer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;发送数据&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&t=剖析REDIS的输出缓冲区"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.</span> <span class="toc-text">添加数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyToBuffer"><span class="toc-number">1.1.</span> <span class="toc-text">_addReplyToBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyProtoToList"><span class="toc-number">1.2.</span> <span class="toc-text">_addReplyProtoToList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#asyncCloseClientOnOutputBufferLimitReached"><span class="toc-number">1.3.</span> <span class="toc-text">asyncCloseClientOnOutputBufferLimitReached</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#checkClientOutputBufferLimits"><span class="toc-number">1.4.</span> <span class="toc-text">checkClientOutputBufferLimits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getClientOutputBufferMemoryUsage"><span class="toc-number">1.5.</span> <span class="toc-text">getClientOutputBufferMemoryUsage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReply"><span class="toc-number">1.6.</span> <span class="toc-text">addReply</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prepareClientToWrite"><span class="toc-number">1.6.1.</span> <span class="toc-text">prepareClientToWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clientInstallWriteHandler"><span class="toc-number">1.6.2.</span> <span class="toc-text">clientInstallWriteHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clientHasPendingReplies"><span class="toc-number">1.6.3.</span> <span class="toc-text">clientHasPendingReplies</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplySds"><span class="toc-number">1.7.</span> <span class="toc-text">addReplySds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyProto"><span class="toc-number">1.8.</span> <span class="toc-text">addReplyProto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyErrorLength"><span class="toc-number">1.9.</span> <span class="toc-text">addReplyErrorLength</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyError"><span class="toc-number">1.9.1.</span> <span class="toc-text">addReplyError</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyErrorFormat"><span class="toc-number">1.9.2.</span> <span class="toc-text">addReplyErrorFormat</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyStatusLength"><span class="toc-number">1.10.</span> <span class="toc-text">addReplyStatusLength</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyStatus"><span class="toc-number">1.10.1.</span> <span class="toc-text">addReplyStatus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyStatusFormat"><span class="toc-number">1.10.2.</span> <span class="toc-text">addReplyStatusFormat</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyDeferredLen"><span class="toc-number">1.11.</span> <span class="toc-text">addReplyDeferredLen</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#trimReplyUnusedTailSpace"><span class="toc-number">1.11.1.</span> <span class="toc-text">trimReplyUnusedTailSpace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setDeferredAggregateLen"><span class="toc-number">1.11.2.</span> <span class="toc-text">setDeferredAggregateLen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setDeferredAggregateLen%E5%BA%94%E7%94%A8"><span class="toc-number">1.11.3.</span> <span class="toc-text">setDeferredAggregateLen应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyDouble"><span class="toc-number">1.12.</span> <span class="toc-text">addReplyDouble</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyHumanLongDouble"><span class="toc-number">1.12.1.</span> <span class="toc-text">addReplyHumanLongDouble</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyLongLongWithPrefix"><span class="toc-number">1.13.</span> <span class="toc-text">addReplyLongLongWithPrefix</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyLongLong"><span class="toc-number">1.13.1.</span> <span class="toc-text">addReplyLongLong</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyNull"><span class="toc-number">1.14.</span> <span class="toc-text">addReplyNull</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyNullArray"><span class="toc-number">1.14.1.</span> <span class="toc-text">addReplyNullArray</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyBulkLen"><span class="toc-number">1.15.</span> <span class="toc-text">addReplyBulkLen</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyBulk"><span class="toc-number">1.15.1.</span> <span class="toc-text">addReplyBulk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyBulkCBuffer"><span class="toc-number">1.15.2.</span> <span class="toc-text">addReplyBulkCBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyBulkSds"><span class="toc-number">1.15.3.</span> <span class="toc-text">addReplyBulkSds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyBulkCString"><span class="toc-number">1.15.4.</span> <span class="toc-text">addReplyBulkCString</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">发送数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#writeToClient"><span class="toc-number">2.1.</span> <span class="toc-text">writeToClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendReplyToClient"><span class="toc-number">2.2.</span> <span class="toc-text">sendReplyToClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleClientsWithPendingWrites"><span class="toc-number">2.3.</span> <span class="toc-text">handleClientsWithPendingWrites</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        剖析REDIS的输出缓冲区
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-01-26T06:18:24.000Z" itemprop="datePublished">2021-01-26</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Redis6-0/" rel="tag">Redis6.0</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>本节分析服务端的发送缓存区 <code>OutputBUffer</code> 设计</p>
<ul>
<li>将回复客户端的数据添加到 <code>Outputbuffer</code></li>
<li>发送数据</li>
</ul>
<span id="more"></span>

<h2 id="添加数据"><a href="#添加数据" class="headerlink" title="添加数据"></a>添加数据</h2><p>在 <code>client</code> 中和发送有关的字段:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTO_REPLY_CHUNK_BYTES (16*1024) <span class="comment">/* 16k output buffer */</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">client</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    list* reply;           				<span class="comment">// 动态 output buffer</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> reply_bytes;  	 <span class="comment">// reply 中所有节点的字节数</span></span><br><span class="line">    <span class="type">size_t</span> sentlen;        				<span class="comment">// 当前缓冲区中已经发送的字节数</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	</span><br><span class="line">    <span class="type">int</span> bufpos;				       		<span class="comment">// buf 中的字节数</span></span><br><span class="line">    <span class="type">char</span> buf[PROTO_REPLY_CHUNK_BYTES]; 	  <span class="comment">// 静态缓冲区 static buffer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一般存储数据，都是先使用静态缓冲区<code>buf</code>，大小是16K，<code>buf</code>不足时再使用动态缓冲区<code>reply</code>。</p>
<ul>
<li><p><code>reply</code>：动态发送缓冲区，主要是针对当要发送的数据较多，静态缓冲区<code>buf</code>内存不足时就会使用<code>reply</code>。<code>reply</code>链表的节点类型是<code>clientReplyBlock</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">clientReplyBlock</span> &#123;</span><br><span class="line">    <span class="type">size_t</span> size;	<span class="comment">// 这个节点的容量</span></span><br><span class="line">    <span class="type">size_t</span> used;	<span class="comment">// 这个节点已使用的容量</span></span><br><span class="line">    <span class="type">char</span> buf[];     <span class="comment">// 用于存储数据</span></span><br><span class="line">&#125; clientReplyBlock;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="addReplyToBuffer"><a href="#addReplyToBuffer" class="headerlink" title="_addReplyToBuffer"></a>_addReplyToBuffer</h3><p>这个函数向静态缓冲区 <code>buf</code>  中添加数据，能顺利存放在<code>buf</code>中，则返回C_OK，否则返回C_ERR.。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _addReplyToBuffer(client *c, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len) &#123;</span><br><span class="line">    <span class="type">size_t</span> available = <span class="built_in">sizeof</span>(c-&gt;buf)-c-&gt;bufpos;  <span class="comment">// 可用空间</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// CLIENT_CLOSE_AFTER_REPLY 表示将当前客户端 output buffer中数据发送完毕，就关闭，</span></span><br><span class="line">    <span class="comment">// 因此不会再接受新的数据</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there already are entries in the reply list, we cannot</span></span><br><span class="line"><span class="comment">     * add anything more to the static buffer. */</span></span><br><span class="line"> 	<span class="comment">//  c-&gt;reply 存在数据，说明 buf 已经满了</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listLength</span>(c-&gt;reply) &gt; <span class="number">0</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check that the buffer has enough space available for this string. */</span></span><br><span class="line">    <span class="comment">// 查看 buf 是否能容纳当前待存放的数据</span></span><br><span class="line">    <span class="keyword">if</span> (len &gt; available) <span class="keyword">return</span> C_ERR;</span><br><span class="line">	</span><br><span class="line">    <span class="built_in">memcpy</span>(c-&gt;buf+c-&gt;bufpos,s,len); <span class="comment">// 复制到buf中</span></span><br><span class="line">    c-&gt;bufpos +=len;			   <span class="comment">// 改变 bufpos</span></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addReplyProtoToList"><a href="#addReplyProtoToList" class="headerlink" title="_addReplyProtoToList"></a>_addReplyProtoToList</h3><p><code>_addReplyProtoToList</code>函数将在 <strong><code>c-&gt;reply</code></strong> 的尾部创建节点，存储待发送的数据。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加数据到动态内存c-&gt;reply的尾部节点</span></span><br><span class="line"><span class="type">void</span> _addReplyProtoToList(client *c, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len) &#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    listNode *ln = <span class="built_in">listLast</span>(c-&gt;reply);</span><br><span class="line">    clientReplyBlock *tail = ln? <span class="built_in">listNodeValue</span>(ln): <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that &#x27;tail&#x27; may be NULL even if we have a tail node, becuase when</span></span><br><span class="line"><span class="comment">     * addReplyDeferredLen() is used, it sets a dummy node to NULL just</span></span><br><span class="line"><span class="comment">     * fo fill it later, when the size of the bulk length is set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * tail 可能是 NULL，因为在 addReplyDeferredLen() 函数中你会创建一个 dummy node，其值是NULL</span></span><br><span class="line"><span class="comment">     * 因此，即使存在尾部节点，其值也可能是 NULL     </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Append to tail string when possible. */</span></span><br><span class="line">    <span class="comment">// 如果不是NULL， 则尝试直接在尾部存储</span></span><br><span class="line">    <span class="keyword">if</span> (tail) &#123;</span><br><span class="line">        <span class="comment">/* Copy the part we can fit into the tail, and leave the rest for new node */</span></span><br><span class="line">        <span class="type">size_t</span> avail = tail-&gt;size - tail-&gt;used;</span><br><span class="line">        <span class="type">size_t</span> copy = avail &gt;= len? len: avail;  <span class="comment">// 取最小</span></span><br><span class="line">        <span class="built_in">memcpy</span>(tail-&gt;buf + tail-&gt;used, s, copy);</span><br><span class="line">        tail-&gt;used += copy;</span><br><span class="line">        s += copy;</span><br><span class="line">        len -= copy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 注意：在使用了 addReplyDeferredLen() 函数后，tail 是 NULL，因此上面的 if(tail) 不会执行，</span></span><br><span class="line"><span class="comment">     * 		而是直接在下面的 if(len) 分支中创建新的节点接在 tail 后面，而 tail 依然是个 dummy node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 tail是 NULL 或者无法完全存储数据，就需要创建一个新的节点</span></span><br><span class="line">    <span class="keyword">if</span> (len) &#123;</span><br><span class="line">        <span class="comment">/* Create a new node, make sure it is allocated to at least PROTO_REPLY_CHUNK_BYTES */</span></span><br><span class="line">        <span class="type">size_t</span> size = len &lt; PROTO_REPLY_CHUNK_BYTES ? PROTO_REPLY_CHUNK_BYTES : len; <span class="comment">//取最大</span></span><br><span class="line">        tail = <span class="built_in">zmalloc</span>(size + <span class="built_in">sizeof</span>(clientReplyBlock));        <span class="comment">// 创建新的节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">/* take over the allocation&#x27;s internal fragmentation */</span></span><br><span class="line">        tail-&gt;size = <span class="built_in">zmalloc_usable</span>(tail) - <span class="built_in">sizeof</span>(clientReplyBlock);</span><br><span class="line">        tail-&gt;used = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(tail-&gt;buf, s, len);</span><br><span class="line">        <span class="built_in">listAddNodeTail</span>(c-&gt;reply, tail);					<span class="comment">// 新节点添加在 tail 尾</span></span><br><span class="line">        c-&gt;reply_bytes += tail-&gt;size;						<span class="comment">// 更新总的已经分配字节数</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看 c-&gt;reply 是否超出内存限制，如果是，则异步关闭这个客户端</span></span><br><span class="line">    <span class="built_in">asyncCloseClientOnOutputBufferLimitReached</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>asyncCloseClientOnOutputBufferLimitReached</code> 函数是个流量控制，如果对端接受不及时，能快速关闭客户端。</p>
<h3 id="asyncCloseClientOnOutputBufferLimitReached"><a href="#asyncCloseClientOnOutputBufferLimitReached" class="headerlink" title="asyncCloseClientOnOutputBufferLimitReached"></a>asyncCloseClientOnOutputBufferLimitReached</h3><p>先检测是否达到内存限制，如果是则异步关闭客户端。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">asyncCloseClientOnOutputBufferLimitReached</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;conn) <span class="keyword">return</span>;   <span class="comment">/* It is unsafe to free fake clients. */</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">serverAssert</span>(c-&gt;reply_bytes &lt; SIZE_MAX-(<span class="number">1024</span>*<span class="number">64</span>)); <span class="comment">// SIZE_MAX - 1024*64，是因为还有一个 buf，其大小是16k</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;reply_bytes == <span class="number">0</span> || c-&gt;flags &amp; CLIENT_CLOSE_ASAP) <span class="keyword">return</span>; </span><br><span class="line">    <span class="comment">// 如果超过了限制，则关闭</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkClientOutputBufferLimits</span>(c)) &#123;</span><br><span class="line">        sds client = <span class="built_in">catClientInfoString</span>(<span class="built_in">sdsempty</span>(), c);</span><br><span class="line">        <span class="comment">// 异步清除客户端</span></span><br><span class="line">        <span class="built_in">freeClientAsync</span>(c);</span><br><span class="line">        <span class="built_in">serverLog</span>(LL_WARNING,</span><br><span class="line">                  <span class="string">&quot;Client %s scheduled to be closed ASAP for overcoming of output buffer limits.&quot;</span>,</span><br><span class="line">                  client);</span><br><span class="line">        <span class="built_in">sdsfree</span>(client);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用 <code>freeClientAsync</code> 异步关闭客户端，是因为客户端的资源较多，同步关闭可能会阻塞主线程。</p>
<h3 id="checkClientOutputBufferLimits"><a href="#checkClientOutputBufferLimits" class="headerlink" title="checkClientOutputBufferLimits"></a>checkClientOutputBufferLimits</h3><p>检测 <code>c-&gt;reply</code>是否超过硬限制(hard limit)或软限制(soft limit)。是则返回1，否则返回0.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">checkClientOutputBufferLimits</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> soft = <span class="number">0</span>, hard = <span class="number">0</span>, <span class="keyword">class</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> used_mem = <span class="built_in">getClientOutputBufferMemoryUsage</span>(c);  <span class="comment">// 见下面分析</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> = <span class="built_in">getClientType</span>(c);</span><br><span class="line">    <span class="comment">/* For the purpose of output buffer limiting, masters are handled</span></span><br><span class="line"><span class="comment">     * like normal clients. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">class</span> == CLIENT_TYPE_MASTER) <span class="keyword">class</span> = CLIENT_TYPE_NORMAL;</span><br><span class="line">    <span class="comment">// 硬限制</span></span><br><span class="line">    <span class="keyword">if</span> (server.client_obuf_limits[<span class="keyword">class</span>].hard_limit_bytes &amp;&amp;</span><br><span class="line">        used_mem &gt;= server.client_obuf_limits[<span class="keyword">class</span>].hard_limit_bytes)</span><br><span class="line">        hard = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 软限制</span></span><br><span class="line">    <span class="keyword">if</span> (server.client_obuf_limits[<span class="keyword">class</span>].soft_limit_bytes &amp;&amp;</span><br><span class="line">        used_mem &gt;= server.client_obuf_limits[<span class="keyword">class</span>].soft_limit_bytes)</span><br><span class="line">        soft = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to check if the soft limit is reached continuously for the</span></span><br><span class="line"><span class="comment">     * specified amount of seconds. */</span></span><br><span class="line">    <span class="comment">// 对于这个软限制，进行综合考虑，给予客户端一次机会，防止直接就关闭客户端</span></span><br><span class="line">    <span class="keyword">if</span> (soft) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;obuf_soft_limit_reached_time == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是首次达到 soft limit，则记录首次达到的时间，然后忽略这次</span></span><br><span class="line">            c-&gt;obuf_soft_limit_reached_time = server.unixtime;</span><br><span class="line">            soft = <span class="number">0</span>;  <span class="comment">/* First time we see the soft limit reached */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">time_t</span> elapsed = server.unixtime - c-&gt;obuf_soft_limit_reached_time;</span><br><span class="line">            <span class="comment">// 如果第二次达到，并且两次之间的时间差小于阈值 soft_limit_seconds</span></span><br><span class="line">            <span class="comment">// 则认为是第一次 soft limit</span></span><br><span class="line">            <span class="keyword">if</span> (elapsed &lt;= server.client_obuf_limits[<span class="keyword">class</span>].soft_limit_seconds) &#123;</span><br><span class="line">                soft = <span class="number">0</span>; <span class="comment">/* The client still did not reached the max number of</span></span><br><span class="line"><span class="comment">                             seconds for the soft limit to be considered</span></span><br><span class="line"><span class="comment">                             reached. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        c-&gt;obuf_soft_limit_reached_time = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> soft || hard;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="getClientOutputBufferMemoryUsage"><a href="#getClientOutputBufferMemoryUsage" class="headerlink" title="getClientOutputBufferMemoryUsage"></a>getClientOutputBufferMemoryUsage</h3><p>计算 <code>c-&gt;reply</code>这个链表占用总字节大小，即存储数据的缓冲区大小+数据结构大小。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="title">getClientOutputBufferMemoryUsage</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> list_item_size = <span class="built_in">sizeof</span>(listNode) + <span class="built_in">sizeof</span>(clientReplyBlock);</span><br><span class="line">    <span class="comment">// c-&gt;rely_bytes 是内存大小，</span></span><br><span class="line">    <span class="comment">// (list_item_size*listLength(c-&gt;reply)); 是数据结构大小</span></span><br><span class="line">    <span class="keyword">return</span> c-&gt;reply_bytes + (list_item_size*<span class="built_in">listLength</span>(c-&gt;reply));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addReply"><a href="#addReply" class="headerlink" title="addReply"></a>addReply</h3><p><code>addReply</code>函数，将<code>server</code>发送给<code>client</code>的回应添加到发送缓冲区中：先使用静态缓冲区，再使用动态缓冲区。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReply</span><span class="params">(client *c, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prepareClientToWrite</span>(c) != C_OK)  <span class="comment">// 是否有数据回应 client</span></span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">sdsEncodedObject</span>(obj)) &#123;</span><br><span class="line">        <span class="comment">// 是字符串编码，则直接添加到缓冲区中</span></span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,obj-&gt;ptr,<span class="built_in">sdslen</span>(obj-&gt;ptr)) != C_OK) <span class="comment">// 先使用 buf</span></span><br><span class="line">            _addReplyProtoToList(c,obj-&gt;ptr,<span class="built_in">sdslen</span>(obj-&gt;ptr));		<span class="comment">// 再使用 c-&gt;reply</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj-&gt;encoding == OBJ_ENCODING_INT) &#123;</span><br><span class="line">        <span class="comment">/* For integer encoded strings we just convert it into a string</span></span><br><span class="line"><span class="comment">         * using our optimized function, and attach the resulting string</span></span><br><span class="line"><span class="comment">         * to the output buffer. */</span></span><br><span class="line">        <span class="comment">// 是整数编码，则先转换为字符串，再添加到缓冲区中</span></span><br><span class="line">        <span class="type">char</span> buf[<span class="number">32</span>];</span><br><span class="line">        <span class="type">size_t</span> len = <span class="built_in">ll2string</span>(buf,<span class="built_in">sizeof</span>(buf),(<span class="type">long</span>)obj-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (_addReplyToBuffer(c,buf,len) != C_OK)</span><br><span class="line">            _addReplyProtoToList(c,buf,len);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">serverPanic</span>(<span class="string">&quot;Wrong obj-&gt;encoding in addReply()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="prepareClientToWrite"><a href="#prepareClientToWrite" class="headerlink" title="prepareClientToWrite"></a>prepareClientToWrite</h4><p><code>prepareClientToWrite</code>函数，在每次添加数据到output buffer之前都会调用，判断是真的需要需要发送数据给客户端 c。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_LUA 			  	 (1&lt;&lt;8)		<span class="comment">/* This is a non connected client used by Lua */</span> <span class="comment">//假的客户端</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_REPLY_OFF 		 (1&lt;&lt;22)	<span class="comment">/* Don&#x27;t send replies to client. */</span>				 <span class="comment">// 不发送</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_REPLY_SKIP 		 (1&lt;&lt;24)  	<span class="comment">/* Don&#x27;t send just this reply. */</span>				 <span class="comment">// 不发送 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_MASTER 			 (1&lt;&lt;1)  	<span class="comment">/* This client is a master */</span>					</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CLIENT_MASTER_FORCE_REPLY (1&lt;&lt;13)   <span class="comment">/* Queue replies even if is master */</span>				</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prepareClientToWrite</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* If it&#x27;s the Lua client we always return ok without installing any</span></span><br><span class="line"><span class="comment">     * handler since there is no socket at all. */</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_LUA|CLIENT_MODULE)) <span class="keyword">return</span> C_OK;		<span class="comment">// ???</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CLIENT REPLY OFF / SKIP handling: don&#x27;t send replies. */</span> </span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; (CLIENT_REPLY_OFF|CLIENT_REPLY_SKIP)) <span class="keyword">return</span> C_ERR; <span class="comment">// 不发送</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Masters don&#x27;t receive replies, unless CLIENT_MASTER_FORCE_REPLY flag</span></span><br><span class="line"><span class="comment">     * is set. */</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_MASTER) &amp;&amp; !(c-&gt;flags &amp; CLIENT_MASTER_FORCE_REPLY)) <span class="keyword">return</span> C_ERR; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!c-&gt;conn) <span class="keyword">return</span> C_ERR; <span class="comment">/* Fake client for AOF loading. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Schedule the client to write the output buffers to the socket, unless</span></span><br><span class="line"><span class="comment">     * it should already be setup to do so (it has already pending data). */</span></span><br><span class="line">    <span class="comment">// 如果之前的数据已经空了，则重新注册可写事件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">clientHasPendingReplies</span>(c)) <span class="built_in">clientInstallWriteHandler</span>(c);  <span class="comment">// 此处的安装handler，</span></span><br><span class="line">    														   <span class="comment">// 就是设置个标志位 CLIENT_PENDING_WRITE</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Authorize the caller to queue in the output buffer of this client. */</span></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="clientInstallWriteHandler"><a href="#clientInstallWriteHandler" class="headerlink" title="clientInstallWriteHandler"></a>clientInstallWriteHandler</h4><p>设立可写标志 <font bold color="yellow"><code>CLIENT_PENDING_WRITE</code> </font>，并将 客户端<code>c</code>加入到待写队列 <code>server.clients_pending_write</code> 中。<font bold color="yellow"><code>CLIENT_PENDING_WRITE</code> </font>标志位在下面三个函数中被取消：</p>
<ul>
<li><code>unlinkClient</code></li>
<li><code>handleClientsWithPendingWrites</code></li>
<li><code>handleClientsWithPendingWritesUsingThreads</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clientInstallWriteHandler</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Schedule the client to write the output buffers to the socket only</span></span><br><span class="line"><span class="comment">     * if not already done and, for slaves, if the slave can actually receive</span></span><br><span class="line"><span class="comment">     * writes at this stage. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_PENDING_WRITE) &amp;&amp;</span><br><span class="line">        (c-&gt;replstate == REPL_STATE_NONE || (c-&gt;replstate == SLAVE_STATE_ONLINE &amp;&amp; !c-&gt;repl_put_online_on_ack)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Here instead of installing the write handler, we just flag the</span></span><br><span class="line"><span class="comment">         * client and put it into a list of clients that have something</span></span><br><span class="line"><span class="comment">         * to write to the socket.</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 这里没有注册可写事件，而是设置了可写标志位：CLIENT_PENDING_WRITE，</span></span><br><span class="line"><span class="comment">         * 并将客户端 c 加入了待写的链表 server.clients_pending_write 中</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * This way before re-entering the event loop, </span></span><br><span class="line"><span class="comment">         * we can try to directly write to the client sockets avoiding a system call. </span></span><br><span class="line"><span class="comment">         * We&#x27;ll only really install the write handler </span></span><br><span class="line"><span class="comment">         * if we&#x27;ll not be able to write the whole reply at once. */</span></span><br><span class="line">        c-&gt;flags |= CLIENT_PENDING_WRITE; </span><br><span class="line">        <span class="built_in">listAddNodeHead</span>(server.clients_pending_write, c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="clientHasPendingReplies"><a href="#clientHasPendingReplies" class="headerlink" title="clientHasPendingReplies"></a>clientHasPendingReplies</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送缓冲区中是否有数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">clientHasPendingReplies</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c-&gt;bufpos || <span class="built_in">listLength</span>(c-&gt;reply);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addReplySds"><a href="#addReplySds" class="headerlink" title="addReplySds"></a>addReplySds</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接添加 sds 格式的字符串到输出缓冲区，其中 s 会被释放</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplySds</span><span class="params">(client *c, sds s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prepareClientToWrite</span>(c) != C_OK) &#123;</span><br><span class="line">        <span class="comment">/* The caller expects the sds to be free&#x27;d. */</span></span><br><span class="line">        <span class="built_in">sdsfree</span>(s); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_addReplyToBuffer(c,s,<span class="built_in">sdslen</span>(s)) != C_OK)</span><br><span class="line">        _addReplyProtoToList(c,s,<span class="built_in">sdslen</span>(s));</span><br><span class="line">    <span class="built_in">sdsfree</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addReplyProto"><a href="#addReplyProto" class="headerlink" title="addReplyProto"></a>addReplyProto</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接添加指定长度的字符串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyProto</span><span class="params">(client *c, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prepareClientToWrite</span>(c) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_addReplyToBuffer(c,s,len) != C_OK)</span><br><span class="line">        _addReplyProtoToList(c,s,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的回复，都是不带格式的，下面是带有格式的，详情参考<a target="_blank" rel="noopener" href="https://redis.io/topics/protocol">RESP</a>。</p>
<h3 id="addReplyErrorLength"><a href="#addReplyErrorLength" class="headerlink" title="addReplyErrorLength"></a>addReplyErrorLength</h3><p>错误类型，前缀是  **<code>-</code>**，在 <code>-</code>之后，可以加错误码，如果没有则REdis设置为<code>ERR</code>，比如<code>&quot;-Error message\r\n&quot;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyErrorLength</span><span class="params">(client *c, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* If the string already starts with &quot;-...&quot; then the error code</span></span><br><span class="line"><span class="comment">     * is provided by the caller. Otherwise we use &quot;-ERR&quot;. */</span></span><br><span class="line">    <span class="comment">// 如果s中没有包含错误码，则使用-ERR替代，总体格式：-ERR &lt;errorMsg&gt; \r\n</span></span><br><span class="line">    <span class="keyword">if</span> (!len || s[<span class="number">0</span>] != <span class="string">&#x27;-&#x27;</span>) <span class="built_in">addReplyProto</span>(c,<span class="string">&quot;-ERR &quot;</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">addReplyProto</span>(c,s,len);</span><br><span class="line">    <span class="built_in">addReplyProto</span>(c,<span class="string">&quot;\r\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addReplyError"><a href="#addReplyError" class="headerlink" title="addReplyError"></a>addReplyError</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyError</span><span class="params">(client *c, <span class="type">const</span> <span class="type">char</span> *err)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">addReplyErrorLength</span>(c,err,<span class="built_in">strlen</span>(err));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addReplyErrorFormat"><a href="#addReplyErrorFormat" class="headerlink" title="addReplyErrorFormat"></a>addReplyErrorFormat</h4><p>格式化错误，可以传入不定参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyErrorFormat</span><span class="params">(client *c, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> l, j;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap,fmt);</span><br><span class="line">    sds s = <span class="built_in">sdscatvprintf</span>(<span class="built_in">sdsempty</span>(),fmt,ap);</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line">    <span class="comment">/* Make sure there are no newlines in the string, otherwise invalid protocol</span></span><br><span class="line"><span class="comment">     * is emitted. */</span></span><br><span class="line">    l = <span class="built_in">sdslen</span>(s);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; l; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[j] == <span class="string">&#x27;\r&#x27;</span> || s[j] == <span class="string">&#x27;\n&#x27;</span>) s[j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addReplyErrorLength</span>(c, s, <span class="built_in">sdslen</span>(s));</span><br><span class="line">    <span class="built_in">sdsfree</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addReplyStatusLength"><a href="#addReplyStatusLength" class="headerlink" title="addReplyStatusLength"></a>addReplyStatusLength</h3><p>回复客户端的简单字符串都是以 <strong><code>+</code></strong> 开始，以 <code>\r\n</code> 结束，格式是： <code>+Message\r\n</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给客户端回</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyStatusLength</span><span class="params">(client *c, <span class="type">const</span> <span class="type">char</span> *s, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">addReplyProto</span>(c,<span class="string">&quot;+&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">addReplyProto</span>(c,s,len);</span><br><span class="line">    <span class="built_in">addReplyProto</span>(c,<span class="string">&quot;\r\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addReplyStatus"><a href="#addReplyStatus" class="headerlink" title="addReplyStatus"></a>addReplyStatus</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyStatus</span><span class="params">(client *c, <span class="type">const</span> <span class="type">char</span> *status)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">addReplyStatusLength</span>(c,status,<span class="built_in">strlen</span>(status));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="addReplyStatusFormat"><a href="#addReplyStatusFormat" class="headerlink" title="addReplyStatusFormat"></a>addReplyStatusFormat</h4><p>能格式化的回复简单字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyStatusFormat</span><span class="params">(client *c, <span class="type">const</span> <span class="type">char</span> *fmt, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    <span class="built_in">va_start</span>(ap,fmt);</span><br><span class="line">    sds s = <span class="built_in">sdscatvprintf</span>(<span class="built_in">sdsempty</span>(),fmt,ap);</span><br><span class="line">    <span class="built_in">va_end</span>(ap);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">addReplyStatusLength</span>(c,s,<span class="built_in">sdslen</span>(s));</span><br><span class="line">    <span class="built_in">sdsfree</span>(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addReplyDeferredLen"><a href="#addReplyDeferredLen" class="headerlink" title="addReplyDeferredLen"></a>addReplyDeferredLen</h3><p><code>addReplyDeferredLen</code>函数，当不知道即将要添加多少数据到缓冲区中时使用。</p>
<ul>
<li>该函数先调用 <strong><code>trimReplyUnusedTailSpace</code></strong>  裁剪掉 <code>c-&gt;reply</code>尾部节点 <code>tail</code>中多余的空间</li>
<li>在<code>tail</code>后新建一个 <code>dummy node</code>（节点值是<code>NULL</code>），然后在这个 <code>dummy node</code> 节点后面新建节点来存储数据。</li>
<li>结束时，调用函数  **<code>setDeferredAggregateLen</code>**， 将新添数据的行数<code>len</code>（即多少条以<code>\r\n</code>结尾的数据）存储到<code>dummpy node</code>中（除非该len太多需要另作处理）。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="title">addReplyDeferredLen</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Note that we install the write event here even if the object is not</span></span><br><span class="line"><span class="comment">     * ready to be sent, since we are sure that before returning to the</span></span><br><span class="line"><span class="comment">     * event loop setDeferredAggregateLen() will be called. */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">prepareClientToWrite</span>(c) != C_OK) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">trimReplyUnusedTailSpace</span>(c);</span><br><span class="line">    <span class="built_in">listAddNodeTail</span>(c-&gt;reply, <span class="literal">NULL</span>); <span class="comment">/* NULL is our placeholder. */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">listLast</span>(c-&gt;reply); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="trimReplyUnusedTailSpace"><a href="#trimReplyUnusedTailSpace" class="headerlink" title="trimReplyUnusedTailSpace"></a>trimReplyUnusedTailSpace</h4><p>裁剪 <code>c-&gt;reply</code> 尾部节点<code>tail</code>中多余的空间</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">trimReplyUnusedTailSpace</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    listNode *ln = <span class="built_in">listLast</span>(c-&gt;reply);</span><br><span class="line">    clientReplyBlock *tail = ln? <span class="built_in">listNodeValue</span>(ln): <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that &#x27;tail&#x27; may be NULL even if we have a tail node, becuase when</span></span><br><span class="line"><span class="comment">     * addReplyDeferredLen() is used */</span></span><br><span class="line">    <span class="keyword">if</span> (!tail) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We only try to trim the space is relatively high (more than a 1/4 of the allocation), </span></span><br><span class="line"><span class="comment">     * otherwise there&#x27;s a high chance realloc will NOP.</span></span><br><span class="line"><span class="comment">     * Also, to avoid large memmove which happens as part of realloc, we only do</span></span><br><span class="line"><span class="comment">     * that if the used part is small.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了避免产生较多内存碎片：可用内存超过1/4 (说明,大部分内存都被使用了), </span></span><br><span class="line">    <span class="comment">// 并且已使用内存小于 PROTO_REPLY_CHUNK_BYTES，那么就裁剪</span></span><br><span class="line">    <span class="keyword">if</span> (tail-&gt;size - tail-&gt;used &gt; tail-&gt;size / <span class="number">4</span> &amp;&amp;</span><br><span class="line">        tail-&gt;used &lt; PROTO_REPLY_CHUNK_BYTES)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> old_size = tail-&gt;size;</span><br><span class="line">        tail = <span class="built_in">zrealloc</span>(tail, tail-&gt;used + <span class="built_in">sizeof</span>(clientReplyBlock)); </span><br><span class="line">        <span class="comment">/* take over the allocation&#x27;s internal fragmentation (at least for</span></span><br><span class="line"><span class="comment">         * memory usage tracking) */</span></span><br><span class="line">        tail-&gt;size = <span class="built_in">zmalloc_usable</span>(tail) - <span class="built_in">sizeof</span>(clientReplyBlock); </span><br><span class="line">        c-&gt;reply_bytes = c-&gt;reply_bytes + tail-&gt;size - old_size;</span><br><span class="line">        <span class="built_in">listNodeValue</span>(ln) = tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setDeferredAggregateLen"><a href="#setDeferredAggregateLen" class="headerlink" title="setDeferredAggregateLen"></a>setDeferredAggregateLen</h4><p>这是在添加数据结束时使用，将添加了数据的行数<code>len</code>设置在dummy node中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDeferredAggregateLen</span><span class="params">(client *c, <span class="type">void</span> *node, <span class="type">long</span> length, <span class="type">char</span> prefix)</span> </span>&#123;</span><br><span class="line">    listNode *ln = (listNode*)node; <span class="comment">// dummpy node</span></span><br><span class="line">    clientReplyBlock *next;			<span class="comment">// 新添加数据的第一个节点</span></span><br><span class="line">    <span class="type">char</span> lenstr[<span class="number">128</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复给客户端的第一行: c len \r\n</span></span><br><span class="line">    <span class="type">size_t</span> lenstr_len = <span class="built_in">sprintf</span>(lenstr, <span class="string">&quot;%c%ld\r\n&quot;</span>, prefix, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Abort when *node is NULL: when the client should not accept writes</span></span><br><span class="line"><span class="comment">     * we return NULL in addReplyDeferredLen() */</span></span><br><span class="line">    <span class="comment">// node 是NULL 表示不应该发数据给客户端, 比如  prepareClientToWrite 返回 C__ERR</span></span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">serverAssert</span>(!<span class="built_in">listNodeValue</span>(ln));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充 dummy node，其值是NULL，现在为其分配值</span></span><br><span class="line">    <span class="comment">/* Normally we fill this dummy NULL node, added by addReplyDeferredLen(),</span></span><br><span class="line"><span class="comment">     * with a new buffer structure containing the protocol needed to specify</span></span><br><span class="line"><span class="comment">     * the length of the array following. However sometimes when there is</span></span><br><span class="line"><span class="comment">     * little memory to move, we may instead remove this NULL node, and prefix</span></span><br><span class="line"><span class="comment">     * our protocol in the node immediately after to it, in order to save a</span></span><br><span class="line"><span class="comment">     * write(2) syscall later. Conditions needed to do it:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * - The next node is non-NULL,</span></span><br><span class="line"><span class="comment">     * - It has enough room already allocated</span></span><br><span class="line"><span class="comment">     * - And not too large (avoid large memmove) */</span></span><br><span class="line">    <span class="keyword">if</span> (ln-&gt;next != <span class="literal">NULL</span> &amp;&amp; </span><br><span class="line">        (next = <span class="built_in">listNodeValue</span>(ln-&gt;next)) &amp;&amp;</span><br><span class="line">        lenstr_len &lt;= (next-&gt;size - next-&gt;used) &amp;&amp; <span class="comment">// 下一个节点可用大小可容纳 lenser</span></span><br><span class="line">        next-&gt;used &lt; PROTO_REPLY_CHUNK_BYTES * <span class="number">4</span>)   </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1 那么就可以将 lenstr 插入 next-&gt;buf 的头部</span></span><br><span class="line">        <span class="built_in">memmove</span>(next-&gt;buf + lenstr_len, next-&gt;buf, next-&gt;used);</span><br><span class="line">        <span class="built_in">memcpy</span>(next-&gt;buf, lenstr, lenstr_len);</span><br><span class="line">        next-&gt;used += lenstr_len;</span><br><span class="line">        <span class="built_in">listDelNode</span>(c-&gt;reply, ln); <span class="comment">// 将 dummy node删除，那么ln-&gt;next的上一个节点是</span></span><br><span class="line">        						 <span class="comment">// 被 trimReplyUnusedTailSpace 裁剪过的节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Create a new node */</span></span><br><span class="line">        <span class="comment">// 2 否则就创建一个新的缓冲区来存储 len_str，</span></span><br><span class="line">        clientReplyBlock *buf = <span class="built_in">zmalloc</span>(lenstr_len + <span class="built_in">sizeof</span>(clientReplyBlock));</span><br><span class="line">        <span class="comment">/* Take over the allocation&#x27;s internal fragmentation */</span></span><br><span class="line">        buf-&gt;size = <span class="built_in">zmalloc_usable</span>(buf) - <span class="built_in">sizeof</span>(clientReplyBlock);</span><br><span class="line">        buf-&gt;used = lenstr_len;</span><br><span class="line">        <span class="built_in">memcpy</span>(buf-&gt;buf, lenstr, lenstr_len);</span><br><span class="line">        <span class="built_in">listNodeValue</span>(ln) = buf; <span class="comment">// 让这个缓冲区成为这个dummy node的值</span></span><br><span class="line">        c-&gt;reply_bytes += buf-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查看 c-&gt;reply 是否超过限制</span></span><br><span class="line">    <span class="built_in">asyncCloseClientOnOutputBufferLimitReached</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setDeferredAggregateLen应用"><a href="#setDeferredAggregateLen应用" class="headerlink" title="setDeferredAggregateLen应用"></a>setDeferredAggregateLen应用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDeferredArrayLen</span><span class="params">(client *c, <span class="type">void</span> *node, <span class="type">long</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">setDeferredAggregateLen</span>(c,node,length,<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDeferredMapLen</span><span class="params">(client *c, <span class="type">void</span> *node, <span class="type">long</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> prefix = c-&gt;resp == <span class="number">2</span> ? <span class="string">&#x27;*&#x27;</span> : <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;resp == <span class="number">2</span>) length *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setDeferredAggregateLen</span>(c,node,length,prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDeferredSetLen</span><span class="params">(client *c, <span class="type">void</span> *node, <span class="type">long</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> prefix = c-&gt;resp == <span class="number">2</span> ? <span class="string">&#x27;*&#x27;</span> : <span class="string">&#x27;~&#x27;</span>;</span><br><span class="line">    <span class="built_in">setDeferredAggregateLen</span>(c,node,length,prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDeferredAttributeLen</span><span class="params">(client *c, <span class="type">void</span> *node, <span class="type">long</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> prefix = c-&gt;resp == <span class="number">2</span> ? <span class="string">&#x27;*&#x27;</span> : <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;resp == <span class="number">2</span>) length *= <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">setDeferredAggregateLen</span>(c,node,length,prefix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">setDeferredPushLen</span><span class="params">(client *c, <span class="type">void</span> *node, <span class="type">long</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> prefix = c-&gt;resp == <span class="number">2</span> ? <span class="string">&#x27;*&#x27;</span> : <span class="string">&#x27;&gt;&#x27;</span>;</span><br><span class="line">    <span class="built_in">setDeferredAggregateLen</span>(c,node,length,prefix);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addReplyDouble"><a href="#addReplyDouble" class="headerlink" title="addReplyDouble"></a>addReplyDouble</h3><p>在缓冲区中添加一个浮点数。在REdis6.0之前的格式是:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">double_num_len\r\n  <span class="comment"># 第一行是回复的浮点数长度，以 &#x27;$&#x27;开始</span></span></span><br><span class="line">double_num			# 第二行是字符串格式的浮点数</span><br></pre></td></tr></table></figure>

<p>在REdis 6.0开始以后的格式：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">double_num\r\n</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyDouble</span><span class="params">(client *c, <span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isinf</span>(d)) &#123;</span><br><span class="line">        <span class="comment">/* Libc in odd systems (Hi Solaris!) will format infinite in a</span></span><br><span class="line"><span class="comment">         * different way, so better to handle it in an explicit way. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;resp == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">addReplyBulkCString</span>(c, d &gt; <span class="number">0</span> ? <span class="string">&quot;inf&quot;</span> : <span class="string">&quot;-inf&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">addReplyProto</span>(c, </span><br><span class="line">                          d &gt; <span class="number">0</span> ? <span class="string">&quot;,inf\r\n&quot;</span> : <span class="string">&quot;,-inf\r\n&quot;</span>,</span><br><span class="line">                          d &gt; <span class="number">0</span> ? <span class="number">6</span> : <span class="number">7</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> dbuf[MAX_LONG_DOUBLE_CHARS+<span class="number">3</span>], sbuf[MAX_LONG_DOUBLE_CHARS+<span class="number">32</span>]; </span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> dlen, slen;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;resp == <span class="number">2</span>) &#123;</span><br><span class="line">            dlen = <span class="built_in">snprintf</span>(dbuf,<span class="built_in">sizeof</span>(dbuf), <span class="string">&quot;%.17g&quot;</span>, d); </span><br><span class="line">            slen = <span class="built_in">snprintf</span>(sbuf,<span class="built_in">sizeof</span>(sbuf), <span class="string">&quot;$%d\r\n%s\r\n&quot;</span>,dlen,dbuf); </span><br><span class="line">            <span class="built_in">addReplyProto</span>(c,sbuf,slen);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dlen = <span class="built_in">snprintf</span>(dbuf,<span class="built_in">sizeof</span>(dbuf),<span class="string">&quot;,%.17g\r\n&quot;</span>,d);</span><br><span class="line">            <span class="built_in">addReplyProto</span>(c,dbuf,dlen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addReplyHumanLongDouble"><a href="#addReplyHumanLongDouble" class="headerlink" title="addReplyHumanLongDouble"></a>addReplyHumanLongDouble</h4><p>回复客户端 <code>long double</code> 格式的字符串，也区分版本。在REdis6.0之前，是按照批量（<code>bulk</code>）回复字符串格式，即以 <code>$</code> 为前缀，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> *	Simple Strings prefix: &quot;+&quot;</span><br><span class="line"> *	Errors         prefix: &quot;-&quot;</span><br><span class="line"> *	Integers       prefix: &quot;:&quot;</span><br><span class="line"> *	Bulk Strings   prefix: &quot;$&quot;</span><br><span class="line"> *	Arrays         prefix: &quot;*&quot;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>在REdis之后，<code>Long double</code> 是以 <code>,</code> 为前缀。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyHumanLongDouble</span><span class="params">(client *c, <span class="type">long</span> <span class="type">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;resp == <span class="number">2</span>) &#123;</span><br><span class="line">        robj *o = <span class="built_in">createStringObjectFromLongDouble</span>(d, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">addReplyBulk</span>(c,o);</span><br><span class="line">        <span class="built_in">decrRefCount</span>(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">char</span> buf[MAX_LONG_DOUBLE_CHARS];</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">ld2string</span>(buf,<span class="built_in">sizeof</span>(buf),d,LD_STR_HUMAN);</span><br><span class="line">        <span class="built_in">addReplyProto</span>(c,<span class="string">&quot;,&quot;</span>,<span class="number">1</span>);  <span class="comment">// 前缀</span></span><br><span class="line">        <span class="built_in">addReplyProto</span>(c,buf,len);</span><br><span class="line">        <span class="built_in">addReplyProto</span>(c,<span class="string">&quot;\r\n&quot;</span>,<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addReplyLongLongWithPrefix"><a href="#addReplyLongLongWithPrefix" class="headerlink" title="addReplyLongLongWithPrefix"></a>addReplyLongLongWithPrefix</h3><p>以指定前缀回复客户端整数.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyLongLongWithPrefix</span><span class="params">(client *c, <span class="type">long</span> <span class="type">long</span> ll, <span class="type">char</span> prefix)</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Things like $3\r\n or *2\r\n are emitted very often by the protocol</span></span><br><span class="line"><span class="comment">     * so we have a few shared objects to use if the integer is small</span></span><br><span class="line"><span class="comment">     * like it is most of the times. */</span></span><br><span class="line">    <span class="keyword">if</span> (prefix == <span class="string">&#x27;*&#x27;</span> &amp;&amp; <span class="number">0</span> &lt;= ll &amp;&amp; ll &lt; OBJ_SHARED_BULKHDR_LEN) &#123;</span><br><span class="line">        <span class="comment">// 数组格式</span></span><br><span class="line">        <span class="built_in">addReply</span>(c, shared.mbulkhdr[ll]); <span class="comment">// 回复给客户端的是：*ll\r\n</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prefix == <span class="string">&#x27;$&#x27;</span> &amp;&amp; <span class="number">0</span> &lt;= ll &amp;&amp; ll &lt; OBJ_SHARED_BULKHDR_LEN) &#123;</span><br><span class="line">        <span class="comment">// 批量字符串格式</span></span><br><span class="line">        <span class="built_in">addReply</span>(c, shared.bulkhdr[ll]); <span class="comment">// 回复给客户端的是： $llr\n</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非  * $ 类型</span></span><br><span class="line">    buf[<span class="number">0</span>] = prefix;	<span class="comment">// 指定前缀</span></span><br><span class="line">    len = <span class="built_in">ll2string</span>(buf+<span class="number">1</span>, <span class="built_in">sizeof</span>(buf)<span class="number">-1</span>, ll);</span><br><span class="line">    buf[len+<span class="number">1</span>] = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">    buf[len+<span class="number">2</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="built_in">addReplyProto</span>(c,buf,len+<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 <code> shared.mbulkhdr</code>和 <code>shared.bulkhdr</code>在 <code>server.c</code>中如下初始化，前缀分别是 <code>*</code>  和 <code>$</code>，表示数组和批量字符串回复。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in server.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; OBJ_SHARED_BULKHDR_LEN; j++) &#123;</span><br><span class="line">        shared.mbulkhdr[j] = <span class="built_in">createObject</span>(OBJ_STRING, <span class="built_in">sdscatprintf</span>(<span class="built_in">sdsempty</span>(), <span class="string">&quot;*%d\r\n&quot;</span>, j));  <span class="comment">// 前缀是 *</span></span><br><span class="line">        shared.bulkhdr[j]  = <span class="built_in">createObject</span>(OBJ_STRING, <span class="built_in">sdscatprintf</span>(<span class="built_in">sdsempty</span>(), <span class="string">&quot;$%d\r\n&quot;</span>, j));  <span class="comment">// 前缀是 $</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="addReplyLongLong"><a href="#addReplyLongLong" class="headerlink" title="addReplyLongLong"></a>addReplyLongLong</h4><p>整数前缀没有改变，一直是 <code>:</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyLongLong</span><span class="params">(client *c, <span class="type">long</span> <span class="type">long</span> ll)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ll == <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">addReply</span>(c,shared.czero);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ll == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">addReply</span>(c,shared.cone);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">addReplyLongLongWithPrefix</span>(c,ll,<span class="string">&#x27;:&#x27;</span>);  <span class="comment">// 整数前缀 &#x27;:&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addReplyNull"><a href="#addReplyNull" class="headerlink" title="addReplyNull"></a>addReplyNull</h3><p>NULL，在REdis6.0之前是回复 <code>$-1\r\n</code>，之后回复 <code>_\r\n</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyNull</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;resp == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">addReplyProto</span>(c,<span class="string">&quot;$-1\r\n&quot;</span>,<span class="number">5</span>);   <span class="comment">// NULL，在resp2中表示为： $-1\r\n</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">addReplyProto</span>(c,<span class="string">&quot;_\r\n&quot;</span>,<span class="number">3</span>);     <span class="comment">// resp3，_\r\n</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addReplyNullArray"><a href="#addReplyNullArray" class="headerlink" title="addReplyNullArray"></a>addReplyNullArray</h4><p>NULL的数组，之前回复的是 <code>*-1\r\n</code>，现在是 <code>_\r\n</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyNullArray</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;resp == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">addReplyProto</span>(c,<span class="string">&quot;*-1\r\n&quot;</span>,<span class="number">5</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">addReplyProto</span>(c,<span class="string">&quot;_\r\n&quot;</span>,<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addReplyBulkLen"><a href="#addReplyBulkLen" class="headerlink" title="addReplyBulkLen"></a>addReplyBulkLen</h3><p>回复客户端的批量字符串长度，前缀是 <code>$</code>，即 <code>$len\r\n</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> OBJ_SHARED_BULKHDR_LEN 32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyBulkLen</span><span class="params">(client *c, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="type">size_t</span> len = <span class="built_in">stringObjectLen</span>(obj);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (len &lt; OBJ_SHARED_BULKHDR_LEN)</span><br><span class="line">        <span class="built_in">addReply</span>(c,shared.bulkhdr[len]);       <span class="comment">// $</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">addReplyLongLongWithPrefix</span>(c,len,<span class="string">&#x27;$&#x27;</span>); <span class="comment">// 指定 $</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addReplyBulk"><a href="#addReplyBulk" class="headerlink" title="addReplyBulk"></a>addReplyBulk</h4><p>批量回复客户端，格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$len\r\n</span><br><span class="line">message\r\n</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Add a Redis Object as a bulk reply */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyBulk</span><span class="params">(client *c, robj *obj)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">addReplyBulkLen</span>(c,obj);</span><br><span class="line">    <span class="built_in">addReply</span>(c,obj);</span><br><span class="line">    <span class="built_in">addReply</span>(c,shared.crlf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addReplyBulkCBuffer"><a href="#addReplyBulkCBuffer" class="headerlink" title="addReplyBulkCBuffer"></a>addReplyBulkCBuffer</h4><p>指定了长度的批量字符串，回复客户都</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyBulkCBuffer</span><span class="params">(client *c, <span class="type">const</span> <span class="type">void</span> *p, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">addReplyLongLongWithPrefix</span>(c,len,<span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">    <span class="built_in">addReplyProto</span>(c,p,len);</span><br><span class="line">    <span class="built_in">addReply</span>(c,shared.crlf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addReplyBulkSds"><a href="#addReplyBulkSds" class="headerlink" title="addReplyBulkSds"></a>addReplyBulkSds</h4><p>sds格式的批量回复</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyBulkSds</span><span class="params">(client *c, sds s)</span>  </span>&#123;</span><br><span class="line">    <span class="built_in">addReplyLongLongWithPrefix</span>(c,<span class="built_in">sdslen</span>(s),<span class="string">&#x27;$&#x27;</span>);</span><br><span class="line">    <span class="built_in">addReplySds</span>(c,s);</span><br><span class="line">    <span class="built_in">addReply</span>(c,shared.crlf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addReplyBulkCString"><a href="#addReplyBulkCString" class="headerlink" title="addReplyBulkCString"></a>addReplyBulkCString</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将一个c风格的字符串回复给客户端</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addReplyBulkCString</span><span class="params">(client *c, <span class="type">const</span> <span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">addReplyNull</span>(c);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">addReplyBulkCBuffer</span>(c,s,<span class="built_in">strlen</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h2><p>上面的 <code>add*()</code>系列函数只是将数据添加到发送缓冲区中，但是还没发送出去，真正发送数据的函数是 <code>writeToClient</code>，即可写事件的处理函数。</p>
<h3 id="writeToClient"><a href="#writeToClient" class="headerlink" title="writeToClient"></a>writeToClient</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NET_MAX_WRITES_PER_EVENT (1024*64)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">writeToClient</span><span class="params">(client *c, <span class="type">int</span> handler_installed)</span> </span>&#123;</span><br><span class="line">    <span class="type">ssize_t</span> nwritten = <span class="number">0</span>, totwritten = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> objlen;</span><br><span class="line">    clientReplyBlock *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表示客户端缓冲区中有待发送的数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">clientHasPendingReplies</span>(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;bufpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先发送静态缓冲区 c-&gt;buf 中的数据</span></span><br><span class="line">            nwritten = <span class="built_in">connWrite</span>(c-&gt;conn, c-&gt;buf+c-&gt;sentlen, c-&gt;bufpos-c-&gt;sentlen);</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>;   <span class="comment">// 发生错误则跳出循环，在循环外判断错误</span></span><br><span class="line">            c-&gt;sentlen += nwritten;     <span class="comment">// 已经发送的</span></span><br><span class="line">            totwritten += nwritten;     <span class="comment">// 待发送的</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the buffer was sent, set bufpos to zero to continue with</span></span><br><span class="line"><span class="comment">             * the remainder of the reply. */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">int</span>)c-&gt;sentlen == c-&gt;bufpos) &#123;</span><br><span class="line">                c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">                c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 再发送动态缓冲区中的数据:</span></span><br><span class="line">            <span class="comment">//      从头部节点开始发送依次发送,每次发送完一个节点的数据,就将其从 c-&gt;reply 中删除</span></span><br><span class="line">            <span class="comment">//      当 c-&gt;reply 中的所有数据都发送完毕,此时 c-&gt;reply_bytes 也应该是0</span></span><br><span class="line">            o = <span class="built_in">listNodeValue</span>(<span class="built_in">listFirst</span>(c-&gt;reply));</span><br><span class="line">            objlen = o-&gt;used;   <span class="comment">//当前节点的待发送数据长度</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (objlen == <span class="number">0</span>) &#123;</span><br><span class="line">                c-&gt;reply_bytes -= o-&gt;size;</span><br><span class="line">                <span class="built_in">listDelNode</span>(c-&gt;reply, <span class="built_in">listFirst</span>(c-&gt;reply));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            nwritten = <span class="built_in">connWrite</span>(c-&gt;conn, o-&gt;buf + c-&gt;sentlen, objlen - c-&gt;sentlen);</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            c-&gt;sentlen += nwritten;</span><br><span class="line">            totwritten += nwritten;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we fully sent the object on head go to the next one */</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;sentlen == objlen) &#123;</span><br><span class="line">                c-&gt;reply_bytes -= o-&gt;size;</span><br><span class="line">                <span class="built_in">listDelNode</span>(c-&gt;reply,<span class="built_in">listFirst</span>(c-&gt;reply));</span><br><span class="line">                c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">/* If there are no longer objects in the list, we expect</span></span><br><span class="line"><span class="comment">                 * the count of reply bytes to be exactly zero. */</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">listLength</span>(c-&gt;reply) == <span class="number">0</span>)</span><br><span class="line">                    <span class="built_in">serverAssert</span>(c-&gt;reply_bytes == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT bytes, </span></span><br><span class="line"><span class="comment">         * in a single threaded server it&#x27;s a good idea to serve other clients as well, </span></span><br><span class="line"><span class="comment">         * even if a very large request comes from super fast link that is always able to accept data </span></span><br><span class="line"><span class="comment">         * (in real world scenario think about &#x27;KEYS *&#x27; against the loopback interface).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * However if we are over the maxmemory limit we ignore that and</span></span><br><span class="line"><span class="comment">         * just deliver as much data as it is possible to deliver.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Moreover, we also send as much as possible if the client is</span></span><br><span class="line"><span class="comment">         * a slave or a monitor (otherwise, on high-speed traffic, the</span></span><br><span class="line"><span class="comment">         * replication/output buffer will grow indefinitely) */</span></span><br><span class="line">        <span class="comment">// 避免单次发送过多的数据</span></span><br><span class="line">        <span class="keyword">if</span> (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp;</span><br><span class="line">            (server.maxmemory == <span class="number">0</span> || <span class="built_in">zmalloc_used_memory</span>() &lt; server.maxmemory) &amp;&amp; </span><br><span class="line">            !(c-&gt;flags &amp; CLIENT_SLAVE))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="comment">// while-end</span></span><br><span class="line"></span><br><span class="line">    server.stat_net_output_bytes += totwritten; <span class="comment">// 发送的总字节</span></span><br><span class="line">    <span class="comment">// 如果发生错误</span></span><br><span class="line">    <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 这个错误是无伤大雅性质，则忽略</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">connGetState</span>(c-&gt;conn) == CONN_STATE_CONNECTED) &#123;</span><br><span class="line">            nwritten = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则释放客户端</span></span><br><span class="line">            <span class="built_in">serverLog</span>(LL_VERBOSE, <span class="string">&quot;Error writing to client: %s&quot;</span>, <span class="built_in">connGetLastError</span>(c-&gt;conn));</span><br><span class="line">            <span class="built_in">freeClientAsync</span>(c);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (totwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* For clients representing masters we don&#x27;t count sending data</span></span><br><span class="line"><span class="comment">         * as an interaction, since we always send REPLCONF ACK commands</span></span><br><span class="line"><span class="comment">         * that take some time to just fill the socket output buffer.</span></span><br><span class="line"><span class="comment">         * We just rely on data / pings received for timeout detection. */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MASTER)) c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果客户端缓冲区已经没有数据了</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">clientHasPendingReplies</span>(c)) &#123;</span><br><span class="line">        c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* Note that writeToClient() is called in a threaded way, but</span></span><br><span class="line"><span class="comment">         * adDeleteFileEvent() is not thread safe: however writeToClient()</span></span><br><span class="line"><span class="comment">         * is always called with handler_installed set to 0 from threads</span></span><br><span class="line"><span class="comment">         * so we are fine. */</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (handler_installed) <span class="built_in">connSetWriteHandler</span>(c-&gt;conn, <span class="literal">NULL</span>);   <span class="comment">// handler_installed 设置为1，</span></span><br><span class="line">        													    <span class="comment">// 则在 output buffer 发送完时，</span></span><br><span class="line">        													    <span class="comment">// 取消注册可写事件，防止busy loop</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Close connection after entire reply has been sent. */</span></span><br><span class="line">        <span class="comment">// 缓冲区中的数据都被发送了，并且设置了标志位 CLIENT_CLOSE_AFTER_REPLY， 就关闭客户端</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) &#123;</span><br><span class="line">            <span class="built_in">freeClientAsync</span>(c);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面 标志位<font color="yellow"> CLIENT_CLOSE_AFTER_REPLY</font>，只是在客户端因为某些指令或者问题要关闭时才会设置。正好在设置了之后，发送缓冲区中的数据发送完毕，则直接调用 <code>freeClientAsync</code> 关闭客户端。</p>
<h3 id="sendReplyToClient"><a href="#sendReplyToClient" class="headerlink" title="sendReplyToClient"></a>sendReplyToClient</h3><p>用于当直接调用 <code>writeToClient</code> 函数，没有将发送缓冲区中数据发送完毕时，注册可写事件， <code>sendReplyToClient</code>作为此时的可写事件处理函数，因为这次会将发送缓冲区中的数据发送完，需要取消注册可写事件，因此 <code>writeToClient</code>的第二个参数设置为1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Write event handler. Just send data to the client. */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sendReplyToClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *c = <span class="built_in">connGetPrivateData</span>(conn);</span><br><span class="line">    <span class="built_in">writeToClient</span>(c,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="handleClientsWithPendingWrites"><a href="#handleClientsWithPendingWrites" class="headerlink" title="handleClientsWithPendingWrites"></a>handleClientsWithPendingWrites</h3><p>函数 <code>handleClientsWithPendingWrites</code>，每次在 <code>epoll_wait</code> 之前的 <code>beforeSleep()</code> 中执行。这个函数是主动行为，即每次在 <code>epoll_wait</code>之前都会先发送一次数据。如果没有发送完，则注册可写事件，并设置回调函数为  <code>sendReplyToClient</code>，在即将阻塞的 <code>epll_wait</code>中等待事件触发。</p>
<p>此外，标志位 <font color="yellow">CLIENT_PENDING_WRITE</font> 在函数 <code>clientInstallWriteHandler</code>中设置的，在发送完数据后取消标志位。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">handleClientsWithPendingWrites</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="type">int</span> processed = <span class="built_in">listLength</span>(server.clients_pending_write);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 遍历每个缓冲区数据待发送的客户端</span></span><br><span class="line">    <span class="built_in">listRewind</span>(server.clients_pending_write,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = <span class="built_in">listNext</span>(&amp;li))) &#123;</span><br><span class="line">        client *c = <span class="built_in">listNodeValue</span>(ln);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_PENDING_WRITE;  <span class="comment">// 去掉标志位 CLIENT_PENDING_WRITE，表示数据已经发送</span></span><br><span class="line">        <span class="built_in">listDelNode</span>(server.clients_pending_write, ln);	 <span class="comment">// 将当前客户端从 </span></span><br><span class="line">        											 <span class="comment">// server.clients_pending_write 中删除</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">/* If a client is protected, don&#x27;t do anything,</span></span><br><span class="line"><span class="comment">         * that may trigger write error or recreate handler. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PROTECTED) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Try to write buffers to the client socket. */</span></span><br><span class="line">        <span class="comment">// 将这个客户端的 output buffer 发送给客户端</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">writeToClient</span>(c,<span class="number">0</span>) == C_ERR) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If after the synchronous writes above we still have data to</span></span><br><span class="line"><span class="comment">         * output to the client, we need to install the writable handler. */</span></span><br><span class="line">        <span class="comment">// 如果还有数据待发送,则需要注册可写事件,等待可写事件的到来</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">clientHasPendingReplies</span>(c)) &#123;</span><br><span class="line">            <span class="type">int</span> ae_barrier = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* For the fsync=always policy, we want that a given FD is never</span></span><br><span class="line"><span class="comment">             * served for reading and writing in the same event loop iteration,</span></span><br><span class="line"><span class="comment">             * so that in the middle of receiving the query, and serving it</span></span><br><span class="line"><span class="comment">             * to the client, we&#x27;ll call beforeSleep() that will do the</span></span><br><span class="line"><span class="comment">             * actual fsync of AOF to disk. the write barrier ensures that. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_state == AOF_ON &amp;&amp;</span><br><span class="line">                server.aof_fsync == AOF_FSYNC_ALWAYS)</span><br><span class="line">            &#123;</span><br><span class="line">                ae_barrier = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 关注可写事件,并设置可写事件处理函数 sendReplyToClient</span></span><br><span class="line">            <span class="comment">// 在即将阻塞的 poll_wait 中等待可写事件触发</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">connSetWriteHandlerWithBarrier</span>(c-&gt;conn, sendReplyToClient, ae_barrier) == C_ERR) &#123;</span><br><span class="line">                <span class="built_in">freeClientAsync</span>(c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.</span> <span class="toc-text">添加数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyToBuffer"><span class="toc-number">1.1.</span> <span class="toc-text">_addReplyToBuffer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyProtoToList"><span class="toc-number">1.2.</span> <span class="toc-text">_addReplyProtoToList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#asyncCloseClientOnOutputBufferLimitReached"><span class="toc-number">1.3.</span> <span class="toc-text">asyncCloseClientOnOutputBufferLimitReached</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#checkClientOutputBufferLimits"><span class="toc-number">1.4.</span> <span class="toc-text">checkClientOutputBufferLimits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getClientOutputBufferMemoryUsage"><span class="toc-number">1.5.</span> <span class="toc-text">getClientOutputBufferMemoryUsage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReply"><span class="toc-number">1.6.</span> <span class="toc-text">addReply</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prepareClientToWrite"><span class="toc-number">1.6.1.</span> <span class="toc-text">prepareClientToWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clientInstallWriteHandler"><span class="toc-number">1.6.2.</span> <span class="toc-text">clientInstallWriteHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clientHasPendingReplies"><span class="toc-number">1.6.3.</span> <span class="toc-text">clientHasPendingReplies</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplySds"><span class="toc-number">1.7.</span> <span class="toc-text">addReplySds</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyProto"><span class="toc-number">1.8.</span> <span class="toc-text">addReplyProto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyErrorLength"><span class="toc-number">1.9.</span> <span class="toc-text">addReplyErrorLength</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyError"><span class="toc-number">1.9.1.</span> <span class="toc-text">addReplyError</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyErrorFormat"><span class="toc-number">1.9.2.</span> <span class="toc-text">addReplyErrorFormat</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyStatusLength"><span class="toc-number">1.10.</span> <span class="toc-text">addReplyStatusLength</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyStatus"><span class="toc-number">1.10.1.</span> <span class="toc-text">addReplyStatus</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyStatusFormat"><span class="toc-number">1.10.2.</span> <span class="toc-text">addReplyStatusFormat</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyDeferredLen"><span class="toc-number">1.11.</span> <span class="toc-text">addReplyDeferredLen</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#trimReplyUnusedTailSpace"><span class="toc-number">1.11.1.</span> <span class="toc-text">trimReplyUnusedTailSpace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setDeferredAggregateLen"><span class="toc-number">1.11.2.</span> <span class="toc-text">setDeferredAggregateLen</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setDeferredAggregateLen%E5%BA%94%E7%94%A8"><span class="toc-number">1.11.3.</span> <span class="toc-text">setDeferredAggregateLen应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyDouble"><span class="toc-number">1.12.</span> <span class="toc-text">addReplyDouble</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyHumanLongDouble"><span class="toc-number">1.12.1.</span> <span class="toc-text">addReplyHumanLongDouble</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyLongLongWithPrefix"><span class="toc-number">1.13.</span> <span class="toc-text">addReplyLongLongWithPrefix</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyLongLong"><span class="toc-number">1.13.1.</span> <span class="toc-text">addReplyLongLong</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyNull"><span class="toc-number">1.14.</span> <span class="toc-text">addReplyNull</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyNullArray"><span class="toc-number">1.14.1.</span> <span class="toc-text">addReplyNullArray</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#addReplyBulkLen"><span class="toc-number">1.15.</span> <span class="toc-text">addReplyBulkLen</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyBulk"><span class="toc-number">1.15.1.</span> <span class="toc-text">addReplyBulk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyBulkCBuffer"><span class="toc-number">1.15.2.</span> <span class="toc-text">addReplyBulkCBuffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyBulkSds"><span class="toc-number">1.15.3.</span> <span class="toc-text">addReplyBulkSds</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyBulkCString"><span class="toc-number">1.15.4.</span> <span class="toc-text">addReplyBulkCString</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE"><span class="toc-number">2.</span> <span class="toc-text">发送数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#writeToClient"><span class="toc-number">2.1.</span> <span class="toc-text">writeToClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendReplyToClient"><span class="toc-number">2.2.</span> <span class="toc-text">sendReplyToClient</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#handleClientsWithPendingWrites"><span class="toc-number">2.3.</span> <span class="toc-text">handleClientsWithPendingWrites</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/01/26/Redis/OutputBuffer/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&text=剖析REDIS的输出缓冲区"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&title=剖析REDIS的输出缓冲区"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&is_video=false&description=剖析REDIS的输出缓冲区"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS的输出缓冲区&body=Check out this article: https://szza.github.io/2021/01/26/Redis/OutputBuffer/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&title=剖析REDIS的输出缓冲区"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&title=剖析REDIS的输出缓冲区"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&title=剖析REDIS的输出缓冲区"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&title=剖析REDIS的输出缓冲区"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&name=剖析REDIS的输出缓冲区&description=&lt;p&gt;本节分析服务端的发送缓存区 &lt;code&gt;OutputBUffer&lt;/code&gt; 设计&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将回复客户端的数据添加到 &lt;code&gt;Outputbuffer&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;发送数据&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/01/26/Redis/OutputBuffer/&t=剖析REDIS的输出缓冲区"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2025
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
