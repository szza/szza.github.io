<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="事件循环EventLoop 是 REdis 得以高效运行的关键部分，下面详细讲解Redis中EventLoop的设计。">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析REDIS的事件循环">
<meta property="og:url" content="https://szza.github.io/2021/01/26/Redis/EventLoop/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="事件循环EventLoop 是 REdis 得以高效运行的关键部分，下面详细讲解Redis中EventLoop的设计。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-01-26T04:57:26.000Z">
<meta property="article:modified_time" content="2021-03-01T08:13:06.000Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Redis6.0">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>剖析REDIS的事件循环</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.3.0"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/01/26/Redis/Networking/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/01/26/Redis/EventLoop/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&text=剖析REDIS的事件循环"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&title=剖析REDIS的事件循环"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&is_video=false&description=剖析REDIS的事件循环"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS的事件循环&body=Check out this article: https://szza.github.io/2021/01/26/Redis/EventLoop/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&title=剖析REDIS的事件循环"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&title=剖析REDIS的事件循环"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&title=剖析REDIS的事件循环"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&title=剖析REDIS的事件循环"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&name=剖析REDIS的事件循环&description=&lt;p&gt;事件循环&lt;code&gt;EventLoop&lt;/code&gt; 是 &lt;code&gt;REdis&lt;/code&gt; 得以高效运行的关键部分，下面详细讲解Redis中&lt;code&gt;EventLoop&lt;/code&gt;的设计。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/01/26/Redis/EventLoop/&t=剖析REDIS的事件循环"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#aeEventLoop"><span class="toc-number">1.</span> <span class="toc-text">aeEventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aeCreateEventLoop"><span class="toc-number">1.1.</span> <span class="toc-text">aeCreateEventLoop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epollfd"><span class="toc-number">2.</span> <span class="toc-text">epollfd</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aeApiCreate"><span class="toc-number">2.1.</span> <span class="toc-text">aeApiCreate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aeApiAddEvent"><span class="toc-number">2.2.</span> <span class="toc-text">aeApiAddEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aeApiDelEvent"><span class="toc-number">2.3.</span> <span class="toc-text">aeApiDelEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aeApiPoll"><span class="toc-number">2.4.</span> <span class="toc-text">aeApiPoll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#anetListen"><span class="toc-number">3.</span> <span class="toc-text">anetListen</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#anetTcpServer"><span class="toc-number">3.1.</span> <span class="toc-text">anetTcpServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#anetTcpServer-1"><span class="toc-number">3.2.</span> <span class="toc-text">_anetTcpServer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aeCreateFileEvent"><span class="toc-number">4.</span> <span class="toc-text">aeCreateFileEvent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aeMain"><span class="toc-number">5.</span> <span class="toc-text">aeMain</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aeProcessEvents"><span class="toc-number">5.1.</span> <span class="toc-text">aeProcessEvents</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#processTimeEvents"><span class="toc-number">5.2.</span> <span class="toc-text">processTimeEvents</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aeCreateTimeEvent"><span class="toc-number">5.3.</span> <span class="toc-text">aeCreateTimeEvent</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        剖析REDIS的事件循环
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-01-26T04:57:26.000Z" itemprop="datePublished">2021-01-26</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Redis6-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Redis6.0 源码解析</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Redis6-0/" rel="tag">Redis6.0</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>事件循环<code>EventLoop</code> 是 <code>REdis</code> 得以高效运行的关键部分，下面详细讲解Redis中<code>EventLoop</code>的设计。</p>
<a id="more"></a>

<h2 id="aeEventLoop"><a href="#aeEventLoop" class="headerlink" title="aeEventLoop"></a>aeEventLoop</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;  			 <span class="comment">/* 当前注册的fd最大数 */</span></span><br><span class="line">    <span class="keyword">int</span> setsize; 			 <span class="comment">/* 能注册的最大fd数 */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId; 	</span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span> </span><br><span class="line">    aeFileEvent *events; <span class="comment">/* 已经注册的事件， events 建立了一个映射关系：fd --&gt; event*/</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* 已经触发的事件，记录的是触发的fd，及其事件类型 */</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line">    <span class="keyword">int</span> stop;           <span class="comment">// EventLoop 是否停止</span></span><br><span class="line">    <span class="keyword">void</span>* apidata;      <span class="comment">/* This is used for polling API specific data ，这个用于存放和 epollfd 相关的数据*/</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep; <span class="comment">// 在 epoll_wait 阻塞之前调用的函数</span></span><br><span class="line">    aeBeforeSleepProc *aftersleep;  <span class="comment">// 在 epoll_wait 唤醒之后调用的函数</span></span><br><span class="line">    <span class="keyword">int</span> flags;        <span class="comment">// 设置的标志位</span></span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>events</code></p>
<p>这是一个数组，在文件描述符<code>fd</code>和<code>fd</code>所关注的事件之间建立映射关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> mask; 				<span class="comment">// AE_NONE、AE_READABLE 、AE_WRITABLE、AE_BARRIER </span></span><br><span class="line">    aeFileProc *rfileProc;   <span class="comment">// 可读事件的回调函数 </span></span><br><span class="line">    aeFileProc *wfileProc;	 <span class="comment">// 可写事件的回调函数</span></span><br><span class="line">    <span class="keyword">void</span> *clientData; 		 <span class="comment">// clinet</span></span><br><span class="line">&#125; aeFileEvent;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p><code>fired</code></p>
<p>  数组，记录了有事件触发的文件描述及其对应的类型</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFiredEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;		<span class="comment">// 有事件触发的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> mask;   <span class="comment">// 这个fd触发具体的事件类型</span></span><br><span class="line">&#125; aeFiredEvent;</span><br></pre></td></tr></table></figure></li>
<li><p><code>timeEventHead</code></p>
<p>  主要是记录了定时器的头部节点，即第一个触发的定时器事件。</p>
  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id;  <span class="comment">/* time event identifier. */</span></span><br><span class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> when_ms;  <span class="comment">/* milliseconds */</span></span><br><span class="line">    aeTimeProc* timeProc;  <span class="comment">// 时间回调函数</span></span><br><span class="line">    aeEventFinalizerProc* finalizerProc;</span><br><span class="line">    <span class="keyword">void</span>* clientData;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span>* <span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span>* <span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">int</span> refcount; <span class="comment">/* refcount to prevent timer events from being freed in recursive time event calls. */</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure>
<h3 id="aeCreateEventLoop"><a href="#aeCreateEventLoop" class="headerlink" title="aeCreateEventLoop"></a>aeCreateEventLoop</h3></li>
</ul>
<p>创建EventLoop对象，完成的是：</p>
<ul>
<li>给<code>events,fired</code>分配内存，每个<code>event[i]</code>设置为不关注任何事件</li>
<li>创建<code>epollfd</code></li>
<li>其他默认初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建 eventLoop</span></span><br><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) </span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    </span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;aftersleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建 epollfd</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">/* Events with mask == AE_NONE are not set. So let&#x27;s initialize the vector with it. */</span></span><br><span class="line">    <span class="comment">// 初始化时，什么事件也没关注</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="epollfd"><a href="#epollfd" class="headerlink" title="epollfd"></a>epollfd</h2><p>针对<code>epollfd</code>有几个相关操作，有关的函数都是有 <strong><code>aeApi_xxx</code></strong> 前缀。</p>
<ul>
<li><code>aeApiCreate</code>：创建 <code>epollfd</code></li>
<li><code>aeApiAddEvent</code>：注册感兴趣的事件</li>
<li><code>aeApiDelEvent</code>：删除感兴趣的事件</li>
<li><code>aeApiPoll</code>：进入<code>epoll_wait</code>中阻塞等待</li>
</ul>
<h3 id="aeApiCreate"><a href="#aeApiCreate" class="headerlink" title="aeApiCreate"></a>aeApiCreate</h3><p><code>aeApiCreate</code>函数，基于<code>epoll_create</code>函数创建<code>epollfd</code>，其中<code>epoll_create</code>中入口参数<code>size</code>没有任何含义，但必须是个大于0的正数，也是可以使用<code>epoll_create1</code>这个函数来创建，不过要传入一个标志位。</p>
<p><code>epollfd</code>相关状态在REdis中使用<code>aeApiState</code>结构体保存</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> epfd;				<span class="comment">// epollfd</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>* <span class="title">events</span>;</span></span><br><span class="line">&#125; aeApiState;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span>     events;   <span class="comment">// epoll_wait中触发的事件</span></span><br><span class="line">   <span class="keyword">epoll_data_t</span> data;	    <span class="comment">// 存放触发事件对应的fd</span></span><br><span class="line">&#125; __EPOLL_PACKED;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>epfd</code>：保存的此<code>EventLoop</code>中的<code>epollfd</code></li>
<li><code>events</code>：用于保存 <code>epoll_wait</code> 检测到的活跃事件类型及其对应的<code>fd</code>，其大小最大是<code>eventLoop</code>中的<code>setsize</code>、</li>
</ul>
<p><code>aeApiCreate</code>函数整个逻辑也很简单，使用的是<code>aeApiState</code>对象来保存<code>epollfd</code>及其事件信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    aeApiState* state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> </span><br><span class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(struct epoll_event)*eventLoop-&gt;setsize);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        zfree(state-&gt;events);</span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoop-&gt;apidata = state; 		<span class="comment">// 将 epollfd 存在这个地方</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aeApiAddEvent"><a href="#aeApiAddEvent" class="headerlink" title="aeApiAddEvent"></a>aeApiAddEvent</h3><p><code>aeApiAddEvent</code>函数， 将<code>fd </code>注册到<code>epollfd</code>上去。 <code>listenfd</code> 、 <code>clientfd</code> 都是使用这个函数来注册感兴趣事情，传入的参数<code>fd</code>就是需要注册的文件描述符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 让 fd 关注事件 mask</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="comment">/* If the fd was already monitored for some event, we need a MOD</span></span><br><span class="line"><span class="comment">     * operation. Otherwise we need an ADD operation. */</span></span><br><span class="line">    <span class="comment">// 如果之前就关注了一些事件，则此次就是修改，否则就是添加</span></span><br><span class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ? EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask;  <span class="comment">/* Merge old events */</span> <span class="comment">// 本次调用后，总共需要关注的事件</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd, op, fd, &amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aeApiDelEvent"><a href="#aeApiDelEvent" class="headerlink" title="aeApiDelEvent"></a>aeApiDelEvent</h3><p>使文件描述符<code>fd</code>不再关注<code>delmask</code>事件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> delmask)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span> =</span> &#123;<span class="number">0</span>&#125;; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    <span class="keyword">int</span> mask = eventLoop-&gt;events[fd].mask &amp; (~delmask); <span class="comment">// 取消对于 delmask 的关注</span></span><br><span class="line"></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="comment">// 如果取消关注事件 delmask 后还由其他事件，那么就修改  EPOLL_CTL_MOD</span></span><br><span class="line">    <span class="comment">// 否则就将fd从state-&gt;efd的事件空间中删除</span></span><br><span class="line">    <span class="keyword">if</span> (mask != AE_NONE) &#123;</span><br><span class="line">        epoll_ctl(state-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ee);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        epoll_ctl(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aeApiPoll"><a href="#aeApiPoll" class="headerlink" title="aeApiPoll"></a>aeApiPoll</h3><p><code>aeApiPoll</code>函数基于<code>epoll_wait</code>实现，阻塞等待事件的发生</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop* eventLoop, struct timeval* tvp)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,                                         <span class="comment">// epollfd</span></span><br><span class="line">                        state-&gt;events,                                       <span class="comment">// 存储触发的事件类型及其fd</span></span><br><span class="line">                        eventLoop-&gt;setsize,                                  <span class="comment">// 最大可触发大小</span></span><br><span class="line">                        tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);  <span class="comment">// 最长阻塞时间</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">         <span class="comment">// 逐个记录事件</span></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>* <span class="title">e</span> =</span> state-&gt;events+j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE|AE_READABLE; <span class="comment">// 错误是即可读又是可写</span></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE|AE_READABLE; <span class="comment">// 对端关闭</span></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd; 					 <span class="comment">// 记录触发事件的 fd</span></span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;     					 <span class="comment">// 记录触发的事件类型</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="anetListen"><a href="#anetListen" class="headerlink" title="anetListen"></a>anetListen</h2><p>将监听文件描述符<code>s</code>绑定到地址 <code>sd</code>上，并开启监听。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">anetListen</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> s, struct sockaddr *sa, <span class="keyword">socklen_t</span> len, <span class="keyword">int</span> backlog)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bind(s,sa,len) == <span class="number">-1</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;bind: %s&quot;</span>, strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(s, backlog) == <span class="number">-1</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;listen: %s&quot;</span>, strerror(errno));</span><br><span class="line">        close(s);</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ANET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数没有什么特别之处，如果出错就直接返回关闭<code>socket</code>，返回-1，与<code>sockfd</code>是否非阻塞模式无关。这个函数只是创建<code>TcpServer</code>的一部分，其上层有一个更加全面的函数<code>_anetTcpServer</code>。</p>
<h3 id="anetTcpServer"><a href="#anetTcpServer" class="headerlink" title="anetTcpServer"></a>anetTcpServer</h3><p><code>anetTcpServer</code>函数，可以创建IPV4、IPV6服务器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcpServer</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _anetTcpServer(err, port, bindaddr, AF_INET, backlog);		<span class="comment">// ipv4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetTcp6Server</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _anetTcpServer(err, port, bindaddr, AF_INET6, backlog);		<span class="comment">// ipv6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="anetTcpServer-1"><a href="#anetTcpServer-1" class="headerlink" title="_anetTcpServer"></a>_anetTcpServer</h3><p><code>_anetTcpServer</code>函数，创建监听状态的服务器，步骤如下：</p>
<ul>
<li><p><code>getaddrinfo</code>函数，获取本机上的所有<code>ip</code>地址及对应的<code>TCP</code>服务。此函数参数：</p>
<ul>
<li><code>SOCK_STREAM</code>：指定了服务类型，是属于tcp</li>
<li><code>AI_PASSIVE</code>：如果传入的地址不是空字符串，那么这个设置无效果。否则，<code>getaddrinfo</code>返回的ip地址就是统配地址。</li>
</ul>
<p>这个函数，为创建的<code>listenfd</code>任选一个由<code>getaddrinfo</code>返回的本地<code>IP</code>地址来绑定。</p>
</li>
<li><p>为了使得地址复用，设置了<code>SO_REUSEADDR</code>参数</p>
</li>
<li><p>再调用了绑定和监听</p>
</li>
</ul>
<p><code>_anetTcpServer</code> 函数，为本地的IPV4、IPV6各自创建一个监听文件描述符并保存在 <code>server.ipfd</code>中，个数由<code>server.ipfd_count</code>记录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _anetTcpServer(<span class="keyword">char</span> *err, <span class="keyword">int</span> port, <span class="keyword">char</span> *bindaddr, <span class="keyword">int</span> af, <span class="keyword">int</span> backlog)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">-1</span>, rv;</span><br><span class="line">    <span class="keyword">char</span> _port[<span class="number">6</span>];  <span class="comment">/* strlen(&quot;65535&quot;) */</span></span><br><span class="line">    <span class="comment">// 调用 getadddrinfo 函数的前提准备</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>, *<span class="title">servinfo</span>, *<span class="title">p</span>;</span> </span><br><span class="line"></span><br><span class="line">    <span class="built_in">snprintf</span>(_port,<span class="number">6</span>,<span class="string">&quot;%d&quot;</span>,port);</span><br><span class="line">    <span class="built_in">memset</span>(&amp;hints,<span class="number">0</span>,<span class="keyword">sizeof</span>(hints));</span><br><span class="line">    hints.ai_family = af;</span><br><span class="line">    hints.ai_socktype = SOCK_STREAM; <span class="comment">// TCP 数据类型</span></span><br><span class="line">    hints.ai_flags = AI_PASSIVE;     <span class="comment">/* No effect if bindaddr != NULL，如果 bindarry==NULL，返回的就是通配地址 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((rv = getaddrinfo(bindaddr, _port, &amp;hints, &amp;servinfo)) != <span class="number">0</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;%s&quot;</span>, gai_strerror(rv));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 绑定成功一个即可</span></span><br><span class="line">    <span class="keyword">for</span> (p = servinfo; p != <span class="literal">NULL</span>; p = p-&gt;ai_next) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((s = socket(p-&gt;ai_family, p-&gt;ai_socktype, p-&gt;ai_protocol)) == <span class="number">-1</span>) <span class="comment">// 创建TCP类型的 listenfd</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (af == AF_INET6 &amp;&amp; anetV6Only(err,s) == ANET_ERR) <span class="keyword">goto</span> error;</span><br><span class="line">        <span class="keyword">if</span> (anetSetReuseAddr(err, s) == ANET_ERR) <span class="keyword">goto</span> error;				  <span class="comment">// 设置地址复用</span></span><br><span class="line">        <span class="keyword">if</span> (anetListen(err,s,p-&gt;ai_addr,p-&gt;ai_addrlen,backlog) == ANET_ERR) s = ANET_ERR;</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;unable to bind socket, errno: %d&quot;</span>, errno);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">error:</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="number">-1</span>) close(s);</span><br><span class="line">    s = ANET_ERR;</span><br><span class="line">end:</span><br><span class="line">    freeaddrinfo(servinfo);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，创建监听服务器已经完成，下一步应该是要创建<code>epollfd</code>，并且<code>listenfd</code>注册到<code>epollfd</code>中，并且关注可读事件。</p>
<h2 id="aeCreateFileEvent"><a href="#aeCreateFileEvent" class="headerlink" title="aeCreateFileEvent"></a>aeCreateFileEvent</h2><p>这个函数的作用是将文件描述符<code>fd</code>挂在 <code>epollfd</code> 上，并且注册感兴趣的事件。在<code>initServer</code>函数中<code>aeCreateFileEvent</code>将<code>listenfd</code>挂在<code>epollfd</code>上并注册可读事件，目的是监听客户端的连接请求，客户端的连接请求处理函数是<code>acceptTcpHandler</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//in server.c</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">     <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler,<span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">         &#123;</span><br><span class="line">             serverPanic(<span class="string">&quot;Unrecoverable error creating server.ipfd file event.&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>由上面分析可知 <code> server.ipfd</code> 中保存的是根据本地的不同ip地址创建的 <code>listenfd</code>。<code>aeCreateFileEvent</code>函数作用是将每个监听<code>listenfd</code>绑定到所属的<code>loop</code>的<code>epollfd</code>中去。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask, aeFileProc *proc, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    aeFileEvent* fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数在此处的主要作用：</p>
<ul>
<li>将 <code>listenfd</code> 注册到所属的 <code>eventLoop</code> 的 <code>epfd</code> 中去，并关注可读事件</li>
<li>设置可读事件的回调函数 <code>acceptTcpHandler</code>，这个也是新的客户端连接到来时候的处理函数</li>
<li>更新最大注册的 <code>fd</code></li>
</ul>
<p>至此，建立监听TCP服务器的流程基本完成：<code>aeCreateEventLoop --&gt; listen --&gt; aeCreateFileEvent</code>，</p>
<h2 id="aeMain"><a href="#aeMain" class="headerlink" title="aeMain"></a>aeMain</h2><p><code>aeMain</code>函数，即事件循环，不断的轮询处理各个请求并回应，核心是函数 <code>aeProcessEvents</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS|</span><br><span class="line">                                   AE_CALL_BEFORE_SLEEP|</span><br><span class="line">                                   AE_CALL_AFTER_SLEEP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aeProcessEvents"><a href="#aeProcessEvents" class="headerlink" title="aeProcessEvents"></a>aeProcessEvents</h3><p><code>aeProcessEvents</code>是<code>eventloop</code>的核心，整个流程可以分为5个部分：</p>
<ol>
<li><p>在<code>aeApiPoll</code>之前就做了一件事：计算<code>epoll_wait</code>需要阻塞的时间</p>
<ul>
<li>如果设置了<code>AE_DONT_WAIT</code>，那么就是不阻塞，<code>epoll_wait</code>的超时时间为0</li>
<li>如果没有其他任务，只有定时器任务，那么<code>epoll_wait</code>阻塞时间即最早超时时间，防止定时器任务等待过久</li>
<li>如果也没有定时器任务，那么就永远等待，直到有事件到来。</li>
</ul>
</li>
<li><p><code>beforesleep</code>：主要是在<code>epoll_wait</code>阻塞前处理一些任务，防止因阻塞长时间无法执行，或者是一些准备工作。（后续介绍）</p>
</li>
<li><p><code>epoll_wait</code>等待事件发生</p>
</li>
<li><p><code>aftersleep</code>：可以用于完成 <code>epoll_wait</code>唤醒之后的一些校验工作</p>
</li>
<li><p>处理事件：根据是否设置了<code>AE_BARRIER</code>，来决定同一个<code>fd</code>上是先处理可读事件还是先处理可写事件。</p>
</li>
<li><p>处理完活跃的事件，最早的定时器可能已经超时了，那么就是可以去执行了。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we want call select() even if there are no</span></span><br><span class="line"><span class="comment">     * file events to process as long as we want to process time</span></span><br><span class="line"><span class="comment">     * events, in order to sleep until the next time event is ready</span></span><br><span class="line"><span class="comment">     * to fire.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 1 eventLoop-&gt;maxfd == -1，即没有事件fd，那么就没有等待处理的事件</span></span><br><span class="line"><span class="comment">     * 2 flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT)：如果存在定时器事件，</span></span><br><span class="line"><span class="comment">     *		要么等待定时器事件，</span></span><br><span class="line"><span class="comment">     *      要么在没有设置 AE_DONT_WAIT，则就一直阻塞在 aeApiPoll，直到有事件触发</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> || ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);    <span class="comment">// 如果有时间事件存在，则获取最近的定时器超时时间</span></span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* How many milliseconds we need to wait for the next</span></span><br><span class="line"><span class="comment">             * time event to fire? */</span></span><br><span class="line">            <span class="comment">// 最近超时的时间转为毫秒单位</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ms = (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> + shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 要么是超时时间为0,即使设置了AE_DONT_WAIT,不要阻塞</span></span><br><span class="line">            <span class="comment">// 要么是没有定时时间,则可以阻塞</span></span><br><span class="line">            <span class="comment">/* If we have to check for events but need to return</span></span><br><span class="line"><span class="comment">             * ASAP because of AE_DONT_WAIT we need to set the timeout</span></span><br><span class="line"><span class="comment">             * to zero */</span></span><br><span class="line">            <span class="comment">// 不要阻塞,则设置超时时间为0</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 没有可触发事件,则等待</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再次确认下</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">            tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_BEFORE_SLEEP)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop); <span class="comment">// 在休眠之前执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call the multiplexing API, will return only on timeout or when some event fires. */</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* After sleep callback. */</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop); <span class="comment">// 在休眠之后执行</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 逐个处理触发的事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd   = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Normally we execute the readable event first, and the writable</span></span><br><span class="line"><span class="comment">             * event laster. This is useful as sometimes we may be able</span></span><br><span class="line"><span class="comment">             * to serve the reply of a query immediately after processing the</span></span><br><span class="line"><span class="comment">             * query.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * However if AE_BARRIER is set in the mask, our application is</span></span><br><span class="line"><span class="comment">             * asking us to do the reverse: never fire the writable event</span></span><br><span class="line"><span class="comment">             * after the readable. In such a case, we invert the calls.</span></span><br><span class="line"><span class="comment">             * This is useful when, for instance, we want to do things</span></span><br><span class="line"><span class="comment">             * in the beforeSleep() hook, like fsynching a file to disk,</span></span><br><span class="line"><span class="comment">             * before replying to a client. */</span></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Note the &quot;fe-&gt;mask &amp; mask &amp; ...&quot; code: maybe an already</span></span><br><span class="line"><span class="comment">             * processed event removed an element that fired and we still</span></span><br><span class="line"><span class="comment">             * didn&#x27;t processed, so we check if the event is still valid.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Fire the readable event if the call sequence is not inverted. */</span></span><br><span class="line">            <span class="comment">// fe-&gt;mask 是之前关注的事件，mask是产生的事件，如果都有 AE_READABLE</span></span><br><span class="line">            <span class="comment">// 则触发可读事件</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">             * after the writable one. */</span></span><br><span class="line">            <span class="keyword">if</span> (invert) &#123;</span><br><span class="line">                fe = &amp;eventLoop-&gt;events[fd]; <span class="comment">/* Refresh in case of resize. */</span></span><br><span class="line">                <span class="keyword">if</span> ((fe-&gt;mask &amp; mask &amp; AE_READABLE) &amp;&amp;</span><br><span class="line">                    (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc))</span><br><span class="line">                &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以去处理时间事件了</span></span><br><span class="line">    <span class="comment">/* Check time events */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="processTimeEvents"><a href="#processTimeEvents" class="headerlink" title="processTimeEvents"></a>processTimeEvents</h3><p>定时器事件中，定时器是基于链表实现的，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process time events */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxId;</span><br><span class="line">    <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the system clock is moved to the future, and then set back to the</span></span><br><span class="line"><span class="comment">     * right value, time events may be delayed in a random way. Often this</span></span><br><span class="line"><span class="comment">     * means that scheduled operations will not be performed soon enough.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here we try to detect system clock skews, and force all the time</span></span><br><span class="line"><span class="comment">     * events to be processed ASAP when this happens: the idea is that</span></span><br><span class="line"><span class="comment">     * processing events earlier is less dangerous than delaying them</span></span><br><span class="line"><span class="comment">     * indefinitely, and practice suggests it is. */</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        <span class="keyword">while</span>(te) &#123;</span><br><span class="line">            te-&gt;when_sec = <span class="number">0</span>;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove events scheduled for deletion. */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</span><br><span class="line">            aeTimeEvent *next = te-&gt;next;</span><br><span class="line">            <span class="comment">/* If a reference exists for this timer event,</span></span><br><span class="line"><span class="comment">             * don&#x27;t free it. This is currently incremented</span></span><br><span class="line"><span class="comment">             * for recursive timerProc calls */</span></span><br><span class="line">            <span class="keyword">if</span> (te-&gt;refcount) &#123;</span><br><span class="line">                te = next;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;prev)</span><br><span class="line">                te-&gt;prev-&gt;next = te-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;next)</span><br><span class="line">                te-&gt;next-&gt;prev = te-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</span><br><span class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</span><br><span class="line">            zfree(te);</span><br><span class="line">            te = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure we don&#x27;t process time events created by time events in</span></span><br><span class="line"><span class="comment">         * this iteration. Note that this check is currently useless: we always</span></span><br><span class="line"><span class="comment">         * add new timers on the head, however if we change the implementation</span></span><br><span class="line"><span class="comment">         * detail, this check may be useful again: we keep it here for future</span></span><br><span class="line"><span class="comment">         * defense. */</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            te-&gt;refcount++;</span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            te-&gt;refcount--;</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aeCreateTimeEvent"><a href="#aeCreateTimeEvent" class="headerlink" title="aeCreateTimeEvent"></a>aeCreateTimeEvent</h3><p>创建定时器事件。定时器回调函数<code>serverCorn</code>作用很大，在后续具体的内容中再讲解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (aeCreateTimeEvent(server.el, <span class="number">1</span>, serverCron, <span class="literal">NULL</span>, <span class="literal">NULL</span>) == AE_ERR) &#123;</span><br><span class="line">    serverPanic(<span class="string">&quot;Can&#x27;t create event loop timers.&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#aeEventLoop"><span class="toc-number">1.</span> <span class="toc-text">aeEventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aeCreateEventLoop"><span class="toc-number">1.1.</span> <span class="toc-text">aeCreateEventLoop</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#epollfd"><span class="toc-number">2.</span> <span class="toc-text">epollfd</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aeApiCreate"><span class="toc-number">2.1.</span> <span class="toc-text">aeApiCreate</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aeApiAddEvent"><span class="toc-number">2.2.</span> <span class="toc-text">aeApiAddEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aeApiDelEvent"><span class="toc-number">2.3.</span> <span class="toc-text">aeApiDelEvent</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aeApiPoll"><span class="toc-number">2.4.</span> <span class="toc-text">aeApiPoll</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#anetListen"><span class="toc-number">3.</span> <span class="toc-text">anetListen</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#anetTcpServer"><span class="toc-number">3.1.</span> <span class="toc-text">anetTcpServer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#anetTcpServer-1"><span class="toc-number">3.2.</span> <span class="toc-text">_anetTcpServer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aeCreateFileEvent"><span class="toc-number">4.</span> <span class="toc-text">aeCreateFileEvent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aeMain"><span class="toc-number">5.</span> <span class="toc-text">aeMain</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aeProcessEvents"><span class="toc-number">5.1.</span> <span class="toc-text">aeProcessEvents</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#processTimeEvents"><span class="toc-number">5.2.</span> <span class="toc-text">processTimeEvents</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aeCreateTimeEvent"><span class="toc-number">5.3.</span> <span class="toc-text">aeCreateTimeEvent</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/01/26/Redis/EventLoop/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&text=剖析REDIS的事件循环"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&title=剖析REDIS的事件循环"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&is_video=false&description=剖析REDIS的事件循环"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS的事件循环&body=Check out this article: https://szza.github.io/2021/01/26/Redis/EventLoop/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&title=剖析REDIS的事件循环"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&title=剖析REDIS的事件循环"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&title=剖析REDIS的事件循环"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&title=剖析REDIS的事件循环"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/01/26/Redis/EventLoop/&name=剖析REDIS的事件循环&description=&lt;p&gt;事件循环&lt;code&gt;EventLoop&lt;/code&gt; 是 &lt;code&gt;REdis&lt;/code&gt; 得以高效运行的关键部分，下面详细讲解Redis中&lt;code&gt;EventLoop&lt;/code&gt;的设计。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/01/26/Redis/EventLoop/&t=剖析REDIS的事件循环"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
