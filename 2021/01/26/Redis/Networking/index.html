<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本节介绍对客户端的封装以及服务器处理客户端连接请求的过程。  客户端的封装 服务器处理客户端的连接请求">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析REDIS网络通信">
<meta property="og:url" content="https://szza.github.io/2021/01/26/Redis/Networking/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="本节介绍对客户端的封装以及服务器处理客户端连接请求的过程。  客户端的封装 服务器处理客户端的连接请求">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-01-26T06:13:20.000Z">
<meta property="article:modified_time" content="2021-03-01T07:26:14.000Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Redis6.0">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>剖析REDIS网络通信</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/01/26/RocksDB/Table/builder/1_BlockBuiler/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/01/26/Redis/EventLoop/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/01/26/Redis/Networking/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/01/26/Redis/Networking/&text=剖析REDIS网络通信"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/01/26/Redis/Networking/&title=剖析REDIS网络通信"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/01/26/Redis/Networking/&is_video=false&description=剖析REDIS网络通信"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS网络通信&body=Check out this article: https://szza.github.io/2021/01/26/Redis/Networking/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/01/26/Redis/Networking/&title=剖析REDIS网络通信"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/01/26/Redis/Networking/&title=剖析REDIS网络通信"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/01/26/Redis/Networking/&title=剖析REDIS网络通信"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/01/26/Redis/Networking/&title=剖析REDIS网络通信"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/01/26/Redis/Networking/&name=剖析REDIS网络通信&description=&lt;p&gt;本节介绍对客户端的封装以及服务器处理客户端连接请求的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端的封装&lt;/li&gt;
&lt;li&gt;服务器处理客户端的连接请求&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/01/26/Redis/Networking/&t=剖析REDIS网络通信"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Connection"><span class="toc-number">1.</span> <span class="toc-text">Connection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConnectionType"><span class="toc-number">1.1.</span> <span class="toc-text">ConnectionType</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketEventHandler"><span class="toc-number">1.1.1.</span> <span class="toc-text">connSocketEventHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketWrite"><span class="toc-number">1.1.2.</span> <span class="toc-text">connSocketWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketRead"><span class="toc-number">1.1.3.</span> <span class="toc-text">connSocketRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketClose"><span class="toc-number">1.1.4.</span> <span class="toc-text">connSocketClose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketSetWriteHandler"><span class="toc-number">1.1.5.</span> <span class="toc-text">connSocketSetWriteHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketSetReadHandler"><span class="toc-number">1.1.6.</span> <span class="toc-text">connSocketSetReadHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Accept"><span class="toc-number">2.</span> <span class="toc-text">Accept</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#acceptTcpHandler"><span class="toc-number">2.1.</span> <span class="toc-text">acceptTcpHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connCreateAcceptedSocket"><span class="toc-number">2.2.</span> <span class="toc-text">connCreateAcceptedSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acceptCommonHandler"><span class="toc-number">2.3.</span> <span class="toc-text">acceptCommonHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#createClient"><span class="toc-number">2.3.1.</span> <span class="toc-text">createClient</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#connEnableTcpNoDelay"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">connEnableTcpNoDelay</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#connNonBlock"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">connNonBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#connKeepAlive"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">connKeepAlive</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connAccept"><span class="toc-number">2.3.2.</span> <span class="toc-text">connAccept</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clientAcceptHandler"><span class="toc-number">2.3.3.</span> <span class="toc-text">clientAcceptHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#callHandler"><span class="toc-number">2.3.4.</span> <span class="toc-text">callHandler</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        剖析REDIS网络通信
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-01-26T06:13:20.000Z" itemprop="datePublished">2021-01-26</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Redis6-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Redis6.0 源码解析</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Redis6-0/" rel="tag">Redis6.0</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>本节介绍对客户端的封装以及服务器处理客户端连接请求的过程。</p>
<ul>
<li>客户端的封装</li>
<li>服务器处理客户端的连接请求</li>
</ul>
<a id="more"></a>

<h2 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h2><p>为了维护客户端的一些状态及其一些读写操作，需要为每个客户端封装一个连接对象<code>conn</code>，结构体如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span> &#123;</span></span><br><span class="line">      ConnectionType* type;  <span class="comment">// 操作 connection 中的函数指针</span></span><br><span class="line">      ConnectionState state; <span class="comment">// 是一个 enum，表示连接的状态</span></span><br><span class="line">      <span class="keyword">short</span> <span class="keyword">int</span> flags;       <span class="comment">// CONN_FLAG_CLOSE_SCHEDULED 或者 CONN_FLAG_WRITE_BARRIER</span></span><br><span class="line">      <span class="keyword">short</span> <span class="keyword">int</span> refs;        <span class="comment">//引用计数，控制着这个连接对象生命周期</span></span><br><span class="line">      <span class="keyword">int</span> last_errno;        <span class="comment">// 最近一次的错误类型</span></span><br><span class="line">      <span class="keyword">void</span> *private_data;    <span class="comment">// 保存的是这个连接对应的客户端 client</span></span><br><span class="line">      ConnectionCallbackFunc conn_handler;  <span class="comment">// 连接回调</span></span><br><span class="line">      ConnectionCallbackFunc write_handler; <span class="comment">// 写回调</span></span><br><span class="line">      ConnectionCallbackFunc read_handler;  <span class="comment">// 读回调</span></span><br><span class="line">      <span class="keyword">int</span> fd;               <span class="comment">// cfd</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>state</code>：客户端的连接状态如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    CONN_STATE_NONE = <span class="number">0</span>,</span><br><span class="line">    CONN_STATE_CONNECTING,  <span class="comment">// connecting, 发起 connect 连接时</span></span><br><span class="line">    CONN_STATE_ACCEPTING,   <span class="comment">// accepting, 创建客户端时初始状态，即 accept 之前的状态</span></span><br><span class="line">    CONN_STATE_CONNECTED,   <span class="comment">// connected, 成功 accept 之后的状态</span></span><br><span class="line">    CONN_STATE_CLOSED,      <span class="comment">// closed,    关闭的状态</span></span><br><span class="line">    CONN_STATE_ERROR        <span class="comment">// error,     出错了</span></span><br><span class="line">&#125; ConnectionState;</span><br></pre></td></tr></table></figure>
<p>也有相应获取状态<code>conn-&gt;state</code>的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connGetState</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>refs</code>：控制着连接对象<code>conn</code>的生命周期</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in conhelpers.h</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connIncrRefs</span><span class="params">(connection *conn)</span> </span>&#123; conn-&gt;refs++; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connDecrRefs</span><span class="params">(connection *conn)</span> </span>&#123; conn-&gt;refs--; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">connHasRefs</span><span class="params">(connection *conn)</span> </span>&#123; <span class="keyword">return</span> conn-&gt;refs; &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>private_data</code>：保存着这个连接对象所属的客户端，在<code>createClient</code>中设置为客户端<code>c</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Associate a private data pointer with the connection */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connSetPrivateData</span><span class="params">(connection *conn, <span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    conn-&gt;private_data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get the associated private data pointer */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">connGetPrivateData</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;private_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>回调函数：<code>read_handler</code>、<code>write_handler</code>以及<code>read_handler</code>都是由函数指针集合<code>ConnectionType</code>来设置。</p>
</li>
</ul>
<h3 id="ConnectionType"><a href="#ConnectionType" class="headerlink" title="ConnectionType"></a>ConnectionType</h3><p><code>ConnectionType</code>结构体封装了客户端连接对象的一些读写、Accept和关闭连接等操作，是函数指针的结构体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读写函数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ConnectionType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 读写</span></span><br><span class="line">    <span class="keyword">void</span> (*ae_handler)(struct aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *clientData, <span class="keyword">int</span> mask);</span><br><span class="line">    <span class="comment">// 处理连接请求</span></span><br><span class="line">    <span class="keyword">int</span>  (*connect) (struct connection *conn, </span><br><span class="line">                     <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *source_addr, </span><br><span class="line">                     ConnectionCallbackFunc connect_handler);</span><br><span class="line">    <span class="comment">// 处理读写、关闭和Accept</span></span><br><span class="line">    <span class="keyword">int</span>  (*write)     (struct connection *conn, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> data_len);</span><br><span class="line">    <span class="keyword">int</span>  (*read)      (struct connection *conn, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> buf_len);</span><br><span class="line">    <span class="keyword">void</span> (*close)     (struct connection *conn);</span><br><span class="line">    <span class="keyword">int</span>  (*accept)    (struct connection *conn, ConnectionCallbackFunc accept_handler);</span><br><span class="line">    <span class="comment">// set</span></span><br><span class="line">    <span class="keyword">int</span>  (*set_write_handler)(struct connection *conn, ConnectionCallbackFunc handler, <span class="keyword">int</span> barrier);</span><br><span class="line">    <span class="keyword">int</span>  (*set_read_handler)(struct connection *conn, ConnectionCallbackFunc handler);</span><br><span class="line">    <span class="comment">// get</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *(*get_last_error)(struct connection *conn);</span><br><span class="line">    <span class="keyword">int</span>  (*blocking_connect)(struct connection *conn, <span class="keyword">const</span> <span class="keyword">char</span> *addr, <span class="keyword">int</span> port, <span class="keyword">long</span> <span class="keyword">long</span> timeout);</span><br><span class="line">    <span class="comment">// 异步读写</span></span><br><span class="line">    <span class="keyword">ssize_t</span> (*sync_write)(struct connection *conn, <span class="keyword">char</span> *ptr, <span class="keyword">ssize_t</span> size, <span class="keyword">long</span> <span class="keyword">long</span> timeout);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*sync_read)(struct connection *conn, <span class="keyword">char</span> *ptr, <span class="keyword">ssize_t</span> size, <span class="keyword">long</span> <span class="keyword">long</span> timeout);</span><br><span class="line">    <span class="keyword">ssize_t</span> (*sync_readline)(struct connection *conn, <span class="keyword">char</span> *ptr, <span class="keyword">ssize_t</span> size, <span class="keyword">long</span> <span class="keyword">long</span> timeout);</span><br><span class="line">&#125; ConnectionType;</span><br></pre></td></tr></table></figure>
<p>在<code>connection.c</code>中，定义了一个<code>ConnectionType</code>对象<code>CT_Socket</code>，及其初始化如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ConnectionType CT_Socket = &#123;</span><br><span class="line">    .ae_handler         = connSocketEventHandler,</span><br><span class="line">    .close              = connSocketClose,</span><br><span class="line">    .write              = connSocketWrite,</span><br><span class="line">    .read               = connSocketRead,</span><br><span class="line">    .accept             = connSocketAccept,</span><br><span class="line">    .connect            = connSocketConnect,</span><br><span class="line">    .set_write_handler  = connSocketSetWriteHandler,</span><br><span class="line">    .set_read_handler   = connSocketSetReadHandler,</span><br><span class="line">    .get_last_error     = connSocketGetLastError,</span><br><span class="line">    .blocking_connect   = connSocketBlockingConnect,</span><br><span class="line">    .sync_write         = connSocketSyncWrite,</span><br><span class="line">    .sync_read          = connSocketSyncRead,</span><br><span class="line">    .sync_readline      = connSocketSyncReadLine</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="connSocketEventHandler"><a href="#connSocketEventHandler" class="headerlink" title="connSocketEventHandler"></a>connSocketEventHandler</h4><p><code>connSocketEventHandler</code>函数，主要是综合处理可读、可写事件。这个函数中的 <code>callHandler</code>在后文详细介绍。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理epllfd上可读可写事件</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connSocketEventHandler</span><span class="params">(struct aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *clientData, <span class="keyword">int</span> mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(fd);</span><br><span class="line">    connection *conn = clientData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 针对发起连接对象</span></span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;state == CONN_STATE_CONNECTING &amp;&amp;</span><br><span class="line">        (mask &amp; AE_WRITABLE) &amp;&amp; </span><br><span class="line">        conn-&gt;conn_handler) </span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (connGetSocketError(conn)) &#123;</span><br><span class="line">            conn-&gt;last_errno = errno;</span><br><span class="line">            conn-&gt;state = CONN_STATE_ERROR;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            conn-&gt;state = CONN_STATE_CONNECTED; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有设置可写事件的处理函数,则直接取消可写事件</span></span><br><span class="line">        <span class="keyword">if</span> (!conn-&gt;write_handler) aeDeleteFileEvent(server.el,conn-&gt;fd,AE_WRITABLE);</span><br><span class="line">        <span class="comment">// 处理新连接到来</span></span><br><span class="line">        <span class="keyword">if</span> (!callHandler(conn, conn-&gt;conn_handler)) <span class="keyword">return</span>;</span><br><span class="line">        conn-&gt;conn_handler = <span class="literal">NULL</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Normally we execute the readable event first, and the writable</span></span><br><span class="line"><span class="comment">     * event later. This is useful as sometimes we may be able</span></span><br><span class="line"><span class="comment">     * to serve the reply of a query immediately after processing the</span></span><br><span class="line"><span class="comment">     * query.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 通常我们先执行可读事件，然后执行可写事件。</span></span><br><span class="line"><span class="comment">     * 这种方式很有用，因为有时我们可以在处理查询之后立即提供查询的结果。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     * However if WRITE_BARRIER is set in the mask, our application is</span></span><br><span class="line"><span class="comment">     * asking us to do the reverse: never fire the writable event after the readable. </span></span><br><span class="line"><span class="comment">     * In such a case, we invert the calls.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 然后,如果设置了 WRITE_BARRIER, 那么处理程序就反过来:在处理了可读事件之后都不触发可写事件</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * This is useful when, for instance, we want to do things</span></span><br><span class="line"><span class="comment">     * in the beforeSleep() hook, like fsync&#x27;ing a file to disk,</span></span><br><span class="line"><span class="comment">     * before replying to a client.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 这种操作很有用,比如,当我在beforeSleep()函数中,执行一些阻塞操作,类似fsync操作</span></span><br><span class="line"><span class="comment">     *  */</span></span><br><span class="line">    <span class="keyword">int</span> invert = conn-&gt;flags &amp; CONN_FLAG_WRITE_BARRIER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> call_write = (mask &amp; AE_WRITABLE) &amp;&amp; conn-&gt;write_handler;</span><br><span class="line">    <span class="keyword">int</span> call_read  = (mask &amp; AE_READABLE) &amp;&amp; conn-&gt;read_handler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle normal I/O flows */</span></span><br><span class="line">    <span class="keyword">if</span> (!invert &amp;&amp; call_read) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!callHandler(conn, conn-&gt;read_handler)) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">    <span class="keyword">if</span> (call_write) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!callHandler(conn, conn-&gt;write_handler)) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">     * after the writable one. */</span></span><br><span class="line">    <span class="keyword">if</span> (invert &amp;&amp; call_read) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!callHandler(conn, conn-&gt;read_handler)) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="connSocketWrite"><a href="#connSocketWrite" class="headerlink" title="connSocketWrite"></a>connSocketWrite</h4><p>这是REdis中实际完成写操作的最底层的函数，调用<code>write</code>函数完成发送。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connSocketWrite</span><span class="params">(connection *conn, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> data_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = write(conn-&gt;fd, data, data_len);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno != EAGAIN) &#123;  <span class="comment">// ret ==-1 &amp;&amp; errno ==EAGAIN，在非阻塞IO是正常下的，不是错误</span></span><br><span class="line">        conn-&gt;last_errno = errno;</span><br><span class="line">        conn-&gt;state = CONN_STATE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>connSocketWrite</code> 函数上层是被<code>connWrite</code>函数调用。用户无法直接调用 <code>connSocketWrite</code>，只能通过<code>conn</code>对象来调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">connWrite</span><span class="params">(connection *conn, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> data_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;type-&gt;write(conn, data, data_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="connSocketRead"><a href="#connSocketRead" class="headerlink" title="connSocketRead"></a>connSocketRead</h4><p>和写操作类似，这是最底层的函数，服务器读取客户端发来的数据，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// conn-&gt;type-&gt;write</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connSocketWrite</span><span class="params">(connection *conn, <span class="keyword">const</span> <span class="keyword">void</span> *data, <span class="keyword">size_t</span> data_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = write(conn-&gt;fd, data, data_len);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span> &amp;&amp; errno != EAGAIN) &#123;	<span class="comment">// ret ==-1 &amp;&amp; errno ==EAGAIN，在非阻塞IO是正常下的，不是错误</span></span><br><span class="line">        conn-&gt;last_errno = errno;</span><br><span class="line">        conn-&gt;state = CONN_STATE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>connSocketWrite</code> 经过封装被 <code>connRead</code>调用，将数据读取到到<code>buf</code>中。用户不应该直接调用 <code>connSocketWrite</code> 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">connRead</span><span class="params">(connection *conn, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> buf_len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;type-&gt;read(conn, buf, buf_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="connSocketClose"><a href="#connSocketClose" class="headerlink" title="connSocketClose"></a>connSocketClose</h4><p>关闭客户端操作。</p>
<p>注意：控制连接对象生命周期的引用计数<code>conn-&gt;refs</code>。如果此时引用计数不为0，说明是处于某个回调函数中，此时不能直接关闭，设置标志位 <font color=yellow> CONN_FLAG_CLOSE_SCHEDULED</font>，需要延迟关闭。这个在后面应用时会有更深的理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">connSocketClose</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        aeDeleteFileEvent(server.el,conn-&gt;fd,AE_READABLE);  <span class="comment">// 取消关注可写事件</span></span><br><span class="line">        aeDeleteFileEvent(server.el,conn-&gt;fd,AE_WRITABLE);  <span class="comment">// 取消关注可读事件</span></span><br><span class="line">        close(conn-&gt;fd);                                    <span class="comment">// 再关闭socket</span></span><br><span class="line">        conn-&gt;fd = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If called from within a handler, schedule the close but</span></span><br><span class="line"><span class="comment">     * keep the connection until the handler returns.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 此处，即通过引用计数来控制conn的生命周期</span></span><br><span class="line">    <span class="comment">// 此时，尽管已经要关闭conn，但是其引用计数不是0</span></span><br><span class="line">    <span class="comment">// 说明处于某个回调函数中，等该回调函数返回之后，这个客户端就可以关闭</span></span><br><span class="line">    <span class="keyword">if</span> (connHasRefs(conn)) &#123;</span><br><span class="line">        conn-&gt;flags |= CONN_FLAG_CLOSE_SCHEDULED;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    zfree(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其上层也是有一个<code>wrapper</code>函数 <code>connClose</code>，提供给用户使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">connClose</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    conn-&gt;type-&gt;close(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="connSocketSetWriteHandler"><a href="#connSocketSetWriteHandler" class="headerlink" title="connSocketSetWriteHandler"></a>connSocketSetWriteHandler</h4><p><code>connSocketSetWriteHandler</code>函数，主要是在<code>epoll_wait</code>上注册可写事件，并设置可写事件的回调函数为 <code>ae_handler</code>，真正执行写操作的还是<code>func</code>：</p>
<ul>
<li>设置连接对象<code>conn</code>的写回调函数 <code>conn-&gt;write_handler</code> 为 <code>func</code>，再注册写事件</li>
<li>如果设置的回调函数 <code>func</code>为<code>NULL</code>，则取消注册可写事件</li>
</ul>
<p>注意：这里注册的可写事件的回调函数是<code>ae_handler</code>，是因为在<code>ae_handler</code>中，综合处理了可读、可写事件。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connSocketSetWriteHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc func, <span class="keyword">int</span> barrier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (func == conn-&gt;write_handler) <span class="keyword">return</span> C_OK; </span><br><span class="line"></span><br><span class="line">    conn-&gt;write_handler = func;         <span class="comment">// 设置新的可写事件处理函数，</span></span><br><span class="line">    <span class="keyword">if</span> (barrier)                </span><br><span class="line">        conn-&gt;flags |= CONN_FLAG_WRITE_BARRIER;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        conn-&gt;flags &amp;= ~CONN_FLAG_WRITE_BARRIER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有设置可写事件处理函数,则取消关注可写事件</span></span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;write_handler)</span><br><span class="line">        aeDeleteFileEvent(server.el, conn-&gt;fd, AE_WRITABLE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 关注可写事件</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,                <span class="comment">// eventLoop</span></span><br><span class="line">                              conn-&gt;fd,                 <span class="comment">// epollfd</span></span><br><span class="line">                              AE_WRITABLE,              <span class="comment">// 关注可写事件</span></span><br><span class="line">                              conn-&gt;type-&gt;ae_handler,   <span class="comment">// 事件处理函数</span></span><br><span class="line">                              conn) == AE_ERR) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据函数 <code>connSocketSetWriteHandler</code> 的第三个标志位<code>barrier</code>，可封装成两个函数给用户使用，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">connSetWriteHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;type-&gt;set_write_handler(conn, func, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">connSetWriteHandlerWithBarrier</span><span class="params">(connection *conn, ConnectionCallbackFunc func, <span class="keyword">int</span> barrier)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;type-&gt;set_write_handler(conn, func, barrier);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="connSocketSetReadHandler"><a href="#connSocketSetReadHandler" class="headerlink" title="connSocketSetReadHandler"></a>connSocketSetReadHandler</h4><p><code>connSocketSetReadHandler</code>主要是注册可读事件，并设置读回调函数为 <code>ae_handler</code>，真正执行读取操作的还是<code>func</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关注可读事件并设置可读取事件处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connSocketSetReadHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (func == conn-&gt;read_handler) <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    conn-&gt;read_handler = func;</span><br><span class="line">    <span class="keyword">if</span> (!conn-&gt;read_handler)</span><br><span class="line">        aeDeleteFileEvent(server.el,conn-&gt;fd,AE_READABLE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,</span><br><span class="line">                              conn-&gt;fd,</span><br><span class="line">                              AE_READABLE,</span><br><span class="line">                              conn-&gt;type-&gt;ae_handler,conn) == AE_ERR) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上层是通过<code>conn</code>对象调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">connSetReadHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;type-&gt;set_read_handler(conn, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，一个连接对象<code>conn</code>基本介绍完毕，其余的等待应用到介绍。</p>
<h2 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h2><p>下面介绍服务端处理客户端连接请求的流程。</p>
<h3 id="acceptTcpHandler"><a href="#acceptTcpHandler" class="headerlink" title="acceptTcpHandler"></a>acceptTcpHandler</h3><p><code>acceptTcpHandler</code>函数，是服务器处理客户端的连接请求的回调函数，即监听文件描述符<code>server.ipfd[j]</code>的处理可读事件的回调函数。这个函数在<code>server.c</code>函数中设置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in server.c</span></span><br><span class="line"><span class="comment">/* Create an event handler for accepting new connections in TCP and Unix domain sockets. */</span></span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.ipfd_count; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (aeCreateFileEvent(server.el, server.ipfd[j], AE_READABLE, acceptTcpHandler, <span class="literal">NULL</span>) == AE_ERR)</span><br><span class="line">        serverPanic(<span class="string">&quot;Unrecoverable error creating server.ipfd file event.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>acceptTcpHandler</code>函数中，获取客户端<code>cfd</code>，并建立连接。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ACCEPTS_PER_CALL 1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cport, cfd, max = MAX_ACCEPTS_PER_CALL;	 <span class="comment">// cport 客户端的端口，cfd 客户端的 fd</span></span><br><span class="line">    <span class="keyword">char</span> cip[NET_IP_STR_LEN]; 					<span class="comment">// 客户端的 ip</span></span><br><span class="line">    UNUSED(el);</span><br><span class="line">    UNUSED(mask);</span><br><span class="line">    UNUSED(privdata);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为了防止短时间内过多的客户端连接请求，造成阻塞</span></span><br><span class="line">    <span class="comment">// 每次事件循环只能处理 MAX_ACCEPTS_PER_CALL 个客户端连接请求</span></span><br><span class="line">    <span class="keyword">while</span>(max--) &#123;</span><br><span class="line">        cfd = anetTcpAccept(server.neterr, fd, cip, <span class="keyword">sizeof</span>(cip), &amp;cport);</span><br><span class="line">        <span class="keyword">if</span> (cfd == ANET_ERR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno != EWOULDBLOCK)</span><br><span class="line">                serverLog(LL_WARNING, <span class="string">&quot;Accepting client connection: %s&quot;</span>, server.neterr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        serverLog(LL_VERBOSE,<span class="string">&quot;Accepted %s:%d&quot;</span>, cip, cport);</span><br><span class="line">        <span class="comment">// 处理客户端</span></span><br><span class="line">        acceptCommonHandler(connCreateAcceptedSocket(cfd), <span class="number">0</span>, cip);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="connCreateAcceptedSocket"><a href="#connCreateAcceptedSocket" class="headerlink" title="connCreateAcceptedSocket"></a>connCreateAcceptedSocket</h3><p>主要是创建客户端连接对象<code>conn</code>，此外</p>
<ul>
<li>设置<code>conn-&gt;fd</code>为客户端<code>cfd</code></li>
<li>将<code>conn</code>对象的状态初始化为 <code>CONN_STATE_ACCEPTING</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">connection *<span class="title">connCreateSocket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    connection *conn = zcalloc(<span class="keyword">sizeof</span>(connection));</span><br><span class="line">    conn-&gt;type = &amp;CT_Socket;</span><br><span class="line">    conn-&gt;fd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">connection* <span class="title">connCreateAcceptedSocket</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    connection *conn = connCreateSocket();</span><br><span class="line">    conn-&gt;fd = fd;							<span class="comment">// accept 得到的 fd</span></span><br><span class="line">    conn-&gt;state = CONN_STATE_ACCEPTING;  	  <span class="comment">// 此时状态</span></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="acceptCommonHandler"><a href="#acceptCommonHandler" class="headerlink" title="acceptCommonHandler"></a>acceptCommonHandler</h3><p>这个函数主要查看<code>accept</code>所得的客户端是否合理，满足各个条件，最终创建客户端。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建客户端</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptCommonHandler</span><span class="params">(connection *conn, <span class="keyword">int</span> flags, <span class="keyword">char</span> *ip)</span> </span>&#123;</span><br><span class="line">    client *c;</span><br><span class="line">    UNUSED(ip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Admission control will happen before a client is created and connAccept() called, </span></span><br><span class="line"><span class="comment">     * because we don&#x27;t want to even start transport-level negotiation if rejected.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 如果客户端连接请求超过限制，则直接关闭这个客户端即可，</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.clients) &gt;= server.maxclients) &#123;</span><br><span class="line">        <span class="keyword">char</span> *err = <span class="string">&quot;-ERR max number of clients reached\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* That&#x27;s a best effort error message, don&#x27;t check write errors.</span></span><br><span class="line"><span class="comment">         * Note that for TLS connections, no handshake was done yet so nothing is written</span></span><br><span class="line"><span class="comment">         * and the connection will just drop.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 发送给客户端错误信息</span></span><br><span class="line">        <span class="keyword">if</span> (connWrite(conn,err,<span class="built_in">strlen</span>(err)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Nothing to do, Just to avoid the warning... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        server.stat_rejected_conn++;    <span class="comment">// 用于调试信息</span></span><br><span class="line">        connClose(conn);			   <span class="comment">// 关闭客户端</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create connection and client */</span></span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    <span class="keyword">if</span> ((c = createClient(conn)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建失败，内存不足，则应该直接关闭这次行为</span></span><br><span class="line">        <span class="keyword">char</span> conninfo[<span class="number">100</span>];</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                 <span class="string">&quot;Error registering fd event for the new client: %s (conn: %s)&quot;</span>,</span><br><span class="line">                  connGetLastError(conn),</span><br><span class="line">                  connGetInfo(conn, conninfo, <span class="keyword">sizeof</span>(conninfo)));</span><br><span class="line">        connClose(conn); <span class="comment">/* May be already closed, just ignore errors */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Last chance to keep flags */</span></span><br><span class="line">    c-&gt;flags |= flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Initiate accept.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that connAccept() is free to do two things here:</span></span><br><span class="line"><span class="comment">     * 1. Call clientAcceptHandler() immediately;</span></span><br><span class="line"><span class="comment">     * 2. Schedule a future call to clientAcceptHandler().</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Because of that, we must do nothing else afterwards.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// connAccept 主要是调用函数 clientAcceptHandler 对获得的客户端状态进行判断</span></span><br><span class="line">    <span class="keyword">if</span> (connAccept(conn, clientAcceptHandler) == C_ERR) &#123;</span><br><span class="line">        <span class="keyword">char</span> conninfo[<span class="number">100</span>];</span><br><span class="line">        <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_ERROR) &#123; </span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Error accepting a client connection: %s (conn: %s)&quot;</span>,</span><br><span class="line">                       connGetLastError(conn), </span><br><span class="line">                       connGetInfo(conn, conninfo, <span class="keyword">sizeof</span>(conninfo)));</span><br><span class="line">        &#125;</span><br><span class="line">        freeClient(connGetPrivateData(conn)); <span class="comment">// 同步关闭</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="createClient"><a href="#createClient" class="headerlink" title="createClient"></a>createClient</h4><p>创建客户端的主要任务如下：</p>
<ul>
<li>将客户端<code>cfd</code>设置为非阻塞<code>IO</code>模式</li>
<li>设置客户端的<code>TCP</code>参数，比如<code>cfd</code>上开启<code>nagle</code>算法</li>
<li>开启保活定时器，即心跳检测，但是改变了默认值</li>
<li>注册可读事件，并设置了读回调函数<code>readQueryFromClient</code>。这点符合<code>LT</code>模式的逻辑，没有注册可写事件，防止<code>busy loop</code></li>
<li><code>client</code>对象其他参数初始化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* passing NULL as conn it is possible to create a non connected client.</span></span><br><span class="line"><span class="comment">     * This is useful since all the commands needs to be executed</span></span><br><span class="line"><span class="comment">     * in the context of a client. When commands are executed in other</span></span><br><span class="line"><span class="comment">     * contexts (for instance a Lua script) we need a non connected client. */</span></span><br><span class="line">    <span class="comment">// Lua 脚本环境下，conn是NULL</span></span><br><span class="line">    <span class="keyword">if</span> (conn) &#123;</span><br><span class="line">        connNonBlock(conn);         <span class="comment">// 设置客户端为非阻塞</span></span><br><span class="line">        connEnableTcpNoDelay(conn); <span class="comment">// 开启 nagle</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)    <span class="comment">// 心跳检测</span></span><br><span class="line">            connKeepAlive(conn,server.tcpkeepalive);</span><br><span class="line">        connSetReadHandler(conn, readQueryFromClient); <span class="comment">// 注册可读事件，可读事件的回调函数是 readQueryFromClient </span></span><br><span class="line">        connSetPrivateData(conn, c);                   <span class="comment">// conn-&gt;private_data = data;</span></span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">// --- 下面是一些参数初始化</span></span><br></pre></td></tr></table></figure>
<h5 id="connEnableTcpNoDelay"><a href="#connEnableTcpNoDelay" class="headerlink" title="connEnableTcpNoDelay"></a>connEnableTcpNoDelay</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connEnableTcpNoDelay</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;fd == <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">return</span> anetEnableTcpNoDelay(<span class="literal">NULL</span>, conn-&gt;fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetEnableTcpNoDelay</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> anetSetTcpNoDelay(err, fd, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="connNonBlock"><a href="#connNonBlock" class="headerlink" title="connNonBlock"></a>connNonBlock</h5><p>将客户端设置为非阻塞IO模式，经过层层套娃，最终是调用 <code>anetSetBlock</code> 函数实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connNonBlock</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;fd == <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">return</span> anetNonBlock(<span class="literal">NULL</span>, conn-&gt;fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetNonBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> anetSetBlock(err,fd,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>anetSetBlock</p>
<p>将文件描述符fd设置为非阻塞IO模式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetSetBlock</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">int</span> non_block)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the socket blocking (if non_block is zero) or non-blocking.</span></span><br><span class="line"><span class="comment">     * Note that fcntl(2) for F_GETFL and F_SETFL can&#x27;t be</span></span><br><span class="line"><span class="comment">     * interrupted by a signal. */</span></span><br><span class="line">    <span class="keyword">if</span> ((flags = fcntl(fd, F_GETFL)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;fcntl(F_GETFL): %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (non_block)</span><br><span class="line">        flags |= O_NONBLOCK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        flags &amp;= ~O_NONBLOCK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fcntl(fd, F_SETFL, flags) == <span class="number">-1</span>) &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;fcntl(F_SETFL,O_NONBLOCK): %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ANET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>anetSetTcpNoDelay</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">anetSetTcpNoDelay</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &amp;val, <span class="keyword">sizeof</span>(val)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        anetSetError(err, <span class="string">&quot;setsockopt TCP_NODELAY: %s&quot;</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ANET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="connKeepAlive"><a href="#connKeepAlive" class="headerlink" title="connKeepAlive"></a>connKeepAlive</h5><p>在 <code>connKeepAlive</code>底层调用的是 <code>anetKeepAlive</code>实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connKeepAlive</span><span class="params">(connection *conn, <span class="keyword">int</span> interval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;fd == <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">return</span> anetKeepAlive(<span class="literal">NULL</span>, conn-&gt;fd, interval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>anetKeepAlive</p>
<p>下面的代码中的心跳检测部分值得学习：</p>
<ul>
<li>是为每个客户端设置心跳检测</li>
<li>通过三个选项，改变了<code>keeplive</code>的默认值</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Set TCP keep alive option to detect dead peers. The interval option</span></span><br><span class="line"><span class="comment">* is only used for Linux as we are using Linux-specific APIs to set</span></span><br><span class="line"><span class="comment">* the probe send time, interval, and count. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">anetKeepAlive</span><span class="params">(<span class="keyword">char</span> *err, <span class="keyword">int</span> fd, <span class="keyword">int</span> interval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> val = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_KEEPALIVE, &amp;val, <span class="keyword">sizeof</span>(val)) == <span class="number">-1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      anetSetError(err, <span class="string">&quot;setsockopt SO_KEEPALIVE: %s&quot;</span>, strerror(errno));</span><br><span class="line">      <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __linux__</span></span><br><span class="line">  <span class="comment">/* Default settings are more or less garbage, with the keepalive time</span></span><br><span class="line"><span class="comment">    * set to 7200 by default on Linux. Modify settings to make the feature</span></span><br><span class="line"><span class="comment">    * actually useful. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Send first probe after interval. */</span></span><br><span class="line">  val = interval;</span><br><span class="line">  <span class="keyword">if</span> (setsockopt(fd, IPPROTO_TCP, TCP_KEEPIDLE, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      anetSetError(err, <span class="string">&quot;setsockopt TCP_KEEPIDLE: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">      <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Send next probes after the specified interval. Note that we set the</span></span><br><span class="line"><span class="comment">    * delay as interval / 3, as we send three probes before detecting</span></span><br><span class="line"><span class="comment">    * an error (see the next setsockopt call). */</span></span><br><span class="line">  val = interval/<span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (val == <span class="number">0</span>) val = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (setsockopt(fd, IPPROTO_TCP, TCP_KEEPINTVL, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      anetSetError(err, <span class="string">&quot;setsockopt TCP_KEEPINTVL: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">      <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Consider the socket in error state after three we send three ACK</span></span><br><span class="line"><span class="comment">    * probes without getting a reply. */</span></span><br><span class="line">  val = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> (setsockopt(fd, IPPROTO_TCP, TCP_KEEPCNT, &amp;val, <span class="keyword">sizeof</span>(val)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      anetSetError(err, <span class="string">&quot;setsockopt TCP_KEEPCNT: %s\n&quot;</span>, strerror(errno));</span><br><span class="line">      <span class="keyword">return</span> ANET_ERR;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  ((<span class="keyword">void</span>) interval); <span class="comment">/* Avoid unused var warning for non Linux systems. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ANET_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="connAccept"><a href="#connAccept" class="headerlink" title="connAccept"></a>connAccept</h4><p>connAccept内部调用如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">connAccept</span><span class="params">(connection *conn, ConnectionCallbackFunc accept_handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> conn-&gt;type-&gt;accept(conn, accept_handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，实际上调用的回调函数是 <code>connSocketAccept</code>，主要完成两个任务：</p>
<ul>
<li>将<code>conn</code>的状态从<code>CONN_STATE_ACCEPTING</code>转变为<code>CONN_STATE_CONNECTED</code></li>
<li>在<code>callHandler</code>中调用<code>accept_handler</code>函数，此处即 <code>clientAcceptHandler</code>，校验<code>conn</code>状态</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// conn-&gt;type-&gt;accept</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">connSocketAccept</span><span class="params">(connection *conn, ConnectionCallbackFunc accept_handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;state != CONN_STATE_ACCEPTING)    <span class="comment">// 判断连接状态</span></span><br><span class="line">        <span class="keyword">return</span> C_ERR;   </span><br><span class="line">    conn-&gt;state = CONN_STATE_CONNECTED;         <span class="comment">// 转换为：连接完成状态</span></span><br><span class="line"></span><br><span class="line">    connIncrRefs(conn);</span><br><span class="line">    <span class="keyword">if</span> (!callHandler(conn, accept_handler))     <span class="comment">// 调用回调函数 accept_handler</span></span><br><span class="line">        ret = C_ERR;</span><br><span class="line">    connDecrRefs(conn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="clientAcceptHandler"><a href="#clientAcceptHandler" class="headerlink" title="clientAcceptHandler"></a>clientAcceptHandler</h4><p>这个回调函数，主要是用于判断调用<code>connAccept</code>是否顺利，此时的状态<code>conn-&gt;state</code>应该是 <code>CONN_STATE_CONNECTED</code>，如果不是则需要关闭客户端、释放相关资源。因此，<code>clientAcceptHandler</code>相当于一个善后校验处理函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对accept后建立的连接状态进行判断</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clientAcceptHandler</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *c = connGetPrivateData(conn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">&quot;Error accepting a client connection: %s&quot;</span>,</span><br><span class="line">                   connGetLastError(conn));</span><br><span class="line">        freeClientAsync(c);  <span class="comment">// 异步的</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the server is running in protected mode (the default) and there is no password set, </span></span><br><span class="line"><span class="comment">     * nor a specific interface is bound, we don&#x27;t accept</span></span><br><span class="line"><span class="comment">     * requests from non loopback interfaces. Instead we try to explain the</span></span><br><span class="line"><span class="comment">     * user what to do to fix it if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.protected_mode &amp;&amp;</span><br><span class="line">        server.bindaddr_count == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        DefaultUser-&gt;flags &amp; USER_FLAG_NOPASS &amp;&amp;</span><br><span class="line">        !(c-&gt;flags &amp; CLIENT_UNIX_SOCKET))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> cip[NET_IP_STR_LEN+<span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        connPeerToString(conn, cip, <span class="keyword">sizeof</span>(cip)<span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// 如果 cip 同时满足 127.0.0.1  与 ::1 </span></span><br><span class="line">        <span class="comment">// 下面 if 中的不可能执行</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(cip,<span class="string">&quot;127.0.0.1&quot;</span>) &amp;&amp; <span class="built_in">strcmp</span>(cip,<span class="string">&quot;::1&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">char</span> *err = <span class="string">&quot;-DENIED Redis is running in protected mode because protected &quot;</span></span><br><span class="line">                        <span class="string">&quot;mode is enabled, no bind address was specified, no &quot;</span></span><br><span class="line">                        <span class="string">&quot;authentication password is requested to clients. In this mode &quot;</span></span><br><span class="line">                        <span class="string">&quot;connections are only accepted from the loopback interface. &quot;</span></span><br><span class="line">                        <span class="string">&quot;If you want to connect from external computers to Redis you &quot;</span></span><br><span class="line">                        <span class="string">&quot;may adopt one of the following solutions: &quot;</span></span><br><span class="line">                        <span class="string">&quot;1) Just disable protected mode sending the command &quot;</span></span><br><span class="line">                        <span class="string">&quot;&#x27;CONFIG SET protected-mode no&#x27; from the loopback interface &quot;</span></span><br><span class="line">                        <span class="string">&quot;by connecting to Redis from the same host the server is &quot;</span></span><br><span class="line">                        <span class="string">&quot;running, however MAKE SURE Redis is not publicly accessible &quot;</span></span><br><span class="line">                        <span class="string">&quot;from internet if you do so. Use CONFIG REWRITE to make this &quot;</span></span><br><span class="line">                        <span class="string">&quot;change permanent. &quot;</span></span><br><span class="line">                        <span class="string">&quot;2) Alternatively you can just disable the protected mode by &quot;</span></span><br><span class="line">                        <span class="string">&quot;editing the Redis configuration file, and setting the protected &quot;</span></span><br><span class="line">                        <span class="string">&quot;mode option to &#x27;no&#x27;, and then restarting the server. &quot;</span></span><br><span class="line">                        <span class="string">&quot;3) If you started the server manually just for testing, restart &quot;</span></span><br><span class="line">                        <span class="string">&quot;it with the &#x27;--protected-mode no&#x27; option. &quot;</span></span><br><span class="line">                        <span class="string">&quot;4) Setup a bind address or an authentication password. &quot;</span></span><br><span class="line">                        <span class="string">&quot;NOTE: You only need to do one of the above things in order for &quot;</span></span><br><span class="line">                        <span class="string">&quot;the server to start accepting connections from the outside.\r\n&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (connWrite(c-&gt;conn,err,<span class="built_in">strlen</span>(err)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">/* Nothing to do, Just to avoid the warning... */</span></span><br><span class="line">            &#125;</span><br><span class="line">            server.stat_rejected_conn++;</span><br><span class="line">            freeClientAsync(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.stat_numconnections++;   <span class="comment">// 仅调试信息</span></span><br><span class="line">    moduleFireServerEvent(REDISMODULE_EVENT_CLIENT_CHANGE,</span><br><span class="line">                          REDISMODULE_SUBEVENT_CLIENT_CHANGE_CONNECTED,</span><br><span class="line">                          c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="callHandler"><a href="#callHandler" class="headerlink" title="callHandler"></a>callHandler</h4><p>只是一个辅助函数，用于调用回调函数 <code>handler</code>。</p>
<p>这里说下，<code>conn</code>的生命周期，因为这里是依靠引用计数维持<code>conn</code>的生命周期，因此每次在将<code>conn</code>作为参数时，都需要调用一次 <code>connIncrRefs(conn);</code>来增加引用，防止在 回调函数 <code>handler</code>中 <code>conn</code>被释放。比如 <code>handler</code>中又包含了一个 <code>callHandler</code>，那么没有这个增加引用计数，则潜藏着在第二个 <code>callHandler</code>中 <code>conn</code>就会关闭，导致返回到第一个 <code>callHandler</code>中时<code>conn</code>就失效了。</p>
<p>注意：整个代码中，只有两处有判断条件  <code>if (!connHasRefs(conn))</code> ：函数 <code>connClose</code> 和  <code>callHandler</code>，最后也肯定是在 <code>callHandler</code> 下面<code>if</code> 中关闭的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">callHandler</span><span class="params">(connection *conn, ConnectionCallbackFunc handler)</span> </span>&#123;</span><br><span class="line">    connIncrRefs(conn);				</span><br><span class="line">    <span class="keyword">if</span> (handler) handler(conn); 				 <span class="comment">// 如果存在处理程序handler,则处理</span></span><br><span class="line">    connDecrRefs(conn);</span><br><span class="line">    <span class="keyword">if</span> (conn-&gt;flags &amp; CONN_FLAG_CLOSE_SCHEDULED) &#123; </span><br><span class="line">        <span class="keyword">if</span> (!connHasRefs(conn)) connClose(conn);    <span class="comment">// 如果客户端conn没有引用了,则直接关闭客户端</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，服务端处理完了客户端连接请求，主要过程如下</p>
<ul>
<li>先是为这个客户<code>cfd</code>创建一个连接对象<code>conn</code>，保存了客户端文件描述符<code>conn-&gt;fd</code>以及当前连接状态<code>conn-&gt;state</code>。</li>
<li>为这个连接创建一个客户端对象<code>c</code>，还要为这个连接注册可读事件，设置读取回调事件为<code>readQueryFromClient</code>。毕竟客户端需要处理很多事情，并且将这个客户端对象保存在<code>conn-&gt;private_data</code>。此时，<code>conn</code>的状态是 <code>CONN_STATE_ACCEPTING</code></li>
<li>对这个客户端其他部分进行初始化，</li>
<li>上面都完成了，那么就是创建完成，状态就变成<code>CONN_STATE_ACCEPTING</code>转为<code>CONN_STATE_CONNECTED</code></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Connection"><span class="toc-number">1.</span> <span class="toc-text">Connection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConnectionType"><span class="toc-number">1.1.</span> <span class="toc-text">ConnectionType</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketEventHandler"><span class="toc-number">1.1.1.</span> <span class="toc-text">connSocketEventHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketWrite"><span class="toc-number">1.1.2.</span> <span class="toc-text">connSocketWrite</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketRead"><span class="toc-number">1.1.3.</span> <span class="toc-text">connSocketRead</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketClose"><span class="toc-number">1.1.4.</span> <span class="toc-text">connSocketClose</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketSetWriteHandler"><span class="toc-number">1.1.5.</span> <span class="toc-text">connSocketSetWriteHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connSocketSetReadHandler"><span class="toc-number">1.1.6.</span> <span class="toc-text">connSocketSetReadHandler</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Accept"><span class="toc-number">2.</span> <span class="toc-text">Accept</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#acceptTcpHandler"><span class="toc-number">2.1.</span> <span class="toc-text">acceptTcpHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#connCreateAcceptedSocket"><span class="toc-number">2.2.</span> <span class="toc-text">connCreateAcceptedSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#acceptCommonHandler"><span class="toc-number">2.3.</span> <span class="toc-text">acceptCommonHandler</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#createClient"><span class="toc-number">2.3.1.</span> <span class="toc-text">createClient</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#connEnableTcpNoDelay"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">connEnableTcpNoDelay</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#connNonBlock"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">connNonBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#connKeepAlive"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">connKeepAlive</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connAccept"><span class="toc-number">2.3.2.</span> <span class="toc-text">connAccept</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clientAcceptHandler"><span class="toc-number">2.3.3.</span> <span class="toc-text">clientAcceptHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#callHandler"><span class="toc-number">2.3.4.</span> <span class="toc-text">callHandler</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/01/26/Redis/Networking/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/01/26/Redis/Networking/&text=剖析REDIS网络通信"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/01/26/Redis/Networking/&title=剖析REDIS网络通信"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/01/26/Redis/Networking/&is_video=false&description=剖析REDIS网络通信"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS网络通信&body=Check out this article: https://szza.github.io/2021/01/26/Redis/Networking/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/01/26/Redis/Networking/&title=剖析REDIS网络通信"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/01/26/Redis/Networking/&title=剖析REDIS网络通信"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/01/26/Redis/Networking/&title=剖析REDIS网络通信"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/01/26/Redis/Networking/&title=剖析REDIS网络通信"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/01/26/Redis/Networking/&name=剖析REDIS网络通信&description=&lt;p&gt;本节介绍对客户端的封装以及服务器处理客户端连接请求的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端的封装&lt;/li&gt;
&lt;li&gt;服务器处理客户端的连接请求&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/01/26/Redis/Networking/&t=剖析REDIS网络通信"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
