<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="为保证主从一致，replication主要实现了两件事：  同步：将master的数据同步到slaves，此时主从一致 传播：将导致master的数据库发生改变的操作传播到slaves，使得主从仍旧一致">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析REDIS的replication">
<meta property="og:url" content="https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="为保证主从一致，replication主要实现了两件事：  同步：将master的数据同步到slaves，此时主从一致 传播：将导致master的数据库发生改变的操作传播到slaves，使得主从仍旧一致">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/images/PYSNC.jpg">
<meta property="article:published_time" content="2021-01-29T11:34:38.000Z">
<meta property="article:modified_time" content="2021-03-01T07:26:14.000Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Redis6.0">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/images/PYSNC.jpg">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>剖析REDIS的replication</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/02/03/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/hiredis/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/01/27/Redis/%E6%8C%81%E4%B9%85%E5%8C%96/RIO/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&text=剖析REDIS的replication"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&title=剖析REDIS的replication"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&is_video=false&description=剖析REDIS的replication"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS的replication&body=Check out this article: https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&title=剖析REDIS的replication"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&title=剖析REDIS的replication"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&title=剖析REDIS的replication"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&title=剖析REDIS的replication"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&name=剖析REDIS的replication&description=&lt;p&gt;为保证主从一致，replication主要实现了两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步：将master的数据同步到slaves，此时主从一致&lt;/li&gt;
&lt;li&gt;传播：将导致master的数据库发生改变的操作传播到slaves，使得主从仍旧一致&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&t=剖析REDIS的replication"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SYNC"><span class="toc-number">1.</span> <span class="toc-text">SYNC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#feedReplicationBacklog"><span class="toc-number">1.0.1.</span> <span class="toc-text">feedReplicationBacklog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyReplicationBacklog"><span class="toc-number">1.0.2.</span> <span class="toc-text">addReplyReplicationBacklog</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replicaofCommand"><span class="toc-number">1.1.</span> <span class="toc-text">replicaofCommand</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SLAVEOF-IP-PORT"><span class="toc-number">1.2.</span> <span class="toc-text">SLAVEOF IP PORT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationSetMaster"><span class="toc-number">1.2.1.</span> <span class="toc-text">replicationSetMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationDiscardCachedMaster"><span class="toc-number">1.2.2.</span> <span class="toc-text">replicationDiscardCachedMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationCacheMasterUsingMyself"><span class="toc-number">1.2.3.</span> <span class="toc-text">replicationCacheMasterUsingMyself</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationCreateMasterClient"><span class="toc-number">1.2.4.</span> <span class="toc-text">replicationCreateMasterClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connectWithMaster"><span class="toc-number">1.2.5.</span> <span class="toc-text">connectWithMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#syncWithMaster"><span class="toc-number">1.2.6.</span> <span class="toc-text">syncWithMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slaveTryPartialResynchronization"><span class="toc-number">1.2.7.</span> <span class="toc-text">slaveTryPartialResynchronization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationResurrectCachedMaster"><span class="toc-number">1.2.8.</span> <span class="toc-text">replicationResurrectCachedMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PYSNC-CONTINUE"><span class="toc-number">1.2.9.</span> <span class="toc-text">PYSNC_CONTINUE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commandProcessed"><span class="toc-number">1.2.10.</span> <span class="toc-text">commandProcessed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationFeedSlavesFromMasterStream"><span class="toc-number">1.2.11.</span> <span class="toc-text">replicationFeedSlavesFromMasterStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PSYNC-FULLRESYNC"><span class="toc-number">1.2.12.</span> <span class="toc-text">PSYNC_FULLRESYNC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readSyncBulkPayload"><span class="toc-number">1.2.13.</span> <span class="toc-text">readSyncBulkPayload</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SLAVEOF-NO-ONE"><span class="toc-number">1.3.</span> <span class="toc-text">SLAVEOF NO ONE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationUnsetMaster"><span class="toc-number">1.3.1.</span> <span class="toc-text">replicationUnsetMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shiftReplicationId"><span class="toc-number">1.3.2.</span> <span class="toc-text">shiftReplicationId</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replconfCommand"><span class="toc-number">1.4.</span> <span class="toc-text">replconfCommand</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#syncCommand-%E2%80%93-Partial"><span class="toc-number">1.4.1.</span> <span class="toc-text">syncCommand – Partial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#masterTryPartialResynchronization"><span class="toc-number">1.4.2.</span> <span class="toc-text">masterTryPartialResynchronization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#syncCommnad-%E2%80%93-Full"><span class="toc-number">1.4.3.</span> <span class="toc-text">syncCommnad – Full</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#startBgsaveForReplication"><span class="toc-number">1.4.4.</span> <span class="toc-text">startBgsaveForReplication</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbSaveToSlavesSockets"><span class="toc-number">1.4.5.</span> <span class="toc-text">rdbSaveToSlavesSockets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationSetupSlaveForFullResync"><span class="toc-number">1.4.6.</span> <span class="toc-text">replicationSetupSlaveForFullResync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbPipeReadHandler"><span class="toc-number">1.4.7.</span> <span class="toc-text">rdbPipeReadHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbPipeWriteHandler"><span class="toc-number">1.4.8.</span> <span class="toc-text">rdbPipeWriteHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbPipeWriteHandlerConnRemoved"><span class="toc-number">1.4.9.</span> <span class="toc-text">rdbPipeWriteHandlerConnRemoved</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#backgroundSaveDoneHandler"><span class="toc-number">1.4.10.</span> <span class="toc-text">backgroundSaveDoneHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateSlavesWaitingBgsave"><span class="toc-number">1.4.11.</span> <span class="toc-text">updateSlavesWaitingBgsave</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendBulkToSlave"><span class="toc-number">1.4.12.</span> <span class="toc-text">sendBulkToSlave</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#putSlaveOnline"><span class="toc-number">1.4.13.</span> <span class="toc-text">putSlaveOnline</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#propagate"><span class="toc-number">1.5.</span> <span class="toc-text">propagate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationFeedSlaves"><span class="toc-number">1.5.1.</span> <span class="toc-text">replicationFeedSlaves</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replicationCron"><span class="toc-number">1.6.</span> <span class="toc-text">replicationCron</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        剖析REDIS的replication
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-01-29T11:34:38.000Z" itemprop="datePublished">2021-01-29</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Redis6-0-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/">Redis6.0 源码解析</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Redis6-0/" rel="tag">Redis6.0</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>为保证主从一致，replication主要实现了两件事：</p>
<ul>
<li>同步：将master的数据同步到slaves，此时主从一致</li>
<li>传播：将导致master的数据库发生改变的操作传播到slaves，使得主从仍旧一致</li>
</ul>
<a id="more"></a>

<h2 id="SYNC"><a href="#SYNC" class="headerlink" title="SYNC"></a>SYNC</h2><p>客户端向slave发<code>SLAVEOF IP PORT</code>，使得slave成为由<code>(IP, PORT)</code>指定的master的slave，slave会向master发送<code>SYNC RUN_ID OFFSET</code>指令，请求与master完成数据同步：</p>
<ul>
<li>slave向master发生SYNC命令</li>
<li>master收到SYNC命令之后执行<code>BGSAVE</code>命令，生成RDB文件，并使用一个缓冲区记录从此刻开始执行的所有写命令</li>
<li><code>BGSAVE</code>命令结束，master将RDB文件发送给slave，再将缓冲区的数据发送给slave</li>
</ul>
<p>SYNC命令结束，主从此刻数据保持一致性。</p>
<p>SYNC指令，适用于slave初次复制master，即slave之前没复制过当前maste。但是，对于断线重新连接比较耗时、效率低，因此此时只是想复制断线期间的不同，而不是整个数据库，即，SYNC不支持同步master的部分数据，仅支持同步全部数据。因此，针对SYNC的缺陷，在REDIS2.8之后引入了部分重同步，新的协议是PSYNC</p>
<p><strong>PSYNC</strong></p>
<p>PSYNC具有完全重同步 （<strong>F</strong>ull  re-<strong>S</strong>ynchronization）和部分重同步（<strong>P</strong>artial re-<strong>S</strong>ynchronization）两种能力：</p>
<ul>
<li>完全重同步：用于slave初次复制master的情况，和SYNC命令一致。</li>
<li>部分重同步：用于断线重连时的复制情况，此时slave应该复制断线期间master累计的写命令，就可以恢复主从数据一致性。</li>
</ul>
<p>部分重同步，主要是由下面三个部分组成：</p>
<ol>
<li><p><code>server.repl_backlog</code>：是一个固定长度循环数组，但可以看作无限长的数组，可以一直向<code>server.repl_backlog</code>中循环写入数据，只是读取不及时会被覆盖。由三个变量指示着<code>server.repl_backlog</code>的状态：</p>
<p>+　  <code>server.repl_backlog_size</code>：是<code>server.repl_backlog</code>的固定大小，默认是1M，可以由配置文件修改<br>+　  <code>server.repl_backlog_histlen</code>：是向<code>server.repl_backlog</code>中已经写入的数据长度<br>+　  <code>server.repl_backlog_idx</code>：是<code>server.repl_backlog</code>当前写指针的位置</p>
<p>上面三个字段都不会超过<code>server.repl_backloh_size</code>的大小。</p>
</li>
<li><p>复制偏移量</p>
<p>+　  <code>server.master_repl_offset</code>：是当前写入<code>server.repl_backlog</code>的总共字节数，可以看着是写入的缓冲区的最后一个字节。每次主服务回应从服务器PSYNC请求，在完全重同步时，<code>+FULLSYNC master_replid offset</code>中的<code>offset</code>即<code>server.master_repl_offset</code><br>+　  <code>server.repl_backlog_off</code>：总是等于<code>server.master_repl_offset-server.repl_backlog_histlen + 1</code>，因此可以看作的缓冲区的第一个字节</p>
<p>因此，当写入字节较多，会出现<code>server.master_repl_offset &gt; server.repl_backlog_size</code> </p>
<h4 id="feedReplicationBacklog"><a href="#feedReplicationBacklog" class="headerlink" title="feedReplicationBacklog"></a>feedReplicationBacklog</h4><p><code>feedReplicationBacklog</code>函数向<code>server.repl_backlog</code>中添加长度为<code>len</code>的数据 <code>ptr</code>的过程如下：</p>
<pre><code>+ ` server.master_repl_offset `：表示一共向`server.repl_backlog`添加的字节数，
+ `server.repl_backlog_off`：表示当前待同步偏移量</code></pre>
<p>这两个是一直增长的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedReplicationBacklog</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ptr;</span><br><span class="line"></span><br><span class="line">    server.master_repl_offset += len; <span class="comment">//缓冲区的最后一个字节</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> thislen = server.repl_backlog_size - server.repl_backlog_idx;</span><br><span class="line">        <span class="keyword">if</span> (thislen &gt; len) thislen = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(server.repl_backlog+server.repl_backlog_idx, p, thislen);</span><br><span class="line">        server.repl_backlog_idx += thislen;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 从头开始写</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog_idx == server.repl_backlog_size)</span><br><span class="line">            server.repl_backlog_idx = <span class="number">0</span>;</span><br><span class="line">        len -= thislen;	</span><br><span class="line">        p += thislen;</span><br><span class="line">        server.repl_backlog_histlen += thislen;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (server.repl_backlog_histlen &gt; server.repl_backlog_size)</span><br><span class="line">        server.repl_backlog_histlen = server.repl_backlog_size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1) 当 server.repl_backlog_histlen == server.repl_backlog_size 不再改变时，</span></span><br><span class="line">    <span class="comment">// 每次向 server.back_log 中写入字节数，总是会增加 server.master_repl_offset</span></span><br><span class="line">    <span class="comment">// 使得 server.repl_backlog_off 也是合理的增加 </span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// 2) 当 server.repl_backlog_histlen &lt; server.repl_backlog_size，</span></span><br><span class="line">    <span class="comment">// 	 server.repl_backlog_off 总是不变</span></span><br><span class="line">    server.repl_backlog_off = server.master_repl_offset -</span><br><span class="line">                              server.repl_backlog_histlen + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="addReplyReplicationBacklog"><a href="#addReplyReplicationBacklog" class="headerlink" title="addReplyReplicationBacklog"></a>addReplyReplicationBacklog</h4><p><code>addReplyReplicationBacklog</code>函数，将<code>[offset, server.master_repl_off]</code>的数据添加到发送缓冲区，但是由于<code>offset</code>和<code>server.master_repl_off</code>会大于<code>server.repl_backlog_size</code>，因此要经过一些转换将将<code>offset</code>转换到隔离范围内。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">addReplyReplicationBacklog</span><span class="params">(client *c, <span class="keyword">long</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> j, skip, len;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_DEBUG, <span class="string">&quot;[PSYNC] Replica request offset: %lld&quot;</span>, offset);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// server.repl_backlog 没有待发送数据，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_backlog_histlen == <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_DEBUG, <span class="string">&quot;[PSYNC] Backlog history len is zero&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_DEBUG, <span class="string">&quot;[PSYNC] Backlog size: %lld&quot;</span>, server.repl_backlog_size);</span><br><span class="line">    serverLog(LL_DEBUG, <span class="string">&quot;[PSYNC] First byte: %lld&quot;</span>,   server.repl_backlog_off);</span><br><span class="line">    serverLog(LL_DEBUG, <span class="string">&quot;[PSYNC] History len: %lld&quot;</span>,  server.repl_backlog_histlen);</span><br><span class="line">    serverLog(LL_DEBUG, <span class="string">&quot;[PSYNC] Current index: %lld&quot;</span>,server.repl_backlog_idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 下面的变化,是为了将 j　转换到 server.repl_backlog_size 范围内 ***/</span></span><br><span class="line">   	</span><br><span class="line">    <span class="comment">// 要跳过的位置</span></span><br><span class="line">    skip = offset - server.repl_backlog_off;</span><br><span class="line">    serverLog(LL_DEBUG, <span class="string">&quot;[PSYNC] Skipping: %lld&quot;</span>, skip);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 由于可能 server.repl_backlog_off &gt; server.repl_backlog_size,</span></span><br><span class="line"><span class="comment">     * 因此不能直接 j = server.repl_backlog_off，而需要转换</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * x = (server.repl_backlog_size - server.repl_backlog_histlen) </span></span><br><span class="line"><span class="comment">     * 那么x是 server.repl_backlog 的剩余空闲空间，</span></span><br><span class="line"><span class="comment">     * j = server.repl_backlog_idx + x 则指向了读指针，</span></span><br><span class="line"><span class="comment">     * 即 j 是 server.repl_backlog_off 在 server.repl_backlog_size 范围内的表示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    j = (server.repl_backlog_idx + (server.repl_backlog_size - server.repl_backlog_histlen)) % </span><br><span class="line">        server.repl_backlog_size;</span><br><span class="line">    serverLog(LL_DEBUG, <span class="string">&quot;[PSYNC] Index of first byte: %lld&quot;</span>, j);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* j = (j+skip) % server.repl_backlog_size; 使得 j 指向了 offset</span></span><br><span class="line"><span class="comment">     * 在 server.repl_backlog_size 范围的合理表示</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    j = (j + skip) % server.repl_backlog_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [offset, server.master_repl_off]之间的数据长度 len</span></span><br><span class="line">    <span class="comment">// 即 len = server.repl_backlog_histlen - skip</span></span><br><span class="line">    <span class="comment">// len 表示待发送的数据长度</span></span><br><span class="line">    len = server.repl_backlog_histlen - skip;</span><br><span class="line">    serverLog(LL_DEBUG, <span class="string">&quot;[PSYNC] Reply total length: %lld&quot;</span>, len);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/******************将 len个字节发送出去******************/</span></span><br><span class="line">    <span class="comment">// 如果 [j, server.repl_backlog_idx] 的长度 &lt; len</span></span><br><span class="line">    <span class="comment">// 则说明，还有部分数据存在 server.repl_backlog的前面:</span></span><br><span class="line">    <span class="comment">// 			[0, len - (server.repl_backlog_size - j)]</span></span><br><span class="line">    <span class="comment">// 如果是上述情况，则分两次发送，否则一次发送</span></span><br><span class="line">    <span class="keyword">while</span>(len) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> thislen = ((server.repl_backlog_size - j) &lt; len) ?</span><br><span class="line">                             (server.repl_backlog_size - j) : </span><br><span class="line">                             len;</span><br><span class="line"></span><br><span class="line">        serverLog(LL_DEBUG, <span class="string">&quot;[PSYNC] addReply() length: %lld&quot;</span>, thislen);</span><br><span class="line">        addReplySds(c, sdsnewlen(server.repl_backlog + j, thislen));</span><br><span class="line">        len -= thislen;</span><br><span class="line">        j = <span class="number">0</span>; <span class="comment">// 这是为了重新回到循环缓冲区前面</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 已发送字节数</span></span><br><span class="line">    <span class="keyword">return</span> server.repl_backlog_histlen - skip;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>服务器的运行Id</p>
<p>每个服务器都有<code>RUN_ID</code>，每个<code>RUN_ID</code>都是由于40个随机的16进制字符。</p>
<p>+　初次复制的时候或者之前执行过<code>SLAVEOF NO ONE</code>命令，slave不知道master的<code>RUN_ID</code>，此时发送的PSYNC指令是 **<code>PSYNC ? -1</code>**。master会将自己的<code>RUN_ID</code>发送给slave，slave会将其保存在<code>server.replid</code><br>+　断开重连后，slave向master发送PSYNC指令，master会检测PSYNC中的<code>RUN_ID</code>，是否与自己的<code>RUN_ID</code>一致。如果一致则执行部分重同步；如果<code>RUN_ID</code>不一致，则执行完全重同步。</p>
<p>上面讲解了实现PSYNC指令在slave端的操作，下面讲解下master对PSYNC指令的回应。</p>
<ul>
<li>如果master判断要执行完全重同步，则回复slave：<font color=blue> ＋FULLRESYNC  RUN_ID OFFSET</font>，其中Run Id是master的运行I的，供Slave保存，<code>OFFSET</code>是主服务器当前的偏移量<code>server.master_repl_offset</code>，从服务器会将其作为自己的初始化偏移量。</li>
<li>如果master判断要执行部分冲同步，则回复slave：<font color=blue>＋CONTINUE</font>，</li>
<li>如果主服务器无法识别PSYNC命令，则回复slave：<font color=red>- ERR </font>，master的REdis版本低于2.8，slave需要发送SYNC指令。</li>
</ul>
</li>
</ol>
<p>主从服务器的同步过程大致如下图：</p>
<p><img src="./images/PYSNC.jpg"></p>
<p>然后，由于在实际中经常会下面情况，在PSYNC之后又实现了PYSNC2指令：</p>
<ul>
<li>出现从服务器出现故障，使得复制信息丢失</li>
<li>master出现故障，导致主从切换，此时需要从多个从服务器中选择一个作为master，那么master的<code>RUN_ID</code>就会发生改变</li>
</ul>
<p>这个时候，是无法执行部分重新同步，在REDIS4.0又提出了PSYNC2协议。</p>
<p><strong>PYSNC2</strong></p>
<p>PSYNC2主要进行了两点进行优化：</p>
<ol>
<li><p>将主从复制信息持久化。将REDIS的复制信息给持久化到RDB文件中（关于RDB详细可见我的RDB设计分析），那么服务器重启的时候，就能加载RDB中的复制信息，依旧可以继续复制了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rdbSaveAuxFieldStrInt(rdb,<span class="string">&quot;repl-stream-db&quot;</span>,rsi-&gt;repl_stream_db) == <span class="number">-1</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveAuxFieldStrStr(rdb,<span class="string">&quot;repl-id&quot;</span>,server.replid) == <span class="number">-1</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (rdbSaveAuxFieldStrInt(rdb,<span class="string">&quot;repl-offset&quot;</span>,server.master_repl_offset) == <span class="number">-1</span>) </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>存储上一个主服务器的复制信息</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">char</span> replid2[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> second_replid_offset;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当master发生故障，就调用<code>shiftReplicationId</code>函数使用<code>server.replid2</code>和<code>server.second_replid_offset</code>来存储该master的复制信息。此外，判断部分同步的条件也会修改，代码下面叙述。</p>
</li>
</ol>
<p><strong>Slave端开始解析</strong></p>
<h3 id="replicaofCommand"><a href="#replicaofCommand" class="headerlink" title="replicaofCommand"></a>replicaofCommand</h3><p>在REDIS5.0开始，<code>SLAVEOF</code>指令和<code>REPLAOF</code>指令完全一致，都是调用<code>replicaofCommand</code>函数开始的，<code>replicaofCommand</code>函数，输入有两种参数：</p>
<ul>
<li><code>SLAVEOF NO ONE</code>：取消从服务器的复制行为</li>
<li><code>SLAVEOF IP PORT</code>：使从服务器slave复制由<code>(IP, PORT)</code>指定主服务器。</li>
</ul>
<h3 id="SLAVEOF-IP-PORT"><a href="#SLAVEOF-IP-PORT" class="headerlink" title="SLAVEOF IP PORT"></a>SLAVEOF IP PORT</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicaofCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> port;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果这个slaveof指令是由于另一个slave发送的，而不是用户的客户端，</span></span><br><span class="line">        <span class="comment">// 则无效</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_SLAVE)</span><br><span class="line">        &#123;</span><br><span class="line">            addReplyError(c, <span class="string">&quot;Command is not valid when client is a replica.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="keyword">if</span> ((getLongFromObjectOrReply(c, c-&gt;argv[<span class="number">2</span>], &amp;port, <span class="literal">NULL</span>) != C_OK))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 已经是 server.masterhost 的从服务器了，也无效</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost &amp;&amp; </span><br><span class="line">            !strcasecmp(server.masterhost, c-&gt;argv[<span class="number">1</span>]-&gt;ptr) &amp;&amp; </span><br><span class="line">            server.masterport == port) </span><br><span class="line">        &#123;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                      <span class="string">&quot;REPLICAOF would result into synchronization &quot;</span></span><br><span class="line">                      <span class="string">&quot;with the master we are already connected &quot;</span></span><br><span class="line">                      <span class="string">&quot;with. No operation performed.&quot;</span>);</span><br><span class="line"></span><br><span class="line">            addReplySds(c,sdsnew(<span class="string">&quot;+OK Already connected to specified master\r\n&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将(ip,port)设置到slave的自己参数里，并断开相关连接</span></span><br><span class="line">        replicationSetMaster(c-&gt;argv[<span class="number">1</span>]-&gt;ptr, port);</span><br><span class="line">        sds client = catClientInfoString(sdsempty(),c);</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">                  <span class="string">&quot;REPLICAOF %s:%d enabled (user request from &#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">                  server.masterhost, </span><br><span class="line">                  server.masterport, </span><br><span class="line">                  client);</span><br><span class="line"></span><br><span class="line">        sdsfree(client);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="replicationSetMaster"><a href="#replicationSetMaster" class="headerlink" title="replicationSetMaster"></a>replicationSetMaster</h4><p><code>replicationSetMaster</code>函数的调用者可能是从服务器，也可能是主服务器，但目的都是将调用<code>replicationSetMaster</code>函数的服务器server变成由<code>(IP, PORT)</code>指定服务器的slave。步骤如下：</p>
<ol>
<li><p>将要复制的master的<code>(IP,PORT)</code>信息存储到<code>server.masterhos</code>和<code>server.masterport</code>。</p>
</li>
<li><p>如果server是slave，已经复制了某个主服务器，那么此次<code>SLAVEOF</code>命令使server复制到新的主服务器，则需要释放掉之前存储的<code>server.master </code>信息，即<code>freeClient(server.master)</code>。进一步，server切换主服务后，那么之前状态下的被阻塞的客户端需要解除阻塞；</p>
</li>
<li><p>如果<code>server</code>也有子服务器sub-slaves，那么也要断开连接。这是因为之前sub-slaves是与server之间保持同步，现在server更改<code>server.master</code>了，如果sub-slaves也与server继续保持连接，会破坏sub-slaves的数据。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnectSlaves</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="comment">//　遍历，与所有的sub-slaves都断开连接</span></span><br><span class="line">    listRewind(server.slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        freeClient((client*)ln-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果server是slave，但是当前正在与之前的主服务器建立连接，那么就需要调用<code>cancelReplicationHandshake</code>函数断开连接，为新的连接准备。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cancelReplicationHandshake</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果server正与主服务器进行同步，则中断</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_TRANSFER) &#123;</span><br><span class="line">        replicationAbortSyncTransfer();</span><br><span class="line">        server.repl_state = REPL_STATE_CONNECT;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 正在建立连接，也断开</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTING || slaveIsInHandshakeState()) &#123;</span><br><span class="line">        undoConnectWithMaster();</span><br><span class="line">        server.repl_state = REPL_STATE_CONNECT;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果server是master，或者之前没有复制过任何服务器。那么调用<code>replicationSetMaster</code>函数会导致主从切换，即之前server是别的slave的master，现在server要变成<code>(IP,PORT)</code>服务器的slave，则要考虑缓存自己的信息：</p>
<p> +　先调用<code>replicationDiscardCachedMaster</code>函数丢弃之前缓存在<code>server.cached_master</code>的信息·<br> +　调用<code>replicationCacheMasterUsingMyself</code>函数将自己缓存在<code>server.cached_master</code>·</p>
</li>
<li><p>最后，将自己的状态设置为 <code>REPL_STATE_CONNECT</code>，这是主从建立的第一个状态。</p>
</li>
</ol>
<p>完整的流程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationSetMaster</span><span class="params">(<span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> was_master = server.masterhost == <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    sdsfree(server.masterhost);</span><br><span class="line"></span><br><span class="line">    server.masterhost = sdsnew(ip);</span><br><span class="line">    server.masterport = port;</span><br><span class="line">    <span class="keyword">if</span> (server.master) &#123;</span><br><span class="line">        freeClient(server.master);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 因为从一个主服务器变成 server.masterhost 副本，</span></span><br><span class="line">    <span class="comment">// 因此要解除原来从服务器中阻塞的客户端，关闭他们</span></span><br><span class="line">    disconnectAllBlockedClients(); <span class="comment">/* Clients blocked in master, now slave. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Force our slaves to resync with us as well. They may hopefully be able</span></span><br><span class="line"><span class="comment">     * to partially resync with us, but we can notify the replid change. */</span></span><br><span class="line">    disconnectSlaves();</span><br><span class="line">    cancelReplicationHandshake();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Before destroying our master state, create a cached master using</span></span><br><span class="line"><span class="comment">     * our own parameters, to later PSYNC with the new master. */</span></span><br><span class="line">    <span class="keyword">if</span> (was_master) &#123;</span><br><span class="line">        replicationDiscardCachedMaster();</span><br><span class="line">        replicationCacheMasterUsingMyself();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    server.repl_state = REPL_STATE_CONNECT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="replicationDiscardCachedMaster"><a href="#replicationDiscardCachedMaster" class="headerlink" title="replicationDiscardCachedMaster"></a>replicationDiscardCachedMaster</h4><p>丢弃之前缓存在<code>server.cached_master</code>的信息。这个函数会被主服务master在上面调用，但是也会被从服务器slave调用，</p>
<p><font color=red>待进一步解读</font></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationDiscardCachedMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.cached_master == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">&quot;Discarding previously cached master state.&quot;</span>);</span><br><span class="line">    server.cached_master-&gt;flags &amp;= ~CLIENT_MASTER;</span><br><span class="line">    freeClient(server.cached_master);</span><br><span class="line">    server.cached_master = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="replicationCacheMasterUsingMyself"><a href="#replicationCacheMasterUsingMyself" class="headerlink" title="replicationCacheMasterUsingMyself"></a>replicationCacheMasterUsingMyself</h4><p>要缓存主服务器的信息，有两种可能，一种是slave将自己的<code>server.master</code>缓存到<code>server.cached_master</code>，另一种是master把自己缓存到<code>server.cached_master</code>。顾名思义，<code>replicationCacheMasterUsingMyself</code>属于后者，只被主服务器master调用，因此调用此函数的server即master，执行步骤如下：</p>
<ul>
<li><p>缓存server的复制偏移量<code>server.master_repl_offset</code></p>
</li>
<li><p>由于主服务器的<code>server.master==NULL</code>，因此需要调用<code>replicationCreateMasterClient</code>函数创建一个<code>server.master</code>。</p>
<p>由于server缓存自己，不需要和自己建立连接通信，因此 <code>replicationCreateMasterClient</code>的第一个参数设置NULL.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicationCreateMasterClient(<span class="literal">NULL</span>, <span class="number">-1</span>);	 <span class="comment">// 创建客户端 server.master</span></span><br></pre></td></tr></table></figure></li>
<li><p>server将自己的<code>RUN_ID</code>缓存到<code>server.master-&gt;replid</code>。</p>
</li>
<li><p>将<code>server.master</code>断开所有的引用后，将<code>server.master</code>信息转移到<code>server.cached_master</code>。这是因为server变成另一个主服务器的slave，那么之前的引用就不再有效了，应该断开相关引用。</p>
</li>
<li><p>由于master即将也变成slave，因此也要将 <code>server.master=NULL</code></p>
</li>
</ul>
<p>但是<code>replicationCacheMasterUsingMyself</code>函数会调用只有两种场景：</p>
<ol>
<li><p>对一个从未复制过的REDIS服务器执行<code>SLAVEOF</code>命令，会将一个单机变成slave。此时，相当于对<code>server.cached_master</code>进行了一次初始化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">server.cached_master-&gt;conn =<span class="literal">NULL</span>;</span><br><span class="line">server.cached_master-&gt;flags |= CLIENT_MASTER;  </span><br><span class="line">server.cached_master-&gt;reploff = <span class="number">0</span>;	</span><br><span class="line">server.cached_master-&gt;read_reploff =<span class="number">0</span>;	</span><br><span class="line">server.cached_master-&gt;replid = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>对一个master执行<code>SLAVEOF</code>命令，此时会将master变成slave。那么此时 <code>replicationCacheMasterUsingMyself</code>函数就是缓存当前master的信息。</p>
</li>
</ol>
<p>完整的过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCacheMasterUsingMyself</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">              <span class="string">&quot;Before turning into a replica, using my own master parameters &quot;</span></span><br><span class="line">              <span class="string">&quot;to synthesize a cached master: I may be able to synchronize with &quot;</span></span><br><span class="line">              <span class="string">&quot;the new master with just a partial transfer.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    server.master_initial_offset = server.master_repl_offset; <span class="comment">// 初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 server.master</span></span><br><span class="line">    replicationCreateMasterClient(<span class="literal">NULL</span>, <span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将server自己的id作为server.master-&gt;replid</span></span><br><span class="line">    <span class="built_in">memcpy</span>(server.master-&gt;replid, server.replid, <span class="keyword">sizeof</span>(server.replid));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set as cached master. */</span></span><br><span class="line">    unlinkClient(server.master);			<span class="comment">// 断开所有的连接</span></span><br><span class="line">    server.cached_master = server.master;	 <span class="comment">// 转移到server.cached_master中</span></span><br><span class="line">    server.master = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="replicationCreateMasterClient"><a href="#replicationCreateMasterClient" class="headerlink" title="replicationCreateMasterClient"></a>replicationCreateMasterClient</h4><p>在介绍 <code>replicationCreateMasterClient</code>函数的实现之前，进一步介绍下<code>server.master</code>的作用。</p>
<p>master和自己的slave之间通信是通过socket实现，在REDIS中封装了网络通信的对象即<code>struct client</code>。因此当建立了主从连接时，在每个slave里都需要创建一个<code>server.master</code>，slave都是通过<code>server.master</code>与主服务器数据交互，相应的主服务中也有个链表结构<code>server.slaves</code>，保存着所有的从服务器的通信接口。</p>
<p>因此，主从服务器建立连接时会调用<code>replicationCreateMasterClient</code>函数，为每个slave创建一个<code>server.master</code>对象，而主服务器的<code>server.master==NULL</code>。</p>
<p><code>replicationCreateMasterClient</code>函数，创建<code>server.master</code>实例的步骤如下：</p>
<ol>
<li>调用<code>createClient()</code>函数，创建客户端实例 <code>server.master</code></li>
<li>如果调用 <code>replicationCreateMasterClient</code>的函数是个slave，那么传入的参数<code>conn !=NULL</code>，就和往常一样需要为<code>conn</code>注册事件，监听主服务发送给slave的数据，此时的可读事件回调函数依然是 <code>readQueryFromClient</code>。如果调用者是master，那么<code>conn==NULL</code>，就不需要注册可读事件。</li>
<li>给客户端<code>server.master</code>标志位<code>CLIENT_MASTER</code></li>
<li>设置与主从复制相关的三个重要变量：<ul>
<li><code> server.master-&gt;reploff</code>：记录主服务器的偏移量</li>
<li><code>server.master-&gt;read_reploff</code>：偏移量的最后一个字节</li>
<li><code>server.master-&gt;replid</code>：主服务器的<code>RUN_ID</code></li>
</ul>
</li>
<li>如果初始化下，<code>server.master_initial_offset ==-1</code>， 表示发送的SYNC指令。主服务器版本低于REDIS2.8初始化位-1</li>
<li>只要<code>dictid != -1</code>，则会为<code>server,master</code>操作的数据库选择一个<code>db</code></li>
</ol>
<p>完整的过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCreateMasterClient</span><span class="params">(connection *conn, <span class="keyword">int</span> dbid)</span> </span>&#123;</span><br><span class="line">    server.master = createClient(conn);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为主服务器注册可读事件，可读回调函数也是 readQueryFromClient</span></span><br><span class="line">    <span class="keyword">if</span> (conn)</span><br><span class="line">        connSetReadHandler(server.master-&gt;conn, readQueryFromClient);</span><br><span class="line"></span><br><span class="line">    server.master-&gt;flags |= CLIENT_MASTER;  <span class="comment">// 这个客户端是主服务器</span></span><br><span class="line">    server.master-&gt;authenticated = <span class="number">1</span>;</span><br><span class="line">    server.master-&gt;reploff = server.master_initial_offset;	<span class="comment">// PSYNC初始时的偏移量</span></span><br><span class="line">    server.master-&gt;read_reploff = server.master-&gt;reploff;	</span><br><span class="line">    server.master-&gt;user = <span class="literal">NULL</span>;  <span class="comment">/* This client can do everything. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(server.master-&gt;replid, server.master_replid, <span class="keyword">sizeof</span>(server.master_replid));</span><br><span class="line">    <span class="comment">/* If master offset is set to -1, this master is old and is not</span></span><br><span class="line"><span class="comment">     * PSYNC capable, so we flag it accordingly. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.master-&gt;reploff == <span class="number">-1</span>)</span><br><span class="line">        server.master-&gt;flags |= CLIENT_PRE_PSYNC;</span><br><span class="line">    <span class="keyword">if</span> (dbid != <span class="number">-1</span>) selectDb(server.master, dbid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="connectWithMaster"><a href="#connectWithMaster" class="headerlink" title="connectWithMaster"></a>connectWithMaster</h4><p>前面的<code>replicaofCommand</code>函数，为后面的主从之间连接做好了准备，下面就要slave就要与master建立连接了。建立连接的任务由<code>connectWithMaster</code>函数完成，但是这个函数在 <code>replicationCron</code>中调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="comment">// 如果还没有发起连接请求，则发起</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECT) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">                  <span class="string">&quot;Connecting to MASTER %s:%d&quot;</span>,</span><br><span class="line">                  server.masterhost, </span><br><span class="line">                  server.masterport);</span><br><span class="line">        <span class="comment">// 与主服务器建立连接，此时从服务器就是主服务器的客户端</span></span><br><span class="line">        <span class="comment">// 因此从服务器要向主服务器发起连接</span></span><br><span class="line">        <span class="keyword">if</span> (connectWithMaster() == C_OK) </span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;MASTER &lt;-&gt; REPLICA sync started&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>connectWithMaster</code>函数步骤如下：</p>
<ul>
<li>建立主从用于主从通信的<code>connection</code>对象<code>server.repl_transfer_s</code></li>
<li>调用<code>connConnect</code>注册连接回调函数，等待连接成功就调用<code>syncWithMaster</code> 来完成主从连接。</li>
<li>将slave的状态更新为 <code>REPL_STATE_CONNECTING</code></li>
</ul>
<p>完整的过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connectWithMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    server.repl_transfer_s = server.tls_replication ? connCreateTLS() : connCreateSocket();</span><br><span class="line">    <span class="keyword">if</span> (connConnect(server.repl_transfer_s, </span><br><span class="line">                    server.masterhost, server.masterport,</span><br><span class="line">                    NET_FIRST_BIND_ADDR, </span><br><span class="line">                    syncWithMaster) == C_ERR) </span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">&quot;Unable to connect to MASTER: %s&quot;</span>,</span><br><span class="line">                  connGetLastError(server.repl_transfer_s));</span><br><span class="line">        connClose(server.repl_transfer_s);</span><br><span class="line">        server.repl_transfer_s = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.repl_transfer_lastio = server.unixtime;</span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTING;      <span class="comment">// 更新状态</span></span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="syncWithMaster"><a href="#syncWithMaster" class="headerlink" title="syncWithMaster"></a>syncWithMaster</h4><p>REDIS定义了13个slave的与master的连接状态，执行SLAVEOF的slave必须从 <code>REPL_STATE_NONE</code> 状态变成 <code>REPL_STATE_CONNECTED</code>状态才算是成功建立连接。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_NONE         0 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_CONNECT      1 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_CONNECTING   2 </span></span><br><span class="line"><span class="comment">/* --- Handshake states, must be ordered --- */</span></span><br><span class="line"><span class="comment">// 下面是主从的校验状态</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_RECEIVE_PONG 3 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_SEND_AUTH    4 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_RECEIVE_AUTH 5 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_SEND_PORT    6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_RECEIVE_PORT 7 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_SEND_IP      8 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_RECEIVE_IP   9 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_SEND_CAPA    10 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_RECEIVE_CAPA 11</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_SEND_PSYNC   12 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_RECEIVE_PSYNC　13 </span></span><br><span class="line"><span class="comment">/* --- End of handshake states --- */</span></span><br><span class="line"><span class="comment">// 校验成功后，</span></span><br><span class="line"><span class="comment">// 如果是完全重同步，还需要经过 REPL_STATE_TRANSFER 状态</span></span><br><span class="line"><span class="comment">// 如果是部分重同步，直接是 REPL_STATE_CONNECTED 状态</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_TRANSFER 14 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REPL_STATE_CONNECTED 15</span></span><br></pre></td></tr></table></figure>
<p><code>syncWithMaster</code>函数，则是将slave从 <code>REPL_STATE_CONNECTING</code> 状态变成 <code>REPL_STATE_CONNECTED</code>，完成连接。下面逐个状态进行分析。</p>
<ol>
<li><p><code>syncWithMaster</code>判断当前状态是 <code>REPL_STATE_ONE</code>，则不是由于上面回调过来的，而是由于<code>SLAVEOF NO ONE</code>触发了<code>syncWithMaster</code>函数则直接返回。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncWithMaster</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> tmpfile[<span class="number">256</span>], *err = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> dfd = <span class="number">-1</span>, maxtries = <span class="number">5</span>; <span class="comment">// 最多尝试五次</span></span><br><span class="line">    <span class="keyword">int</span> psync_result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this event fired after the user turned the instance into a master</span></span><br><span class="line"><span class="comment">     * with SLAVEOF NO ONE we must just return ASAP. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_NONE) &#123;</span><br><span class="line">        connClose(conn);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还需要判断<code>connConnect</code>函数是否调用成功，即socket是否连接成功</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">              <span class="string">&quot;Error condition on socket for SYNC: %s&quot;</span>,</span><br><span class="line">              connGetLastError(conn));</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_STATE_CONNECTING</code>  to  <code>REPL_STATE_RECEIVE_PONG</code></p>
<p>当校验完成后，socket确实连接成功。</p>
<p>+　注册可读事件，回调函数还是<code>syncWithMaster</code>，·等待master对<code>PING</code>的回应<br>+　取消可写事件，因为此次要发送的数据只有<code>PING</code>，四个字符，不存在发送不完<br>+　将slave的状态转变为 <code>REPL_STATE_RECEIVE_PONG</code><br>+　slave基于conn向master发送<code>PING</code></p>
<p><font color=red> 注意</font>：执行完就直接return了，也就是说下次调用 <code>syncWithMaster</code> 则应该服务器对<code>PING</code>回应</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 PING 给主服务器</span></span><br><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTING) &#123;</span><br><span class="line">    serverLog(LL_NOTICE, <span class="string">&quot;Non blocking connect for SYNC fired the event.&quot;</span>);       </span><br><span class="line">    <span class="comment">// 由于要等待服务器的 PONG 回应，因此要注册可读事件，</span></span><br><span class="line">    <span class="comment">// 同时要取消可写事件，因为暂时没有可写数据要发送</span></span><br><span class="line">    connSetReadHandler(conn, syncWithMaster);</span><br><span class="line">    connSetWriteHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PONG;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE, conn, <span class="string">&quot;PING&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_STATE_RECEIVE_PONG</code>  to  <code>REPL_STATE_SEND_AUTH</code></p>
<p>slave接受到master对PING的回应后，先校验有效性，两种是有效的</p>
<p>+　<code>+PONG</code>：有效<br>+　<code>-NOAUTH</code>：有效，不设置认证<br>+　<code>-ERR operation not permitted</code>：在REDIS低于２.８时回复</p>
<p>如果没有发生错误，则将状态转为 <code>REPL_STATE_SEND_AUTH</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PONG) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ, conn, <span class="literal">NULL</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 错误回复，</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] != <span class="string">&#x27;+&#x27;</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">&quot;-NOAUTH&quot;</span>,<span class="number">7</span>) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        <span class="built_in">strncmp</span>(err,<span class="string">&quot;-ERR operation not permitted&quot;</span>,<span class="number">28</span>) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Error reply to PING from master: &#x27;%s&#x27;&quot;</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_NOTICE, <span class="string">&quot;Master replied to PING, replication can continue...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    sdsfree(err);</span><br><span class="line">    <span class="comment">// 进入下一个状态</span></span><br><span class="line">    server.repl_state = REPL_STATE_SEND_AUTH;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的if分支没有return，而是直接向下执行，根绝<code>server.masteruser </code>与<code>server.masterauth</code>查看是否需要设置认证。，如果需要则向master发送<code>AUTH</code>信息，进入下一步；否则则直接进入第5步。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_AUTH) &#123;</span><br><span class="line">    <span class="keyword">if</span> (server.masteruser &amp;&amp; server.masterauth) &#123;</span><br><span class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,</span><br><span class="line">                                     conn,</span><br><span class="line">                                     <span class="string">&quot;AUTH&quot;</span>, server.masteruser, server.masterauth, </span><br><span class="line">                                     <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.masterauth) &#123;</span><br><span class="line">        err = sendSynchronousCommand(SYNC_CMD_WRITE,</span><br><span class="line">                                     conn,</span><br><span class="line">                                     <span class="string">&quot;AUTH&quot;</span>, server.masterauth, </span><br><span class="line">                                     <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">        server.repl_state = REPL_STATE_RECEIVE_AUTH;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，如果没有设置密切认证，则进入下一个分支</span></span><br><span class="line">        server.repl_state = REPL_STATE_SEND_PORT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_STATE_SEND_AUTH</code> to   <code>REPL_STATE_RECEIVE_AUTH</code> </p>
<p>如果设置了密码认证，则会在第4步会验证master的回复。如果没有错误、校验成功后，再将slave状态转换为 <code>REPL_STATE_SEND_PORT</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_AUTH) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ, conn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">&quot;Unable to AUTH to MASTER: %s&quot;</span>,err);</span><br><span class="line">        sdsfree(err);</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PORT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_STATE_SEND_PORT</code> to   <code>REPL_STATE_RECEIVE_PORT</code></p>
<p>在这里，slave向master发送<font color=blue> <code>REPLCONF listening-port PORT</code></font>  信息，告诉master自己的监听端口。向master发送PORT，以及后面的IP只是为了<code>INFO</code>指令信息。</p>
<p>如果没有发生写错误，将状态转换为<code>REPL_STATE_RECEIVE_PORT</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PORT) &#123;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">// 设置 port</span></span><br><span class="line">    <span class="comment">// server.slave_announce_port 默认是 0</span></span><br><span class="line">    <span class="comment">// server.tls_replication 与  server.tls_port 默认也是 0</span></span><br><span class="line">    <span class="comment">// port = server.port 默认值是 6379</span></span><br><span class="line">    <span class="keyword">if</span> (server.slave_announce_port) port = server.slave_announce_port;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (server.tls_replication &amp;&amp; server.tls_port) port = server.tls_port;</span><br><span class="line">    <span class="keyword">else</span> port = server.port;</span><br><span class="line">    sds portstr = sdsfromlonglong(port);</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,</span><br><span class="line">                                 conn,</span><br><span class="line">                                 <span class="string">&quot;REPLCONF&quot;</span>, <span class="string">&quot;listening-port&quot;</span>,portstr, </span><br><span class="line">                                 <span class="literal">NULL</span>);</span><br><span class="line">    sdsfree(portstr);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PORT;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_STATE_RECEIVE_PORT </code>  to   <code>REPL_STATE_SEND_IP</code></p>
<p>等待master对<font color=blue> <code>REPLCONF listening-port PORT</code></font>  的回复，没有错误则进入下一个状态 <code>REPL_STATE_SEND_IP</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_PORT) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ, conn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF listening-port. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">                  <span class="string">&quot;(Non critical) Master does not understand REPLCONF listening-port: %s&quot;</span>, </span><br><span class="line">                  err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_IP;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是if分支是没有return的，因此直接进入下面的分支。在此判断是否要跳过IP认证阶段，默认情况下，不把ip地址发送master。</p>
<p>如果修改配置文件，<code>server.slave_announce_ip</code> 不是  <code>NULL</code>,则进入下一步，否则进入第9步</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.slave_announce_ip 默认值是 NULL</span></span><br><span class="line">   <span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP &amp;&amp; server.slave_announce_ip == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">           server.repl_state = REPL_STATE_SEND_CAPA;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_STATE_SEND_IP</code> to  <code>REPL_STATE_RECEIVE_IP</code></p>
<p>向master发送<font color=blue> <code>REPLCONF ip-address ip</code></font>  </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_IP) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,</span><br><span class="line">                                 conn,</span><br><span class="line">                                 <span class="string">&quot;REPLCONF&quot;</span>, <span class="string">&quot;ip-address&quot;</span>, server.slave_announce_ip, </span><br><span class="line">                                 <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_IP;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_STATE_RECEIVE_IP</code> to  <code>REPL_STATE_SEND_CAPA</code></p>
<p>在这忽略错误，因为不是所有的REDIS版本都支持 <font color=blue> <code>REPLCONF ip-address ip</code></font>   命令。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_IP) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ, conn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">/* Ignore the error if any, not all the Redis versions support</span></span><br><span class="line"><span class="comment">     * REPLCONF listening-port. */</span></span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">                  <span class="string">&quot;(Non critical) Master does not understand REPLCONF ip-address: %s&quot;</span>, </span><br><span class="line">                  err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_CAPA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_STATE_SEND_CAPA</code> to  <code>REPL_STATE_RECEIVE_CAPA</code></p>
<p>CAPAd是单词capabilities的缩写，表示slave具有的能力。slave向master发送 <font color=blue><code>REPLCONF capa eof capa pasync2</code></font>  </p>
<ul>
<li><code>eof</code>：表示slave支持 <strong>dickless</strong> 方式的同步数据流程，即master可以直接将<code>server.db</code>中的键值以RDB协议格式向<code>pipe[1]</code>里写，slave从<code>pipe[0]</code>中读取数据，而不需要经过先序列化为RDB文件，再将RDB文件发送到slave的过程。</li>
<li><code>pasync2</code>：即slave支持PSYNC2协议。对于slave的PSYNC请求，主服务器发生故障，发生主从切换后执行部分重同步，支持PYSNC2协议回复的是 <code>+CONTINUE new_repl_id</code>，如果不支持PYSNC2协议回复的是<code>+CONTINUE</code>。</li>
</ul>
<p>再将slave状态转向为 <code>REPL_STATE_RECEIVE_CAPA</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_CAPA) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_WRITE,</span><br><span class="line">                                 conn,</span><br><span class="line">                                 <span class="string">&quot;REPLCONF&quot;</span>, <span class="string">&quot;capa&quot;</span>, <span class="string">&quot;eof&quot;</span>, <span class="string">&quot;capa&quot;</span>, <span class="string">&quot;psync2&quot;</span>,</span><br><span class="line">                                 <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> write_error;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_CAPA;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_STATE_RECEIVE_CAPA</code> to  <code>REPL_STATE_SEND_PSYNC</code></p>
<p>上面slave告诉master自己具备的功能，但是如果master的REDIS版本较低无法识别这些功能，那么就会回复slave错误，但是这不是致命错误，因此仍旧可以继续向下运行。</p>
<p>继续将 slave状态设置为 <code>REPL_STATE_SEND_PSYNC</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_RECEIVE_CAPA) &#123;</span><br><span class="line">    err = sendSynchronousCommand(SYNC_CMD_READ, conn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (err[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">                  <span class="string">&quot;(Non critical) Master does not understand REPLCONF capa: %s&quot;</span>, </span><br><span class="line">                  err);</span><br><span class="line">    &#125;</span><br><span class="line">    sdsfree(err);</span><br><span class="line">    server.repl_state = REPL_STATE_SEND_PSYNC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_STATE_SEND_PSYNC</code> to  <code>REPL_STATE_RECEIVE_PSYNC</code></p>
<p>在此:</p>
<ul>
<li>slave调用函数<code>slaveTryPartialResynchronization</code>函数向master发起PSYNC请求，</li>
<li>将状态转变为<code>REPL_STATE_RECEIVE_PSYNC</code></li>
</ul>
<p>这里，是有return返回的，因为需要等待master对PYSNC指令的回应。下次调用<code>syncWithMaster</code>函数状态应该是 <code>REPL_STATE_RECEIVE_PSYNC</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state == REPL_STATE_SEND_PSYNC) &#123;</span><br><span class="line">    <span class="comment">// 向主服务器发起 PSYNC 请求</span></span><br><span class="line">    <span class="keyword">if</span> (slaveTryPartialResynchronization(conn, <span class="number">0</span>) == PSYNC_WRITE_ERROR) &#123;</span><br><span class="line">        err = sdsnew(<span class="string">&quot;Write error sending the PSYNC command.&quot;</span>);</span><br><span class="line">        <span class="keyword">goto</span> write_error;</span><br><span class="line">    &#125;</span><br><span class="line">    server.repl_state = REPL_STATE_RECEIVE_PSYNC;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="slaveTryPartialResynchronization"><a href="#slaveTryPartialResynchronization" class="headerlink" title="slaveTryPartialResynchronization"></a>slaveTryPartialResynchronization</h4></li>
</ol>
<p>先中断下介绍 <code>slaveTryPartialResynchronization</code>函数怎么发起PYSNC请求的，再续上面的状态变化。此函数的<code>read_reply</code>选项，决定着slave从<code>conn</code>里读取master的回复还是向master写数据。</p>
<p><strong>发送PSYNC请求</strong></p>
<p><code>read_reply ==0</code> 时slave向master发送<code>PSYNC replid offset</code>命令，请求同步数据。</p>
<p>在slave端，根据 <code>server.cached_master</code> 来判断是否发起部分重同步PSYNC请求：</p>
<ul>
<li><p><code>server.cached_master !=NULL</code>：说明在此次启动slave之前，slave已复制过一个主服务器，因故障导致下线时将该主服务的信息缓存在<code>serer.cached_master</code>：</p>
<ul>
<li>之前主服务器的<code>replid</code>即 <code>server.cached_master-&gt;replid</code>，</li>
<li>与之前主服务的复制偏移量<code>offset</code>即 <code>server.cached_master-&gt;reploff+1</code></li>
</ul>
<p>因此，当slave向新的主服务器master（由<code>(IP,PORT)</code>指定）发送<code>PSYNC replid offset</code>时，master会根据<code>replid</code>以及<code>offset</code>判断，是否能执行部分重同步。如果能，则回复<code>+CONTINUE</code>；不能则执行完全重同步。</p>
</li>
<li><p><code>server.cached_master ==NULL</code>，则直接发送<code>PSYNC ? -1</code>，请求执行完全重同步</p>
</li>
</ul>
<p>如果没有发生错误，则返回 <code>PSYNC_WAIT_REPLY</code>状态，否则返回 <code>PSYNC_WRITE_ERROR</code> 状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slaveTryPartialResynchronization</span><span class="params">(connection *conn, <span class="keyword">int</span> read_reply)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *psync_replid;</span><br><span class="line">    <span class="keyword">char</span> psync_offset[<span class="number">32</span>];</span><br><span class="line">    sds reply;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!read_reply) &#123;</span><br><span class="line">        <span class="comment">// 表示当前的 master_run_id 不是有效的， </span></span><br><span class="line">        server.master_initial_offset = <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (server.cached_master) &#123;</span><br><span class="line">            psync_replid = server.cached_master-&gt;replid;</span><br><span class="line">            <span class="built_in">snprintf</span>(psync_offset,<span class="keyword">sizeof</span>(psync_offset),<span class="string">&quot;%lld&quot;</span>, server.cached_master-&gt;reploff+<span class="number">1</span>);</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                      <span class="string">&quot;Trying a partial resynchronization (request %s:%s).&quot;</span>, </span><br><span class="line">                      psync_replid, psync_offset);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                      <span class="string">&quot;Partial resynchronization not possible (no cached master)&quot;</span>);</span><br><span class="line">            psync_replid = <span class="string">&quot;?&quot;</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(psync_offset,<span class="string">&quot;-1&quot;</span>,<span class="number">3</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送 PSYNC 指令</span></span><br><span class="line">        reply = sendSynchronousCommand(SYNC_CMD_WRITE,</span><br><span class="line">                                       conn,</span><br><span class="line">                                       <span class="string">&quot;PSYNC&quot;</span>, psync_replid, psync_offset, <span class="comment">// PSYNC replid offset</span></span><br><span class="line">                                       <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (reply != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING, </span><br><span class="line">                      <span class="string">&quot;Unable to send PSYNC to master: %s&quot;</span>, </span><br><span class="line">                      reply);</span><br><span class="line">            sdsfree(reply);</span><br><span class="line">            connSetReadHandler(conn, <span class="literal">NULL</span>);   <span class="comment">// 取消注册可读事件</span></span><br><span class="line">            <span class="keyword">return</span> PSYNC_WRITE_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> PSYNC_WAIT_REPLY;  		    <span class="comment">// 成功发送 PSYNC 指令，等待主服务器回复</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 读取</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>syncWtithMaster</code>函数中，发出了<code>PSYNC</code>请求后，如果再次调用<code>syncWtithMaster</code>函数，则会先判断slave的状态，此时应该还是<code>REPL_STATE_RECEIVE_PSYNC</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.repl_state != REPL_STATE_RECEIVE_PSYNC) &#123;</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">              <span class="string">&quot;syncWithMaster(): state machine error,state should be RECEIVE_PSYNC but is %d&quot;</span>,</span><br><span class="line">              server.repl_state);</span><br><span class="line">    <span class="keyword">goto</span> error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>校验成功后，slave则进入等待master回应<code>PSYNC</code>请求的阶段</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">psync_result = slaveTryPartialResynchronization(conn, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><strong>读取PYSNC请求回复</strong></p>
<p><code>read_reply ==1</code>时，slave 等待并读取master对 PSYNC命令的回应。返回的标志位有以下几种有效可能：</p>
<p>1）<code>PSYNC_WAIT_REPLY</code>：这种是读取到一个空行</p>
<p>这个返回值和上面的写<code>PYSNC</code>的返回值是一样的，都需要再次调用<code>slaveTryPartialResynchronization</code>函数读取mastet的回应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slaveTryPartialResynchronization</span><span class="params">(connection *conn, <span class="keyword">int</span> read_reply)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*********** 下面是读取 ***************/</span></span><br><span class="line">    reply = sendSynchronousCommand(SYNC_CMD_READ, conn, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 主服务器发送给从服务器的是一个空行</span></span><br><span class="line">    <span class="comment">// 则继续等待回应</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(reply) == <span class="number">0</span>) &#123;</span><br><span class="line">       sdsfree(reply);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_WAIT_REPLY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）<code>PSYNC_FULLRESYNC</code>：说明master经过判断，对slave执行完全重同步。</p>
<p>此时，回应slave的消息是 <code>+FULLRESYNC replid offset</code>，其中<code>replid</code>是master的RUN_ID，<code>offset</code>是复制偏移量<code>server.master_repl_offset</code>。 </p>
<p> <code>replid</code>与<code>offset</code>解析正确后，函数返回 <code>PSYNC_FULLRESYNC</code>，标志着master即将要和自己（slave）进行完全重同步操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slaveTryPartialResynchronization</span><span class="params">(connection *conn, <span class="keyword">int</span> read_reply)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// 如果已经读取到数据，则取消注册可读事件</span></span><br><span class="line">    connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完全重同步回应：FUNLLRESYNC replid offset</span></span><br><span class="line">    <span class="comment">// 解析 replid offset</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">&quot;+FULLRESYNC&quot;</span>,<span class="number">11</span>)) &#123;</span><br><span class="line">        <span class="keyword">char</span> *replid = <span class="literal">NULL</span>, *offset = <span class="literal">NULL</span>;</span><br><span class="line">	</span><br><span class="line">        replid = <span class="built_in">strchr</span>(reply,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (replid) &#123;</span><br><span class="line">            replid++;</span><br><span class="line">            offset = <span class="built_in">strchr</span>(replid,<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            <span class="keyword">if</span> (offset) offset++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下两种回复都是语法错误： </span></span><br><span class="line">        <span class="comment">//  +  replid 和 offset 有一个不存在</span></span><br><span class="line">        <span class="comment">//  +  replid 没有40个字符</span></span><br><span class="line">        <span class="keyword">if</span> (!replid || !offset || (offset-replid<span class="number">-1</span>) != CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">            serverLog(LL_WARNING, <span class="string">&quot;Master replied with wrong +FULLRESYNC syntax.&quot;</span>);</span><br><span class="line">            <span class="comment">// master回复了FULLRESYNC，说明master是支持PYSNC协议的，但是格式不对</span></span><br><span class="line">            <span class="comment">// 则将replid设置为0，使得下次调用PYSNC失败</span></span><br><span class="line">            <span class="built_in">memset</span>(server.master_replid, <span class="number">0</span>, CONFIG_RUN_ID_SIZE+<span class="number">1</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 将主服务器的replid填充到 server.master_replid</span></span><br><span class="line">            <span class="built_in">memcpy</span>(server.master_replid, replid, offset-replid<span class="number">-1</span>);</span><br><span class="line">            server.master_replid[CONFIG_RUN_ID_SIZE] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">            <span class="comment">// 将主服务的复制缓冲区偏移量 offset 填充到 server.master_initial_offset</span></span><br><span class="line">            <span class="comment">// initial 体现在第一次，即这是个完全重同步操作</span></span><br><span class="line">            server.master_initial_offset = strtoll(offset,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">          </span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                      <span class="string">&quot;Full resync from master: %s:%lld&quot;</span>,</span><br><span class="line">                       server.master_replid,</span><br><span class="line">                       server.master_initial_offset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We are going to full resync, discard the cached master structure. */</span></span><br><span class="line">        <span class="comment">// 由于将要去执行完全重同步，说明之前的master已经可能失效了</span></span><br><span class="line">        <span class="comment">// 因此要丢弃 server.cached_master，等完全重更新完，再重新缓存 server.cached_master</span></span><br><span class="line">        replicationDiscardCachedMaster();</span><br><span class="line">        sdsfree(reply);</span><br><span class="line">        <span class="keyword">return</span> PSYNC_FULLRESYNC;    <span class="comment">// 表示即将要完全重同步</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）<code>PSYNC_CONTINUE</code>： master回应slave<code>+CONTINUE</code>，标志master同意进行部分重同步操作。</p>
<p>考虑到PYSNC2协议，判断 <code>CONTINUE</code> 后面是否附带<code>new_replid</code>。如果有，则说明slave当前请求的master是新选出的主服务器，<code>server.cached_master</code>是宕机之前的主服务器，那么slave需要更新下主服务的信息：</p>
<ol>
<li>用<code>server.replid2</code>来存储<code>PSYNC replid offset</code>中的<code>replid</code>，<code>server.second_replid_offset</code>存储<code>offset</code></li>
<li>将<code>server.replid</code>及<code>server.cached_master-&gt;replid</code>更新为新主服务器的运行ID:<code>new_replid</code></li>
<li>slave更改主服务器了，调用<code>disconnectSlaves</code>函数断开之前在旧服务器下建立的sub-slaves</li>
</ol>
<p>到此，要为开始部分重同步做准备，要完成下面两个关键步骤：</p>
<ol>
<li><p>要将<code>server.cached_master</code>的信息移动到<code>server.master</code>，因为slave后期还要依赖于<code>server.master</code>与master进行数据通信</p>
</li>
<li><p>如果么有复制缓冲区<code>server.repl_backlog</code>（比如首次调用就没有），要创建复制缓冲区</p>
<p>最后，返回<code>PSYNC_CONTINUE</code>标志位，告诉slave要开始部分重同步了。</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">slaveTryPartialResynchronization</span><span class="params">(connection *conn, <span class="keyword">int</span> read_reply)</span> </span>&#123;</span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line">    <span class="comment">// +CONTINUE replid \r\n</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(reply,<span class="string">&quot;+CONTINUE&quot;</span>,<span class="number">9</span>)) &#123;</span><br><span class="line">         serverLog(LL_NOTICE, <span class="string">&quot;Successful partial resynchronization with master.&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span> *start = reply+<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">char</span> *end   = reply+<span class="number">9</span>;</span><br><span class="line">        <span class="keyword">while</span>(end[<span class="number">0</span>] != <span class="string">&#x27;\r&#x27;</span> &amp;&amp; end[<span class="number">0</span>] != <span class="string">&#x27;\n&#x27;</span> &amp;&amp; end[<span class="number">0</span>] != <span class="string">&#x27;\0&#x27;</span>) end++;</span><br><span class="line">        <span class="comment">// 表示支持PSYNC2协议</span></span><br><span class="line">        <span class="keyword">if</span> (end-start == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">            <span class="keyword">char</span> <span class="keyword">new</span>[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];     <span class="comment">// 新的 replid</span></span><br><span class="line">            <span class="built_in">memcpy</span>(<span class="keyword">new</span>, start, CONFIG_RUN_ID_SIZE);</span><br><span class="line">            <span class="keyword">new</span>[CONFIG_RUN_ID_SIZE] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果和之前已经缓存的主服务器replid不等</span></span><br><span class="line">            <span class="comment">// 即，主服务器发送了变化</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(<span class="keyword">new</span>, server.cached_master-&gt;replid)) &#123;</span><br><span class="line"></span><br><span class="line">                serverLog(LL_WARNING,<span class="string">&quot;Master replication ID changed to %s&quot;</span>,<span class="keyword">new</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 1) Set the old ID as our ID2, up to the current offset+1. */</span></span><br><span class="line">                <span class="built_in">memcpy</span>(server.replid2, </span><br><span class="line">                       server.cached_master-&gt;replid, </span><br><span class="line">                       <span class="keyword">sizeof</span>(server.replid2));</span><br><span class="line">                <span class="comment">// 2)</span></span><br><span class="line">                server.second_replid_offset = server.master_repl_offset+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 3) Update the cached master ID and our own primary ID to the</span></span><br><span class="line"><span class="comment">                 * new one. */</span></span><br><span class="line">                <span class="built_in">memcpy</span>(server.replid, <span class="keyword">new</span>, <span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">                <span class="built_in">memcpy</span>(server.cached_master-&gt;replid, <span class="keyword">new</span>, <span class="keyword">sizeof</span>(server.replid));</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* 4) Disconnect all the sub-slaves: they need to be notified. */</span></span><br><span class="line">                disconnectSlaves();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Setup the replication to continue. */</span></span><br><span class="line">        sdsfree(reply);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 server.cached_master 信息移动到 server.master</span></span><br><span class="line">        <span class="comment">// 并且为 conn 注册可读事件，</span></span><br><span class="line">        <span class="comment">// 如果有带发送的缓冲区，也注册可写事件</span></span><br><span class="line">        replicationResurrectCachedMaster(conn);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建复制缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span>) </span><br><span class="line">            createReplicationBacklog();</span><br><span class="line">        <span class="comment">// 下面等待部分重同步</span></span><br><span class="line">        <span class="keyword">return</span> PSYNC_CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="replicationResurrectCachedMaster"><a href="#replicationResurrectCachedMaster" class="headerlink" title="replicationResurrectCachedMaster"></a>replicationResurrectCachedMaster</h4><p><code>replicationResurrectCachedMaster</code>函数，用于将<code>server.cached_master</code>转移<code>server.master</code>，明显这个函数只会在slave中调用，而调用的时机也是因为要执行数据同步了，slave需要<code>server.master</code>与master进行数据交互，因此要执行的步骤大致如下：</p>
<ol>
<li>将之前的<code>server.cached_master</code>转移到<code>server.master</code>中。</li>
<li>要将slave的状态由<code>REPL_STATE_RECEIVE_PSYNC</code>转为<code>REPL_STATE_CONNECTED</code></li>
<li>为<code>server.master-&gt;conn</code>注册可读事件，使用回调函数<code>readQueryFromClient</code>处理master的部分重同步数据，把部分重同步数据解析为普通客户端的写指令，再对slave数据库执行一遍</li>
<li>如果<code>server.master</code>的发送缓冲区中有数据，则也注册可写事件</li>
</ol>
<p>经过上述步骤，slave状态也是<font color=blue><code>REPL_STATE_CONNECTED</code></font>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationResurrectCachedMaster</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    server.master = server.cached_master;</span><br><span class="line">    server.cached_master = <span class="literal">NULL</span>;</span><br><span class="line">    server.master-&gt;conn = conn;</span><br><span class="line">    connSetPrivateData(server.master-&gt;conn, server.master);</span><br><span class="line">    <span class="comment">// 去掉两个标志位，因为这个server.master才开启生命周期</span></span><br><span class="line">    server.master-&gt;flags &amp;= ~(CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP);</span><br><span class="line">    server.master-&gt;authenticated = <span class="number">1</span>;</span><br><span class="line">    server.master-&gt;lastinteraction = server.unixtime;   <span class="comment">// 最近的交互时间</span></span><br><span class="line">    server.repl_state = REPL_STATE_CONNECTED;           <span class="comment">// 已经变成连接状态了</span></span><br><span class="line">    server.repl_down_since = <span class="number">0</span>;                         <span class="comment">// 上线</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立连接后，那么主服务器也是从服务器的客户端</span></span><br><span class="line">    <span class="comment">// 因此，将 server.master 添加到当前从服务器的客户端链表 server.clients 中</span></span><br><span class="line">    linkClient(server.master);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为客户端（即主服务器）注册可读事件，监听从服务器的请求</span></span><br><span class="line">    <span class="keyword">if</span> (connSetReadHandler(server.master-&gt;conn, readQueryFromClient)) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">&quot;Error resurrecting the cached master, impossible to add the readable handler: %s&quot;</span>, </span><br><span class="line">                  strerror(errno));</span><br><span class="line">        freeClientAsync(server.master); <span class="comment">/* Close ASAP. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We may also need to install the write handler as well if there is</span></span><br><span class="line"><span class="comment">     * pending data in the write buffers. </span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 如果主服务器的发送缓冲区中有数据，则注册可写事件，</span></span><br><span class="line"><span class="comment">     * 等待可写事件发送，将其发送给从服务器 </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (clientHasPendingReplies(server.master)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connSetWriteHandler(server.master-&gt;conn, sendReplyToClient)) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Error resurrecting the cached master, &quot;</span></span><br><span class="line">                      <span class="string">&quot;impossible to add the writable handler: %s&quot;</span>, </span><br><span class="line">                      strerror(errno));</span><br><span class="line">            freeClientAsync(server.master); <span class="comment">/* Close ASAP. */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PYSNC-CONTINUE"><a href="#PYSNC-CONTINUE" class="headerlink" title="PYSNC_CONTINUE"></a>PYSNC_CONTINUE</h4><p>下面将视线再拉回到<code>sysnWithMaster</code>函数中， <code>sysnWithMaster</code>函数需要对 <code>slaveTryPartialResynchronization</code>的读取<code>PSYNC</code>的返回标志位结果进行处理，错误标志不讲解了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (psync_result == PSYNC_CONTINUE) &#123;</span><br><span class="line">        serverLog(LL_NOTICE, </span><br><span class="line">                  <span class="string">&quot;MASTER &lt;-&gt; REPLICA sync: Master accepted a Partial Resynchronization.&quot;</span>);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>那么slave是从哪里接收到master的部分重同步的数据？ 是在<code>replicationResurrectCachedMaster</code>函数中为<code>serevr.master-&gt;conn</code>  注册的可读事件回调函数中。</p>
<p>在<code>readQueryFromClient</code>中，如果发现是从master发送过来的数据，那么就增加读取偏移量 <code>c-&gt;read_reploff</code>，而数据仍在<code>c-&gt;querybuf</code>中，被解析后在<code>processCommandAndResetClient</code>中执行，使得主从一致。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) </span><br><span class="line">    c-&gt;read_reploff += nread;</span><br></pre></td></tr></table></figure>
<p>slave端读取到部分重同步数据之后，把数据解析成指令再执行就使得主从数据同步，其具体解析到执行的过程可以参考 <a href="">剖析REDIS输入缓冲区设计</a>。</p>
<p>此外，slave在接收到部分重同步数据，完成了同步之后，会继续<code>commandProcessed</code>函数中，会进一步调用<code>replicationFeedSlavesFromMasterStream</code>函数把这个数据传递给sub-slaves。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (processCommand(c) == C_OK) &#123;</span><br><span class="line">    commandProcessed(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="commandProcessed"><a href="#commandProcessed" class="headerlink" title="commandProcessed"></a>commandProcessed</h4><p><code>commandProcessed</code>函数主要完成三个任务：</p>
<ul>
<li>每次在接收到部分重同步数据之后，都要更新下复制偏移量<code>server.master-&gt;read_reploff</code>，此处的客户端 <code>c</code> 即<code>server.master</code></li>
<li>非阻塞模式，都会<code>resetClient</code></li>
<li>需要递归传播，即将slave从master接受到的数据传递给sub-slaves</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">commandProcessed</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> prev_offset = c-&gt;reploff;</span><br><span class="line">	<span class="comment">// 更新偏移量</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER &amp;&amp; !(c-&gt;flags &amp; CLIENT_MULTI)) &#123; </span><br><span class="line">        c-&gt;reploff = c-&gt;read_reploff - sdslen(c-&gt;querybuf) + c-&gt;qb_pos;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_BLOCKED) || c-&gt;btype != BLOCKED_MODULE)</span><br><span class="line">        resetClient(c);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 传播</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> applied = c-&gt;reploff - prev_offset;</span><br><span class="line">        <span class="keyword">if</span> (applied) &#123;</span><br><span class="line">            replicationFeedSlavesFromMasterStream(server.slaves,</span><br><span class="line">                                                  c-&gt;pending_querybuf, </span><br><span class="line">                                                  applied);</span><br><span class="line">            sdsrange(c-&gt;pending_querybuf,applied, <span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="replicationFeedSlavesFromMasterStream"><a href="#replicationFeedSlavesFromMasterStream" class="headerlink" title="replicationFeedSlavesFromMasterStream"></a>replicationFeedSlavesFromMasterStream</h4><p>slave作为自己的sub-slave的主服务，因为将数据传递到sub-slave时原理和主服务器传递给自己类似：</p>
<ul>
<li>1）写入 <code>server.repl_backlog</code></li>
<li>2）写入 <code>sub_slave-&gt;conn</code>，发送给sub-slave</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationFeedSlavesFromMasterStream</span><span class="params">(<span class="built_in">list</span> *slaves, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buflen)</span> </span>&#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for debug</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%zu:&quot;</span>,buflen);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; buflen; j++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, <span class="built_in">isprint</span>(buf[j]) ? buf[j] : <span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 写入到 serveer.repl_backlog 中</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_backlog) feedReplicationBacklog(buf,buflen);</span><br><span class="line">    listRewind(slaves,&amp;li);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 发送给所有的sub-slaves</span></span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 发送到sub-slaves</span></span><br><span class="line">        addReplyProto(slave,buf,buflen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PSYNC-FULLRESYNC"><a href="#PSYNC-FULLRESYNC" class="headerlink" title="PSYNC_FULLRESYNC"></a>PSYNC_FULLRESYNC</h4><p>下面继续讲解<code>syncWithMaster</code>函数中的完全重同步。</p>
<ul>
<li>在高版本的REDIS中，支持dickles方式的传输RDB数据。如果不支持，则需要在slave端创建一个<code>rdb</code>文件用于接收master的RDB协议格式的数据；<ul>
<li><code>server.repl_transfer_tmpfile</code>：表示RDB文件名</li>
<li><code>server.repl_transfer_fd</code>：rdb文件对应的文件描述符</li>
</ul>
</li>
<li>为<code>conn</code>设置可读事件，等待master的全同步数据，读回调函数是<code>readSyncBulkPayload</code>，完成读取master的RDB数据以及加载到slave中。</li>
</ul>
<p>全同步的准备如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncWithMaster</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// useDisklessLoad() 返回0，则主服务器是将当前数据库状态先存储到磁盘，</span></span><br><span class="line">    <span class="comment">// 再将rdb文件发送给从服务器，因此从服务器要先创建个本地文件</span></span><br><span class="line">    <span class="keyword">if</span> (!useDisklessLoad()) &#123;</span><br><span class="line">        <span class="keyword">while</span>(maxtries--) &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(tmpfile, <span class="number">256</span>, <span class="string">&quot;temp-%d.%ld.rdb&quot;</span>, (<span class="keyword">int</span>)server.unixtime, (<span class="keyword">long</span> <span class="keyword">int</span>)getpid());</span><br><span class="line">            dfd = open(tmpfile, O_CREAT|O_WRONLY|O_EXCL,<span class="number">0644</span>);</span><br><span class="line">            <span class="keyword">if</span> (dfd != <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dfd == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Can&#x27;t Opening the temp file needed for MASTER &lt;-&gt; REPLICA sync: %s&quot;</span>,</span><br><span class="line">                      strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server.repl_transfer_tmpfile = zstrdup(tmpfile); <span class="comment">// 文件名</span></span><br><span class="line">        server.repl_transfer_fd = dfd;                   <span class="comment">// 对应的fd</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the non blocking download of the bulk file. */</span></span><br><span class="line">    <span class="comment">// 设置可读事件，等待rdb数据到来</span></span><br><span class="line">    <span class="keyword">if</span> (connSetReadHandler(conn, readSyncBulkPayload) == C_ERR) &#123;</span><br><span class="line">        <span class="keyword">char</span> conninfo[CONN_INFO_LEN];</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">&quot;Can&#x27;t create readable event for SYNC: %s (%s)&quot;</span>,</span><br><span class="line">                   strerror(errno), </span><br><span class="line">                   connGetInfo(conn, conninfo, <span class="keyword">sizeof</span>(conninfo)));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.repl_state = REPL_STATE_TRANSFER;        <span class="comment">// 传递文件状态</span></span><br><span class="line">	<span class="comment">// 下面三个字段适用于slave端选择将数据先存储到rdb中</span></span><br><span class="line">    server.repl_transfer_size = <span class="number">-1</span>;                 <span class="comment">// Rdb文件大小</span></span><br><span class="line">    server.repl_transfer_read = <span class="number">0</span>;				   <span class="comment">// 已读取字节数</span></span><br><span class="line">    server.repl_transfer_last_fsync_off = <span class="number">0</span>;	    <span class="comment">// 已经同步字节数 </span></span><br><span class="line"></span><br><span class="line">    server.repl_transfer_lastio = server.unixtime;  <span class="comment">// 最近读取操作的时间</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="readSyncBulkPayload"><a href="#readSyncBulkPayload" class="headerlink" title="readSyncBulkPayload"></a>readSyncBulkPayload</h4><p>如果这是首次同步数据，比如建立连接时同步数据，master在给slave发送同步数据之前， 会先发送一个<code>slave-&gt;replpreamble</code> ，格式是<code>$&lt;length&gt;\r\n</code>：</p>
<ul>
<li>如果是RDB方式则告诉slave即将要发送的RDB文件大小</li>
<li>如果是dickless方式则发送的是<code>$&lt;eofmark&gt;\r\n</code>，其中<code>eofmark</code>和<code>RUN_ID</code>长度一致，都是40个字符</li>
</ul>
<p>因此，首次调用<code>readSyncBulkPayload</code>函数是为了检测主从同步数据的方式，就return了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readSyncBulkPayload</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[PROTO_IOBUF_LEN];</span><br><span class="line">    <span class="keyword">ssize_t</span> nread, readlen, nwritten;</span><br><span class="line">    <span class="keyword">int</span> use_diskless_load = useDisklessLoad();</span><br><span class="line">    redisDb *diskless_load_backup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> empty_db_flags = server.repl_slave_lazy_flush ? EMPTYDB_ASYNC : EMPTYDB_NO_FLAGS;</span><br><span class="line">    <span class="keyword">off_t</span> left;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在dickless方式下，lastbytes用于检测是否达到rdb数据发送完毕</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> eofmark[CONFIG_RUN_ID_SIZE];    <span class="comment">//  结束标志</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> lastbytes[CONFIG_RUN_ID_SIZE];  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> usemark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// server.repl_transfer_size == -1 表示首次读取</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_transfer_size == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connSyncReadLine(conn,buf,<span class="number">1024</span>,server.repl_syncio_timeout*<span class="number">1000</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;I/O error reading bulk count from MASTER: %s&quot;</span>,</span><br><span class="line">                      strerror(errno));</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;MASTER aborted replication with an error: %s&quot;</span>,</span><br><span class="line">                      buf+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 空行只是为了保持连接，用于心疼检测，</span></span><br><span class="line">            server.repl_transfer_lastio = server.unixtime; <span class="comment">// 更改最近一次主从读取时间</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">&#x27;$&#x27;</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Bad protocol from MASTER, the first byte is not &#x27;$&#x27; (we received &#x27;%s&#x27;),&quot;</span></span><br><span class="line">                      <span class="string">&quot;are you sure the host and port are right?&quot;</span>, </span><br><span class="line">                      buf);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 主服务器的回应有两种格式：</span></span><br><span class="line"><span class="comment">         *  1. 发送的是RDB文件，格式即使 $&lt;count&gt; </span></span><br><span class="line"><span class="comment">         *  2. dickless方式，事先不知大文件大小，因此先传输 $EOF:&lt;40 bytes delimiter&gt;</span></span><br><span class="line"><span class="comment">         *     在文件的末尾，再次传输预定义的分隔符delimiter，由于分隔符足够长且随机，</span></span><br><span class="line"><span class="comment">         *     因此不会有与实际文件内容发生冲突的可能性。 </span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strncmp</span>(buf+<span class="number">1</span>,<span class="string">&quot;EOF:&quot;</span>,<span class="number">4</span>) == <span class="number">0</span> &amp;&amp; <span class="built_in">strlen</span>(buf+<span class="number">5</span>) &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">            usemark = <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">memcpy</span>(eofmark,buf+<span class="number">5</span>,CONFIG_RUN_ID_SIZE);</span><br><span class="line">            <span class="built_in">memset</span>(lastbytes,<span class="number">0</span>, CONFIG_RUN_ID_SIZE);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更改 server.repl_transfer_size的值</span></span><br><span class="line">            <span class="comment">// 因此 if(server.repl_transfer_size == -1)，下次就不会进入</span></span><br><span class="line">            server.repl_transfer_size = <span class="number">0</span>;</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                      <span class="string">&quot;MASTER &lt;-&gt; REPLICA sync: receiving streamed RDB from master with EOF %s&quot;</span>,</span><br><span class="line">                      use_diskless_load? <span class="string">&quot;to parser&quot;</span>:<span class="string">&quot;to disk&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            usemark = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 存储rdb文件大小</span></span><br><span class="line">            server.repl_transfer_size = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                      <span class="string">&quot;MASTER &lt;-&gt; REPLICA sync: receiving %lld bytes from master %s&quot;</span>,</span><br><span class="line">                      (<span class="keyword">long</span> <span class="keyword">long</span>) server.repl_transfer_size,</span><br><span class="line">                      use_diskless_load? <span class="string">&quot;to parser&quot;</span>:<span class="string">&quot;to disk&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次调用<code>readSyncBulkPayload</code>函数，如果是dickless方式同步，则<code>server.repl_transfer_size==0</code>，否则<code>server.repl_transfer_size</code>是即将要传输的文件大小<code>length</code>，因此不会再陷入 <code>if(repl_transfer_size==-1)</code> 分支中。</p>
<p>master有两种传输同步数据方式，而slave也相应有两种加载方式：</p>
<ul>
<li>先存储到RDB文件中再加载进内存</li>
<li>直接从socket读取数据然后加载到内存中</li>
</ul>
<p>这由<code>useDisklessLoad</code>函数确定</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">useDisklessLoad</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* compute boolean decision to use diskless load */</span></span><br><span class="line">    <span class="keyword">int</span> enabled = server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB ||</span><br><span class="line">                 (server.repl_diskless_load == REPL_DISKLESS_LOAD_WHEN_DB_EMPTY &amp;&amp;</span><br><span class="line">                  dbTotalServerKeyCount()==<span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Check all modules handle read errors, otherwise it&#x27;s not safe to use diskless load. */</span></span><br><span class="line">    <span class="keyword">if</span> (enabled &amp;&amp; !moduleAllDatatypesHandleErrors()) &#123;</span><br><span class="line">        serverLog(LL_WARNING, </span><br><span class="line">                  <span class="string">&quot;Skipping diskless-load because there are modules &quot;</span></span><br><span class="line">                  <span class="string">&quot;that don&#x27;t handle read errors.&quot;</span>);</span><br><span class="line">        enabled = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> enabled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果slave端选择先将master发送过来的RDB数据存储到本地RDB文件<code>server.repl_transfer_fd</code>中，流程如下：</p>
<ul>
<li>设置单次最大读取字节数<code>readlen</code></li>
<li>读取<code>readlen</code>个字节数据。在<code>usemark==1</code>方式下检测下是否读取到数据流末尾，到了则<code>eof_reached=1</code></li>
<li>将读取到的数据写入到<code>server.repl_transfer_fd</code>。如果此时<code>eof_reached==1 &amp;&amp; usemark==1</code>，则需要在同步之前将写入slave端RDB文件末尾的<code>eofmark</code>给删除掉</li>
<li>每次累计写入了<code>REPL_MAX_WRITTEN_BEFORE_FSYNC</code>个字节，就需要自动同步一次</li>
<li>如果master是发送的RDB文件，判断是否达到了文件末尾。</li>
</ul>
<p>这个函数，只有在master发送完毕才会向下继续运行，否则每次都是直接return.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readSyncBulkPayload</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span> (!use_diskless_load) &#123;</span><br><span class="line">        <span class="comment">/* Read the data from the socket, store it to a file and search for the EOF. */</span></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            readlen = <span class="keyword">sizeof</span>(buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 传输的是RDB文件，则直接读取RDB文件数据</span></span><br><span class="line">            left = server.repl_transfer_size - server.repl_transfer_read;</span><br><span class="line">            readlen = (left &lt; (<span class="keyword">signed</span>)<span class="keyword">sizeof</span>(buf)) ? left : (<span class="keyword">signed</span>)<span class="keyword">sizeof</span>(buf);</span><br><span class="line">        &#125;   </span><br><span class="line"></span><br><span class="line">        <span class="comment">//2 将数据读取到 buf 中</span></span><br><span class="line">        nread = connRead(conn,buf,readlen);</span><br><span class="line">        <span class="keyword">if</span> (nread &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connGetState(conn) == CONN_STATE_CONNECTED) &#123; </span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;I/O error trying to sync with MASTER: %s&quot;</span>,</span><br><span class="line">                      (nread == <span class="number">-1</span>) ? strerror(errno) : <span class="string">&quot;connection lost&quot;</span>);</span><br><span class="line">            cancelReplicationHandshake();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server.stat_net_input_bytes += nread;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> eof_reached = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查看当前读取的nread个数据，是否包含了结束标志 eofmark</span></span><br><span class="line">        <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">            <span class="comment">/* Update the last bytes array, and check if it matches our</span></span><br><span class="line"><span class="comment">             * delimiter. */</span></span><br><span class="line">            <span class="keyword">if</span> (nread &gt;= CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">                <span class="comment">// 将读取的字节中最后40个字节复制到 lastbytes</span></span><br><span class="line">                <span class="comment">// 直接比较即可</span></span><br><span class="line">                <span class="built_in">memcpy</span>(lastbytes, buf+nread-CONFIG_RUN_ID_SIZE, CONFIG_RUN_ID_SIZE);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 将lastbytes中后面字节前移nread个字节，把新读取的添加到lastbyes</span></span><br><span class="line">                <span class="comment">// 凑满最新的40个字节，逐次比较</span></span><br><span class="line">                <span class="keyword">int</span> rem = CONFIG_RUN_ID_SIZE-nread;</span><br><span class="line">                memmove(lastbytes, lastbytes+nread, rem);</span><br><span class="line">                <span class="built_in">memcpy</span>(lastbytes+rem,buf,nread);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断是否达到末尾</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">memcmp</span>(lastbytes,eofmark,CONFIG_RUN_ID_SIZE) == <span class="number">0</span>)</span><br><span class="line">                eof_reached = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        server.repl_transfer_lastio = server.unixtime;  <span class="comment">// 更新最近的从主服务器中读取的时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//3 将buf中的数据写入slave端RDB文件</span></span><br><span class="line">        <span class="keyword">if</span> ((nwritten = write(server.repl_transfer_fd, buf, nread)) != nread) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Write error or short write writing to the DB dump file &quot;</span></span><br><span class="line">                      <span class="string">&quot;needed for MASTER &lt;-&gt; REPLICA synchronization: %s&quot;</span>,</span><br><span class="line">                      (nwritten == <span class="number">-1</span>) ? strerror(errno) : <span class="string">&quot;short write&quot;</span>);</span><br><span class="line">            <span class="keyword">goto</span> error;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server.repl_transfer_read += nread;  </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果已经到达文件末尾,则将最后的40个字符删除掉</span></span><br><span class="line">        <span class="keyword">if</span> (usemark &amp;&amp; eof_reached) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.repl_transfer_fd, </span><br><span class="line">                          server.repl_transfer_read - CONFIG_RUN_ID_SIZE) == <span class="number">-1</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                          <span class="string">&quot;Error truncating the RDB file received from the master &quot;</span></span><br><span class="line">                          <span class="string">&quot;for SYNC: %s&quot;</span>, </span><br><span class="line">                          strerror(errno));</span><br><span class="line">                <span class="keyword">goto</span> error;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*4 每次都将数据尝试同步到磁盘中,否则最后统一同步,会产生较大的延时、阻塞</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 每当累计写入的字节数大于 REPL_MAX_WRITTEN_BEFORE_FSYNC ，就同步</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_transfer_read &gt;= </span><br><span class="line">            server.repl_transfer_last_fsync_off + REPL_MAX_WRITTEN_BEFORE_FSYNC)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">off_t</span> sync_size = server.repl_transfer_read - server.repl_transfer_last_fsync_off;</span><br><span class="line">            rdb_fsync_range(server.repl_transfer_fd,</span><br><span class="line">                            server.repl_transfer_last_fsync_off, </span><br><span class="line">                            sync_size);</span><br><span class="line">            server.repl_transfer_last_fsync_off += sync_size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对于实现知道的传输方式，检测是否达到文件末尾</span></span><br><span class="line">        <span class="keyword">if</span> (!usemark) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.repl_transfer_read == server.repl_transfer_size)</span><br><span class="line">                eof_reached = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the transfer is yet not complete, we need to read more, so</span></span><br><span class="line"><span class="comment">         * return ASAP and wait for the handler to be called again. */</span></span><br><span class="line">        <span class="keyword">if</span> (!eof_reached) <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面就是加载数据的方式了:<br>+　<code>use_diskless_load==1</code>：则slave端可以直接从socket中读取数据直接加载<br>+　<code>use_diskless_load==0</code>：则slave从<code>server.repl_transfer_fd</code>文件中加载</p>
<p>在正式加载之前需要先检测是否有AO重写子进程。因为下面slave与master同步会对自己的数据库造成很多修改，如果此时AOF在重写，则会破坏<code>copy-on-write</code>使得内存暴涨。AOF重写只有在slave同步master成功后才会重启。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.aof_state != AOF_OFF) stopAppendOnly();</span><br></pre></td></tr></table></figure>
<p>dickless 加载有两种类型<code>server.repl_diskless_load </code>：</p>
<ul>
<li><p><code>REPL_DISKLESS_LOAD_SWAPDB</code>：将加载前的数据库<code>server.db[]</code>备份<code>diskless_load_backup</code>，防止加载失败无法恢复到之前的状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (use_diskless_load &amp;&amp; server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">    diskless_load_backup = disklessLoadMakeBackups();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>REPL_DISKLESS_LOAD_WHEN_DB_EMPTY</code>：即使记载失败也不恢复到之前状态</p>
</li>
</ul>
<p>在加载之前，需要释放原来的<code>server.db[]</code>，<code>REPL_DISKLESS_LOAD_SWAPDB</code>方式下已经备份，<code>REPL_DISKLESS_LOAD_WHEN_DB_EMPTY</code>方式下不需要备份，因此可以直接清空<code>server.db[]</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br></pre></td></tr></table></figure>
<p>为了简化传输，REDIS将<code>conn</code>设置阻塞IO，并且单次阻塞时间是60s，如果加载错误则选择 <code>server.repl_diskless_load </code>选择是恢复<code>server.db[]</code>还是直接清空。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">   emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br><span class="line"></span><br><span class="line">   connSetReadHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">   serverLog(LL_NOTICE, <span class="string">&quot;MASTER &lt;-&gt; REPLICA sync: Loading DB in memory&quot;</span>);</span><br><span class="line">   rdbSaveInfo rsi = RDB_SAVE_INFO_INIT;</span><br><span class="line">   <span class="keyword">if</span> (use_diskless_load) &#123;</span><br><span class="line">       rio rdb;</span><br><span class="line">       rioInitWithConn(&amp;rdb, conn, server.repl_transfer_size); <span class="comment">// 底层使用socket</span></span><br><span class="line"></span><br><span class="line">       connBlock(conn); 								 <span class="comment">// 设置其为阻塞模式</span></span><br><span class="line">       connRecvTimeout(conn, server.repl_timeout*<span class="number">1000</span>);    <span class="comment">// 设置从conn中读取数据最多阻塞时间 60s</span></span><br><span class="line">       startLoading(server.repl_transfer_size, RDBFLAGS_REPLICATION);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (rdbLoadRio(&amp;rdb, RDBFLAGS_REPLICATION, &amp;rsi) != C_OK) &#123;</span><br><span class="line">           <span class="comment">// 加载失败的处理</span></span><br><span class="line">           stopLoading(<span class="number">0</span>);</span><br><span class="line">           serverLog(LL_WARNING,</span><br><span class="line">                     <span class="string">&quot;Failed trying to load the MASTER synchronization DB from socket&quot;</span>);</span><br><span class="line">           cancelReplicationHandshake();</span><br><span class="line">           rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">                <span class="comment">// 加载失败，则回复 server.db 加载之前的数据</span></span><br><span class="line">                disklessLoadRestoreBackups(diskless_load_backup, <span class="number">1</span>, empty_db_flags);</span><br><span class="line">           &#125; </span><br><span class="line">           <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 否则，直接清空本次加载的数据，下次以一个空的server.db[]开始</span></span><br><span class="line">               emptyDb(<span class="number">-1</span>,empty_db_flags,replicationEmptyDbCallback);</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       stopLoading(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/******************成功加载********************/</span></span><br><span class="line">       <span class="comment">// 加载策略是 REPL_DISKLESS_LOAD_SWAPDB时，要释放 diskless_load_backup</span></span><br><span class="line">       <span class="keyword">if</span> (server.repl_diskless_load == REPL_DISKLESS_LOAD_SWAPDB) &#123;</span><br><span class="line">             disklessLoadRestoreBackups(diskless_load_backup,<span class="number">0</span>,empty_db_flags);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 校验结束标志</span></span><br><span class="line">       <span class="keyword">if</span> (usemark) &#123;</span><br><span class="line">           <span class="keyword">if</span> (!rioRead(&amp;rdb,buf,CONFIG_RUN_ID_SIZE) || <span class="built_in">memcmp</span>(buf,eofmark,CONFIG_RUN_ID_SIZE) != <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               serverLog(LL_WARNING,<span class="string">&quot;Replication stream EOF marker is broken&quot;</span>);</span><br><span class="line">               cancelReplicationHandshake();</span><br><span class="line">               rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 将 socket 恢复非阻塞模式，</span></span><br><span class="line">       rioFreeConn(&amp;rdb, <span class="literal">NULL</span>);</span><br><span class="line">       connNonBlock(conn);</span><br><span class="line">       connRecvTimeout(conn,<span class="number">0</span>);</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>
<p>如果slave设置的RDB文件加载方式，则和持久化的加载方式基本一致：</p>
<p>+　如果此时slave正在执行rdb持久化，直接kill这个进程，因为马上要同步master数据，这个持久化是无意义的<br>+　打开slave端rdb持久化的文件<code>server.rdb_filename</code><br>+　将之前存储的<code>server.repl_transfer_tmpfile</code>的rdb文件直接rename为 <code>server.rdb_filename</code>即可<br>+　<code>rdbLoad</code>函数将<code>server.repl_transfer_tmpfile</code>加载到内存，即可实现数据同步<br>+　由于<code>server.repl_transfer_tmpfile</code>是用于数据同步产生，而不是用于持久化，因此需要删除rdb文件<br>+　最后关闭<code>server.repl_transfer_tmpfile</code>及其fd，并初始化</p>
<p>到此，数据加载就结束，slave与master实现了完全重同步。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/* Ensure background save doesn&#x27;t overwrite synced data */</span></span><br><span class="line">      <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">          serverLog(LL_NOTICE,</span><br><span class="line">                    <span class="string">&quot;Replica is about to load the RDB file received from the master,&quot;</span></span><br><span class="line">                    <span class="string">&quot; but there is a pending RDB child running. &quot;</span></span><br><span class="line">                    <span class="string">&quot;Killing process %ld and removing its temp file to avoid any race&quot;</span>,</span><br><span class="line">                    (<span class="keyword">long</span>) server.rdb_child_pid);</span><br><span class="line">          <span class="comment">// 此时RDB save的文件不重要，因为马上要覆盖它</span></span><br><span class="line">          killRDBChild();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Rename rdb like renaming rewrite aof asynchronously. */</span></span><br><span class="line">      <span class="keyword">int</span> old_rdb_fd = open(server.rdb_filename, O_RDONLY|O_NONBLOCK);</span><br><span class="line">      <span class="keyword">if</span> (rename(server.repl_transfer_tmpfile, server.rdb_filename) == <span class="number">-1</span>) &#123;</span><br><span class="line">          serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;Failed trying to rename the temp DB into %s &quot;</span></span><br><span class="line">                    <span class="string">&quot;in MASTER &lt;-&gt; REPLICA synchronization: %s&quot;</span>,</span><br><span class="line">                    server.rdb_filename, </span><br><span class="line">                    strerror(errno));</span><br><span class="line">          cancelReplicationHandshake();</span><br><span class="line">          <span class="keyword">if</span> (old_rdb_fd != <span class="number">-1</span>) close(old_rdb_fd);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// rename success</span></span><br><span class="line">      <span class="comment">/* Close old rdb asynchronously. */</span></span><br><span class="line">      <span class="keyword">if</span> (old_rdb_fd != <span class="number">-1</span>) </span><br><span class="line">          bioCreateBackgroundJob(BIO_CLOSE_FILE,(<span class="keyword">void</span>*)(<span class="keyword">long</span>)old_rdb_fd,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载</span></span><br><span class="line">      <span class="keyword">if</span> (rdbLoad(server.rdb_filename, &amp;rsi, RDBFLAGS_REPLICATION) != C_OK) &#123;</span><br><span class="line">          serverLog(LL_WARNING, <span class="string">&quot;Failed trying to load the MASTER synchronization DB from disk&quot;</span>);</span><br><span class="line">          cancelReplicationHandshake();</span><br><span class="line">          <span class="comment">// server.rdb_del_sync_files 默认值是 0，</span></span><br><span class="line">          <span class="keyword">if</span> (server.rdb_del_sync_files &amp;&amp; allPersistenceDisabled()) &#123;</span><br><span class="line">              serverLog(LL_NOTICE,</span><br><span class="line">                        <span class="string">&quot;Removing the RDB file obtained from the master. &quot;</span></span><br><span class="line">                        <span class="string">&quot;This replica has persistence disabled&quot;</span>);</span><br><span class="line">              bg_unlink(server.rdb_filename); <span class="comment">// 在后台中删除 server.rdb_filename</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* Note that there&#x27;s no point in restarting the AOF on sync failure,</span></span><br><span class="line"><span class="comment">             it&#x27;ll be restarted when sync succeeds or replica promoted. */</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Cleanup. */</span></span><br><span class="line">      <span class="keyword">if</span> (server.rdb_del_sync_files &amp;&amp; allPersistenceDisabled()) &#123;</span><br><span class="line">          serverLog(LL_NOTICE,<span class="string">&quot;Removing the RDB file obtained from &quot;</span></span><br><span class="line">                              <span class="string">&quot;the master. This replica has persistence &quot;</span></span><br><span class="line">                              <span class="string">&quot;disabled&quot;</span>);</span><br><span class="line">          bg_unlink(server.rdb_filename);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      zfree(server.repl_transfer_tmpfile);</span><br><span class="line">      close(server.repl_transfer_fd);         <span class="comment">// 关闭rdb文件fd</span></span><br><span class="line">      server.repl_transfer_fd = <span class="number">-1</span>;</span><br><span class="line">      server.repl_transfer_tmpfile = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载rdb完成</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>加载成功还需要处理啥？</p>
<p>+　和前面的部分重同步类似，要为连接<code>conn</code>对象<code>server.repl_transfer_s</code>创建<code>server.master</code>实际，为其注册可读事件<br>+　将状态设置为 <font color=blue><code>REPL_STATE_CONNECTED</code></font>状态<br>+　完全同步完成，那么可以设置<code>server.replid</code>和<code>master_repl_offset</code>，并清除缓存的<code>server.replid2</code>等。因为完全重同步成功，说明master已经换了，不需要再保存之前宕机的主服务器信息了。<br>+　重启AOF重写子进程，进行一次持久化。</p>
<p>至此，slave的状态变成了<code>REPL_STATE_CONNECTED</code>，标志着slave与master连接成功，并且进行了首次数据同步。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* Final setup of the connected slave &lt;- master link */</span></span><br><span class="line">   replicationCreateMasterClient(server.repl_transfer_s, rsi.repl_stream_db);</span><br><span class="line">   <span class="comment">// 到此，从服务器状态终于变成了 REPL_STATE_CONNECTED</span></span><br><span class="line">   server.repl_state = REPL_STATE_CONNECTED;</span><br><span class="line">   server.repl_down_since = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 全部重同步完成，相当于开启一个新的记录，那么就需要清除 replid2</span></span><br><span class="line">   <span class="built_in">memcpy</span>(server.replid, server.master-&gt;replid, <span class="keyword">sizeof</span>(server.replid));</span><br><span class="line">   server.master_repl_offset = server.master-&gt;reploff;</span><br><span class="line">   clearReplicationId2();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无论是否有sub-slaves，都需要创建 server.repl_backlog</span></span><br><span class="line"><span class="comment">// 当这个slave升级为master时，备用</span></span><br><span class="line">   <span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span>) createReplicationBacklog();</span><br><span class="line">   serverLog(LL_NOTICE, <span class="string">&quot;MASTER &lt;-&gt; REPLICA sync: Finished with success&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 等全部重同步完成，就可以重启AOF重写了</span></span><br><span class="line">   <span class="keyword">if</span> (server.aof_enabled) restartAOFAfterSYNC();</span><br><span class="line">   <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
<h3 id="SLAVEOF-NO-ONE"><a href="#SLAVEOF-NO-ONE" class="headerlink" title="SLAVEOF NO ONE"></a>SLAVEOF NO ONE</h3><p><code>SLAVEOF</code>命令，可以让server变成slave，也可以让其从slave恢复到单机。</p>
<p>对一个slave执行<code>SLAVEOF NO ONE</code>命令，即取消其复制行为，对主服务器执行这个命令没有效果。脱离复制的过程由<code>replicationUnsetMaster</code>函数实现。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicaofCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// 集群模式下不允许SLAVEOF</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;REPLICAOF not allowed in cluster mode.&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  SLAVE NO ONE 指令会关闭当前从服务器的复制行为，使其成为单独的主服务器</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;no&quot;</span>) &amp;&amp; !strcasecmp(c-&gt;argv[<span class="number">2</span>]-&gt;ptr,<span class="string">&quot;one&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.masterhost) &#123;</span><br><span class="line">            replicationUnsetMaster();	</span><br><span class="line">            sds client = catClientInfoString(sdsempty(), c);</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">&quot;MASTER MODE enabled (user request from &#x27;%s&#x27;)&quot;</span>,client);</span><br><span class="line">            sdsfree(client);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// else .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="replicationUnsetMaster"><a href="#replicationUnsetMaster" class="headerlink" title="replicationUnsetMaster"></a>replicationUnsetMaster</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationUnsetMaster</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">/* Nothing to do. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fire the master link modules event. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECTED)</span><br><span class="line">        moduleFireServerEvent(REDISMODULE_EVENT_MASTER_LINK_CHANGE,</span><br><span class="line">                              REDISMODULE_SUBEVENT_MASTER_LINK_DOWN,</span><br><span class="line">                              <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    sdsfree(server.masterhost); </span><br><span class="line">    server.masterhost = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.master) </span><br><span class="line">        freeClient(server.master);</span><br><span class="line">    <span class="comment">// freeClient() 中会缓存 server.cached_master </span></span><br><span class="line">    <span class="comment">// 因此要调用 replicationDiscardCachedMaster() 函数取消缓存</span></span><br><span class="line">    replicationDiscardCachedMaster();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果正在与主服务建立连接，则取消</span></span><br><span class="line">    cancelReplicationHandshake();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成server自己的replid</span></span><br><span class="line">    shiftReplicationId();</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 不再复制主服务器，那么也需要断开自己的 sub-slaves</span></span><br><span class="line">    disconnectSlaves();</span><br><span class="line">    server.repl_state = REPL_STATE_NONE; <span class="comment">// 连接状态设置初始化状态</span></span><br><span class="line"></span><br><span class="line">    server.slaveseldb = <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前服务器的下线时间</span></span><br><span class="line">    server.repl_no_slaves_since = server.unixtime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fire the role change modules event. */</span></span><br><span class="line">    moduleFireServerEvent(REDISMODULE_EVENT_REPLICATION_ROLE_CHANGED,</span><br><span class="line">                          REDISMODULE_EVENT_REPLROLECHANGED_NOW_MASTER,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果之前手动关闭了AOF进程，现在重启</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_enabled &amp;&amp; server.aof_state == AOF_OFF) </span><br><span class="line">        restartAOFAfterSYNC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="shiftReplicationId"><a href="#shiftReplicationId" class="headerlink" title="shiftReplicationId"></a>shiftReplicationId</h4><p>调用<code>shiftReplicationId</code>函数的时机，是当的server将要从slave变成master。因此<code>server.replid</code>要替换为自己的<code>replid</code>，同时要把之前复制的主服务器信息存储在<code>server.replid2</code>及 <code>server.second_replid_offset</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftReplicationId</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(server.replid2, server.replid, <span class="keyword">sizeof</span>(server.replid));</span><br><span class="line"> </span><br><span class="line">    server.second_replid_offset = server.master_repl_offset+<span class="number">1</span>;  </span><br><span class="line">	<span class="comment">// 生成自己的 replid</span></span><br><span class="line">    changeReplicationId();</span><br><span class="line">    serverLog(LL_WARNING,</span><br><span class="line">              <span class="string">&quot;Setting secondary replication ID to %s, valid up to offset: %lld.&quot;</span></span><br><span class="line">              <span class="string">&quot; New replication ID is %s&quot;</span>, </span><br><span class="line">              server.replid2, </span><br><span class="line">              server.second_replid_offset, </span><br><span class="line">              server.replid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Master端解析</strong></p>
<p>那么主服务器端是如何回应slave端？下面进行讲解。</p>
<h3 id="replconfCommand"><a href="#replconfCommand" class="headerlink" title="replconfCommand"></a>replconfCommand</h3><p>在主从握手过程中，slave端通过<code>server.repl_transfer_s</code>向master端发送<code>REPLCONF option value</code>命令，master在 <code>replconfCommand</code>函数对其进行解析。</p>
<p>这个函数master和slave都会调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replconfCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 参数个数必须是奇数个</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">0</span>) &#123;     </span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Process every option-value pair. */</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; c-&gt;argc; j+=<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">&quot;listening-port&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">long</span> port;</span><br><span class="line">            <span class="keyword">if</span> ((getLongFromObjectOrReply(c,c-&gt;argv[j+<span class="number">1</span>],&amp;port,<span class="literal">NULL</span>) != C_OK))  <span class="comment">// 取出 port</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c-&gt;slave_listening_port = port;	</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">&quot;ip-address&quot;</span>)) &#123;</span><br><span class="line">            sds ip = c-&gt;argv[j+<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">            <span class="comment">// c-&gt;slave_ip 有长度限制</span></span><br><span class="line">            <span class="keyword">if</span> (sdslen(ip) &lt; <span class="keyword">sizeof</span>(c-&gt;slave_ip)) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(c-&gt;slave_ip,ip,sdslen(ip)+<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                addReplyErrorFormat(c,</span><br><span class="line">                                    <span class="string">&quot;REPLCONF ip-address provided by replica instance is too long: &quot;</span></span><br><span class="line">                                    <span class="string">&quot;%zd bytes&quot;</span>, </span><br><span class="line">                                    sdslen(ip));</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">&quot;capa&quot;</span>)) &#123;</span><br><span class="line">           <span class="comment">// 如果REDIS版本过低，无法识别CAPA就直接忽略</span></span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j+<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;eof&quot;</span>))</span><br><span class="line">                c-&gt;slave_capa |= SLAVE_CAPA_EOF;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j+<span class="number">1</span>]-&gt;ptr,<span class="string">&quot;psync2&quot;</span>))</span><br><span class="line">                c-&gt;slave_capa |= SLAVE_CAPA_PSYNC2;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">&quot;ack&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// REPLCONF ACK OFFSET 指令是slave用来通知master到目前为止</span></span><br><span class="line">            <span class="comment">// slave 处理的复制流的数量</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> offset;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_SLAVE)) <span class="comment">// c必须是slave</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">if</span> ((getLongLongFromObject(c-&gt;argv[j+<span class="number">1</span>], &amp;offset) != C_OK))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="comment">// c-&gt;repl_ack_off 是上一次ACK时的偏移量</span></span><br><span class="line">            <span class="keyword">if</span> (offset &gt; c-&gt;repl_ack_off)</span><br><span class="line">                c-&gt;repl_ack_off = offset;</span><br><span class="line">            <span class="comment">// 心跳检测</span></span><br><span class="line">            c-&gt;repl_ack_time = server.unixtime;</span><br><span class="line">    </span><br><span class="line">            <span class="keyword">if</span> (c-&gt;repl_put_online_on_ack &amp;&amp; c-&gt;replstate == SLAVE_STATE_ONLINE)</span><br><span class="line">                putSlaveOnline(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[j]-&gt;ptr,<span class="string">&quot;getack&quot;</span>)) &#123;</span><br><span class="line">            <span class="comment">// master向slave请求ACK</span></span><br><span class="line">            <span class="keyword">if</span> (server.masterhost &amp;&amp; server.master) </span><br><span class="line">                replicationSendAck();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            addReplyErrorFormat(c,</span><br><span class="line">                                <span class="string">&quot;Unrecognized REPLCONF option: %s&quot;</span>,</span><br><span class="line">                                (<span class="keyword">char</span>*)c-&gt;argv[j]-&gt;ptr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    addReply(c,shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="syncCommand-–-Partial"><a href="#syncCommand-–-Partial" class="headerlink" title="syncCommand – Partial"></a>syncCommand – Partial</h4><p>当slave端向master发送<code>PYSNC replid offset</code>请求时，master端就会进入<code>syscCommand</code> 函数中。在正式处理PYSNC请求之前，先判断下：</p>
<ul>
<li>如果当前server是master，<code>c</code>已经是master的slave，那么直接忽略请求</li>
<li>如果当前server是slave，<code>PSYNC</code>是c是用户发出的的而不是sub-slave，如果此时<code>server</code>的状态没有和master连接好，则也忽略此次请求。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 c 已经是master的slave，则忽略请求</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_SLAVE) <span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 如果当前server是slave，但是还没与master建立好连接，</span></span><br><span class="line">    <span class="comment">// 但是客户端c在强制发送PSYNC请求，则回复用户客户端：xxx</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED) &#123;</span><br><span class="line">        addReplySds(c,sdsnew(<span class="string">&quot;-NOMASTERLINK Can&#x27;t SYNC while not connected with my master\r\n&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果slave在此之前master发过指令请求，刚好此刻master要发送给slave</span></span><br><span class="line">    <span class="comment">// 那么旧中止，mastet回应SYNC请求需要的一个全新的发送缓冲区，否则slave无法识别</span></span><br><span class="line">    <span class="keyword">if</span> (clientHasPendingReplies(c)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">&quot;SYNC and PSYNC are invalid with pending output&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先处理<code>PSYNC</code>请求，基于<code>masterTryPartialResynchronization</code>函数尝试执行部分重同步，如果经过master判断无法执行部分重同步再执行完全重同步。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="comment">// 同意slave c 的请求</span></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">             <span class="string">&quot;Replica %s asks for synchronization&quot;</span>,</span><br><span class="line">             replicationGetSlaveName(c));</span><br><span class="line">   	</span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr, <span class="string">&quot;psync&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 先尝试执行部分重同步，返回C_ERR则转而执行完全重同步</span></span><br><span class="line">        <span class="keyword">if</span> (masterTryPartialResynchronization(c) == C_OK) &#123;</span><br><span class="line">            server.stat_sync_partial_ok++; <span class="comment">// for debug</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 那么应该执行完全重同步</span></span><br><span class="line">            <span class="keyword">char</span> *master_replid = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">            <span class="keyword">if</span> (master_replid[<span class="number">0</span>] != <span class="string">&#x27;?&#x27;</span>) </span><br><span class="line">                server.stat_sync_partial_err++;	<span class="comment">// for debug</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="masterTryPartialResynchronization"><a href="#masterTryPartialResynchronization" class="headerlink" title="masterTryPartialResynchronization"></a>masterTryPartialResynchronization</h4><p>无论slave发的PSYNC是啥，<code>masterTryPartialResynchronization</code>函数都先尝试能不能执行部分重同步，如果能则直接传输<code>server.repl_backlog</code>中的数据，不能则返回<code>C_ERR</code>，留到上面<code>syncCommand</code>函数中else分支执行：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (masterTryPartialResynchronization(c) == C_OK) &#123;</span><br><span class="line">    <span class="comment">// 部分重同步成功</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">   <span class="comment">// 需要执行完全重同步</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而判断是否能部分重同步，对于<code>PSYNC master_replid pysnc_offset</code>请求，必须满足：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.replid == master_replid  &amp;&amp; </span><br><span class="line">pysnc_offset &gt; server.repl_backlog_off &amp;&amp; pysnc_offset &lt; server.master_repl_offset</span><br></pre></td></tr></table></figure>
<p>如果<code>PYSNC</code>请求的<code>master_replid</code>与当前主服务器的<code>server.replid</code>不一致，则有可能是因为这个server是新被选出来的主服务器，那么就需要判断将<code>master_replid</code>与之前宕机的旧主服务器的<code>server.replid2</code>进行比较，也需要满足</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">master_replid == server.replid2 &amp;&amp; psync_offset &lt; server.second_replid_offset</span><br></pre></td></tr></table></figure>
<p>如果经过判断能执行部分重同步，</p>
<ul>
<li> 将客户端c标志位加上 <code>CLIENT_SLAVE</code>，区别于普通的用户客户端</li>
<li> 将c的状态设置为 <font color=blue><code>SLAVE_STATE_ONLINE</code></font>，表示建立连接，可以正常传输数据。</li>
<li> master根据slave是否支持<code>PSYNC2</code>协议，回复客户端 <code>+CONTINUE\r\n</code> or   <code>+CONTINUE replid \r\n</code>   </li>
<li>将 <code>serevr.repl_backlog</code> 中从<code>psync_offset</code>开始积累的数据添加待<code>output</code>, 等待可写事件触发即可发送</li>
</ul>
<p>函数执行成功，则返回<code>C_OK</code>，返回 <code>syncCommand</code>函数后，也直接return。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PYSNC replid offset</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">masterTryPartialResynchronization</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> psync_offset, psync_len;</span><br><span class="line">    <span class="keyword">char</span> *master_replid = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;  <span class="comment">// replid</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> buflen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// offset</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,c-&gt;argv[<span class="number">2</span>],&amp;psync_offset,<span class="literal">NULL</span>) != C_OK) </span><br><span class="line">        <span class="keyword">goto</span> need_full_resync;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">/***** 判断是否能执行部分重同步 ******/</span></span><br><span class="line">    <span class="comment">// 先判断 master_replid 对不对，不对再检测下 server.replid2对不对</span></span><br><span class="line">    <span class="keyword">if</span> (strcasecmp(master_replid, server.replid) &amp;&amp; (strcasecmp(master_replid, server.replid2) ||   </span><br><span class="line">                                                     psync_offset &gt; server.second_replid_offset))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 不匹配，说明是需要完全重同步</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果 master_replid[0] 不是 ?，就不是save强制执行完全重同步</span></span><br><span class="line">        <span class="comment">// 那么就判断导致完全重同步的原因，是因为PSYNC的 replid 还是因为 replid2</span></span><br><span class="line">        <span class="keyword">if</span> (master_replid[<span class="number">0</span>] != <span class="string">&#x27;?&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// PSYNC 请求的 master_replid 不匹配导致无法部分重同步</span></span><br><span class="line">            <span class="keyword">if</span> (strcasecmp(master_replid, server.replid) &amp;&amp; </span><br><span class="line">                strcasecmp(master_replid, server.replid2))</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                          <span class="string">&quot;Partial resynchronization not accepted:&quot;</span></span><br><span class="line">                          <span class="string">&quot;Replication ID mismatch (Replica asked for &#x27;%s&#x27;, my &quot;</span></span><br><span class="line">                          <span class="string">&quot;replication IDs are &#x27;%s&#x27; and &#x27;%s&#x27;)&quot;</span>,</span><br><span class="line">                          master_replid, </span><br><span class="line">                          server.replid, </span><br><span class="line">                          server.replid2);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// replid2 不匹配导致的</span></span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                          <span class="string">&quot;Partial resynchronization not accepted: &quot;</span></span><br><span class="line">                          <span class="string">&quot;Requested offset for second ID was %lld, but I can reply &quot;</span></span><br><span class="line">                          <span class="string">&quot;up to %lld&quot;</span>, </span><br><span class="line">                          psync_offset, </span><br><span class="line">                          server.second_replid_offset);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//master_replid[0] == &#x27;?&#x27;，说明是slave强制请求完全重同步导致的</span></span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                      <span class="string">&quot;Full resync requested by replica %s&quot;</span>,</span><br><span class="line">                      replicationGetSlaveName(c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> need_full_resync;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 对PSYNC的psync_offset判断,是否能执行部分重同步</span></span><br><span class="line">    <span class="keyword">if</span> (!server.repl_backlog ||</span><br><span class="line">        psync_offset &lt; server.repl_backlog_off ||</span><br><span class="line">        psync_offset &gt; (server.repl_backlog_off + server.repl_backlog_histlen))</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">                  <span class="string">&quot;Unable to partial resync with replica %s &quot;</span></span><br><span class="line">                  <span class="string">&quot;for lack of backlog (Replica request was: %lld).&quot;</span>, </span><br><span class="line">                  replicationGetSlaveName(c), </span><br><span class="line">                  psync_offset);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (psync_offset &gt; server.master_repl_offset) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Warning: replica %s tried to PSYNC &quot;</span></span><br><span class="line">                      <span class="string">&quot;with an offset that is greater than the master replication offset.&quot;</span>, </span><br><span class="line">                      replicationGetSlaveName(c));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">goto</span> need_full_resync;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行到此，说明满足部分重同步的条件</span></span><br><span class="line">    c-&gt;flags |= CLIENT_SLAVE;</span><br><span class="line">    c-&gt;replstate = SLAVE_STATE_ONLINE;  <span class="comment">// 开始在线更新数据</span></span><br><span class="line">    c-&gt;repl_ack_time = server.unixtime; <span class="comment">// 更新心跳检测时间</span></span><br><span class="line">    c-&gt;repl_put_online_on_ack = <span class="number">0</span>;      <span class="comment">// 是否注册ACK可写事件 </span></span><br><span class="line">    listAddNodeTail(server.slaves, c);  <span class="comment">// 将从服务器加入主服务器的从服务器客户端队列中</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (c-&gt;slave_capa &amp; SLAVE_CAPA_PSYNC2) &#123;</span><br><span class="line">        buflen = <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">&quot;+CONTINUE %s\r\n&quot;</span>, server.replid); <span class="comment">// PYSNC2协议</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        buflen = <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">&quot;+CONTINUE\r\n&quot;</span>);					<span class="comment">// PYSNC 协议</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送通知：+CONTINUE</span></span><br><span class="line">    <span class="keyword">if</span> (connWrite(c-&gt;conn,buf,buflen) != buflen) &#123;</span><br><span class="line">        freeClientAsync(c);</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 server.repl_backlog 中[pysnc_offset，server.master_offset]区间的数据</span></span><br><span class="line">    <span class="comment">// 添加到发送缓冲区，发送给 slave</span></span><br><span class="line">    psync_len = addReplyReplicationBacklog(c, psync_offset);</span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">              <span class="string">&quot;Partial resynchronization request from %s accepted. &quot;</span></span><br><span class="line">              <span class="string">&quot;Sending %lld bytes of backlog starting from offset %lld.&quot;</span>,</span><br><span class="line">              replicationGetSlaveName(c),</span><br><span class="line">              psync_len, </span><br><span class="line">              psync_offset);</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 如果能执行部分重同步，那么不需要发送select指令</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新有效slave个数</span></span><br><span class="line">    refreshGoodSlavesCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C_OK; </span><br><span class="line"></span><br><span class="line">need_full_resync:</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="syncCommnad-–-Full"><a href="#syncCommnad-–-Full" class="headerlink" title="syncCommnad – Full"></a>syncCommnad – Full</h4><p><code>masterTryPartialResynchronization</code>函数如果返回<code>C_ERR</code>，则将执行完全重同步。先简要的一些判断</p>
<ul>
<li>导致<code>PYSNC</code>部分重同步失败，是否因为slave强行执行完全重同步</li>
<li>slave发送如果是SYNC请求，那么之后有些回复不能发送给slave，因为slave版本低无法识别。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr, <span class="string">&quot;psync&quot;</span>)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (masterTryPartialResynchronization(c) == C_OK) &#123;</span><br><span class="line">           server.stat_sync_partial_ok++; <span class="comment">// for debug</span></span><br><span class="line">           <span class="keyword">return</span>; <span class="comment">/* No full resync needed, return. */</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// 那么应该执行完全重同步</span></span><br><span class="line">           <span class="keyword">char</span> *master_replid = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">		<span class="comment">// 不是?，则是部分重同步请求失败了</span></span><br><span class="line">           <span class="keyword">if</span> (master_replid[<span class="number">0</span>] != <span class="string">&#x27;?&#x27;</span>) </span><br><span class="line">               server.stat_sync_partial_err++;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 如果slave端发送是SYNC请求，加上 CLIENT_PRE_PSYNC 标志</span></span><br><span class="line">       <span class="comment">// 说明slave版本过低，很多能力不支持</span></span><br><span class="line">       c-&gt;flags |= CLIENT_PRE_PSYNC;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行到此，说明要执行完全重同步</span></span><br><span class="line">   <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>当判断确实要执行完全重同步，即slave从零开始，同步到当前server的状态，需要做一些处理</p>
<ul>
<li>加上到当前server的从服务器链表<code>server.slaves</code></li>
<li>也要给slave机上<code>CLIENT_SLAVE</code>以区别于普通的客户端</li>
<li>slave的状态设置为<font color=blue><code>SLAVE_STATE_WAIT_BGSAVE_START</code></font>，表示即将开始启动<code>BGSAVE</code></li>
<li>如果这个slave是server的第一个从服务器，那么就需要做较多的工作：<ul>
<li>创建<code>server.repl_backlog</code>，积累数据，为后面部分重同同步准备。</li>
<li>为当前<code>server</code>创建<code>replid</code>，</li>
<li>消除<code>server.replid2</code>。都已经执行完全重同步了，那么之前宕机的主服务器和此时的slave没有关系，不需要缓存<code>server.replid2</code></li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">	<span class="comment">//...</span></span><br><span class="line">c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</span><br><span class="line">   <span class="keyword">if</span> (server.repl_disable_tcp_nodelay)</span><br><span class="line">       connDisableTcpNoDelay(c-&gt;conn);  <span class="comment">/* Non critical if it fails. */</span></span><br><span class="line"></span><br><span class="line">   c-&gt;repldbfd = <span class="number">-1</span>;</span><br><span class="line">   c-&gt;flags |= CLIENT_SLAVE;</span><br><span class="line">   listAddNodeTail(server.slaves, c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建server.repl_backlog</span></span><br><span class="line"><span class="comment">// 在server第一个slave时就创建 server.repl_backlog</span></span><br><span class="line"><span class="comment">// 在之后的slave共享的都是server.repl_backlog</span></span><br><span class="line">   <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">1</span> &amp;&amp; server.repl_backlog == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="comment">// 生成新的 server.replid</span></span><br><span class="line">       changeReplicationId();</span><br><span class="line">       clearReplicationId2();</span><br><span class="line">       createReplicationBacklog();</span><br><span class="line">       serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">&quot;Replication backlog created, my new replication IDs are &#x27;%s&#x27; and &#x27;%s&#x27;&quot;</span>,</span><br><span class="line">                server.replid, </span><br><span class="line">                server.replid2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>下面master需要根据传输RDB数据的方式<code>server.rdb_child_type</code>做不同的处理:</p>
<ul>
<li><code>RDB_CHILD_TYPE_DISK</code>：在master端先将<code>server.db[]</code>以RDB协议格式保存到磁盘，再发送给slave</li>
<li><code>RDB_CHILD_TYPE_SOCKET</code>：master端直接将生成的RDB数据通过socket发送给slave</li>
</ul>
<p><code>syncCommnad</code>函数处理如下：</p>
<ol>
<li><code>server.rdb_child_pid != -1 &amp;&amp; server.rdb_child_type == RDB_CHILD_TYPE_DISK</code></li>
</ol>
<p>由于master的所有slaves最终都是要同步到master的状态，那么如果此时子进程正在持久化操作，而当前从服务器c的同步类型<code>RDB_CHILD_TYPE_DISK</code>，那么就是可以直接利用此次持久化产生的rdb文件。</p>
<p>进一步，此刻有另一个slave正在处于<code>SLAVE_STATE_WAIT_BGSAVE_END</code>状态，那么将slave的发送缓存区数据复制给c，再给c开启<code>replicationSetupSlaveForFullResync</code>函数，那么当 <code>server.rdb_child_pid</code>进程产生rdb文件后就可以将此次的c一起同步了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp; server.rdb_child_type == RDB_CHILD_TYPE_DISK) &#123;</span><br><span class="line">       client *slave;</span><br><span class="line">       listNode *ln;</span><br><span class="line">       listIter li;</span><br><span class="line"></span><br><span class="line">       listRewind(server.slaves, &amp;li);</span><br><span class="line">       <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">           slave = ln-&gt;value;</span><br><span class="line">           <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    	<span class="comment">// 如果c和sslave的能力一致，那么就把slave的缓冲区数据发复制给c</span></span><br><span class="line">    	<span class="comment">// 然后也给c开启全同步</span></span><br><span class="line">    	<span class="comment">// c就可以更快的执行同步</span></span><br><span class="line">       <span class="keyword">if</span> (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) &#123;</span><br><span class="line">           copyClientOutputBuffer(c, slave);</span><br><span class="line">           replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);</span><br><span class="line">           serverLog(LL_NOTICE,<span class="string">&quot;Waiting for end of BGSAVE for SYNC&quot;</span>);</span><br><span class="line">       &#125; </span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           serverLog(LL_NOTICE,</span><br><span class="line">                     <span class="string">&quot;Can&#x27;t attach the replica to the current BGSAVE.&quot;</span></span><br><span class="line">                     <span class="string">&quot; Waiting for next BGSAVE for SYNC&quot;</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>
<p>2）<code>server.rdb_child_pid != -1 &amp;&amp; server.rdb_child_type == RDB_CHILD_TYPE_SOCKET</code></p>
<p>如果此时有子进程在RDB持久化，但是master设置的传输方式<code>RDB_CHILD_TYPE_SOCKET</code>，那么完全重同步操作只能等待下次BGSAVE。因为当前持久化对同步没有帮助，不能像上面那样可以重复利用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* CASE 2: BGSAVE is in progress, with socket target. */</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp; server.rdb_child_type == RDB_CHILD_TYPE_SOCKET) &#123;</span><br><span class="line">    serverLog(LL_NOTICE, </span><br><span class="line">              <span class="string">&quot;Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>那么 <code>RDB_CHILD_TYPE_SOCKET</code>类型的完全重同步，延迟到何时执行?</p>
<p>需要等到在<code>replicationCron</code>函数中调用<code>startBgsaveForReplication</code>开启同步操作。为了让更多的slave能处于同步就绪状态，在<code>replicationCron</code>函数中等待<code>server.repl_diskless_sync_delay</code>秒后才能开启dickelss方式复制。过程如下：</p>
<ul>
<li>在<code>replicationCron</code>函数中，确认没有子进程在持久化</li>
<li>必须要有处于<font color=blue><code>SLAVE_STATE_WAIT_BGSAVE_START</code></font>状态的slave，即 <code>slaves_waiting !=0</code></li>
<li>slaves与master最长空闲时间<code>max_idle &gt; server.repl_diskless_sync_delay</code>时，就可以开启dickless复制方式。只要slave与master有数据交互就会更新<code>slave-&gt;lastinteraction</code>，因此在开启<code>dickelss</code>方时会阻塞一会儿。</li>
<li>计算这些slaves能力的交集<code>mincapa</code></li>
</ul>
<p>以上条件都满足了，才能调用<code>startBgsaveForReplication(mincapa)</code>函数开启<code>RDB_CHILD_TYPE_SOCKET</code>传输方式的完全重同步：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//... in replicationCron()</span></span><br><span class="line">    <span class="keyword">if</span> (!hasActiveChildProcess()) &#123;</span><br><span class="line">        <span class="keyword">time_t</span> idle, max_idle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slaves_waiting = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mincapa = <span class="number">-1</span>;   <span class="comment">// 求所有从服务器能力的交集，即最小的能力</span></span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1 计算最大的max_idle</span></span><br><span class="line">        <span class="comment">// 2 计算处于等待RDB的从服务器数量</span></span><br><span class="line">        <span class="comment">// 3 计算从服务器最小的能力 mincapa</span></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client* slave = ln-&gt;value;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">                idle = server.unixtime - slave-&gt;lastinteraction;</span><br><span class="line">                <span class="keyword">if</span> (idle &gt; max_idle) max_idle = idle;</span><br><span class="line">                slaves_waiting++;</span><br><span class="line">                mincapa = (mincapa == <span class="number">-1</span>) ? </span><br><span class="line">                    	 slave-&gt;slave_capa : </span><br><span class="line">                		 (mincapa &amp; slave-&gt;slave_capa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 必须要有从服务器处于等待同步状态，再满足下面两个条件之一：</span></span><br><span class="line">        <span class="comment">// 要么启动的是 dick_sync</span></span><br><span class="line">        <span class="comment">// 要么等待 server.repl_diskless_sync_delay seconds 后再同步</span></span><br><span class="line">        <span class="keyword">if</span> (slaves_waiting &amp;&amp;</span><br><span class="line">            (!server.repl_diskless_sync || max_idle &gt; server.repl_diskless_sync_delay))</span><br><span class="line">        &#123;</span><br><span class="line">            startBgsaveForReplication(mincapa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>3） <code>server.rdb_child_pid == -1 </code></p>
<p>此时，没有开启rdb持久化子进程，那么就可以根据 <code>server.repl_diskless_sync</code>方式来处理，</p>
<ul>
<li><code>server.repl_diskless_sync == RDB_CHILD_TYPE_SOCKET</code>：还是要延迟到<code>replicationCron()</code>函数中执行</li>
<li><code>server.repl_diskless_sync == RDB_CHILD_TYPE_DISK</code>：就直接在此处调用<code>startBgsaveForReplication</code>函数</li>
</ul>
<p>这个分支表述如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in syncCommand(client* c)</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) &#123;</span><br><span class="line">            <span class="comment">// dickless 的复制方式</span></span><br><span class="line">            <span class="comment">// 由于在 replicationCron() 函数里创建rdb子进程，将数据复制给slave，</span></span><br><span class="line">            <span class="comment">// 因此希望让更多的slave处于准备就绪状态</span></span><br><span class="line">            <span class="comment">// 那么在此延时等待 server.repl_diskless_sync_delay sec</span></span><br><span class="line">            <span class="keyword">if</span> (server.repl_diskless_sync_delay)</span><br><span class="line">                serverLog(LL_NOTICE, <span class="string">&quot;Delay next BGSAVE for diskless SYNC&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;         </span><br><span class="line">            <span class="comment">// 如果复制方式配置的是先存储到磁盘再发送，或者slave端不支持 diskless 复制方式</span></span><br><span class="line">            <span class="comment">// 那么就启动子进程，生成RDB文件</span></span><br><span class="line">            <span class="keyword">if</span> (!hasActiveChildProcess()) &#123;</span><br><span class="line">                startBgsaveForReplication(c-&gt;slave_capa);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                          <span class="string">&quot;No BGSAVE in progress, but another BG operation is active. &quot;</span></span><br><span class="line">                          <span class="string">&quot;BGSAVE for replication delayed&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="startBgsaveForReplication"><a href="#startBgsaveForReplication" class="headerlink" title="startBgsaveForReplication"></a>startBgsaveForReplication</h4><p><code>startBgsaveForReplication</code> 开启完全重同步。根据master端的同步方式<code>server.repl_diskless_sync</code>以及slave支持<code>EOF</code>，才可以开启socket传输rdb数据，否则还是先生成RDB文件，再传输到slave端。</p>
<ul>
<li><code>socket_target ==1</code>：<code>rdbSaveToSlavesSockets</code>函数通过socket传输，此时slave直接在接受了。</li>
<li><code>socket_target ==0</code>：<code> rdbSaveBackground</code>将rdb数据线保存到本底<code>server.rdb_filename</code>，然后调用<code>replicationSetupSlaveForFullResync</code>函数将<code>server.rdb_filename</code>中数据传入到slave。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">startBgsaveForReplication</span><span class="params">(<span class="keyword">int</span> mincapa)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">int</span> socket_target = server.repl_diskless_sync &amp;&amp; (mincapa &amp; SLAVE_CAPA_EOF);</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">              <span class="string">&quot;Starting BGSAVE for SYNC with target: %s&quot;</span>,</span><br><span class="line">              socket_target ? <span class="string">&quot;replicas sockets&quot;</span> : <span class="string">&quot;disk&quot;</span>);</span><br><span class="line"></span><br><span class="line">    rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">    rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line">    <span class="comment">/* Only do rdbSave* when rsiptr is not NULL,</span></span><br><span class="line"><span class="comment">     * otherwise slave will miss repl-stream-db. */</span></span><br><span class="line">    <span class="keyword">if</span> (rsiptr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (socket_target)</span><br><span class="line">            retval = rdbSaveToSlavesSockets(rsiptr);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            retval = rdbSaveBackground(server.rdb_filename,rsiptr);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">&quot;BGSAVE for replication: replication information not available,&quot;</span></span><br><span class="line">                  <span class="string">&quot; can&#x27;t generate the RDB file right now. Try later.&quot;</span>);</span><br><span class="line">        retval = C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  	<span class="comment">// 是否删除此处生成的 server.rdb_filaname 文件</span></span><br><span class="line">    <span class="keyword">if</span> (retval == C_OK &amp;&amp; !socket_target &amp;&amp; server.rdb_del_sync_files)</span><br><span class="line">        RDBGeneratedByReplication = <span class="number">1</span>;	<span class="comment">// 删除</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果发生错误，则取消所有等待master产生rdb数据的slave，断开主从连接</span></span><br><span class="line">    <span class="keyword">if</span> (retval == C_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING, <span class="string">&quot;BGSAVE for replication failed&quot;</span>);</span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">                slave-&gt;replstate = REPL_STATE_NONE;</span><br><span class="line">                slave-&gt;flags &amp;= ~CLIENT_SLAVE;</span><br><span class="line">                listDelNode(server.slaves, ln);</span><br><span class="line">                addReplyError(slave, <span class="string">&quot;BGSAVE failed, replication can&#x27;t continue&quot;</span>);</span><br><span class="line">                slave-&gt;flags |= CLIENT_CLOSE_AFTER_REPLY;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给master的每个slave发送rdb数据</span></span><br><span class="line">    <span class="keyword">if</span> (!socket_target) &#123;</span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">                replicationSetupSlaveForFullResync(slave, getPsyncInitialOffset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (retval == C_OK) replicationScriptCacheFlush();</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rdbSaveToSlavesSockets"><a href="#rdbSaveToSlavesSockets" class="headerlink" title="rdbSaveToSlavesSockets"></a>rdbSaveToSlavesSockets</h4><p><code>rdbSaveToSlavesSockets</code>函数和 <code>rdbSaveBackground</code>函数原理类似，后者是向rdb文件 <code>server.rdb_filename</code> 中写入数据，而前者是向socket中写入rdb数据。但是REDIS并没有直接让产生rdb数据的子进程向socket中写入数据传递给slave，而是让子进程把生成的rdb数据都传递到父进程，让父进程写入socket，这是为了当子进程中止被父进程接管时不会影响TLS的连续状态。</p>
<ul>
<li>在fork之前，创建管道<code> server.rdb_pipe_read</code>与 <code>server.rdb_pipe_write</code>。</li>
<li>将所有处于<code>SLAVE_STATE_WAIT_BGSAVE_START</code>状态的slaves都在<code>server.rdb_pipe_conns </code>中建立一个引用，使得<code>server.rdb_pipe_conns[i]</code>指向等待BGSAVE启动的slave，再并将他们的状态修改为 <code>SLAVE_STATE_WAIT_BGSAVE_END</code></li>
<li>在子进程中，创建基于 <code>server.rdb_pipe_write</code> 的rdb对象，使得子进程直接将生成的rdb协议格式的数据写入管道，父进程在<code>server.rdb_pipe_read</code>端读取</li>
<li>在父进程中，需要将<code>server.rdb_pipe_read</code>管道设置为非阻塞模式，为<code>server.rdb_pipe_read</code>注册可读事件，设置可读事件的回调函数<code>rdbPipeReadHandler</code>，等待子进程数据的到来</li>
</ul>
<p><code>rdbSaveToSlavesSockets</code>函数结束后，子进程的数据可能尚未完全发送至父进程。需要等子进程结束后，rdb数据全部写完，那个时候就可以将rdb数据写入socket中。因此，真正发送rdb数据，是在进程结束后的处理函数<code>backgroundSaveDoneHandler</code>中。</p>
<p>此外，将rdb数据先存储到磁盘再同步的方式也是在<code>backgroundSaveDoneHandler</code>函数中完成发送。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveToSlavesSockets</span><span class="params">(rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line">    <span class="keyword">int</span> pipefds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasActiveChildProcess()) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    <span class="keyword">if</span> (server.rdb_pipe_conns) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Before to fork, create a pipe that is used to transfer the rdb bytes to</span></span><br><span class="line"><span class="comment">     * the parent, we can&#x27;t let it write directly to the sockets, since in case</span></span><br><span class="line"><span class="comment">     * of TLS we must let the parent handle a continuous TLS state when the</span></span><br><span class="line"><span class="comment">     * child terminates and parent takes over. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (pipe(pipefds) == <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    server.rdb_pipe_read  = pipefds[<span class="number">0</span>];</span><br><span class="line">    server.rdb_pipe_write = pipefds[<span class="number">1</span>];</span><br><span class="line">    anetNonBlock(<span class="literal">NULL</span>, server.rdb_pipe_read);   <span class="comment">// 读设置为非阻塞IO</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// server.rdb_pipe_conns 保存着所有处于 SLAVE_STATE_WAIT_BGSAVE_START 状态的 slave</span></span><br><span class="line">    server.rdb_pipe_conns = zmalloc(<span class="keyword">sizeof</span>(connection *)*listLength(server.slaves));</span><br><span class="line">    server.rdb_pipe_numconns = <span class="number">0</span>;</span><br><span class="line">    server.rdb_pipe_numconns_writing = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    listRewind(server.slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *slave = ln-&gt;value;</span><br><span class="line">        <span class="comment">// 对于等待master开启BGSAVE的slave，进行处理</span></span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">            <span class="comment">// 将 SLAVE_STATE_WAIT_BGSAVE_START 状态的slave 保存在 server.rdb_pipe_conns</span></span><br><span class="line">            server.rdb_pipe_conns[server.rdb_pipe_numconns++] = slave-&gt;conn;</span><br><span class="line">            <span class="comment">// 将slave状态设置为 SLAVE_STATE_WAIT_BGSAVE_END</span></span><br><span class="line">            <span class="comment">// 发送slave： +FULLSYNC master_repliId  master_replioff</span></span><br><span class="line">            replicationSetupSlaveForFullResync(slave, getPsyncInitialOffset());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    openChildInfoPipe();</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = redisFork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line">        rio rdb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 server.rdb_pipe_write 管道初始化rdb对象</span></span><br><span class="line">        <span class="comment">// 那么就是向父进程写rdb数据</span></span><br><span class="line">        rioInitWithFd(&amp;rdb, server.rdb_pipe_write);</span><br><span class="line"></span><br><span class="line">        redisSetProcTitle(<span class="string">&quot;redis-rdb-to-slaves&quot;</span>);</span><br><span class="line">        redisSetCpuAffinity(server.bgsave_cpulist);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数据流式的写：前后都会有 eofmark</span></span><br><span class="line">        retval = rdbSaveRioWithEOFMark(&amp;rdb,<span class="literal">NULL</span>,rsi);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK &amp;&amp; rioFlush(&amp;rdb) == <span class="number">0</span>)	<span class="comment">// rioFlush(&amp;rdb) ==0 表示失败</span></span><br><span class="line">            retval = C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) &#123;</span><br><span class="line">            sendChildCOWInfo(CHILD_INFO_TYPE_RDB, <span class="string">&quot;RDB&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 写完毕</span></span><br><span class="line">        rioFreeFd(&amp;rdb);				</span><br><span class="line">        close(server.rdb_pipe_write);        <span class="comment">/* wake up the reader, tell it we&#x27;re done. */</span></span><br><span class="line">        exitFromChild((retval == C_OK) ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果子进程没有启动</span></span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                     <span class="string">&quot;Can&#x27;t save in background: fork: %s&quot;</span>,</span><br><span class="line">                     strerror(errno));</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* 需要将修该为 SLAVE_STATE_WAIT_BGSAVE_END 状态的slave</span></span><br><span class="line"><span class="comment">             * 都重新恢复到 SLAVE_STATE_WAIT_BGSAVE_START 状态</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            listRewind(server.slaves,&amp;li);</span><br><span class="line">            <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">                client* slave = ln-&gt;value;</span><br><span class="line">                <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) &#123;</span><br><span class="line">                    slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 关闭pipe</span></span><br><span class="line">            close(server.rdb_pipe_write);</span><br><span class="line">            close(server.rdb_pipe_read);</span><br><span class="line">            zfree(server.rdb_pipe_conns);	<span class="comment">// 释放内存</span></span><br><span class="line">            server.rdb_pipe_conns = <span class="literal">NULL</span>;</span><br><span class="line">            server.rdb_pipe_numconns = <span class="number">0</span>;</span><br><span class="line">            server.rdb_pipe_numconns_writing = <span class="number">0</span>;</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则子进程就是启动成功</span></span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                      <span class="string">&quot;Background RDB transfer started by pid %d&quot;</span>,</span><br><span class="line">                      childpid);</span><br><span class="line">            </span><br><span class="line">            server.rdb_save_time_start = time(<span class="literal">NULL</span>); <span class="comment">// 保存rdb子进程启动时间 </span></span><br><span class="line">            server.rdb_child_pid = childpid;</span><br><span class="line">            server.rdb_child_type = RDB_CHILD_TYPE_SOCKET; <span class="comment">// rdb类型</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将父进程中的 server.rdb_pipe_write 关闭，父进程是只读</span></span><br><span class="line">            close(server.rdb_pipe_write); </span><br><span class="line">            </span><br><span class="line">             <span class="comment">// 并为 server.rdb_pipe_read 注册可读事件，回调函数是 rdbPipeReadHandler</span></span><br><span class="line">             <span class="comment">// 在回调函数中读取rdb数据</span></span><br><span class="line">            <span class="keyword">if</span> (aeCreateFileEvent(server.el, </span><br><span class="line">                                  server.rdb_pipe_read, </span><br><span class="line">                                  AE_READABLE, </span><br><span class="line">                                  rdbPipeReadHandler,</span><br><span class="line">                                  <span class="literal">NULL</span>) == AE_ERR) </span><br><span class="line">            &#123;</span><br><span class="line">                serverPanic(<span class="string">&quot;Unrecoverable error creating server.rdb_pipe_read file event.&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (childpid == <span class="number">-1</span>) ? C_ERR : C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* Unreached. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="replicationSetupSlaveForFullResync"><a href="#replicationSetupSlaveForFullResync" class="headerlink" title="replicationSetupSlaveForFullResync"></a>replicationSetupSlaveForFullResync</h4><p><code>replicationSetupSlaveForFullResync</code>给slave发送<font color=blue><code>+FULLRESYNC server.replid server.master_repl_offset\r\n</code></font>，master要积累数据即将要发送自己数据。</p>
<ul>
<li>设置<code>slave</code>此时的状态是<font color=blue><code>SLAVE_STATE_WAIT_BGSAVE_END</code></font>，表示从BGSAVE已经启动，要开始积累rdb数据了。</li>
<li><code> server.slaveseldb = -1</code>是为了先发送个<code>SELECT </code>指令</li>
</ul>
<p>整个流程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">replicationSetupSlaveForFullResync</span><span class="params">(client *slave, <span class="keyword">long</span> <span class="keyword">long</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">    <span class="keyword">int</span> buflen;</span><br><span class="line"></span><br><span class="line">    slave-&gt;psync_initial_offset = offset;</span><br><span class="line">    slave-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_END; </span><br><span class="line">    server.slaveseldb = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// master接收到的是SYNC指令，则不回复</span></span><br><span class="line">    <span class="keyword">if</span> (!(slave-&gt;flags &amp; CLIENT_PRE_PSYNC)) &#123;</span><br><span class="line">        buflen = <span class="built_in">snprintf</span>(buf,<span class="keyword">sizeof</span>(buf),<span class="string">&quot;+FULLRESYNC %s %lld\r\n&quot;</span>, server.replid, offset);</span><br><span class="line">        <span class="keyword">if</span> (connWrite(slave-&gt;conn,buf,buflen) != buflen) &#123;</span><br><span class="line">            freeClientAsync(slave);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rdbPipeReadHandler"><a href="#rdbPipeReadHandler" class="headerlink" title="rdbPipeReadHandler"></a>rdbPipeReadHandler</h4><p><code>rdbPipeReadHandler</code>函数，是从子进程读取rdb数据流的回调函数。当子进程向父进程向<code>server.rdb_pipe_write</code>中写入数据时，<code>server.rdb_pipe_read</code>上就会触发可读事件，进而调用<code>rdbPipeReadHandler</code>函数读取。这个函数主要完成了三个任务：</p>
<ul>
<li>从<code>server.rdb_pipe_read</code>中将数据读取到<code>server.rdb_pipe_buff</code></li>
<li>将<code>server.rdb_pipe_buff</code>中数据发到<code>server.rdb_pipe_conns</code>中等待数据的slave</li>
<li>当子进程写完数据，会调用<code>close(server.rdb_pipe_write)</code>，关闭子进程的管道<code>server.rdb_pipe_write</code>，<code>rdbPipeReadHandler</code>函数检测到<code>server.rdb_pipe_bufflen == 0</code>时则会进行关闭清理工作。</li>
</ul>
<p>因此，<code>rdbPipeReadHandler</code>完成的任务即，将从<code>server.rdb_pipe_read</code>读取到的rdb数据发送到<code>server.rdb_pipe_conns</code>还存活的slave中，并负责最后的关闭处理。<font color=red>因此！！！，当子进程结束，父进程也已经全部的RDB数据发送到等待数据的slave。</font></p>
<p>其他处理细节，见代码讲解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdbPipeReadHandler</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">void</span> *clientData, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    UNUSED(mask);</span><br><span class="line">    UNUSED(clientData);</span><br><span class="line">    UNUSED(eventLoop);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!server.rdb_pipe_buff)</span><br><span class="line">        server.rdb_pipe_buff = zmalloc(PROTO_IOBUF_LEN);</span><br><span class="line">    serverAssert(server.rdb_pipe_numconns_writing ==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 1) 从 server.rdb_pipe_read 中读取数据至 server.rdb_pipe_buff</span></span><br><span class="line">        server.rdb_pipe_bufflen = read(fd, server.rdb_pipe_buff, PROTO_IOBUF_LEN);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 读取错误处理</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_pipe_bufflen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) <span class="comment">// 非阻塞IO下这不是错误</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Diskless rdb transfer, read error sending DB to replicas: %s&quot;</span>, </span><br><span class="line">                      strerror(errno));</span><br><span class="line">            <span class="comment">// 释放所有等待数据的 slaves </span></span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; server.rdb_pipe_numconns; i++) &#123;</span><br><span class="line">                connection *conn = server.rdb_pipe_conns[i];</span><br><span class="line">                <span class="keyword">if</span> (!conn) <span class="keyword">continue</span>;</span><br><span class="line">                client *slave = connGetPrivateData(conn);</span><br><span class="line">                freeClient(slave);</span><br><span class="line">                server.rdb_pipe_conns[i] = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 杀死子进程</span></span><br><span class="line">            killRDBChild();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 子进程调用 close(server.rdb_pipe_write);表示数据已传输完毕</span></span><br><span class="line">        <span class="comment">// 子进程即将正确关闭: exit(0)</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_pipe_bufflen == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> stillUp = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 需要删除 server.rdb_pipe_read 可读事件</span></span><br><span class="line">            aeDeleteFileEvent(server.el, server.rdb_pipe_read, AE_READABLE);</span><br><span class="line">            <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; server.rdb_pipe_numconns; i++) &#123;</span><br><span class="line">                connection *conn = server.rdb_pipe_conns[i];</span><br><span class="line">                <span class="keyword">if</span> (!conn) <span class="keyword">continue</span>;</span><br><span class="line">                stillUp++;</span><br><span class="line">            &#125;	</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Diskless rdb transfer, done reading from pipe, %d replicas still up.&quot;</span>, </span><br><span class="line">                      stillUp);</span><br><span class="line">            <span class="comment">// 清理</span></span><br><span class="line">            RdbPipeCleanup();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2) 将数据写入到 server.rdb_pipe_conns 中slave</span></span><br><span class="line">        <span class="keyword">int</span> stillAlive = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span> (i=<span class="number">0</span>; i &lt; server.rdb_pipe_numconns; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> nwritten;</span><br><span class="line">            connection* conn = server.rdb_pipe_conns[i];</span><br><span class="line">            <span class="keyword">if</span> (!conn) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将 server.rdb_pipe_read 中读取到的rdb数据发送给 slave </span></span><br><span class="line">            client *slave = connGetPrivateData(conn);</span><br><span class="line">            <span class="keyword">if</span> ((nwritten = connWrite(conn, server.rdb_pipe_buff, server.rdb_pipe_bufflen)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">// 发送失败</span></span><br><span class="line">                <span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">                    serverLog(LL_WARNING,</span><br><span class="line">                              <span class="string">&quot;Diskless rdb transfer, write error sending DB to replica: %s&quot;</span>,</span><br><span class="line">                              connGetLastError(conn));</span><br><span class="line">                    freeClient(slave);</span><br><span class="line">                    server.rdb_pipe_conns[i] = <span class="literal">NULL</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/* An error and still in connected state, is equivalent to EAGAIN */</span></span><br><span class="line">                slave-&gt;repldboff = <span class="number">0</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 发送成功</span></span><br><span class="line">                slave-&gt;repldboff = nwritten;	<span class="comment">// slave-&gt;repldboff 表示每次发送的数据</span></span><br><span class="line">                server.stat_net_output_bytes += nwritten;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果没有将 server.rdb_pipe_buff 中数据都发送给conn，</span></span><br><span class="line">            <span class="comment">// 则为单独为 conn 注册可写事件</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten != server.rdb_pipe_bufflen) &#123;</span><br><span class="line">                server.rdb_pipe_numconns_writing++;</span><br><span class="line">                connSetWriteHandler(conn, rdbPipeWriteHandler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            stillAlive++;</span><br><span class="line">        &#125; <span class="comment">// for-end</span></span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 如果 server.rdb_pipe_conns 中所有的slave都掉线了</span></span><br><span class="line">        <span class="comment">// 则直接kill子进程</span></span><br><span class="line">        <span class="keyword">if</span> (stillAlive == <span class="number">0</span>) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Diskless rdb transfer, last replica dropped, killing fork child.&quot;</span>);</span><br><span class="line">            killRDBChild();</span><br><span class="line">            RdbPipeCleanup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 以下两种情况要删除可读事件：</span></span><br><span class="line">        <span class="comment">// 	case1: server.rdb_pipe_numconns_writing != 0</span></span><br><span class="line">        <span class="comment">// 		如果这一轮从 server.rdb_pipe_read 中读取的数据没有发送完毕，</span></span><br><span class="line">        <span class="comment">// 		则需要将这个数据发送完，才能继续从 server.rdb_pipe_read 中读取，</span></span><br><span class="line">        <span class="comment">// 		否则不知道是哪个conn没有接受到完整的数据</span></span><br><span class="line">        <span class="comment">//	case2: stillAlive == 0: 所有的slave都掉线了</span></span><br><span class="line">        <span class="keyword">if</span> (server.rdb_pipe_numconns_writing || stillAlive == <span class="number">0</span>) &#123;</span><br><span class="line">            aeDeleteFileEvent(server.el, server.rdb_pipe_read, AE_READABLE);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rdbPipeWriteHandler"><a href="#rdbPipeWriteHandler" class="headerlink" title="rdbPipeWriteHandler"></a>rdbPipeWriteHandler</h4><p><code>rdbPipeWriteHandler</code>函数，是将 <code>rdbPipeReadHandler</code> 函数中<code>server.rdb_pipe_buff</code>里的剩余数发送给没有接受到 <code>server.rdb_pipe_bufflen</code> 个字节的slave。因此，当<code>conn</code>上可写事件触发，就将剩余数据发送给slave。</p>
<ul>
<li>如果此次仍然没有将<code>server.rdb_pipe_buff</code>里的剩余数据发送完，则直接return，等待下次可写事件触发</li>
<li>如果此次将<code>server.rdb_pipe_buff</code>里的剩余数据全部发送至slave，那么取消<code>conn</code>上的可写事件，并且<code>server.rdb_pipe_numconns_writing--</code></li>
<li>如果<code>server.rdb_pipe_numconns_writing ==0</code>，那么就可以重新开启<code>server.rdb_pipe_read</code>上的可读事件，从子进程继续读取rdb数据</li>
</ul>
<p>上述最后一个部分是在内部调用<code>rdbPipeWriteHandlerConnRemoved</code>函数完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdbPipeWriteHandler</span><span class="params">(struct connection *conn)</span> </span>&#123;</span><br><span class="line">    serverAssert(server.rdb_pipe_bufflen&gt;<span class="number">0</span>);</span><br><span class="line">    client *slave = connGetPrivateData(conn);</span><br><span class="line">    <span class="keyword">int</span> nwritten;</span><br><span class="line">    <span class="keyword">if</span> ((nwritten = connWrite(conn, </span><br><span class="line">                              server.rdb_pipe_buff + slave-&gt;repldboff,</span><br><span class="line">                              server.rdb_pipe_bufflen - slave-&gt;repldboff)) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;  </span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">&quot;Write error sending DB to replica: %s&quot;</span>,</span><br><span class="line">                    connGetLastError(conn));</span><br><span class="line">            freeClient(slave);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 发送成功 </span></span><br><span class="line">    slave-&gt;repldboff += nwritten;</span><br><span class="line">    server.stat_net_output_bytes += nwritten;</span><br><span class="line">    <span class="comment">// 如果待发送数据没有发送完，则等待下次可写事件的触发</span></span><br><span class="line">    <span class="keyword">if</span> (slave-&gt;repldboff &lt; server.rdb_pipe_bufflen)</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// slave-&gt;repldboff &gt;= server.rdb_pipe_bufflen</span></span><br><span class="line">    <span class="comment">// 表示数据发送完毕，则需要取消注册可写事件</span></span><br><span class="line">    rdbPipeWriteHandlerConnRemoved(conn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="rdbPipeWriteHandlerConnRemoved"><a href="#rdbPipeWriteHandlerConnRemoved" class="headerlink" title="rdbPipeWriteHandlerConnRemoved"></a>rdbPipeWriteHandlerConnRemoved</h4><p>如果主服务器master已经将<code>server.rdb_pipe_buff</code>中的数据全部发送至<code>server.rdb_pipe_conns</code>中的每一个没有掉线的slave，那么将为<code>server.rdb_pipe_read</code>重新注册可读事件，等待子进程的rdb数据到来，再次进入<code>rdbPipeReadHandler</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rdbPipeWriteHandlerConnRemoved</span><span class="params">(struct connection *conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!connHasWriteHandler(conn))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 取消注册可写事件</span></span><br><span class="line">    connSetWriteHandler(conn, <span class="literal">NULL</span>);</span><br><span class="line">    server.rdb_pipe_numconns_writing--;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 当 server.rdb_pipe_numconns_writing ==0</span></span><br><span class="line">    <span class="comment">// 说明所有的conn的数据都发送完毕，</span></span><br><span class="line">    <span class="comment">// 那么就需要重新开启可读事件，从子进程继续读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_pipe_numconns_writing == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el, </span><br><span class="line">                              server.rdb_pipe_read, </span><br><span class="line">                              AE_READABLE, </span><br><span class="line">                              rdbPipeReadHandler,<span class="literal">NULL</span>) == AE_ERR) </span><br><span class="line">        &#123;</span><br><span class="line">            serverPanic(<span class="string">&quot;Unrecoverable error creating server.rdb_pipe_read file event.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="backgroundSaveDoneHandler"><a href="#backgroundSaveDoneHandler" class="headerlink" title="backgroundSaveDoneHandler"></a>backgroundSaveDoneHandler</h4><p>运行到<code>backgroundSaveDoneHandler</code>函数，说明子进程已经结束。那么到此，对于完全重同步任务，master已完成三步：</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 向所有处于<code>SLAVE_STATE_WAIT_BGSAVE_START</code>状态的slave发送了 <font color=blue><code>+FULLRESYNC server.replid offset\r\n</code></font></li>
<li><input checked="" disabled="" type="checkbox"> 在<code>rdbSaveToSlavesSockets</code>函数 or <code>rdbSaveBackground</code>函数中，已经完全生成同步所需的rdb数据</li>
<li><input checked="" disabled="" type="checkbox"> dickless传输方式下，当子进程已经结束，master的数据也已完全同步至slaves</li>
<li><input disabled="" type="checkbox"> 不是dickless方式，还需要从<code>server.rdb_filename</code>读取数据再完全进行同步至slave</li>
<li><input disabled="" type="checkbox"> 将完成主从同步的slaves状态都设置为<font color=blue><code>SLAVE_STATE_ONLINE</code></font></li>
</ul>
<p>最后两个任务，<code>backgroundSaveDoneHandler</code> 函数是通过调用 <code>updateSlavesWaitingBgsave</code> 函数来完成的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backgroundSaveDoneHandler</span><span class="params">(<span class="keyword">int</span> exitcode, <span class="keyword">int</span> bysignal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(server.rdb_child_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> RDB_CHILD_TYPE_DISK:</span><br><span class="line">        backgroundSaveDoneHandlerDisk(exitcode,bysignal);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> RDB_CHILD_TYPE_SOCKET:</span><br><span class="line">        backgroundSaveDoneHandlerSocket(exitcode,bysignal);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        serverPanic(<span class="string">&quot;Unknown RDB child type.&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="updateSlavesWaitingBgsave"><a href="#updateSlavesWaitingBgsave" class="headerlink" title="updateSlavesWaitingBgsave"></a>updateSlavesWaitingBgsave</h4><p><code>updateSlavesWaitingBgsave</code>中处理slave对象不仅仅只有 <code>server.rdb_pipe_conns</code>中，而是当前<code>server.slaves</code>。</p>
<p>此时<code>serer.slaves</code>中可能有部分slaves处于<code>SLAVE_STATE_WAIT_BGSAVE_START</code>状态，等待开启BGSAVE，因此这部分slaves的处理和之前类似：1）获取他们的能力交集；2）调用 <code>startBgsaveForReplication(mincapa)</code>函数，来开启完全重同步过程。</p>
<p>状态是<code>SLAVE_STATE_WAIT_BGSAVE_END</code>的slave，则是从上面运行至此。对于这些slave，<code>updateSlavesWaitingBgsave</code>函数需要完成剩余的两个任务：</p>
<ul>
<li><input disabled="" type="checkbox"> 不是dickless方式，从<code>server.rdb_filename</code>读取数据完全重同步至slaves</li>
<li><input disabled="" type="checkbox"> 传输完毕，需要将slaves的状态设置为 <font color=blue><code>SLAVE_STATE_ONLINE</code></font></li>
</ul>
<p>在 <code>RDB_CHILD_TYPE_DISK</code>类型下，将slave的状态修改为<font color=blue><code>SLAVE_STATE_SEND_BULK</code></font>，在回调函数<code>sendBulkToSlave</code>完成数据发送，再将slave状态修改为<font color=blue><code>SLAVE_STATE_ONLINE</code></font>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateSlavesWaitingBgsave</span><span class="params">(<span class="keyword">int</span> bgsaveerr, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    <span class="keyword">int</span> startbgsave = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mincapa     = <span class="number">-1</span>;</span><br><span class="line">    listIter li;</span><br><span class="line"></span><br><span class="line">    listRewind(server.slaves, &amp;li);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *slave = ln-&gt;value;</span><br><span class="line">		<span class="comment">// 等待开启BGSAVE的 slave 处理方式</span></span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">            startbgsave = <span class="number">1</span>;</span><br><span class="line">            mincapa = (mincapa == <span class="number">-1</span>) ? slave-&gt;slave_capa : (mincapa &amp; slave-&gt;slave_capa);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// other</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) &#123;</span><br><span class="line">            struct redis_stat buf;</span><br><span class="line">            <span class="comment">// RDB_CHILD_TYPE_SOCKET 类型，已经同步完数据</span></span><br><span class="line">            <span class="comment">// 需要将slave状态设置为 SLAVE_STATE_ONLINE</span></span><br><span class="line">            <span class="keyword">if</span> (type == RDB_CHILD_TYPE_SOCKET) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                          <span class="string">&quot;Streamed RDB transfer with replica %s succeeded (socket).&quot;</span></span><br><span class="line">                          <span class="string">&quot;Waiting for REPLCONF ACK from slave to enable streaming&quot;</span>,</span><br><span class="line">                          replicationGetSlaveName(slave));</span><br><span class="line"></span><br><span class="line">                slave-&gt;replstate = SLAVE_STATE_ONLINE;</span><br><span class="line">                slave-&gt;repl_put_online_on_ack = <span class="number">1</span>;</span><br><span class="line">                slave-&gt;repl_ack_time = server.unixtime; <span class="comment">// 心跳检测</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// RDB_CHILD_TYPE_DISK 类型</span></span><br><span class="line">                <span class="comment">// 需要判断子进程是否正常退出，正常退出的才有完整的rdb文件</span></span><br><span class="line">                <span class="keyword">if</span> (bgsaveerr != C_OK) &#123;</span><br><span class="line">                    freeClient(slave);</span><br><span class="line">                    serverLog(LL_WARNING,</span><br><span class="line">                              <span class="string">&quot;SYNC failed. BGSAVE child returned an error&quot;</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 打开rdb文件 </span></span><br><span class="line">                <span class="keyword">if</span> ((slave-&gt;repldbfd = open(server.rdb_filename, O_RDONLY)) == <span class="number">-1</span> || </span><br><span class="line">                    redis_fstat(slave-&gt;repldbfd,&amp;buf) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    freeClient(slave);</span><br><span class="line">                    serverLog(LL_WARNING,</span><br><span class="line">                              <span class="string">&quot;SYNC failed. Can&#x27;t open/stat DB after BGSAVE: %s&quot;</span>, </span><br><span class="line">                              strerror(errno));</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                slave-&gt;repldboff = <span class="number">0</span>;					    <span class="comment">// rdb文件已发送数据字节数</span></span><br><span class="line">                slave-&gt;repldbsize = buf.st_size;			<span class="comment">// rdb文件大小</span></span><br><span class="line">                slave-&gt;replstate = SLAVE_STATE_SEND_BULK;	 <span class="comment">// 发送数据状态</span></span><br><span class="line">                <span class="comment">// 发送文件前，先告诉slave文件大小</span></span><br><span class="line">                <span class="comment">// 格式：$&lt; slave-&gt;repldbsize&gt;\r\n</span></span><br><span class="line">                slave-&gt;replpreamble = sdscatprintf(sdsempty(),</span><br><span class="line">                                                   <span class="string">&quot;$%lld\r\n&quot;</span>,</span><br><span class="line">                                                   (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) slave-&gt;repldbsize);</span><br><span class="line">                <span class="comment">// 先取消注册可写事件？？？</span></span><br><span class="line">                connSetWriteHandler(slave-&gt;conn,<span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 注册可写事件，将rdb文件中的数据发送至slave</span></span><br><span class="line">                <span class="keyword">if</span> (connSetWriteHandler(slave-&gt;conn,sendBulkToSlave) == C_ERR) &#123;</span><br><span class="line">                    freeClient(slave);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (startbgsave) startBgsaveForReplication(mincapa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="sendBulkToSlave"><a href="#sendBulkToSlave" class="headerlink" title="sendBulkToSlave"></a>sendBulkToSlave</h4><p>将<code>server.rdb_filename</code>中的数据发送至slave，分为四个部分：</p>
<ul>
<li><code>slave-&gt;replpreamble ==1?</code> ，是则先告诉slave即将要发送的rdb文件大小 <code>slave-&gt;repldbsize</code></li>
<li>从rdb文件<code>slave-&gt;repldbfd</code>中读取数据至<code>buf</code>，</li>
<li>将<code>buf</code>数据发送至slave</li>
<li>如果rdb文件中的数据发送完毕，则取消注册可写事件、关闭<code>slave-&gt;repldbfd</code>，以及将slave状态修改为<font color=blue><code>SLAVE_STATE_ONLINE</code></font></li>
</ul>
<p>细节可见源码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendBulkToSlave</span><span class="params">(connection *conn)</span> </span>&#123;</span><br><span class="line">    client *slave = connGetPrivateData(conn);</span><br><span class="line">    <span class="keyword">char</span> buf[PROTO_IOBUF_LEN];</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten, buflen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0) 发送文件前，先告诉slave文件大小</span></span><br><span class="line">    <span class="keyword">if</span> (slave-&gt;replpreamble) &#123;</span><br><span class="line">        nwritten = connWrite(conn,slave-&gt;replpreamble,sdslen(slave-&gt;replpreamble));</span><br><span class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            serverLog(LL_VERBOSE,</span><br><span class="line">                      <span class="string">&quot;Write error sending RDB preamble to replica: %s&quot;</span>,</span><br><span class="line">                      connGetLastError(conn));</span><br><span class="line">            freeClient(slave);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        server.stat_net_output_bytes += nwritten;</span><br><span class="line">        <span class="comment">// 裁剪 slave-&gt;replpreamble，为下次写准备</span></span><br><span class="line">        sdsrange(slave-&gt;replpreamble,nwritten,<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 如果 slave-&gt;replpreamble 中数据没有发送完毕</span></span><br><span class="line">        <span class="comment">// 直接返回，等待下次可写事件发送</span></span><br><span class="line">        <span class="keyword">if</span> (sdslen(slave-&gt;replpreamble) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        sdsfree(slave-&gt;replpreamble);</span><br><span class="line">        slave-&gt;replpreamble = <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="comment">//  if (slave-&gt;replpreamble) --end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下面开始发送正文数据</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1) 继续rdb文件读取未发送数据，读取位置是从文件开始偏移 slave-&gt;repldboff 个字节</span></span><br><span class="line">    lseek(slave-&gt;repldbfd,slave-&gt;repldboff,SEEK_SET);</span><br><span class="line">    buflen = read(slave-&gt;repldbfd,buf,PROTO_IOBUF_LEN);</span><br><span class="line">    <span class="keyword">if</span> (buflen &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">&quot;Read error sending DB to replica: %s&quot;</span>,</span><br><span class="line">                  (buflen == <span class="number">0</span>) ? <span class="string">&quot;premature EOF&quot;</span> : strerror(errno));</span><br><span class="line">        freeClient(slave);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 2) 将从rdb读取到的数据 buf，发送至slave</span></span><br><span class="line">    <span class="keyword">if</span> ((nwritten = connWrite(conn,buf,buflen)) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (connGetState(conn) != CONN_STATE_CONNECTED) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                      <span class="string">&quot;Write error sending DB to replica: %s&quot;</span>,</span><br><span class="line">                      connGetLastError(conn));</span><br><span class="line">            freeClient(slave);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 3) 是否发送完文件数据</span></span><br><span class="line">    slave-&gt;repldboff += nwritten;  	 		<span class="comment">// 更新已发给slave的字节数</span></span><br><span class="line">    server.stat_net_output_bytes += nwritten;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果整个rdb数据发送完毕，取消注册可写事件、关闭 slave-&gt;repldbfd </span></span><br><span class="line">    <span class="comment">// 并且要把！！！slave状态设置为 SLAVE_STATE_ONLINE</span></span><br><span class="line">    <span class="keyword">if</span> (slave-&gt;repldboff == slave-&gt;repldbsize) &#123;</span><br><span class="line">        close(slave-&gt;repldbfd);</span><br><span class="line">        slave-&gt;repldbfd = <span class="number">-1</span>;</span><br><span class="line">        connSetWriteHandler(slave-&gt;conn,<span class="literal">NULL</span>);</span><br><span class="line">        putSlaveOnline(slave);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="putSlaveOnline"><a href="#putSlaveOnline" class="headerlink" title="putSlaveOnline"></a>putSlaveOnline</h4><p>将slave状态设置为 <font color=blue><code>SLAVE_STATE_ONLINE</code></font>，表示与slave的完全重同步完成了。</p>
<p>为slave注册可写事件。以后master与slave的数据交互应该就是传播了，即当master的客户端对master执行了写指令<code>writeCmd</code>，导致master的<code>server.dirty++</code>，那么就需要将<code>writeCmd</code>及其参数传播到salve，使得slave与master仍然具有一致性。此时这个写回调函数就应该是<a href="">剖析REDIS的输出缓冲区</a>中讲解的 <code>sendReplyToClient</code>，这样可以让slave像接受到普通客户端的指令一样去解析并执行这条写命令<code>writeCmd</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putSlaveOnline</span><span class="params">(client *slave)</span> </span>&#123;</span><br><span class="line">    slave-&gt;replstate = SLAVE_STATE_ONLINE;</span><br><span class="line">    slave-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line">    slave-&gt;repl_ack_time = server.unixtime;     <span class="comment">// 心跳检测</span></span><br><span class="line">    <span class="comment">// 注册新写回调函数</span></span><br><span class="line">    <span class="keyword">if</span> (connSetWriteHandler(slave-&gt;conn, sendReplyToClient) == C_ERR) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">                  <span class="string">&quot;Unable to register writable event for replica bulk transfer: %s&quot;</span>,</span><br><span class="line">                  strerror(errno));</span><br><span class="line">        freeClient(slave);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新有效从服务器个数</span></span><br><span class="line">    refreshGoodSlavesCount();</span><br><span class="line">    <span class="comment">/* Fire the replica change modules event. */</span></span><br><span class="line">    moduleFireServerEvent(REDISMODULE_EVENT_REPLICA_CHANGE,</span><br><span class="line">                          REDISMODULE_SUBEVENT_REPLICA_CHANGE_ONLINE,</span><br><span class="line">                          <span class="literal">NULL</span>);</span><br><span class="line">    serverLog(LL_NOTICE,</span><br><span class="line">              <span class="string">&quot;Synchronization with replica %s succeeded&quot;</span>,</span><br><span class="line">              replicationGetSlaveName(slave));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="propagate"><a href="#propagate" class="headerlink" title="propagate"></a>propagate</h3><p>上面详细讲解了slave向master发送PSYNC请求的过程，初步使得主从一致，继续维持这个一致性就需要靠<code>propagate</code>。</p>
<p>每次调用<code>call()</code>函数都会判断当前指令<code>c-&gt;cmd</code>是否对服务器键产生修改，即<code>server.dirty !=0</code>，那么就会调用<code>propagate</code>函数，将<code>c-&gt;cmd</code>及其参数传播到slaves。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"> 	<span class="comment">/* Propagate the command into the AOF and replication link */</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; CMD_CALL_PROPAGATE &amp;&amp; (c-&gt;flags &amp; CLIENT_PREVENT_PROP) != CLIENT_PREVENT_PROP) &#123;</span><br><span class="line">        <span class="keyword">int</span> propagate_flags = PROPAGATE_NONE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只要这个命令对数据库产生修改，就需要AOF持久化 以及复制行为</span></span><br><span class="line">        <span class="keyword">if</span> (dirty) propagate_flags |= (PROPAGATE_AOF|PROPAGATE_REPL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了强制传播，那么不论 server.dirty 是否改变，</span></span><br><span class="line">        <span class="comment">// 都会将call调用的指令传播到所有的 slaves</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_REPL) propagate_flags |= PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_FORCE_AOF)  propagate_flags |= PROPAGATE_AOF;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 但是如果调用 preventCommandPropagation() 函数来阻止传播</span></span><br><span class="line">        <span class="comment">// 则需要去掉标志位</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_REPL_PROP || !(flags &amp; CMD_CALL_PROPAGATE_REPL))</span><br><span class="line">            propagate_flags &amp;= ~PROPAGATE_REPL;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_PREVENT_AOF_PROP  || !(flags &amp; CMD_CALL_PROPAGATE_AOF))</span><br><span class="line">            propagate_flags &amp;= ~PROPAGATE_AOF;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 传播!!!</span></span><br><span class="line">        <span class="keyword">if</span> (propagate_flags != PROPAGATE_NONE &amp;&amp; !(c-&gt;cmd-&gt;flags &amp; CMD_MODULE))</span><br><span class="line">            propagate(c-&gt;cmd,c-&gt;db-&gt;id,c-&gt;argv,c-&gt;argc,propagate_flags);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在<code>propagate</code>函数中，调用<code>replicationFeedSlaves</code>函数将当前指令及其参数<code>argv</code>传递给所有的<code>server.slaves</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagate</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dbid, robj **argv, <span class="keyword">int</span> argc, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF &amp;&amp; flags &amp; PROPAGATE_AOF)</span><br><span class="line">        feedAppendOnlyFile(cmd,dbid,argv,argc);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; PROPAGATE_REPL)</span><br><span class="line">        replicationFeedSlaves(server.slaves, dbid, argv, argc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="replicationFeedSlaves"><a href="#replicationFeedSlaves" class="headerlink" title="replicationFeedSlaves"></a>replicationFeedSlaves</h4><p><code>replicationFeedSlaves</code>函数，只能被最顶级的master调用。如果一个slave也有sub-slave要实现这样的功能需要调用<code>replicationFeedSlavesFromMasterStream</code>函数，原因见上文分析。整个过程也是类似：</p>
<ul>
<li>如果<code>dictId</code>和上次执行写入的指令所在的<code>server.slaveseldb</code>不一致，则需要将<code>SELECT dictid</code>以rdb格式序列化后写入<code>server.repl_backlog</code>和所有的slaves</li>
<li>将导致<code>server.diry++</code>的指令及其参数分别写入<code>server.repl_backlog</code>和所有的<code>slaves</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationFeedSlaves</span><span class="params">(<span class="built_in">list</span> *slaves, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    listIter li;</span><br><span class="line">    <span class="keyword">int</span> j, len;</span><br><span class="line">    <span class="keyword">char</span> llstr[LONG_STR_SIZE];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不是最顶层的master,则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If there aren&#x27;t slaves, and there is no backlog buffer to populate,</span></span><br><span class="line"><span class="comment">     * we can return ASAP. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_backlog == <span class="literal">NULL</span> &amp;&amp; listLength(slaves) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    serverAssert(!(listLength(slaves) != <span class="number">0</span> &amp;&amp; server.repl_backlog == <span class="literal">NULL</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 不等，则需要先将 SELECT dictid 序列化成rdb格式字符串</span></span><br><span class="line">    <span class="comment">// 1 先发送到 server.repl_backlog 中</span></span><br><span class="line">    <span class="comment">// 2 再发送给所有的 slaves</span></span><br><span class="line">    <span class="keyword">if</span> (server.slaveseldb != dictid) &#123;</span><br><span class="line">        robj *selectcmd;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> &lt;= dictid  &amp;&amp; dictid &lt; PROTO_SHARED_SELECT_CMDS) &#123;</span><br><span class="line">            selectcmd = shared.select[dictid];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> dictid_len;</span><br><span class="line">            <span class="comment">// 序列化 SELECT dictid</span></span><br><span class="line">            dictid_len = ll2string(llstr, <span class="keyword">sizeof</span>(llstr), dictid);</span><br><span class="line">            selectcmd = createObject(OBJ_STRING,</span><br><span class="line">                                     sdscatprintf(sdsempty(),</span><br><span class="line">                                     <span class="string">&quot;*2\r\n$6\r\nSELECT\r\n$%d\r\n%s\r\n&quot;</span>,</span><br><span class="line">                                     dictid_len, </span><br><span class="line">                                     llstr));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将selectcmd添加到复制缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (server.repl_backlog) </span><br><span class="line">            feedReplicationBacklogWithObject(selectcmd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再发送给所有的slaves</span></span><br><span class="line">        listRewind(slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            addReply(slave,selectcmd);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dictid &lt; <span class="number">0</span> || dictid &gt;= PROTO_SHARED_SELECT_CMDS)</span><br><span class="line">            decrRefCount(selectcmd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.slaveseldb = dictid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the command to the replication backlog if any. */</span></span><br><span class="line">    <span class="comment">// 将写指令添加到 sever.repl_backlog</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_backlog) &#123;</span><br><span class="line">        <span class="keyword">char</span> aux[LONG_STR_SIZE+<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// *&lt;argc&gt;\r\n</span></span><br><span class="line">        aux[<span class="number">0</span>] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">        len = ll2string(aux+<span class="number">1</span>,<span class="keyword">sizeof</span>(aux)<span class="number">-1</span>,argc);</span><br><span class="line">        aux[len+<span class="number">1</span>] = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">        aux[len+<span class="number">2</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        feedReplicationBacklog(aux,len+<span class="number">3</span>);</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// $&lt;len&gt;\r\n&lt;argv[j]\r\n，</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">            <span class="keyword">long</span> objlen = stringObjectLen(argv[j]);</span><br><span class="line"></span><br><span class="line">  			<span class="comment">//aux : $len\r\n</span></span><br><span class="line">            aux[<span class="number">0</span>] = <span class="string">&#x27;$&#x27;</span>;</span><br><span class="line">            len = ll2string(aux+<span class="number">1</span>,<span class="keyword">sizeof</span>(aux)<span class="number">-1</span>,objlen);</span><br><span class="line">            aux[len+<span class="number">1</span>] = <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">            aux[len+<span class="number">2</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">            feedReplicationBacklog(aux,len+<span class="number">3</span>);</span><br><span class="line">            feedReplicationBacklogWithObject(argv[j]);</span><br><span class="line">            feedReplicationBacklog(aux+len+<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再将写写指令发送给slaves</span></span><br><span class="line">    <span class="comment">/* Write the command to every slave. */</span></span><br><span class="line">    listRewind(slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *slave = ln-&gt;value;</span><br><span class="line">		<span class="comment">// 连接好的客户端状态都是 ONLINE</span></span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// *&lt;argc&gt;\r\n</span></span><br><span class="line">        addReplyArrayLen(slave,argc);</span><br><span class="line">	   <span class="comment">// 将每个参数都序列化: $&lt;len&gt;\r\n&lt;argv[j]\r\n，</span></span><br><span class="line">       <span class="comment">// 发送给slave</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++)</span><br><span class="line">            addReplyBulk(slave,argv[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="replicationCron"><a href="#replicationCron" class="headerlink" title="replicationCron"></a>replicationCron</h3><p><code>replicationCron</code>函数是个定时触发的函数，除去上述已提到的功能外，主要就是检测超时。</p>
<p>1）检测slave与master在建立连接的过程是否超时</p>
<p>REDIS的超时时间<code>server.repl_timeout</code>默认是60s，每个slave都有个<code>server.repl_transfer_lastio</code>字段，记录着最近一次读取master数据的时间。在slave与master建立连接的过程中，会记录更新每个状态<code>server.repl_state</code>是否超时。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">    <span class="comment">// (server.repl_state == REPL_STATE_CONNECTING || slaveIsInHandshakeState()) &amp;&amp; 校验是否超时</span></span><br><span class="line">    <span class="comment">// server.repl_state == REPL_STATE_TRANSFER &amp;&amp;	// 完全重同步超时</span></span><br><span class="line">    (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2）超时连接</p>
<p>当主从已经建立好连接，slave的状态是 <code>REPL_STATE_CONNECTED</code>。那么之后slave会在<code>replicationCron</code>函数中检测与master的连接是否超时。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; </span><br><span class="line">    server.repl_state == REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">    (time(<span class="literal">NULL</span>)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)</span><br><span class="line">&#123;</span><br><span class="line">    serverLog(LL_WARNING,<span class="string">&quot;MASTER timeout: no data nor PING received...&quot;</span>);</span><br><span class="line">    freeClient(server.master);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接是否超时，基于<code>server.master-&gt;lastinteraction</code>字段判断，而这个字段更新有两处：</p>
<ul>
<li><p><code>writeToClient</code>：即 slave向master发送数据会更新</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeToClient</span><span class="params">(client *c, <span class="keyword">int</span> handler_installed)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (totwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MASTER)) c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><code>readQueryFromClient</code>：即 slave接受到master的数据也会更新</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(connection *conn)</span> </span>&#123; </span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    c-&gt;lastinteraction = server.unixtime; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>为了维持主从连接，主服务器会在<code>replicationCron</code>函数中定时向所有的slave发送<code>PING</code>，来让从服务器slave更新<code>server.master-&gt;lastinteraction</code>字段。其中<code>server.repl_ping_slave_period</code>默认值是10，大概每10ms发送一次。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((replication_cron_loops % server.repl_ping_slave_period) == <span class="number">0</span> &amp;&amp; listLength(server.slaves)) &#123;</span><br><span class="line">    <span class="comment">// 不是集群模式，就会发送PING</span></span><br><span class="line">    <span class="keyword">int</span> manual_failover_in_progress = server.cluster_enabled &amp;&amp;</span><br><span class="line">                                      server.cluster-&gt;mf_end &amp;&amp;</span><br><span class="line">                                      clientsArePaused();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!manual_failover_in_progress) &#123;</span><br><span class="line">        ping_argv[<span class="number">0</span>] = createStringObject(<span class="string">&quot;PING&quot;</span>, <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 PING 发送给从服务器</span></span><br><span class="line">        replicationFeedSlaves(server.slaves, server.slaveseldb, ping_argv, <span class="number">1</span>);</span><br><span class="line">        decrRefCount(ping_argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3）心跳检测<br>而slave也会定时向主服务器发送 <code>REPLCONF ACK offset</code>指令，主要目的：</p>
<pre><code>+ 告诉主服务器自己当前的复制偏移量；
+ 心跳检测，告诉master自己还活着</code></pre>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (server.masterhost &amp;&amp; </span><br><span class="line">    server.master     &amp;&amp; </span><br><span class="line">    !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</span><br><span class="line">&#123;</span><br><span class="line">    replicationSendAck();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向master发送: REPLCONF ACK reploff</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationSendAck</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    client *c = server.master;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        c-&gt;flags |= CLIENT_MASTER_FORCE_REPLY; <span class="comment">// CLIENT_MASTER_FORCE_REPLY 表示有数据待发送给 master</span></span><br><span class="line">        addReplyArrayLen(c,<span class="number">3</span>);</span><br><span class="line">        addReplyBulkCString(c,<span class="string">&quot;REPLCONF&quot;</span>);</span><br><span class="line">        addReplyBulkCString(c,<span class="string">&quot;ACK&quot;</span>);</span><br><span class="line">        addReplyBulkLongLong(c,c-&gt;reploff);</span><br><span class="line">        c-&gt;flags &amp;= ~CLIENT_MASTER_FORCE_REPLY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>slave-&gt;repl_ack_time</code>字段，主服务器就可以判断从服务器中是否有slave超时连接，有则调用<code>freeClient(slave)</code>关闭连接。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Disconnect timedout slaves. */</span></span><br><span class="line"><span class="keyword">if</span> (listLength(server.slaves)) &#123;</span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    listRewind(server.slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;replstate != SLAVE_STATE_ONLINE) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (slave-&gt;flags &amp; CLIENT_PRE_PSYNC) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 超时，则关闭与从服务器的链接</span></span><br><span class="line">        <span class="keyword">if</span> ((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout) &#123;</span><br><span class="line">            serverLog(LL_WARNING, </span><br><span class="line">                      <span class="string">&quot;Disconnecting timedout replica: %s&quot;</span>,</span><br><span class="line">                      replicationGetSlaveName(slave));</span><br><span class="line">            freeClient(slave);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#SYNC"><span class="toc-number">1.</span> <span class="toc-text">SYNC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#feedReplicationBacklog"><span class="toc-number">1.0.1.</span> <span class="toc-text">feedReplicationBacklog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#addReplyReplicationBacklog"><span class="toc-number">1.0.2.</span> <span class="toc-text">addReplyReplicationBacklog</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replicaofCommand"><span class="toc-number">1.1.</span> <span class="toc-text">replicaofCommand</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SLAVEOF-IP-PORT"><span class="toc-number">1.2.</span> <span class="toc-text">SLAVEOF IP PORT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationSetMaster"><span class="toc-number">1.2.1.</span> <span class="toc-text">replicationSetMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationDiscardCachedMaster"><span class="toc-number">1.2.2.</span> <span class="toc-text">replicationDiscardCachedMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationCacheMasterUsingMyself"><span class="toc-number">1.2.3.</span> <span class="toc-text">replicationCacheMasterUsingMyself</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationCreateMasterClient"><span class="toc-number">1.2.4.</span> <span class="toc-text">replicationCreateMasterClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#connectWithMaster"><span class="toc-number">1.2.5.</span> <span class="toc-text">connectWithMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#syncWithMaster"><span class="toc-number">1.2.6.</span> <span class="toc-text">syncWithMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#slaveTryPartialResynchronization"><span class="toc-number">1.2.7.</span> <span class="toc-text">slaveTryPartialResynchronization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationResurrectCachedMaster"><span class="toc-number">1.2.8.</span> <span class="toc-text">replicationResurrectCachedMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PYSNC-CONTINUE"><span class="toc-number">1.2.9.</span> <span class="toc-text">PYSNC_CONTINUE</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#commandProcessed"><span class="toc-number">1.2.10.</span> <span class="toc-text">commandProcessed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationFeedSlavesFromMasterStream"><span class="toc-number">1.2.11.</span> <span class="toc-text">replicationFeedSlavesFromMasterStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PSYNC-FULLRESYNC"><span class="toc-number">1.2.12.</span> <span class="toc-text">PSYNC_FULLRESYNC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readSyncBulkPayload"><span class="toc-number">1.2.13.</span> <span class="toc-text">readSyncBulkPayload</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SLAVEOF-NO-ONE"><span class="toc-number">1.3.</span> <span class="toc-text">SLAVEOF NO ONE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationUnsetMaster"><span class="toc-number">1.3.1.</span> <span class="toc-text">replicationUnsetMaster</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shiftReplicationId"><span class="toc-number">1.3.2.</span> <span class="toc-text">shiftReplicationId</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replconfCommand"><span class="toc-number">1.4.</span> <span class="toc-text">replconfCommand</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#syncCommand-%E2%80%93-Partial"><span class="toc-number">1.4.1.</span> <span class="toc-text">syncCommand – Partial</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#masterTryPartialResynchronization"><span class="toc-number">1.4.2.</span> <span class="toc-text">masterTryPartialResynchronization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#syncCommnad-%E2%80%93-Full"><span class="toc-number">1.4.3.</span> <span class="toc-text">syncCommnad – Full</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#startBgsaveForReplication"><span class="toc-number">1.4.4.</span> <span class="toc-text">startBgsaveForReplication</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbSaveToSlavesSockets"><span class="toc-number">1.4.5.</span> <span class="toc-text">rdbSaveToSlavesSockets</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationSetupSlaveForFullResync"><span class="toc-number">1.4.6.</span> <span class="toc-text">replicationSetupSlaveForFullResync</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbPipeReadHandler"><span class="toc-number">1.4.7.</span> <span class="toc-text">rdbPipeReadHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbPipeWriteHandler"><span class="toc-number">1.4.8.</span> <span class="toc-text">rdbPipeWriteHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rdbPipeWriteHandlerConnRemoved"><span class="toc-number">1.4.9.</span> <span class="toc-text">rdbPipeWriteHandlerConnRemoved</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#backgroundSaveDoneHandler"><span class="toc-number">1.4.10.</span> <span class="toc-text">backgroundSaveDoneHandler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateSlavesWaitingBgsave"><span class="toc-number">1.4.11.</span> <span class="toc-text">updateSlavesWaitingBgsave</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sendBulkToSlave"><span class="toc-number">1.4.12.</span> <span class="toc-text">sendBulkToSlave</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#putSlaveOnline"><span class="toc-number">1.4.13.</span> <span class="toc-text">putSlaveOnline</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#propagate"><span class="toc-number">1.5.</span> <span class="toc-text">propagate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#replicationFeedSlaves"><span class="toc-number">1.5.1.</span> <span class="toc-text">replicationFeedSlaves</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#replicationCron"><span class="toc-number">1.6.</span> <span class="toc-text">replicationCron</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&text=剖析REDIS的replication"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&title=剖析REDIS的replication"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&is_video=false&description=剖析REDIS的replication"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析REDIS的replication&body=Check out this article: https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&title=剖析REDIS的replication"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&title=剖析REDIS的replication"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&title=剖析REDIS的replication"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&title=剖析REDIS的replication"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&name=剖析REDIS的replication&description=&lt;p&gt;为保证主从一致，replication主要实现了两件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同步：将master的数据同步到slaves，此时主从一致&lt;/li&gt;
&lt;li&gt;传播：将导致master的数据库发生改变的操作传播到slaves，使得主从仍旧一致&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/01/29/Redis/%E5%88%86%E5%B8%83%E5%BC%8F/replication/&t=剖析REDIS的replication"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
