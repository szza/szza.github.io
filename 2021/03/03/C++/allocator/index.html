<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本期主要讲解C++ STL中的内存分配器std::allocator及其特性萃取器__gnu_cxx::__alloc_traits。 为防止混淆，规定如下：  allocator：泛指内存分配器，仅仅是一个术语。 std::allocator：是STL实现的内存分配器类std::allocator。  __gnu_cxx::new_allocatorC++的默认的内存分配器std::alloca">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析 STL 内存分配器设计">
<meta property="og:url" content="https://szza.github.io/2021/03/03/C++/allocator/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="本期主要讲解C++ STL中的内存分配器std::allocator及其特性萃取器__gnu_cxx::__alloc_traits。 为防止混淆，规定如下：  allocator：泛指内存分配器，仅仅是一个术语。 std::allocator：是STL实现的内存分配器类std::allocator。  __gnu_cxx::new_allocatorC++的默认的内存分配器std::alloca">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-03-03T01:38:49.000Z">
<meta property="article:modified_time" content="2023-08-26T17:48:00.811Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Modern C++">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>剖析 STL 内存分配器设计</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/03/03/C++/RVO/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/03/01/Path/2/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/03/03/C++/allocator/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/03/03/C++/allocator/&text=剖析 STL 内存分配器设计"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/03/03/C++/allocator/&title=剖析 STL 内存分配器设计"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/03/03/C++/allocator/&is_video=false&description=剖析 STL 内存分配器设计"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析 STL 内存分配器设计&body=Check out this article: https://szza.github.io/2021/03/03/C++/allocator/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/03/03/C++/allocator/&title=剖析 STL 内存分配器设计"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/03/03/C++/allocator/&title=剖析 STL 内存分配器设计"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/03/03/C++/allocator/&title=剖析 STL 内存分配器设计"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/03/03/C++/allocator/&title=剖析 STL 内存分配器设计"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/03/03/C++/allocator/&name=剖析 STL 内存分配器设计&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/03/03/C++/allocator/&t=剖析 STL 内存分配器设计"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#gnu-cxx-new-allocator"><span class="toc-number">1.</span> <span class="toc-text">__gnu_cxx::new_allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#allocate"><span class="toc-number">1.1.</span> <span class="toc-text">allocate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deallocate"><span class="toc-number">1.2.</span> <span class="toc-text">deallocate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#construct"><span class="toc-number">1.3.</span> <span class="toc-text">construct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#destroy"><span class="toc-number">1.4.</span> <span class="toc-text">destroy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-allocator"><span class="toc-number">2.</span> <span class="toc-text">std::allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rebind"><span class="toc-number">2.1.</span> <span class="toc-text">rebind</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-allocator-traits-base"><span class="toc-number">3.</span> <span class="toc-text">std::__allocator_traits_base</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rebind-1"><span class="toc-number">3.1.</span> <span class="toc-text">__rebind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alloc-rebind"><span class="toc-number">3.2.</span> <span class="toc-text">__alloc_rebind</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-allocator-traits"><span class="toc-number">4.</span> <span class="toc-text">std::allocator_traits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gnu-cxx-alloc-traits"><span class="toc-number">5.</span> <span class="toc-text">__gnu_cxx::__alloc_traits</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        剖析 STL 内存分配器设计
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-03-03T01:38:49.000Z" itemprop="datePublished">2021-03-03</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Modern-C/" rel="tag">Modern C++</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>本期主要讲解C++ STL中的内存分配器<code>std::allocator</code>及其特性萃取器<code>__gnu_cxx::__alloc_traits</code>。</p>
<p>为防止混淆，规定如下：</p>
<ul>
<li><code>allocator</code>：泛指内存分配器，仅仅是一个术语。</li>
<li><code>std::allocator</code>：是STL实现的内存分配器类<code>std::allocator</code>。</li>
</ul>
<h3 id="gnu-cxx-new-allocator"><a href="#gnu-cxx-new-allocator" class="headerlink" title="__gnu_cxx::new_allocator"></a>__gnu_cxx::new_allocator</h3><p>C++的默认的内存分配器<code>std::allocator</code>，继承至<code>__gnu_cxx::new_allocator</code>。而 <code>__gnu_cxx::new_allocator</code> 主要完成两个任务：</p>
<ul>
<li>分配对象内存、初始化对象</li>
<li>析构对象、释放对象内存</li>
</ul>
<p><code>__gnu_cxx::new_allocator</code> 是个空类，没有成员变量，主要有四种成员函数完成上述任务：</p>
<ul>
<li><code>allocate</code> 函数，用于分配内存</li>
<li><code>construct</code>函数，调用已分配内存对象的构造函数</li>
<li><code>destroy</code>函数，调用析构函数</li>
<li><code>deallocate</code>函数，用于释放内存</li>
</ul>
<p><code>__gnu_cxx::new_allocator</code>  的整体框架大致如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">new_allocator</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">size_t</span>      size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp*        pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Tp*  const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp &amp;       reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="type">const</span> _Tp &amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp         value_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">rebind</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">typedef</span> new_allocator&lt;_Tp1&gt; other;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">new_allocator</span>() _GLIBCXX_USE_NOEXCEPT &#123;&#125;</span><br><span class="line">  <span class="built_in">new_allocator</span>(<span class="type">const</span> new_allocator &amp;) <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">  <span class="built_in">new_allocator</span>(<span class="type">const</span> new_allocator&lt;_Tp1&gt; &amp;) <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line">  ~<span class="built_in">new_allocator</span>() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type __n, <span class="type">const</span> <span class="type">void</span> * = <span class="keyword">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span> *&gt;(<span class="number">0</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer __p, size_type)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(_Up *__p, _Args &amp;&amp;...__args)</span> </span></span><br><span class="line"><span class="function">    				<span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(::<span class="keyword">new</span> ((<span class="type">void</span> *)__p)_Up(std::forward&lt;_Args&gt;(__args)...)))</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(_Up *__p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(__p-&gt;~_Up()))</span></span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h4><p><code>allocate</code>函数，用于分配大小为<code>__n</code>个字节内存，返回值是分配所得内存的地址。</p>
<ul>
<li>如果待分配内存大小<code>__n</code>大于当前进程最大可用内存，那么就会抛出<code>bad_alloc</code>异常。</li>
<li>再调用<code>operator new</code>来分配内存。<code>operator new</code>对<code>malloc</code>作了一层简单的封装，等效于<code>malloc</code></li>
<li>将指向<code>operator new</code>的返回值类型转换为此次分配对象<code>_Tp</code>的指针类型。</li>
</ul>
<p>整个过程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type __n, <span class="type">const</span> <span class="type">void</span> * = <span class="keyword">static_cast</span>&lt;<span class="type">const</span> <span class="type">void</span> *&gt;(<span class="number">0</span>))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (__n &gt; <span class="keyword">this</span>-&gt;<span class="built_in">max_size</span>())</span><br><span class="line">        std::__throw_bad_alloc();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cpp_aligned_new</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">alignof</span>(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)</span><br><span class="line">      &#123;</span><br><span class="line">        std::<span class="type">align_val_t</span> __al = std::<span class="built_in">align_val_t</span>(<span class="built_in">alignof</span>(_Tp));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp *&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(__n * <span class="built_in">sizeof</span>(_Tp), __al));</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;_Tp *&gt;(::<span class="keyword">operator</span> <span class="built_in">new</span>(__n * <span class="built_in">sizeof</span>(_Tp)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h4><p><code>deallocate</code>函数，使用<code>operator delete</code>来释放地址<code>__p</code>指向的内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(pointer __p, size_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __cpp_aligned_new</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">alignof</span>(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)</span><br><span class="line">      &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(__p, std::<span class="type">align_val_t</span>(<span class="keyword">alignof</span>(_Tp)))</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(__p)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h4><p>上面的<code>allocate</code>函数相当于<code>malloc</code>函数，只是分配<code>__n</code>个字节的内存，但是并未对这片内存进行初始化。对<code>allocate</code> 函数分配的内存<code>__p</code>进行初始化的任务，交给<code>construct</code>函数来完成。</p>
<p><code>constuct</code>函数，使用了<code>new</code>表达式的另一种形式，叫做<code>placement new</code>，使用方式如下注释：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(_Up *__p, _Args &amp;&amp;...__args)</span> </span></span><br><span class="line"><span class="function">  				<span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(::<span class="keyword">new</span> ((<span class="type">void</span> *)__p)_Up(std::forward&lt;_Args&gt;(__args)...)))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 表示在 地址 _p 上调用对象 _Up的构造函数</span></span><br><span class="line">    <span class="comment">// 其中，__args是构造函数的参数</span></span><br><span class="line">    ::<span class="keyword">new</span> ((<span class="type">void</span> *)__p) _Up(std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h4><p><code>deallocate</code>函数，是完成了释放内存，但是在释放内存之前一般需要先调用对象的析构函数，完成相关的资源的释放、关闭操作。因此在<code>destoy</code>函数中，直接调用了类型<code>_Up</code>的析构函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(_Up *__p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(__p-&gt;~_Up()))</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   __p-&gt;~_Up();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h3 id="std-allocator"><a href="#std-allocator" class="headerlink" title="std::allocator"></a>std::allocator</h3><p>类<code>std::allocator</code> 继承<code>__gnu_cxx::new_allocator</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">using</span> __allocator_base = __gnu_cxx::new_allocator&lt;_Tp&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">allocator</span> : <span class="keyword">public</span> __allocator_base&lt;_Tp&gt;</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">size_t</span>      size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">ptrdiff_t</span>   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*        pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> _Tp*  const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;        reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> _Tp&amp;  const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp         value_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rebind</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">typedef</span> allocator&lt;_Tp1&gt; other;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">allocator</span>() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line">    <span class="built_in">allocator</span>(<span class="type">const</span> allocator &amp;__a) <span class="keyword">noexcept</span> : __allocator_base&lt;_Tp&gt;(__a) &#123;&#125;</span><br><span class="line">    allocator &amp;<span class="keyword">operator</span>=(<span class="type">const</span> allocator &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">    <span class="built_in">allocator</span>(<span class="type">const</span> allocator&lt;_Tp1&gt; &amp;) _GLIBCXX_NOTHROW</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">allocator</span>() _GLIBCXX_NOTHROW &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">    <span class="comment">// Inherit everything else.</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="rebind"><a href="#rebind" class="headerlink" title="rebind"></a>rebind</h4><p>在<code>__gnu_cxx::new_allocator</code>、<code>std::allocator</code>中都有一个<code>rebind</code>函数，其主要作用：获得类型<code>_Tp1</code>的内存分配器<code>allocator&lt;_Tp1&gt;</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">rebind</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">typedef</span> allocator&lt;_Tp1&gt; other;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>这个函数在容器中被STL中被广泛使用。比如，在<code>std::list&lt;_Tp, std::allocator&lt;_Tp&gt;&gt;</code>中，<code>std::allocator</code>不仅要为<code>_Tp</code>类型的对象分配内存，还要为存储<code>_Tp</code>对象的节点<code>list_node&lt;_Tp&gt;</code>分配内存。但是<code>std::list&lt;_Tp, std::allocator&lt;_Tp&gt;&gt;</code>的类模板参数中只是传入了用于分配<code>_Tp</code>类型的内存分配器<code>std::allocator&lt;_Tp&gt;</code>，那么怎么获得<code>list_node&lt;_Tp&gt;</code>类型的内存分配器呢？</p>
<p>答案就是依靠<code>rebind</code>函数：<code>allocator&lt;_Tp&gt;::rebind&lt;list_node&lt;_Tp&gt;&gt;::other</code>，获得的就是用于分配<code>list_node&lt;_Tp&gt;</code>类型的内存分配器 <code>allocator&lt;list_node&lt;_Tp&gt;&gt;</code>。</p>
<p>在<code>list</code>中的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">_List_base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 用于分配 _Tp 类型的内存分配器: _Tp_alloc_type</span></span><br><span class="line">  <span class="comment">// _Tp_alloc_type 实际上就是 std::allocator</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::<span class="keyword">template</span> rebind&lt;_Tp&gt;::other _Tp_alloc_type;</span><br><span class="line">  <span class="comment">// 用于分配 List_node&lt;_Tp&gt; 类型的内存分配器：_Node_alloc_type</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Tp_alloc_traits::<span class="keyword">template</span> rebind&lt;_List_node&lt;_Tp&gt; &gt;::other _Node_alloc_type;        </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = std::allocator&lt;_Tp&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> list : <span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _List_node&lt;_Tp&gt;				 _Node;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="std-allocator-traits-base"><a href="#std-allocator-traits-base" class="headerlink" title="std::__allocator_traits_base"></a>std::__allocator_traits_base</h3><p>上面的<code>list</code>中使用到了用于萃取内存分配器属性的类<code>__gnu_cxx::__alloc_traits</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::__alloc_traits 继承自 std::allocator_traits</span><br><span class="line">std::allocator_traits 	  继承自 std::__allocator_traits_base</span><br></pre></td></tr></table></figure>

<p>类<code>__allocator_traits_base</code>，用于获取内存分配器<code>_Alloc</code>的属性，这个分配器<code>_Alloc</code>不一定是上面所述的<code>std::allocator</code>，可以是自定义的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__allocator_traits_base</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,</span><br><span class="line">            <span class="keyword">typename</span> _Up,</span><br><span class="line">            <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line">  <span class="keyword">struct</span> __rebind : __replace_first_arg&lt;_Tp, _Up&gt;</span><br><span class="line">  &#123; &#125;;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// __rebind 特化版本：当分配器 _Tp 有成员函数 rebind 时调用此特化版本</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up&gt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__rebind</span>&lt;_Tp,</span><br><span class="line">                  _Up,</span><br><span class="line">                  <span class="type">__void_t</span>&lt;<span class="keyword">typename</span> _Tp::<span class="keyword">template</span> rebind&lt;_Up&gt;::other&gt;&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> _Tp::<span class="keyword">template</span> rebind&lt;_Up&gt;::other;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __pointer 	= <span class="keyword">typename</span> _Tp::pointer;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __c_pointer 	= <span class="keyword">typename</span> _Tp::const_pointer;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __v_pointer 	= <span class="keyword">typename</span> _Tp::void_pointer;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __cv_pointer 	= <span class="keyword">typename</span> _Tp::const_void_pointer;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __pocca = <span class="keyword">typename</span> _Tp::propagate_on_container_copy_assignment;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __pocma = <span class="keyword">typename</span> _Tp::propagate_on_container_move_assignment;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __pocs  = <span class="keyword">typename</span> _Tp::propagate_on_container_swap;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __equal = <span class="keyword">typename</span> _Tp::is_always_equal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="rebind-1"><a href="#rebind-1" class="headerlink" title="__rebind"></a>__rebind</h4><p>类<code>__allocator_traits_base</code> 中最重要的是成员函数<code>__rebind</code>。 <code>__rebind</code>的模板参数<code>_Tp</code>是分配器类型，根据<code>_Tp</code>来实现重载：</p>
<ul>
<li><p>当传入的内存分配器类型<code>_Tp</code>，实现了<code>rebind</code>成员函数时，比如上面的<code>std::allocator</code>，那么就调用<code>__rebind</code>的特化版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__rebind</span>&lt;_Tp,</span><br><span class="line">                _Up,</span><br><span class="line">                <span class="type">__void_t</span>&lt;<span class="keyword">typename</span> _Tp::<span class="keyword">template</span> rebind&lt;_Up&gt;::other&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> _Tp::<span class="keyword">template</span> rebind&lt;_Up&gt;::other;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>以<code>std::allocator&lt;int&gt;</code>为例，获取<code>Node&lt;int&gt;</code>类型的内存分配器：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__allocator_traits_base::__rebind&lt;std::allocator&lt;<span class="type">int</span>&gt;, Node&lt;<span class="type">int</span>&gt;&gt;::type  </span><br><span class="line"><span class="comment">// 等价于 </span></span><br><span class="line">std::allocator&lt;Node&lt;<span class="type">int</span>&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当传入的分配器<code>_Tp</code>没有实现<code>rebind</code>成员函数时，就调用普通<code>__rebind</code>版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Tp需要是分配器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,</span><br><span class="line">          <span class="keyword">typename</span> _Up,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> __rebind : __replace_first_arg&lt;_Tp, _Up&gt;</span><br><span class="line">&#123; &#125;;  </span><br></pre></td></tr></table></figure>

<p>其中<code>__replace_first_arg</code>实现如下。此时，需要自定义一个内存分配器模板<code>_Template</code>，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__replace_first_arg</span></span><br><span class="line">&#123; &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// _Template 是个类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>...&gt; <span class="keyword">class</span> <span class="title class_">_Template</span>, </span><br><span class="line">          <span class="keyword">typename</span> _Up,</span><br><span class="line">          <span class="keyword">typename</span> _Tp, </span><br><span class="line">          <span class="keyword">typename</span>... _Types&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__replace_first_arg</span>&lt;_Template&lt;_Tp, _Types...&gt;, _Up&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> type = _Template&lt;_Up, _Types...&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>by the way</strong></p>
<p>在此，补充点模板的一点知识：</p>
<ol>
<li><p>模板参数模板</p>
<p>在<code>__replace_first_arg</code>类中，使用了一个类模板参数模板<code>_Template</code>，这表示模板参数<code>_Template</code>本身就是个类模板。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>...&gt; <span class="keyword">class</span> <span class="title class_">_Template</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>::template</code></p>
<p>在<code>__rebind</code>函数体中，在<code>::</code>后面有个<code>template</code>关键字，这是用于告诉编译器 <code>template</code>后面的 <code>&lt;</code> 不是比较符号，而是模板参数符号。就是类似于<code>_Tp</code>前面的<code>typename</code>是告诉编译器<code>::</code>后面的是类成员函数，而不是<code>static</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> _Tp::<span class="keyword">template</span> rebind&lt;_Up&gt;::other;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="alloc-rebind"><a href="#alloc-rebind" class="headerlink" title="__alloc_rebind"></a>__alloc_rebind</h4><p>全局函数<code>__alloc_rebind</code>，是<code>std::__allocator_traits_base</code>的wrapper，用于获取为<code>_Up</code>类型分配内存的内存分配器<code>_Alloc&lt;_Up&gt;</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span> _Up&gt;</span><br><span class="line"><span class="keyword">using</span> __alloc_rebind = <span class="keyword">typename</span> __allocator_traits_base::<span class="keyword">template</span> __rebind&lt;_Alloc, _Up&gt;::type;</span><br></pre></td></tr></table></figure>

<h3 id="std-allocator-traits"><a href="#std-allocator-traits" class="headerlink" title="std::allocator_traits"></a>std::allocator_traits</h3><p>类<code>std::allocator_traits</code>，继承于<code>std::__allocator_traits_base</code>，用于获取内存分配器<code>allocator</code>的各个属性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">allocator_traits</span> : __allocator_traits_base</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">typedef</span> _Alloc allocator_type;					  <span class="comment">/// The allocator type</span></span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::value_type value_type;	  <span class="comment">/// The allocated type</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<p>当<code>_Alloc</code>是<code>std::allocator</code>时，有个特化版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">allocator_traits</span>&lt;allocator&lt;_Tp&gt;&gt;</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">using</span> allocator_type = allocator&lt;_Tp&gt;;  <span class="comment">// 分配器类型</span></span><br><span class="line">   <span class="keyword">using</span> value_type = _Tp;                 <span class="comment">// 待分配内存的对象类型</span></span><br><span class="line">   <span class="keyword">using</span> pointer = _Tp *;                 <span class="comment">// 对象指针</span></span><br><span class="line">   <span class="keyword">using</span> const_pointer = <span class="type">const</span> _Tp *;</span><br><span class="line"><span class="comment">//...  using </span></span><br><span class="line">   <span class="keyword">using</span> is_always_equal = true_type;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用allocator为_Up分配内存</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">   <span class="keyword">using</span> rebind_alloc = allocator&lt;_Up&gt;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">   <span class="keyword">using</span> rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">// 下面是 std::allocator&lt;_Tp&gt; 成员函数的 wrapper</span></span><br><span class="line">   <span class="function"><span class="type">static</span> pointer <span class="title">allocate</span><span class="params">(allocator_type &amp;__a, size_type __n)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> __a.<span class="built_in">allocate</span>(__n);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> pointer <span class="title">allocate</span><span class="params">(allocator_type &amp;__a, size_type __n, const_void_pointer __hint)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> __a.<span class="built_in">allocate</span>(__n, __hint);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">deallocate</span><span class="params">(allocator_type &amp;__a, pointer __p, size_type __n)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     __a.<span class="built_in">deallocate</span>(__p, __n);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">construct</span><span class="params">(allocator_type &amp;__a, _Up *__p, _Args &amp;&amp;...__args)</span> </span></span><br><span class="line"><span class="function">               <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(__a.construct(__p, std::forward&lt;_Args&gt;(__args)...)))</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     __a.<span class="built_in">construct</span>(__p, std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">   <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">destroy</span><span class="params">(allocator_type &amp;__a, _Up *__p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(__a.destroy(__p)))</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     __a.<span class="built_in">destroy</span>(__p);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">static</span> size_type <span class="title">max_size</span><span class="params">(<span class="type">const</span> allocator_type &amp;__a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> __a.<span class="built_in">max_size</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="gnu-cxx-alloc-traits"><a href="#gnu-cxx-alloc-traits" class="headerlink" title="__gnu_cxx::__alloc_traits"></a>__gnu_cxx::__alloc_traits</h3><p><code>__gnu_cxx::__alloc_traits</code>类，也大都是<code>std::allocator_traits</code>的wrapper，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span> = <span class="keyword">typename</span> _Alloc::value_type&gt;</span><br><span class="line"><span class="keyword">struct</span> __alloc_traits : std::allocator_traits&lt;_Alloc&gt; &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _Alloc 								 allocator_type;</span><br><span class="line">    <span class="keyword">typedef</span> std::allocator_traits&lt;_Alloc&gt;        _Base_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::value_type      value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::pointer         pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::const_pointer   const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::size_type       size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::difference_type difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> value_type &amp;      					 reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">const</span> value_type&amp; 					 const_reference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> _Base_type::allocate;</span><br><span class="line">    <span class="keyword">using</span> _Base_type::construct;</span><br><span class="line">    <span class="keyword">using</span> _Base_type::deallocate;</span><br><span class="line">    <span class="keyword">using</span> _Base_type::destroy;</span><br><span class="line">    <span class="keyword">using</span> _Base_type::max_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当 _Ptr 不是个标准指针，但是 _Ptr 和 value_type* 相同</span></span><br><span class="line">    <span class="comment">// __is_custom_pointer 才是 true，即 _Ptr 是个自定义指针</span></span><br><span class="line">    <span class="comment">// 即 _Ptr 可转换为 pointer</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">    <span class="keyword">using</span> __is_custom_pointer </span><br><span class="line">        = std::__and_&lt;std::is_same&lt;pointer, _Ptr&gt;, std::__not_&lt;std::is_pointer&lt;_Ptr&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// overload construct for non-standard pointer types</span></span><br><span class="line">    <span class="comment">// 重载非标准类型的指针，调用构造函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">typename</span> std::enable_if&lt;__is_custom_pointer&lt;_Ptr&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">construct</span><span class="params">(_Alloc &amp;__a, _Ptr __p, _Args &amp;&amp;...__args)</span> <span class="title">noexcept</span><span class="params">(...)</span> <span class="comment">// 省略了noexcept中的表达式</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="comment">// 使用分配器 __a , 在地址 __p 调用构造函数</span></span><br><span class="line">      _Base_type::<span class="built_in">construct</span>(__a, </span><br><span class="line">                            std::__to_address(__p),</span><br><span class="line">                            std::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overload destroy for non-standard pointer types</span></span><br><span class="line">    <span class="comment">// 重载非标准类型指针，调用析构函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">typename</span> std::enable_if&lt;__is_custom_pointer&lt;_Ptr&gt;::value&gt;::<span class="function">type</span></span><br><span class="line"><span class="function">    <span class="title">destroy</span><span class="params">(_Alloc &amp;__a, _Ptr __p)</span> <span class="title">noexcept</span><span class="params">(...)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      _Base_type::<span class="built_in">destroy</span>(__a, std::__to_address(__p));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** 对于标准的指针，会直接调用父类的constuct、destroy ***/</span></span><br><span class="line">	</span><br><span class="line">    <span class="comment">// wrapper</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">rebind</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::<span class="keyword">template</span> rebind_alloc&lt;_Tp&gt; other;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体来说，<code>__gnu_cxx::__alloc_traits</code>提供了一个顶层的内存分配器萃取器，可以使用 <code>_Alloc</code> 的 <code>allocate</code>、 <code>deallocate</code>、<code>construct</code> 以及 <code>destroy </code>等函数来完成对象构造和析构等任务。</p>
<p>而类<code>std::allocator_traits</code> 是底层直接获取内存分配器<code>_Alloc</code>属性的类，其中<code>std::allocator_traits</code>有个特化版本，即使<code>_Alloc</code>是<code>std::allocator</code>，因为<code>std::allocator</code>是STL的容器默认的内存分配器。</p>
<p>如果想将自定义的内存分配器<code>Custome_Alloc</code>融入到STL体系中，那么也需要像<code>std::allocator</code>一样完成相应的接口设计、以及<code>rebind</code>函数。这样，容器就能通过<code>__gnu_cxx::__alloc_traits&lt;Custome_Alloc&gt;</code>使用自定义的内存分配器<code>Custome_Alloc</code>。</p>
<p>好嘞，到此完成了本期的目标，即讲解完毕C++ STL内存分配器的设计。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#gnu-cxx-new-allocator"><span class="toc-number">1.</span> <span class="toc-text">__gnu_cxx::new_allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#allocate"><span class="toc-number">1.1.</span> <span class="toc-text">allocate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#deallocate"><span class="toc-number">1.2.</span> <span class="toc-text">deallocate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#construct"><span class="toc-number">1.3.</span> <span class="toc-text">construct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#destroy"><span class="toc-number">1.4.</span> <span class="toc-text">destroy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-allocator"><span class="toc-number">2.</span> <span class="toc-text">std::allocator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rebind"><span class="toc-number">2.1.</span> <span class="toc-text">rebind</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-allocator-traits-base"><span class="toc-number">3.</span> <span class="toc-text">std::__allocator_traits_base</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rebind-1"><span class="toc-number">3.1.</span> <span class="toc-text">__rebind</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alloc-rebind"><span class="toc-number">3.2.</span> <span class="toc-text">__alloc_rebind</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-allocator-traits"><span class="toc-number">4.</span> <span class="toc-text">std::allocator_traits</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gnu-cxx-alloc-traits"><span class="toc-number">5.</span> <span class="toc-text">__gnu_cxx::__alloc_traits</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/03/03/C++/allocator/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/03/03/C++/allocator/&text=剖析 STL 内存分配器设计"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/03/03/C++/allocator/&title=剖析 STL 内存分配器设计"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/03/03/C++/allocator/&is_video=false&description=剖析 STL 内存分配器设计"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析 STL 内存分配器设计&body=Check out this article: https://szza.github.io/2021/03/03/C++/allocator/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/03/03/C++/allocator/&title=剖析 STL 内存分配器设计"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/03/03/C++/allocator/&title=剖析 STL 内存分配器设计"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/03/03/C++/allocator/&title=剖析 STL 内存分配器设计"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/03/03/C++/allocator/&title=剖析 STL 内存分配器设计"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/03/03/C++/allocator/&name=剖析 STL 内存分配器设计&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/03/03/C++/allocator/&t=剖析 STL 内存分配器设计"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
         
          <li><a href="/about/">About</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
