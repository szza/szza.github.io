<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="BlockBasedTableBuilder::ParallelCompressionRep先来看看BlockBasedTableBuilder中的多线程压缩部分  BlockBasedTableBuilder::ParallelCompressionRep。 以下代码不加说明，都是在类 BlockBasedTableBuilder::ParallelCompressionRep 里面。 Keys">
<meta property="og:type" content="article">
<meta property="og:title" content="BlockBasedTableBuilder 源码分析">
<meta property="og:url" content="https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="BlockBasedTableBuilder::ParallelCompressionRep先来看看BlockBasedTableBuilder中的多线程压缩部分  BlockBasedTableBuilder::ParallelCompressionRep。 以下代码不加说明，都是在类 BlockBasedTableBuilder::ParallelCompressionRep 里面。 Keys">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-11-28T06:15:35.000Z">
<meta property="article:modified_time" content="2023-08-26T17:48:00.000Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="RocksDb">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>BlockBasedTableBuilder 源码分析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2021/12/01/rocksdb/utility/HashTablel/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2021/11/27/rocksdb/Table/builder/3_FilterBlock/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&text=BlockBasedTableBuilder 源码分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&title=BlockBasedTableBuilder 源码分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&is_video=false&description=BlockBasedTableBuilder 源码分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=BlockBasedTableBuilder 源码分析&body=Check out this article: https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&title=BlockBasedTableBuilder 源码分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&title=BlockBasedTableBuilder 源码分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&title=BlockBasedTableBuilder 源码分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&title=BlockBasedTableBuilder 源码分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&name=BlockBasedTableBuilder 源码分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&t=BlockBasedTableBuilder 源码分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockBasedTableBuilder-ParallelCompressionRep"><span class="toc-number">1.</span> <span class="toc-text">BlockBasedTableBuilder::ParallelCompressionRep</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Keys"><span class="toc-number">1.1.</span> <span class="toc-text">Keys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WorkQueue"><span class="toc-number">1.2.</span> <span class="toc-text">WorkQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#push"><span class="toc-number">1.2.1.</span> <span class="toc-text">push</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop"><span class="toc-number">1.2.2.</span> <span class="toc-text">pop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#waitUntilFinished"><span class="toc-number">1.2.3.</span> <span class="toc-text">waitUntilFinished</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finish"><span class="toc-number">1.2.4.</span> <span class="toc-text">finish</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockRepSlot"><span class="toc-number">1.3.</span> <span class="toc-text">BlockRepSlot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileSizeEstimator"><span class="toc-number">1.4.</span> <span class="toc-text">FileSizeEstimator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EmitBlock"><span class="toc-number">1.4.1.</span> <span class="toc-text">EmitBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReapBlock"><span class="toc-number">1.4.2.</span> <span class="toc-text">ReapBlock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParallelCompressionRep"><span class="toc-number">1.5.</span> <span class="toc-text">ParallelCompressionRep</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PrepareBlockInternal"><span class="toc-number">1.5.1.</span> <span class="toc-text">PrepareBlockInternal</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TODO"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">TODO</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PrepareBlock"><span class="toc-number">1.5.2.</span> <span class="toc-text">PrepareBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PrepareBlock-1"><span class="toc-number">1.5.3.</span> <span class="toc-text">PrepareBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EmitBlock-1"><span class="toc-number">1.5.4.</span> <span class="toc-text">EmitBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReapBlock-1"><span class="toc-number">1.5.5.</span> <span class="toc-text">ReapBlock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TODO-1"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">TODO</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockBasedTableBuilder"><span class="toc-number">2.</span> <span class="toc-text">BlockBasedTableBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ParallelCompression"><span class="toc-number">2.1.</span> <span class="toc-text">ParallelCompression</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IsParallelCompressionEnabled"><span class="toc-number">2.1.1.</span> <span class="toc-text">IsParallelCompressionEnabled</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StartParallelCompression"><span class="toc-number">2.1.2.</span> <span class="toc-text">StartParallelCompression</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BGWorkCompression"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">BGWorkCompression</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CompressAndVerifyBlock"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">CompressAndVerifyBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BGWorkWriteRawBlock"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">BGWorkWriteRawBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WriteRawBlock"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">WriteRawBlock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StopParallelCompression"><span class="toc-number">2.1.3.</span> <span class="toc-text">StopParallelCompression</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add"><span class="toc-number">2.2.</span> <span class="toc-text">Add</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#State"><span class="toc-number">2.2.1.</span> <span class="toc-text">State</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#should-flush"><span class="toc-number">2.2.2.</span> <span class="toc-text">should_flush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flush"><span class="toc-number">2.2.3.</span> <span class="toc-text">Flush</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WriteBlock"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">WriteBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WriteBlock-1"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">WriteBlock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EnterUnbuffered"><span class="toc-number">2.2.4.</span> <span class="toc-text">EnterUnbuffered</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Finish"><span class="toc-number">2.3.</span> <span class="toc-text">Finish</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MetaIndexBuilder"><span class="toc-number">2.3.1.</span> <span class="toc-text">MetaIndexBuilder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WriteFilterBlock"><span class="toc-number">2.3.2.</span> <span class="toc-text">WriteFilterBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WriteIndexBlock"><span class="toc-number">2.3.3.</span> <span class="toc-text">WriteIndexBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WriteFooter"><span class="toc-number">2.3.4.</span> <span class="toc-text">WriteFooter</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        BlockBasedTableBuilder 源码分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2021-11-28T06:15:35.000Z" itemprop="datePublished">2021-11-28</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/RocksDb/" rel="tag">RocksDb</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="BlockBasedTableBuilder-ParallelCompressionRep"><a href="#BlockBasedTableBuilder-ParallelCompressionRep" class="headerlink" title="BlockBasedTableBuilder::ParallelCompressionRep"></a>BlockBasedTableBuilder::ParallelCompressionRep</h2><p>先来看看<code>BlockBasedTableBuilder</code>中的多线程压缩部分 <code> BlockBasedTableBuilder::ParallelCompressionRep</code>。</p>
<p>以下代码不加说明，都是在类 <code>BlockBasedTableBuilder::ParallelCompressionRep</code> 里面。</p>
<h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p>在 <code>class ParallelCompressionRep</code> 中，有个<code>class Keys</code>，这是一个为了提高内存利用率的类。涉及点：</p>
<ul>
<li>预分配 <code>kKeysInitSize</code>个元素的内存：若向<code>Keys</code>中添加的元素个数小于 <code>kKeysInitSize</code>，则使用可以使用预分配的内存，避免了动态内存分配；</li>
<li>每次<code>Keys::Clear()</code>的时候，并不是真的释放了之前的内存，仅仅是调整了计数器<code>size_</code>，即常见的『惰性删除』。</li>
</ul>
<p>这是常见而有效的设计，代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Keys</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Keys</span>() : <span class="built_in">keys_</span>(kKeysInitSize), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">PushBack</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (size_ == keys_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">       <span class="comment">// 说明 keys_的元素个数超过预分配</span></span><br><span class="line">       keys_.<span class="built_in">emplace_back</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 使用预分配内存</span></span><br><span class="line">       keys_[size_].<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">     &#125;</span><br><span class="line">     size_++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">SwapAssign</span><span class="params">(std::vector&lt;std::string&gt;&amp; keys)</span> </span>&#123;</span><br><span class="line">     size_ = keys.<span class="built_in">size</span>();</span><br><span class="line">     std::<span class="built_in">swap</span>(keys_, keys);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 惰性删除</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123; size_ = <span class="number">0</span>; &#125;</span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">   <span class="function">std::string&amp; <span class="title">Back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> keys_[size_ - <span class="number">1</span>]; &#125;</span><br><span class="line">   std::string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> idx) &#123;</span><br><span class="line">     <span class="built_in">assert</span>(idx &lt; size_);</span><br><span class="line">     <span class="keyword">return</span> keys_[idx];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   <span class="type">const</span> <span class="type">size_t</span> kKeysInitSize = <span class="number">32</span>;</span><br><span class="line">   std::vector&lt;std::string&gt; keys_;</span><br><span class="line">   <span class="type">size_t</span> size_;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Keys&gt; curr_block_keys;</span><br></pre></td></tr></table></figure>

<h3 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h3><p>在继续讲解之前，先讲解下Rocksdb保证多线程安全的队列。</p>
<p>在rocksdb中，是怎么保证多线程压缩的顺序性呢，依赖<code>WorkQueue</code>，<code>WorkQueue</code>其实就是个很简单的『生产-消费』多线程模型：写线程和多线程之间共享一个任务队列 <code>queue_</code>，以及保护这个共享队列<code>queue_</code>的互斥锁<code>mutex_</code>。</p>
<p><code>WorkQueue</code>在<code>::Finish</code>函数之后，就不可用了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkQueue</span> &#123;</span><br><span class="line">  std::mutex mutex_;</span><br><span class="line">  std::condition_variable readerCv_;</span><br><span class="line">  std::condition_variable writerCv_;</span><br><span class="line">  std::condition_variable finishCv_;</span><br><span class="line"></span><br><span class="line">  std::queue&lt;T&gt; queue_;</span><br><span class="line">  <span class="type">bool</span> done_;</span><br><span class="line">  std::<span class="type">size_t</span> maxSize_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 必须在锁中调用这个函数</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue_.<span class="built_in">size</span>() &gt;= maxSize_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">WorkQueue</span>(std::<span class="type">size_t</span> maxSize = <span class="number">0</span>) : <span class="built_in">done_</span>(<span class="literal">false</span>), <span class="built_in">maxSize_</span>(maxSize) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(U&amp;&amp; item)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">waitUntilFinished</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 更改 queue_ 大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setMaxSize</span><span class="params">(std::<span class="type">size_t</span> maxSize)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">      maxSize_ = maxSize;</span><br><span class="line">     &#125;</span><br><span class="line">    writerCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p><code>push</code> 函数，向共享队列<code>queue_</code> 中添加一个任务，成功则返回true。如果已经调用了<code>::Finish</code> 函数，则返回false。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorkQueue::push</span><span class="params">(U&amp;&amp; item)</span> </span>&#123;</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// 等待 queue_ 队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">full</span>() &amp;&amp; !done_) &#123;</span><br><span class="line">      writerCv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果调用了 Finish 函数</span></span><br><span class="line">    <span class="comment">// 则不再接受新的元素</span></span><br><span class="line">    <span class="keyword">if</span> (done_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加新的元素</span></span><br><span class="line">    queue_.<span class="built_in">push</span>(std::forward&lt;U&gt;(item));</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 通知读线程</span></span><br><span class="line">  readerCv_.<span class="built_in">notify_one</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p><code>pop</code>函数，按照FIFO规则从共享任务队列 <code>queue_</code> 中弹出一个待处理任务，并返回true。</p>
<p>如果已经调用了<code>::Finish</code> 函数，则返回false。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"> <span class="type">bool</span> <span class="title">WorkQueue::pop</span><span class="params">(T&amp; item)</span> </span>&#123;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">// 等写线程添加元素</span></span><br><span class="line">     <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">     <span class="keyword">while</span> (queue_.<span class="built_in">empty</span>() &amp;&amp; !done_) &#123;</span><br><span class="line">       readerCv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 如果已经调用了 ::Finish 函数</span></span><br><span class="line">     <span class="comment">// 则不再处理</span></span><br><span class="line">     <span class="keyword">if</span> (queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">       <span class="built_in">assert</span>(done_);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 弹出</span></span><br><span class="line">     item = queue_.<span class="built_in">front</span>();</span><br><span class="line">     queue_.<span class="built_in">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 通知写线程</span></span><br><span class="line">   writerCv_.<span class="built_in">notify_one</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="waitUntilFinished"><a href="#waitUntilFinished" class="headerlink" title="waitUntilFinished"></a>waitUntilFinished</h4><p><code>waitUntilFinished</code> 函数，用于阻塞等待 <code>WorkQueue::Finish</code> 函数调用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitUntilFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (!done_) &#123;</span><br><span class="line">    finishCv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h4><p><code>::Finish</code> 函数调用后，<code>WorkQueue</code> 不再处理接受新的元素，也不再弹出旧的元素，<code>waitUntilFinished</code> 函数就能返回了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkQueue::finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="built_in">assert</span>(!done_);</span><br><span class="line">    done_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  readerCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  writerCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  finishCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BlockRepSlot"><a href="#BlockRepSlot" class="headerlink" title="BlockRepSlot"></a>BlockRepSlot</h3><p><code>BlockRepSlot</code> 是基于<code>WorkQueue</code>实现的线程安全队列。</p>
<p>每个节点<code>BlockRep*</code>记录一个block的相关数据及其状态，那么就可以由写线程将<code>BlockRep</code>节点加入到<code>BlockRepSlot</code>中，压缩等工作线程从<code>BlockRepSlot</code>中通过<code>take</code>函数取出<code>BlockRep</code>节点，对其进行压缩等操作。</p>
<p>如此，就能完成多线程操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// BlockRep 记录一个 block 的数据及其相关信息</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">BlockRep</span> &#123;</span><br><span class="line">   Slice contents; 					                     <span class="comment">// 原始内容</span></span><br><span class="line">   Slice compressed_contents;                     <span class="comment">// 压缩内容</span></span><br><span class="line">   std::unique_ptr&lt;std::string&gt; data;             <span class="comment">// 原始内容， 与 contents 区别</span></span><br><span class="line">   std::unique_ptr&lt;std::string&gt; compressed_data;  <span class="comment">// 压缩之后的数据</span></span><br><span class="line">   CompressionType compression_type;              <span class="comment">// 压缩类型</span></span><br><span class="line">   std::unique_ptr&lt;std::string&gt; first_key_in_next_block;</span><br><span class="line">   std::unique_ptr&lt;Keys&gt; keys;                    <span class="comment">// 此block的所有keys</span></span><br><span class="line">   std::unique_ptr&lt;BlockRepSlot&gt; slot;            <span class="comment">// 所属的 BlockRepSlot  ???          </span></span><br><span class="line">   Status status;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockRepSlot</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">BlockRepSlot</span>() : <span class="built_in">slot_</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">// 向 slot_ 中添加一</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Fill</span><span class="params">(T&amp;&amp; rep)</span> </span>&#123;</span><br><span class="line">     slot_.<span class="built_in">push</span>(std::forward&lt;T&gt;(rep));</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Take</span><span class="params">(BlockRep*&amp; rep)</span> </span>&#123; slot_.<span class="built_in">pop</span>(rep); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   WorkQueue&lt;BlockRep*&gt; slot_;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="FileSizeEstimator"><a href="#FileSizeEstimator" class="headerlink" title="FileSizeEstimator"></a>FileSizeEstimator</h3><p>当并行压缩开启时，类 <code>FileSizeEstimator</code> 用于计算输出文件大小。主要是有两个回调函数 <code>EmitBlock</code>  、<code>ReapBlock</code>：</p>
<ul>
<li><code>EmitBlock</code>：在添加到压缩线程之前调用</li>
<li><code>ReapBlock</code>：在压缩完成之后调用</li>
</ul>
<p><code>FileSizeEstimator</code> 的源码简单如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSizeEstimator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FileSizeEstimator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      : raw_bytes_compressed(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        raw_bytes_curr_block(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        raw_bytes_curr_block_set(false),</span></span><br><span class="line"><span class="function">        raw_bytes_inflight(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        blocks_inflight(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        curr_compression_ratio(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        estimated_file_size(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 当一个 block 要 emit to 压缩线程时，则计算一个文件大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(<span class="type">uint64_t</span> raw_block_size, <span class="type">uint64_t</span> curr_file_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 当一个 block 从压缩线程压缩完毕时</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(<span class="type">uint64_t</span> compressed_block_size, <span class="type">uint64_t</span> curr_file_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 设置文件近似大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetEstimatedFileSize</span><span class="params">(<span class="type">uint64_t</span> size)</span> </span>&#123;</span><br><span class="line">    estimated_file_size.<span class="built_in">store</span>(size, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 获得文件近似大小</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">GetEstimatedFileSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> estimated_file_size.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/// 设置block大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetCurrBlockRawSize</span><span class="params">(<span class="type">uint64_t</span> size)</span> </span>&#123;</span><br><span class="line">    raw_bytes_curr_block = size;</span><br><span class="line">    raw_bytes_curr_block_set = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint64_t</span> raw_bytes_compressed;  <span class="comment">// 到目前为止压缩的字节，即这么多的字节是要要压缩的</span></span><br><span class="line">  <span class="type">uint64_t</span> raw_bytes_curr_block;  <span class="comment">// Size of current block being appended.</span></span><br><span class="line">  <span class="type">bool</span> raw_bytes_curr_block_set;  <span class="comment">// </span></span><br><span class="line">  std::atomic&lt;<span class="type">uint64_t</span>&gt; raw_bytes_inflight; <span class="comment">// 正在压缩，但尚未添加到sst文件的字节大小</span></span><br><span class="line">  std::atomic&lt;<span class="type">uint64_t</span>&gt; blocks_inflight;    <span class="comment">// Number of blocks under compression and not appended yet.</span></span><br><span class="line">  std::atomic&lt;<span class="type">double</span>&gt; curr_compression_ratio; <span class="comment">// 压缩率</span></span><br><span class="line">  std::atomic&lt;<span class="type">uint64_t</span>&gt; estimated_file_size;  <span class="comment">// SST 文件的近似大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="EmitBlock"><a href="#EmitBlock" class="headerlink" title="EmitBlock"></a>EmitBlock</h4><p><code>EmitBlock</code>函数，在将一个待压缩的block发送给压缩线程之前调用，用于计算当所有block压缩完成后sst文件的近似大小。主要有三部分组成：</p>
<ol>
<li><code>curr_file_size</code>：已写入到sst的部分</li>
<li><code>new_raw_bytes_inflight</code>：当前正在压缩，还没写入sst的部分。这部分按照压缩率<code>curr_compression_ratio</code> 大致折算成最终写入sst的大小。</li>
<li><code>kBlockTrailerSize</code>：每个block都有<code>footer</code>，这部分不压缩，按照正在压缩的block数<code>new_blocks_inflight</code> 乘以每个<code>footer</code>的大小<code>kBlockTrailerSize</code>，即这部分写入sst的大小。</li>
</ol>
<p>源码简单如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param raw_block_size 待压缩的 block 大小</span></span><br><span class="line"><span class="comment">/// @param curr_file_size </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(<span class="type">uint64_t</span> raw_block_size, <span class="type">uint64_t</span> curr_file_size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前正在压缩的字节数</span></span><br><span class="line">    <span class="type">uint64_t</span> new_raw_bytes_inflight =</span><br><span class="line">        raw_bytes_inflight.<span class="built_in">fetch_add</span>(raw_block_size,</span><br><span class="line">                                     std::memory_order_relaxed) +</span><br><span class="line">        raw_block_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在压缩的block数据</span></span><br><span class="line">    <span class="type">uint64_t</span> new_blocks_inflight =</span><br><span class="line">        blocks_inflight.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    estimated_file_size.<span class="built_in">store</span>(</span><br><span class="line">        curr_file_size +  <span class="comment">// 1. 已经写入 sst 的大小</span></span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(new_raw_bytes_inflight) * <span class="comment">// 2. 压缩完成的大小 = 当前正在压缩 * 压缩率</span></span><br><span class="line">                curr_compression_ratio.<span class="built_in">load</span>(std::memory_order_relaxed)) +</span><br><span class="line">            new_blocks_inflight * kBlockTrailerSize, <span class="comment">// 3. new_blocks_inflight * 脚注大小</span></span><br><span class="line">        std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReapBlock"><a href="#ReapBlock" class="headerlink" title="ReapBlock"></a>ReapBlock</h4><p><code>ReapBlock</code>，也是个回调函数 ，当一个block压缩完毕时调用，来更新当前压缩的状态：</p>
<ul>
<li><code>raw_bytes_compressed</code>：到目前为止，有多少字节的数据被压缩了；</li>
<li><code>curr_compression_ratio</code>：已压缩的字节数 &#x2F; 当前对应的原始字节数</li>
<li>重新估算最终写入sst文件的大小</li>
</ul>
<p>代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(<span class="type">uint64_t</span> compressed_block_size, <span class="type">uint64_t</span> curr_file_size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(raw_bytes_curr_block_set);</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 目前一共被压缩的字节数</span></span><br><span class="line">    <span class="type">uint64_t</span> new_raw_bytes_compressed =</span><br><span class="line">        raw_bytes_compressed + raw_bytes_curr_block;</span><br><span class="line">    <span class="built_in">assert</span>(new_raw_bytes_compressed &gt; <span class="number">0</span>);</span><br><span class="line">			</span><br><span class="line">    <span class="comment">// 更新压缩率</span></span><br><span class="line">    <span class="comment">// 分子：压缩的字节，分母：原始字节</span></span><br><span class="line">    curr_compression_ratio.<span class="built_in">store</span>(</span><br><span class="line">        (curr_compression_ratio.<span class="built_in">load</span>(std::memory_order_relaxed) *</span><br><span class="line">             raw_bytes_compressed +</span><br><span class="line">         compressed_block_size) /</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(new_raw_bytes_compressed),</span><br><span class="line">        std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    raw_bytes_compressed = new_raw_bytes_compressed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复</span></span><br><span class="line">    <span class="type">uint64_t</span> new_raw_bytes_inflight =</span><br><span class="line">        raw_bytes_inflight.<span class="built_in">fetch_sub</span>(raw_bytes_curr_block,</span><br><span class="line">                                     std::memory_order_relaxed) -</span><br><span class="line">        raw_bytes_curr_block;</span><br><span class="line">		</span><br><span class="line">    <span class="type">uint64_t</span> new_blocks_inflight =</span><br><span class="line">        blocks_inflight.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算下文件大小</span></span><br><span class="line">    estimated_file_size.<span class="built_in">store</span>(</span><br><span class="line">        curr_file_size +</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(new_raw_bytes_inflight) * </span><br><span class="line">                curr_compression_ratio.<span class="built_in">load</span>(std::memory_order_relaxed)) +</span><br><span class="line">            new_blocks_inflight * kBlockTrailerSize,</span><br><span class="line">        std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    raw_bytes_curr_block_set = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ParallelCompressionRep"><a href="#ParallelCompressionRep" class="headerlink" title="ParallelCompressionRep"></a>ParallelCompressionRep</h3><p>为了更好地理解 <code>class ParallelCompressionRep</code>，下面在讲解源码时，会调整下不同字段的顺序。</p>
<p><code>ParallelCompressionRep</code>，使用顺序如下：</p>
<ul>
<li>在<code>ParallelCompressionRep</code>内部，会调用<code>ParallelCompressionRep::PrepareBlock</code>接口，准备此block的数据；</li>
<li>调用 <code>EmitBlock</code>函数发送给压缩线程；</li>
<li>当压缩完成，会调用<code>ParallelCompressionRep::ReapBlock</code>接口。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BlockBasedTableBuilder</span>::ParallelCompressionRep &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Keys</span>              &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">BlockRepSlot</span>      &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">BlockRep</span>         &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">FileSizeEstimator</span> &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typedef</span> std::vector&lt;BlockRep&gt;    BlockRepBuffer;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRep*&gt;     BlockRepPool;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRep*&gt;     CompressQueue;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRepSlot*&gt; WriteQueue;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 字段</span></span><br><span class="line">  std::unique_ptr&lt;Keys&gt;         curr_block_keys;      <span class="comment">// 当前block的key</span></span><br><span class="line">  BlockRepBuffer                block_rep_buf;        <span class="comment">// 记录各个block的数据状态</span></span><br><span class="line">  BlockRepPool                  block_rep_pool;       <span class="comment">// block_rep_pool 中记录的是 block_rep_buf</span></span><br><span class="line">  CompressQueue                 compress_queue;       <span class="comment">// 待压缩的任务队列</span></span><br><span class="line">  std::vector&lt;port::Thread&gt;     compress_thread_pool; <span class="comment">// 压缩线程</span></span><br><span class="line">  WriteQueue                    write_queue;          <span class="comment">// 写入文件的队列</span></span><br><span class="line">  std::unique_ptr&lt;port::Thread&gt; write_thread;			    <span class="comment">// 写线程</span></span><br><span class="line">  FileSizeEstimator             file_size_estimator;  <span class="comment">// 评估文件大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待第一个 block 压缩完成</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt;             first_block_processed;</span><br><span class="line">  std::condition_variable       first_block_cond;</span><br><span class="line">  std::mutex                    first_block_mutex;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ParallelCompressionRep</span><span class="params">(<span class="type">uint32_t</span> parallel_threads)</span></span></span><br><span class="line"><span class="function">      : curr_block_keys(new Keys()),</span></span><br><span class="line"><span class="function">        block_rep_buf(parallel_threads),</span></span><br><span class="line"><span class="function">        block_rep_pool(parallel_threads),</span></span><br><span class="line"><span class="function">        compress_queue(parallel_threads),</span></span><br><span class="line"><span class="function">        write_queue(parallel_threads),</span></span><br><span class="line"><span class="function">        first_block_processed(false) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; parallel_threads; i++) &#123;</span><br><span class="line">      block_rep_buf[i].contents = <span class="built_in">Slice</span>();</span><br><span class="line">      block_rep_buf[i].compressed_contents = <span class="built_in">Slice</span>();</span><br><span class="line">      block_rep_buf[i].data.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].compressed_data.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].compression_type = <span class="built_in">CompressionType</span>();</span><br><span class="line">      block_rep_buf[i].first_key_in_next_block.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].keys.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Keys</span>());</span><br><span class="line">      block_rep_buf[i].slot.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">BlockRepSlot</span>());</span><br><span class="line">      block_rep_buf[i].status = Status::<span class="built_in">OK</span>();</span><br><span class="line">      <span class="comment">// 放到线程池</span></span><br><span class="line">      <span class="comment">// 因此，block_rep_pool 中每个元素的生命周期是由 block_rep_buf 中的每个元素负责</span></span><br><span class="line">      <span class="comment">// block_rep_buf 中存储着原始数据</span></span><br><span class="line">      block_rep_pool.<span class="built_in">push</span>(&amp;block_rep_buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/// 等待完成</span></span><br><span class="line">  ~<span class="built_in">ParallelCompressionRep</span>() &#123; block_rep_pool.<span class="built_in">finish</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 使用在 non-buffered 模式</span></span><br><span class="line">  <span class="comment">/// 准备好一个 block，并准备发送给 压缩线程</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                         BlockBuilder* data_block)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Used in EnterUnbuffered</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::string* data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::vector&lt;std::string&gt;* keys)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将 block 发送给 压缩线程</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 接受从压缩线程的结果</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(BlockRep* block_rep)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// 生成 block</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlockInternal</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> Slice* first_key_in_next_block)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="PrepareBlockInternal"><a href="#PrepareBlockInternal" class="headerlink" title="PrepareBlockInternal"></a>PrepareBlockInternal</h4><p>下面，先来讲讲怎么创建一个 <code>BlockRep</code>对象。</p>
<h5 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h5><p><code>block_rep_pool</code> 的意义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 block</span></span><br><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlockInternal</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Slice* first_key_in_next_block)</span> </span>&#123;</span><br><span class="line">  BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 从 block_rep_pool 头部出来</span></span><br><span class="line">  block_rep_pool.<span class="built_in">pop</span>(block_rep);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(block_rep-&gt;data);</span><br><span class="line"></span><br><span class="line">  block_rep-&gt;compression_type = compression_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_key_in_next_block == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 表示最后一个block</span></span><br><span class="line">    block_rep-&gt;first_key_in_next_block.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非最后一个block</span></span><br><span class="line">    block_rep-&gt;first_key_in_next_block-&gt;<span class="built_in">assign</span>(</span><br><span class="line">        first_key_in_next_block-&gt;<span class="built_in">data</span>(), first_key_in_next_block-&gt;<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PrepareBlock"><a href="#PrepareBlock" class="headerlink" title="PrepareBlock"></a>PrepareBlock</h4><p>在将待压缩的block发送给压缩线程之前，要先准备好这个block。</p>
<p><code>PrepareBlock</code> 函数，即用于完成这个过程。</p>
<ul>
<li><code>compression_type</code>：压缩类型</li>
<li><code>first_key_in_next_block</code>：下一个block的第一个<code>key</code></li>
<li><code>data_block</code>：待压缩的block的数据部分</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                       BlockBuilder* data_block)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 block_req</span></span><br><span class="line">  BlockRep* block_rep =</span><br><span class="line">      <span class="built_in">PrepareBlockInternal</span>(compression_type, first_key_in_next_block);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 将 data_block 中数据给 block_rep-&gt;data</span></span><br><span class="line">  data_block-&gt;<span class="built_in">SwapAndReset</span>(*(block_rep-&gt;data));</span><br><span class="line">  <span class="comment">// 数据复制给 block_rep-&gt;contents</span></span><br><span class="line">  block_rep-&gt;contents = *(block_rep-&gt;data);</span><br><span class="line">  <span class="comment">// 再将当前block的数据给 block_rep-&gt;keys</span></span><br><span class="line">  std::<span class="built_in">swap</span>(block_rep-&gt;keys, curr_block_keys);</span><br><span class="line">  curr_block_keys-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PrepareBlock-1"><a href="#PrepareBlock-1" class="headerlink" title="PrepareBlock"></a>PrepareBlock</h4><p><code>PrepareBlock</code> 只是上述函数的重载。上述函数传入的是一个<code>BlockBuilder*</code>，这里只是把原本一个<code>BlockBuilder</code> 记录的数据分别传入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::string* data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::vector&lt;std::string&gt;* keys)</span> </span>&#123;</span><br><span class="line">  BlockRep* block_rep =</span><br><span class="line">      <span class="built_in">PrepareBlockInternal</span>(compression_type, first_key_in_next_block);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  std::<span class="built_in">swap</span>(*(block_rep-&gt;data), *data_block);</span><br><span class="line">  block_rep-&gt;contents = *(block_rep-&gt;data);</span><br><span class="line">  block_rep-&gt;keys-&gt;<span class="built_in">SwapAssign</span>(*keys);</span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="EmitBlock-1"><a href="#EmitBlock-1" class="headerlink" title="EmitBlock"></a>EmitBlock</h4><p>将上述准备好的block发送给压缩线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 block 发送给 压缩线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep-&gt;status.<span class="built_in">ok</span>());</span><br><span class="line">  <span class="comment">// 将准备好的block加入工作队列</span></span><br><span class="line">  <span class="keyword">if</span> (!write_queue.<span class="built_in">push</span>(block_rep-&gt;slot.<span class="built_in">get</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!compress_queue.<span class="built_in">push</span>(block_rep)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等待压缩完成 </span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到 first_block_processed 为 true</span></span><br><span class="line">    first_block_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">return</span> first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ReapBlock-1"><a href="#ReapBlock-1" class="headerlink" title="ReapBlock"></a>ReapBlock</h4><h5 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h5><p><code>ReapBlock</code>，当压缩完成时的回调函数。??? 应该是写入文件???</p>
<p>用于清除压缩数据，通知emit线程，可以继续压缩</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reap a block from compression thread</span></span><br><span class="line"><span class="comment">// 接受从压缩线程的结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 清除压缩数据</span></span><br><span class="line">  block_rep-&gt;compressed_data-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="comment">// ??? </span></span><br><span class="line">  block_rep_pool.<span class="built_in">push</span>(block_rep);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知 emit Block，可以继续压缩</span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    first_block_processed.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">    first_block_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BlockBasedTableBuilder"><a href="#BlockBasedTableBuilder" class="headerlink" title="BlockBasedTableBuilder"></a>BlockBasedTableBuilder</h2><p>初始化操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">BlockBasedTableBuilder::<span class="built_in">BlockBasedTableBuilder</span>(</span><br><span class="line">    <span class="type">const</span> BlockBasedTableOptions&amp; table_options, <span class="type">const</span> TableBuilderOptions&amp; tbo,</span><br><span class="line">    WritableFileWriter* file) &#123;</span><br><span class="line">  <span class="function">BlockBasedTableOptions <span class="title">sanitized_table_options</span><span class="params">(table_options)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 压缩格式</span></span><br><span class="line">  <span class="keyword">if</span> (sanitized_table_options.format_version == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      sanitized_table_options.checksum != kCRC32c) &#123;</span><br><span class="line">    <span class="built_in">ROCKS_LOG_WARN</span>(</span><br><span class="line">        tbo.ioptions.logger,</span><br><span class="line">        <span class="string">&quot;Silently converting format_version to 1 because checksum is &quot;</span></span><br><span class="line">        <span class="string">&quot;non-default&quot;</span>);</span><br><span class="line">    <span class="comment">// silently convert format_version to 1 to keep consistent with current</span></span><br><span class="line">    <span class="comment">// behavior</span></span><br><span class="line">    sanitized_table_options.format_version = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// 创建 rep_</span></span><br><span class="line">  rep_ = <span class="keyword">new</span> <span class="built_in">Rep</span>(sanitized_table_options, tbo, file);</span><br><span class="line">	</span><br><span class="line">  <span class="comment">// filter block 此时还没创建，初始化</span></span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    rep_-&gt;filter_builder-&gt;<span class="built_in">StartBlock</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成前缀</span></span><br><span class="line">  <span class="keyword">if</span> (table_options.block_cache_compressed.<span class="built_in">get</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    BlockBasedTable::<span class="built_in">GenerateCachePrefix</span>&lt;Cache, FSWritableFile&gt;(</span><br><span class="line">        table_options.block_cache_compressed.<span class="built_in">get</span>(), </span><br><span class="line">        file-&gt;<span class="built_in">writable_file</span>(),</span><br><span class="line">        &amp;rep_-&gt;compressed_cache_key_prefix[<span class="number">0</span>],    <span class="comment">// 输出参数</span></span><br><span class="line">        &amp;rep_-&gt;compressed_cache_key_prefix_size,  <span class="comment">// 输出参数</span></span><br><span class="line">        tbo.db_session_id,</span><br><span class="line">        tbo.cur_file_num);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开启多线程压缩</span></span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">StartParallelCompression</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ParallelCompression"><a href="#ParallelCompression" class="headerlink" title="ParallelCompression"></a>ParallelCompression</h3><p>下面从压缩开始。</p>
<p>每个data_block在写入sst之前，如果设置了压缩，则都会经过一个压缩的过程。</p>
<h4 id="IsParallelCompressionEnabled"><a href="#IsParallelCompressionEnabled" class="headerlink" title="IsParallelCompressionEnabled"></a>IsParallelCompressionEnabled</h4><p>是否开启多线程压缩，则由 <code>CompressionOptions::parallel_threads</code> 字段的值指示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> BlockBasedTableBuilder::Rep::<span class="built_in">IsParallelCompressionEnabled</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> compression_opts.parallel_threads &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StartParallelCompression"><a href="#StartParallelCompression" class="headerlink" title="StartParallelCompression"></a>StartParallelCompression</h4><p>如果开启了多线程压缩，压缩流程如下：</p>
<ul>
<li>在每次压缩前，主线程，使用<code>ParallelCompressionRep::PrepareBlock</code>函数，准备好待压缩的block；</li>
<li>主线程调用<code>ParallelCompressionRep::EmitBlock</code>函数，将block送入压缩线程；</li>
<li>压缩线程再进行压缩</li>
<li>将压缩完毕的data_block，写入到sst文件中</li>
</ul>
<p>下面是开启多个压缩线程的代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::StartParallelCompression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化 ParallelCompressionRep 对象</span></span><br><span class="line">  rep_-&gt;pc_rep.<span class="built_in">reset</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">ParallelCompressionRep</span>(rep_-&gt;compression_opts.parallel_threads));</span><br><span class="line">  rep_-&gt;pc_rep-&gt;compress_thread_pool.<span class="built_in">reserve</span>(</span><br><span class="line">      rep_-&gt;compression_opts.parallel_threads);</span><br><span class="line">  <span class="comment">// 开启 parallel_threads 个压缩线程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; rep_-&gt;compression_opts.parallel_threads; i++) &#123;</span><br><span class="line">    rep_-&gt;pc_rep-&gt;compress_thread_pool.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i] &#123;</span><br><span class="line">      <span class="built_in">BGWorkCompression</span>(*(rep_-&gt;compression_ctxs[i]),  <span class="comment">// 压缩上下文</span></span><br><span class="line">                          rep_-&gt;verify_ctxs[i].<span class="built_in">get</span>()); <span class="comment">// 解压上下文</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开启 1 个写线程</span></span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_thread.<span class="built_in">reset</span>(</span><br><span class="line">      <span class="keyword">new</span> port::<span class="built_in">Thread</span>([<span class="keyword">this</span>] &#123; <span class="built_in">BGWorkWriteRawBlock</span>(); &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BGWorkCompression"><a href="#BGWorkCompression" class="headerlink" title="BGWorkCompression"></a>BGWorkCompression</h5><p>压缩线程的入口函数，<code>BGWorkCompression</code> ，仅用于压缩<code>data_block</code>，他一直在等待主线程发送待压缩的block，然后取出来，进行压缩。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::BGWorkCompression</span><span class="params">(<span class="type">const</span> CompressionContext&amp; compression_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               UncompressionContext* verify_ctx)</span> </span>&#123;</span><br><span class="line">  ParallelCompressionRep::BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (rep_-&gt;pc_rep-&gt;compress_queue.<span class="built_in">pop</span>(block_rep)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">CompressAndVerifyBlock</span>(block_rep-&gt;contents, </span><br><span class="line">                           <span class="literal">true</span>, <span class="comment">/* is_data_block*/</span></span><br><span class="line">                           compression_ctx, </span><br><span class="line">                           verify_ctx,</span><br><span class="line">                           block_rep-&gt;compressed_data.<span class="built_in">get</span>(), <span class="comment">// 输出参数，unused ?</span></span><br><span class="line">                           &amp;block_rep-&gt;compressed_contents,  <span class="comment">// 保存压缩结果</span></span><br><span class="line">                           &amp;(block_rep-&gt;compression_type),   <span class="comment">// 压缩结果的字节数</span></span><br><span class="line">                           &amp;block_rep-&gt;status);              <span class="comment">// 压缩是否成功</span></span><br><span class="line">    <span class="comment">// 将压缩完毕的 block 加入到 block_rep-&gt;slot 中</span></span><br><span class="line">    <span class="comment">// 为后面写入sst准备</span></span><br><span class="line">    block_rep-&gt;slot-&gt;<span class="built_in">Fill</span>(block_rep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="CompressAndVerifyBlock"><a href="#CompressAndVerifyBlock" class="headerlink" title="CompressAndVerifyBlock"></a>CompressAndVerifyBlock</h5><p>CompressAndVerifyBlock&#96; 函数，不仅尝试去压缩，而且会统计压缩过程中的一些信息。为便于下面的代码简洁，易于理解，把这部分去掉了，专注于功能。</p>
<p>sst是由一系列的<code>block</code>组成，每个<code>block</code>的格式都是：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block_data: uint8[n] <span class="comment"># block 存储的数据</span></span><br><span class="line"><span class="built_in">type</span>: uint8          <span class="comment"># 压缩类型</span></span><br><span class="line">crc: uint32          <span class="comment"># 校验和</span></span><br></pre></td></tr></table></figure>

<p>顺序的压缩过程如下：</p>
<ol>
<li>当前待压缩的数据是<code>raw_block_contents</code>，其大小不能超过 <code>kCompressionSizeLimit</code> 限制；</li>
<li>先尝试调用 <code>CompressBlock</code> 函数压缩，结果保存至<code>block_contents</code>；</li>
<li>如果设置了校验压缩结果，即设置了 <code>table_options.verify_compression</code> 标志位，则会对<code>block_contents</code>进行解压，保存至<code>contents</code>，顺利的压缩，需要保证 <code>block_contents</code> 和 <code>contents</code> 相同；</li>
</ol>
<p>如果一切顺利，则：</p>
<ul>
<li><code>block_contents</code> 中保存了<code>raw_block_contents</code>的压缩结果，</li>
<li><code>type</code> 保存了压缩类型；</li>
</ul>
<p>代码简洁后如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::CompressAndVerifyBlock</span><span class="params">(<span class="type">const</span> Slice&amp; raw_block_contents, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">bool</span> is_data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">const</span> CompressionContext&amp; compression_ctx, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    UncompressionContext* verify_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    std::string* compressed_output,  <span class="comment">// unused</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Slice* block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    CompressionType* type, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Status* out_status)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="type">bool</span> is_status_ok = <span class="built_in">ok</span>();</span><br><span class="line">  <span class="keyword">if</span> (!r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(is_status_ok);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *type = r-&gt;compression_type;</span><br><span class="line">  <span class="comment">// 采样多少个字节用于压缩</span></span><br><span class="line">  <span class="type">uint64_t</span> sample_for_compression = r-&gt;sample_for_compression;</span><br><span class="line">  <span class="comment">// 中止压缩</span></span><br><span class="line">  <span class="type">bool</span> abort_compression = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">StopWatchNano <span class="title">timer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      r-&gt;ioptions.clock,</span></span></span><br><span class="line"><span class="params"><span class="function">      ShouldReportDetailedTime(r-&gt;ioptions.env, r-&gt;ioptions.stats))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次压缩字节大小有限制</span></span><br><span class="line">  <span class="keyword">if</span> (is_status_ok &amp;&amp; raw_block_contents.<span class="built_in">size</span>() &lt; kCompressionSizeLimit) &#123;</span><br><span class="line">    <span class="comment">// 1. 获取 compression_dict</span></span><br><span class="line">    <span class="type">const</span> CompressionDict* compression_dict;</span><br><span class="line">    <span class="keyword">if</span> (!is_data_block || r-&gt;compression_dict == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      compression_dict = &amp;CompressionDict::<span class="built_in">GetEmptyDict</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      compression_dict = r-&gt;compression_dict.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(compression_dict != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="function">CompressionInfo <span class="title">compression_info</span><span class="params">(r-&gt;compression_opts, </span></span></span><br><span class="line"><span class="params"><span class="function">                                     compression_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     *compression_dict, </span></span></span><br><span class="line"><span class="params"><span class="function">                                     *type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sample_for_compression)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::string sampled_output_fast;</span><br><span class="line">    std::string sampled_output_slow;</span><br><span class="line">    <span class="comment">/// 尝试将 @c raw_block_contents 进行压缩，并返回至 @c compressed_output</span></span><br><span class="line">    *block_contents = <span class="built_in">CompressBlock</span>(raw_block_contents, </span><br><span class="line">                                    compression_info, </span><br><span class="line">                                    type,</span><br><span class="line">                                    r-&gt;table_options.format_version, </span><br><span class="line">                                    is_data_block <span class="comment">/* do_sample */</span>,</span><br><span class="line">                                    compressed_output, </span><br><span class="line">                                    &amp;sampled_output_fast, </span><br><span class="line">                                    &amp;sampled_output_slow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于一些压缩算法不太可靠，因此如果设置了 verify_compression</span></span><br><span class="line">    <span class="comment">// 则需要校验</span></span><br><span class="line">    <span class="keyword">if</span> (*type != kNoCompression &amp;&amp; r-&gt;table_options.verify_compression) &#123;</span><br><span class="line">      <span class="comment">// Retrieve the uncompressed contents into a new buffer</span></span><br><span class="line">      <span class="type">const</span> UncompressionDict* verify_dict;</span><br><span class="line">      <span class="keyword">if</span> (!is_data_block || r-&gt;verify_dict == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        verify_dict = &amp;UncompressionDict::<span class="built_in">GetEmptyDict</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        verify_dict = r-&gt;verify_dict.<span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">assert</span>(verify_dict != <span class="literal">nullptr</span>);</span><br><span class="line">      BlockContents contents;</span><br><span class="line">      <span class="function">UncompressionInfo <span class="title">uncompression_info</span><span class="params">(*verify_ctx, </span></span></span><br><span class="line"><span class="params"><span class="function">                                           *verify_dict,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           r-&gt;compression_type)</span></span>;</span><br><span class="line">      Status stat = <span class="built_in">UncompressBlockContentsForCompressionType</span>(</span><br><span class="line">          uncompression_info, block_contents-&gt;<span class="built_in">data</span>(), block_contents-&gt;<span class="built_in">size</span>(),</span><br><span class="line">          &amp;contents, r-&gt;table_options.format_version, r-&gt;ioptions);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stat.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// 将解压的内容与压缩之前的源内容比较</span></span><br><span class="line">        <span class="type">bool</span> compressed_ok = contents.data.<span class="built_in">compare</span>(raw_block_contents) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!compressed_ok) &#123;</span><br><span class="line">          <span class="comment">// 解压内容与原来的待压缩的内容，不匹配，终止压缩</span></span><br><span class="line">          abort_compression = <span class="literal">true</span>;</span><br><span class="line">          <span class="built_in">ROCKS_LOG_ERROR</span>(r-&gt;ioptions.logger,</span><br><span class="line">                          <span class="string">&quot;Decompressed block did not match raw block&quot;</span>);</span><br><span class="line">          *out_status =</span><br><span class="line">              Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Decompressed block did not match raw block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解压失败，终止压缩</span></span><br><span class="line">        *out_status = Status::<span class="built_in">Corruption</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Could not decompress: &quot;</span>) +</span><br><span class="line">                                         stat.<span class="built_in">getState</span>());</span><br><span class="line">        abort_compression = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// block 内容太多，无法一次性压缩，也要终止压缩</span></span><br><span class="line">    <span class="keyword">if</span> (is_data_block) &#123;</span><br><span class="line">      r-&gt;uncompressible_input_data_bytes.<span class="built_in">fetch_add</span>(raw_block_contents.<span class="built_in">size</span>(),</span><br><span class="line">                                                   std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    abort_compression = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 校验压缩结果</span></span><br><span class="line">  <span class="keyword">if</span> (abort_compression) &#123;</span><br><span class="line">    *type = kNoCompression;</span><br><span class="line">    *block_contents = raw_block_contents;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BGWorkWriteRawBlock"><a href="#BGWorkWriteRawBlock" class="headerlink" title="BGWorkWriteRawBlock"></a>BGWorkWriteRawBlock</h5><p>在<code>BGWorkCompression</code> 函数，我们可以看到，压缩线程主要有两个动作：</p>
<ul>
<li>先压缩 <code>data block</code>，并将相关信息记录在<code>block_rep</code>中</li>
<li>再将 <code>block_rep</code> 保存在 <code>block_rep-&gt;slot</code> 中</li>
</ul>
<p>此时呢，可以回顾下 <code>ParallelCompressionRep::EmitBlock</code> 函数，<code>block_rep-&gt;slot</code> 一开始就就加入到 <code>write_queue</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!write_queue.<span class="built_in">push</span>(block_rep-&gt;slot.<span class="built_in">get</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!compress_queue.<span class="built_in">push</span>(block_rep)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待压缩完成 </span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到 ReapBlock 函数调用</span></span><br><span class="line">    first_block_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">return</span> first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这说明什么？</p>
<p>如果前面的压缩部分没有完成，则当执行到<code>BGWorkWriteRawBlock</code> 函数时，会一直阻塞在：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot-&gt;<span class="built_in">Take</span>(block_rep);</span><br></pre></td></tr></table></figure>

<p>无论前面的 <code>CompressAndVerifyBlock</code>函数是否压缩成功，都需要调用<code>ReapBlock</code> 函数，以防止<code>EmitBlock</code>处产生死锁。</p>
<p>Of Course，若前面压缩成功，则还大致需要执行以下流程：</p>
<ul>
<li>先将当前<code>block</code>中的每个key添加到 <code>filter_builder</code>、<code>index_builder</code>；</li>
<li>再生成 <code>filter_block</code>、<code>idnex_block</code>；</li>
<li>将block压缩后的数据写入sst</li>
</ul>
<p>下面来看看细节。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::BGWorkWriteRawBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  ParallelCompressionRep::BlockRepSlot* slot = <span class="literal">nullptr</span>;</span><br><span class="line">  ParallelCompressionRep::BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (r-&gt;pc_rep-&gt;write_queue.<span class="built_in">pop</span>(slot)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(slot != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 阻塞于此，直到压缩完成，Take 函数才能返回</span></span><br><span class="line">    slot-&gt;<span class="built_in">Take</span>(block_rep);</span><br><span class="line">    <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!block_rep-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      r-&gt;<span class="built_in">SetStatus</span>(block_rep-&gt;status);</span><br><span class="line">      <span class="comment">// Flush() 中存在 Emit(), 需要 ReapBlock</span></span><br><span class="line">      block_rep-&gt;status = Status::<span class="built_in">OK</span>();</span><br><span class="line">      r-&gt;pc_rep-&gt;<span class="built_in">ReapBlock</span>(block_rep);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; block_rep-&gt;keys-&gt;<span class="built_in">Size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; key = (*block_rep-&gt;keys)[i];</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">size_t</span> ts_sz =</span><br><span class="line">            r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">         <span class="comment">// 为后面创建 filter block 准备</span></span><br><span class="line">        r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为后面创建 index block 准备</span></span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为后续重新估算 sst 文件大小准备</span></span><br><span class="line">    r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">SetCurrBlockRawSize</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将压缩后的数据写入sst</span></span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(block_rep-&gt;compressed_contents, <span class="comment">// 压缩的数据</span></span><br><span class="line">                 block_rep-&gt;compression_type,     <span class="comment">// 压缩类型</span></span><br><span class="line">                 &amp;r-&gt;pending_handle, </span><br><span class="line">                 <span class="literal">true</span> <span class="comment">/* is_data_block*/</span>,</span><br><span class="line">                 &amp;block_rep-&gt;contents);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">break</span>;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 基于前面添加的key，生成 filter block</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      r-&gt;filter_builder-&gt;<span class="built_in">StartBlock</span>(r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;props.data_size = r-&gt;<span class="built_in">get_offset</span>();</span><br><span class="line">    ++r-&gt;props.num_data_blocks;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 基于前面添加的key， 生成 index block</span></span><br><span class="line">    <span class="keyword">if</span> (block_rep-&gt;first_key_in_next_block == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 最后一个data block</span></span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;(block_rep-&gt;keys-&gt;<span class="built_in">Back</span>()), <span class="literal">nullptr</span>,</span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非最后一个data block</span></span><br><span class="line">      Slice first_key_in_next_block =</span><br><span class="line">          <span class="built_in">Slice</span>(*block_rep-&gt;first_key_in_next_block);</span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;(block_rep-&gt;keys-&gt;<span class="built_in">Back</span>()),</span><br><span class="line">                                      &amp;first_key_in_next_block,</span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 通知 ParallelCompressionRep::EmitBlock</span></span><br><span class="line">    r-&gt;pc_rep-&gt;<span class="built_in">ReapBlock</span>(block_rep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WriteRawBlock"><a href="#WriteRawBlock" class="headerlink" title="WriteRawBlock"></a>WriteRawBlock</h5><p>最后一步，就是要将压缩完的数据按照如下格式写入到sst文件中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block_data: uint8[n] <span class="comment"># block 存储的数据</span></span><br><span class="line"><span class="built_in">type</span>: uint8          <span class="comment"># 压缩类型</span></span><br><span class="line">crc: uint32          <span class="comment"># 校验和</span></span><br><span class="line">padding              <span class="comment"># 填充</span></span><br></pre></td></tr></table></figure>

<p>注意，<code>WriteRawBlock</code> 函数的传入的参数<code>handle</code> ，在函数返回时记录了关于block的两个元信息：</p>
<ul>
<li>此block在sst文件中存储的起始位置</li>
<li>此block压缩后的大小。</li>
</ul>
<p>这个参数，实际上由<code>Add（key, value）</code>函数中的<code>r-&gt;pending_handle</code>传入，后续写入<code>index builder</code>，建立<code>index block</code>，这个在后面会讲解。</p>
<p>下面，简洁了部分代码后如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteRawBlock</span><span class="params">(<span class="type">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           CompressionType type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           BlockHandle* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">bool</span> is_data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">const</span> Slice* raw_block_contents)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Status s = Status::<span class="built_in">OK</span>();</span><br><span class="line">  IOStatus io_s = IOStatus::<span class="built_in">OK</span>();</span><br><span class="line">  <span class="function">StopWatch <span class="title">sw</span><span class="params">(r-&gt;ioptions.clock, r-&gt;ioptions.stats, WRITE_RAW_BLOCK_MICROS)</span></span>;</span><br><span class="line">  <span class="comment">// 1. 初始化 handle</span></span><br><span class="line">  handle-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>());     <span class="comment">// block 在sst文件中的offset</span></span><br><span class="line">  handle-&gt;<span class="built_in">set_size</span>(block_contents.<span class="built_in">size</span>()); <span class="comment">// 这个block 压缩后的大小</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">io_status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="comment">// 2. 向sst文件中追加内容 block_contents</span></span><br><span class="line">  io_s = r-&gt;file-&gt;<span class="built_in">Append</span>(block_contents); </span><br><span class="line">  <span class="comment">// 3. 下面写入footer</span></span><br><span class="line">  <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="type">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;     <span class="comment">// 压缩类型</span></span><br><span class="line">    <span class="type">uint32_t</span> checksum = <span class="number">0</span>; <span class="comment">// 校验和</span></span><br><span class="line">    <span class="keyword">switch</span> (r-&gt;table_options.checksum) &#123;</span><br><span class="line">      <span class="comment">// 计算校验和</span></span><br><span class="line">      <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储校验和</span></span><br><span class="line">    <span class="built_in">EncodeFixed32</span>(trailer + <span class="number">1</span>, checksum);</span><br><span class="line">    <span class="built_in">assert</span>(io_s.<span class="built_in">ok</span>());</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(</span><br><span class="line">        <span class="string">&quot;BlockBasedTableBuilder::WriteRawBlock:TamperWithChecksum&quot;</span>,</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(trailer));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入 footer</span></span><br><span class="line">    io_s = r-&gt;file-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="comment">// 设置文件偏移量 : 当前偏移量 + block 数据大小 + footer </span></span><br><span class="line">      r-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>() + block_contents.<span class="built_in">size</span>() +</span><br><span class="line">                    kBlockTrailerSize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 填充</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;table_options.block_align &amp;&amp; is_data_block) &#123;</span><br><span class="line">        <span class="type">size_t</span> pad_bytes =</span><br><span class="line">            (r-&gt;alignment - ((block_contents.<span class="built_in">size</span>() + kBlockTrailerSize) &amp; (r-&gt;alignment - <span class="number">1</span>))) &amp;</span><br><span class="line">            (r-&gt;alignment - <span class="number">1</span>);</span><br><span class="line">        io_s = r-&gt;file-&gt;<span class="built_in">Pad</span>(pad_bytes);</span><br><span class="line">        <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="comment">// 填充后，重新更新文件偏移量</span></span><br><span class="line">          r-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>() + pad_bytes);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;<span class="built_in">SetIOStatus</span>(io_s);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5. 这个时候再重新计算文件大小</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_data_block) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">ReapBlock</span>(block_contents.<span class="built_in">size</span>(),</span><br><span class="line">                                                   r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">SetEstimatedFileSize</span>(r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r-&gt;<span class="built_in">SetIOStatus</span>(io_s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>() &amp;&amp; s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    r-&gt;<span class="built_in">SetStatus</span>(io_s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="StopParallelCompression"><a href="#StopParallelCompression" class="headerlink" title="StopParallelCompression"></a>StopParallelCompression</h4><p>和启动多线程部分相应，停止压缩线程、写线程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::StopParallelCompression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  rep_-&gt;pc_rep-&gt;compress_queue.<span class="built_in">finish</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : rep_-&gt;pc_rep-&gt;compress_thread_pool) &#123;</span><br><span class="line">    thread.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_queue.<span class="built_in">finish</span>();</span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_thread-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>好嘞，终于到了这里。</p>
<p>经过前面压缩部分的铺垫，相信这里会让你更加易懂。</p>
<p>每个key的编码信息中，都包含着一个<code>value_type</code>信息，关于<code>value_type</code>，详细地后续再说，这里一点，<code>IsValueType</code> 返回值为true，表示这对<code>&#123;k, v&#125;</code>可以写入到sst文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsValueType</span><span class="params">(ValueType t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt;= kTypeMerge || t == kTypeSingleDeletion || t == kTypeBlobIndex</span><br><span class="line">         || kTypeDeletionWithTimestamp == t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsExtendedValueType</span><span class="params">(ValueType t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">IsValueType</span>(t) || t == kTypeRangeDeletion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BlockBasedTableBuilder</code> 在添加<code>&#123;k, v&#125;</code>并写入到sst文件的过程，会经历三个阶段<code>State</code>。</p>
<h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  kBuffered,</span><br><span class="line">  kUnbuffered,</span><br><span class="line">  kClosed,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在<code>kBuffered</code>模式下，将待压缩、待写入sst文件的<code>data_block</code> 暂时缓存在<code>r-&gt;data_block_buffer</code>中。当缓存中的数据长度<code>r-&gt;data_begin_offset</code>超过限制<code>buffer_limit</code> 时，就会进入到<code>kUnbuffered</code>模式。</p>
<p>一旦进入到<code>kUnbuffered</code>，就不可逆转到<code>kBuffered</code>。最终只能在调用 <code>BlockBasedTableBuilder::Finish</code> 时进入<code>kClosed</code>模式。</p>
<h4 id="should-flush"><a href="#should-flush" class="headerlink" title="should_flush"></a>should_flush</h4><p>每个<code>BlockBasedTableBuilder</code>  中都有个刷新策略<code>r-&gt;flush_block_policy</code>：将当前<code>&#123;k, v&#125;</code>添加到 <code>r-&gt;data_block</code>，若会触发更新，则会先将当前 <code>r-&gt;data_block</code> 的数据进行<code>flush</code>：</p>
<ul>
<li>若 <code>r-&gt;data_begin_offset &lt; r-&gt;buffer_limit</code>：暂时缓存到  <code>r-&gt;data_block_buffer</code>中；</li>
<li>否则，会先压缩，再写入sst文件。</li>
</ul>
<p>此外，由于多线程的压缩、写入sst的过程在相应的子线程中完成，当没有开启多线程时，一些细节需要在主线程中单独进行处理，因此在下面的代码中会经常看到下面的代码结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (r-&gt;IsParallelCompressionEnabled()) &#123; </span><br><span class="line">&#125; else &#123; </span><br><span class="line">  // 对单线程进行处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要理解了之前讲解的多线程逻辑，下面的<code>Add</code>函数会很好理解。</p>
<p>代码简略后如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 向 cur_block 中添加 &#123;key, value&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  ValueType value_type = <span class="built_in">ExtractValueType</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsValueType</span>(value_type)) &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要 flush</span></span><br><span class="line">    <span class="keyword">auto</span> should_flush = r-&gt;flush_block_policy-&gt;<span class="built_in">Update</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (should_flush) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(!r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">      r-&gt;first_key_in_next_block = &amp;key;</span><br><span class="line">      <span class="built_in">Flush</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从 kBuffer 模式进入 kUnbuffered 模式</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered </span><br><span class="line">          &amp;&amp; r-&gt;buffer_limit != <span class="number">0</span> </span><br><span class="line">          &amp;&amp;r-&gt;data_begin_offset &gt; r-&gt;buffer_limit) &#123;</span><br><span class="line">        <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 单线程：在 index builder 中添加一个 &#123;k, pending_handle&#125; </span></span><br><span class="line">          <span class="comment">// 其中 pending_handle 记录了写入sst的位置及大小</span></span><br><span class="line">          r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;r-&gt;last_key, </span><br><span class="line">                                          &amp;key,</span><br><span class="line">                                          r-&gt;pending_handle);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> PartitionedFilterBlockBuilder 需要在 key先添加到 index builder 之后，</span></span><br><span class="line">    <span class="comment">//       再添加到 PartitionedFilterBlockBuilder 中</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">PushBack</span>(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 单线程：在 filter builder 中添加一个记录</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="type">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">          r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 更新当前data_block的last_key</span></span><br><span class="line">    r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 添加 &#123;k, v&#125; 到当前 data_block</span></span><br><span class="line">    r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">      <span class="comment">// Buffered keys will be replayed from data_block_buffers during</span></span><br><span class="line">      <span class="comment">// `Finish()` once compression dictionary has been finalized.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        <span class="comment">// 单线程</span></span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NotifyCollectTableCollectorsOnAdd</span>(key, value, r-&gt;<span class="built_in">get_offset</span>(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_type == kTypeRangeDeletion) &#123;</span><br><span class="line">    r-&gt;range_del_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="built_in">NotifyCollectTableCollectorsOnAdd</span>(key, value, r-&gt;<span class="built_in">get_offset</span>(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 统计</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h4 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h4><p>在<code>Flush</code> 函数中，针对多线程和单线程两种模式：</p>
<ul>
<li>如果开启了多线程 &amp;&amp; 已经处于 <code>kUnbuffered</code> 模式，则调用多线程压缩、写入sst文件。</li>
<li>否则，直接调用单线程的压缩写入。</li>
</ul>
<p>下面来看看源码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">    <span class="comment">// 序列化 r-&gt;data_block 中的数据</span></span><br><span class="line">    r-&gt;data_block.<span class="built_in">Finish</span>();</span><br><span class="line">    <span class="comment">// 利用 r-&gt;data_block 中的数据生成 block_rep</span></span><br><span class="line">    ParallelCompressionRep::BlockRep* block_rep = r-&gt;pc_rep-&gt;<span class="built_in">PrepareBlock</span>(</span><br><span class="line">        r-&gt;compression_type, r-&gt;first_key_in_next_block, &amp;(r-&gt;data_block));</span><br><span class="line">    <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 此时，r-&gt;data_block 中是空的了</span></span><br><span class="line">    <span class="built_in">assert</span>(r-&gt;data_block.<span class="built_in">emoty</span>());</span><br><span class="line">    <span class="comment">// 在压缩前，估计下 sst 文件大小</span></span><br><span class="line">    r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">EmitBlock</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                             r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">    <span class="comment">// 将 data_block 送入压缩线程，后台线程会压缩、写入sst文件</span></span><br><span class="line">    r-&gt;pc_rep-&gt;<span class="built_in">EmitBlock</span>(block_rep);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 单线程压缩</span></span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle, <span class="literal">true</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="WriteBlock"><a href="#WriteBlock" class="headerlink" title="WriteBlock"></a>WriteBlock</h5><p>调用 <code>WriteBlock</code> 函数，不仅会来自于上面的 <code>Flush</code> 函数，还有会后面的<code>WriteIndexBlock</code>、<code>EnterUnbuffered</code>函数等。因此，<code>WriteBlock</code> 函数做了统一接口，来应对 <code>State::kBuffered</code> 和 <code>State::kUnBuffered</code>两种状态。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteBlock</span><span class="params">(BlockBuilder* block,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        BlockHandle* handle,  <span class="comment">// 正在pending的</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">bool</span> is_data_block)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 序列化 block 中的数据</span></span><br><span class="line">  block-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">  std::string raw_block_contents;</span><br><span class="line">  <span class="comment">// 将block序列化后的内容swap到 raw_block_contents 中</span></span><br><span class="line">  block-&gt;<span class="built_in">SwapAndReset</span>(raw_block_contents);</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">    <span class="comment">// 只有 data_block 存在 kbuffered 模式</span></span><br><span class="line">    <span class="built_in">assert</span>(is_data_block);</span><br><span class="line">    <span class="comment">// 将数据先写入 data_block_buffers</span></span><br><span class="line">    rep_-&gt;data_block_buffers.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(raw_block_contents));</span><br><span class="line">    rep_-&gt;data_begin_offset += rep_-&gt;data_block_buffers.<span class="built_in">back</span>().<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="comment">// else 就是 KUnBuffer 模式 </span></span><br><span class="line">  <span class="built_in">WriteBlock</span>(raw_block_contents, handle, is_data_block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="WriteBlock-1"><a href="#WriteBlock-1" class="headerlink" title="WriteBlock"></a>WriteBlock</h5><p>重载形式的<code>WriteBlock</code> ，只用于单线程压缩（没有写入sst文件的操作），且<code>BlockBasedTableBuilder</code>当前处于<code>kUnbuffered</code>模式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 用于 kUnbuffered 模式：单线程压缩</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteBlock</span><span class="params">(<span class="type">const</span> Slice&amp; raw_block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        BlockHandle* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">bool</span> is_data_block)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state == Rep::State::kUnbuffered);</span><br><span class="line">  Slice block_contents;</span><br><span class="line">  CompressionType type;</span><br><span class="line">  Status compress_status;</span><br><span class="line">  <span class="comment">// 进行压缩</span></span><br><span class="line">  <span class="built_in">CompressAndVerifyBlock</span>(raw_block_contents, </span><br><span class="line">                         is_data_block,</span><br><span class="line">                         *(r-&gt;compression_ctxs[<span class="number">0</span>]), </span><br><span class="line">                         r-&gt;verify_ctxs[<span class="number">0</span>].<span class="built_in">get</span>(),</span><br><span class="line">                         &amp;(r-&gt;compressed_output), </span><br><span class="line">                         &amp;(block_contents), </span><br><span class="line">                         &amp;type,</span><br><span class="line">                         &amp;compress_status);</span><br><span class="line">  r-&gt;<span class="built_in">SetStatus</span>(compress_status);</span><br><span class="line">  <span class="comment">// 如果压缩不成功</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="EnterUnbuffered"><a href="#EnterUnbuffered" class="headerlink" title="EnterUnbuffered"></a>EnterUnbuffered</h4><p><code>EnterUnbuffered</code>函数，将<code>BlockBasedTableBuilder</code>的状态，从<code>kBuffered</code>推向<code>kUnBuffered</code>，仅会执行一次。</p>
<p>那么这个函数的使命？</p>
<p>我们知道在 <code>kBuffered</code> 模式下，每次调用<code>Flush</code>函数时，都是将<code>r-&gt;data_block</code>的数据缓存到<code>r-&gt;data_block_buffers</code>。</p>
<p>当从<code>kBuffered</code>专向<code>kUnBuffered</code>时，很自然，就需要让<code>r-&gt;data_block_buffers</code> 中的数据也经历两个过程：</p>
<ul>
<li>压缩</li>
<li>写入sst</li>
</ul>
<p>带着这个思路，下面的代码就很好理解。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::EnterUnbuffered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state == Rep::State::kBuffered);</span><br><span class="line">  r-&gt;state = Rep::State::kUnbuffered;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 获得 r-&gt;data_block_buffers[i] 的读迭代器</span></span><br><span class="line">  <span class="keyword">auto</span> get_iterator_for_block = [&amp;r](<span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; data_block = r-&gt;data_block_buffers[i];</span><br><span class="line">    <span class="built_in">assert</span>(!data_block.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">    Block reader&#123;BlockContents&#123;data_block&#125;&#125;;</span><br><span class="line">    DataBlockIter* iter = reader.<span class="built_in">NewDataIterator</span>(r-&gt;internal_comparator.<span class="built_in">user_comparator</span>(), </span><br><span class="line">                                                 kDisableGlobalSequenceNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到这个 data_block 的起始处</span></span><br><span class="line">    iter-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">    <span class="built_in">assert</span>(iter-&gt;<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;DataBlockIter&gt;(iter);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;DataBlockIter&gt; iter = <span class="literal">nullptr</span>, next_block_iter = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; <span class="built_in">ok</span>() &amp;&amp; i &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 初始化迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter = <span class="built_in">get_iterator_for_block</span>(i);</span><br><span class="line">      <span class="built_in">assert</span>(iter != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个 data_block 的迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      next_block_iter = <span class="built_in">get_iterator_for_block</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 data_block</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; data_block = r-&gt;data_block_buffers[i];</span><br><span class="line">		</span><br><span class="line">    <span class="comment">/*** 下面对data_block进行压缩、写入***/</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">      <span class="comment">/*** 开启了多线程压缩 ***/</span></span><br><span class="line">      </span><br><span class="line">      Slice first_key_in_next_block;</span><br><span class="line">      <span class="type">const</span> Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">// 下一个 data_block 的第一个key</span></span><br><span class="line">        first_key_in_next_block = next_block_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// r-&gt;first_key_in_next_block </span></span><br><span class="line">        <span class="comment">// 即处于 kUnBuffered 状态的 data_block 第一个key</span></span><br><span class="line">        first_key_in_next_block_ptr = r-&gt;first_key_in_next_block;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 迭代当前 data_block, 将所有的key，全部添加到 keys</span></span><br><span class="line">      std::vector&lt;std::string&gt; keys;</span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">        keys.<span class="built_in">emplace_back</span>(iter-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>());</span><br><span class="line">      &#125;</span><br><span class="line">			</span><br><span class="line">      <span class="comment">// 生成 block_req </span></span><br><span class="line">      ParallelCompressionRep::BlockRep* block_rep = r-&gt;pc_rep-&gt;<span class="built_in">PrepareBlock</span>(</span><br><span class="line">          r-&gt;compression_type, first_key_in_next_block_ptr, &amp;data_block, &amp;keys);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="comment">// 在发送前，估计下sst文件大小</span></span><br><span class="line">      r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">EmitBlock</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">      <span class="comment">// 发送至压缩线程</span></span><br><span class="line">      r-&gt;pc_rep-&gt;<span class="built_in">EmitBlock</span>(block_rep);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*** 没有开启多线程压缩 ***/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// fileter block，index block</span></span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">        Slice key = iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="type">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">          r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(<span class="built_in">Slice</span>(data_block),</span><br><span class="line">                 &amp;r-&gt;pending_handle,  <span class="comment">// 记录了 data_block 在文件中的位置及其大小</span></span><br><span class="line">                 <span class="literal">true</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//! 此for循环，不包含最后一个data block</span></span><br><span class="line">      <span class="comment">//! 因此，在 ::Finish 函数中，需要为最后一个 data block 单独调用一次 AddIndexEntry</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        Slice first_key_in_next_block = next_block_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line"></span><br><span class="line">        Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line"></span><br><span class="line">        iter-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">        std::string last_key = iter-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>();</span><br><span class="line">        <span class="comment">// 添加一个 &#123;key, handle&#125;</span></span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;last_key, first_key_in_next_block_ptr,</span><br><span class="line">                                        r-&gt;pending_handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** 遍历完当前 data_block ***/</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">swap</span>(iter, next_block_iter);</span><br><span class="line">  &#125; <span class="comment">// 遍历完所有的 data_block</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 清除数据</span></span><br><span class="line">  r-&gt;data_block_buffers.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p>在前文说过，一个table序列化到sst文件的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beginning_of_file&gt;</span><br><span class="line">[data block 1]</span><br><span class="line">[data block 2]</span><br><span class="line">...</span><br><span class="line">[data block N]</span><br><span class="line">[meta block 1: filter block]                 </span><br><span class="line">[meta block 2: index block]</span><br><span class="line">[meta block 3: compression dictionary block]</span><br><span class="line">[meta block 4: range deletion block]        </span><br><span class="line">[meta block 5: stats block]</span><br><span class="line">...</span><br><span class="line">[meta block K: future extended block]</span><br><span class="line">[metaindex block]</span><br><span class="line">[Footer]</span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure>

<p>当调用<code>::Finish</code>函数时，<code>data block</code>部分已经构建完毕，下面就需要开始构建<code>meta block</code> 。</p>
<h4 id="MetaIndexBuilder"><a href="#MetaIndexBuilder" class="headerlink" title="MetaIndexBuilder"></a>MetaIndexBuilder</h4><p>前面的<code>filter block</code>、<code>index block</code>、<code>compression dictionary block</code>、<code>range deletion block</code>、<code>prop block</code>等记录着<code>data block</code>各种信息，我们把这些记录<code>data block</code>信息的<code>block</code>统一叫做<code>meta block</code>。所谓<code>meta</code>，即信息的信息。</p>
<p><code>MetaIndexBuilder</code>，则用于存储前面这些<code>meta block</code>在sst中的存储位置及其大小，最终用于构建整个<code>Table</code>的<code>footer</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaIndexBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MetaIndexBuilder</span>()</span><br><span class="line">  : <span class="built_in">meta_index_block_</span>(<span class="keyword">new</span> <span class="built_in">BlockBuilder</span>(<span class="number">1</span> <span class="comment">/* restart interval */</span>)) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">MetaIndexBuilder</span>(<span class="type">const</span> MetaIndexBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MetaIndexBuilder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MetaIndexBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 添加 &#123;k, v&#125;</span></span><br><span class="line">  <span class="comment">/// handle 中记录了指向的 meta block 在sst中的位置及其大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> BlockHandle&amp; handle)</span> </span>&#123; </span><br><span class="line">     std::string handle_encoding;</span><br><span class="line">     handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding); <span class="comment">// 编码为字符串</span></span><br><span class="line">     meta_block_handles_.<span class="built_in">emplace</span>(key, std::<span class="built_in">move</span>(handle_encoding));</span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="comment">/// 将所有添加到 meta_block_handles_ 中的&#123;k, v&#125; 序列化后返回</span></span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span> </span>&#123; </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; metablock : meta_block_handles_) &#123;</span><br><span class="line">       meta_index_block_-&gt;<span class="built_in">Add</span>(metablock.first, metablock.second);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> meta_index_block_-&gt;<span class="built_in">Finish</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  stl_wrappers::KVMap meta_block_handles_;          <span class="comment">// 存着所有meta block的信息</span></span><br><span class="line">  std::unique_ptr&lt;BlockBuilder&gt; meta_index_block_;  <span class="comment">// 由这些meta block的元信息构建的block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>有了这个思路，下面，就可以先来看看整体代码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BlockBasedTableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="type">bool</span> empty_data_block = r-&gt;data_block.<span class="built_in">empty</span>();</span><br><span class="line">  <span class="comment">// 在flush时，暗示最后一个data block</span></span><br><span class="line">  r-&gt;first_key_in_next_block = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// flush最后一个data block</span></span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">  <span class="comment">// 如果状态不是 kUnBuffered，则直接进入</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">    <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">StopParallelCompression</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对于单线程，EnterUnbuffered 函数没发为最后一个 data block 建立 index </span></span><br><span class="line">    <span class="comment">// 因此，需要手动添加</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_data_block) &#123;</span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;r-&gt;last_key, </span><br><span class="line">                                     <span class="literal">nullptr</span> <span class="comment">/* no next data block */</span>, </span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 开始构建 meta-block</span></span><br><span class="line">  BlockHandle metaindex_block_handle, index_block_handle;</span><br><span class="line">  MetaIndexBuilder meta_index_builder;</span><br><span class="line">  <span class="built_in">WriteFilterBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WriteIndexBlock</span>(&amp;meta_index_builder, &amp;index_block_handle);</span><br><span class="line">  <span class="built_in">WriteCompressionDictBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WriteRangeDelBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WritePropertiesBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 将meta-block写入sst文件</span></span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(meta_index_builder.<span class="built_in">Finish</span>(), kNoCompression,</span><br><span class="line">                  &amp;metaindex_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// metaindex_block_handle 记录着 meta-block的信息</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">WriteFooter</span>(metaindex_block_handle, index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;state = Rep::State::kClosed;</span><br><span class="line">  r-&gt;<span class="built_in">SetStatus</span>(r-&gt;<span class="built_in">CopyIOStatus</span>());</span><br><span class="line">  Status ret_status = r-&gt;<span class="built_in">CopyStatus</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!ret_status.<span class="built_in">ok</span>() || <span class="built_in">io_status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="keyword">return</span> ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WriteFilterBlock"><a href="#WriteFilterBlock" class="headerlink" title="WriteFilterBlock"></a>WriteFilterBlock</h4><p><code>WriteFilterBlock</code>函数的逻辑如下：</p>
<ul>
<li>如果不是 <code>PartitionFilterBuilder</code>，则直接将整个<code>FilterBuiler</code>构建的数据，在直接序列化后写入sst文件。</li>
<li>如果是<code>PartitionFilterBuilder</code>，则以<code>partition</code>为单位，逐个写入到sst文件；</li>
<li>等上述过程完毕，再将将此 <code>FilterBuilder</code> 的属性作为<code>&#123;k, v&#125;</code>添加到 <code>meta_index_builder</code>中：<ul>
<li><code>k</code>：是<code>FilterBuilderType.FilterPolicyName</code>；</li>
<li><code>v</code>：是写入sst文件的<code>filter block</code>的元信息。</li>
</ul>
</li>
</ul>
<p>代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteFilterBlock</span><span class="params">(MetaIndexBuilder* meta_index_builder)</span> </span>&#123;</span><br><span class="line">  BlockHandle filter_block_handle;</span><br><span class="line">  <span class="type">bool</span> empty_filter_block =</span><br><span class="line">      (rep_-&gt;filter_builder == <span class="literal">nullptr</span> || rep_-&gt;filter_builder-&gt;<span class="built_in">IsEmpty</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_filter_block) &#123;</span><br><span class="line">    <span class="comment">// 添加的key数</span></span><br><span class="line">    rep_-&gt;props.num_filter_entries +=</span><br><span class="line">        rep_-&gt;filter_builder-&gt;<span class="built_in">EstimateEntriesAdded</span>();</span><br><span class="line">    Status s = Status::<span class="built_in">Incomplete</span>();</span><br><span class="line">    <span class="comment">// 如果是 PartitionFilterBuilder</span></span><br><span class="line">    <span class="comment">// 返回值是 IsIncomplete</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ok</span>() &amp;&amp; s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">      <span class="comment">// 此处的 filter_block_handle 表示上一个partition的handle</span></span><br><span class="line">      Slice filter_content =</span><br><span class="line">          rep_-&gt;filter_builder-&gt;<span class="built_in">Finish</span>(filter_block_handle, &amp;s);</span><br><span class="line">      <span class="built_in">assert</span>(s.<span class="built_in">ok</span>() || s.<span class="built_in">IsIncomplete</span>());</span><br><span class="line">      rep_-&gt;props.filter_size += filter_content.<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">// filter_content : 当前 filter partition 的内容</span></span><br><span class="line">      <span class="comment">// filter_block_handle : 记录该 partition 在sst中大小及偏移量</span></span><br><span class="line">      <span class="built_in">WriteRawBlock</span>(filter_content, kNoCompression, &amp;filter_block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*** 全部写入sst ***/</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_filter_block) &#123;</span><br><span class="line">    <span class="comment">// 获取 FilterBuilder 的名字</span></span><br><span class="line">    std::string key;</span><br><span class="line">    <span class="keyword">if</span> (rep_-&gt;filter_builder-&gt;<span class="built_in">IsBlockBased</span>()) &#123;</span><br><span class="line">      key = BlockBasedTable::kFilterBlockPrefix;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      key = rep_-&gt;table_options.partition_filters</span><br><span class="line">                ? BlockBasedTable::kPartitionedFilterBlockPrefix</span><br><span class="line">                : BlockBasedTable::kFullFilterBlockPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 FilterPolicy 的名字</span></span><br><span class="line">    key.<span class="built_in">append</span>(rep_-&gt;table_options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">    <span class="comment">// 添加元信息</span></span><br><span class="line">    meta_index_builder-&gt;<span class="built_in">Add</span>(key, filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WriteIndexBlock"><a href="#WriteIndexBlock" class="headerlink" title="WriteIndexBlock"></a>WriteIndexBlock</h4><p>由前文可知，<code>IndexBuiler</code>对外提供了两种：</p>
<ul>
<li>HashIndexBuilder</li>
<li>PartitionIndexBuiler</li>
</ul>
<p>无论是哪种，最后的<code>index block</code>结果都是由 <code>IndexBuilder::IndexBlocks::index_block_contents</code> 保存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexBuilder</span>::IndexBlocks &#123;</span><br><span class="line">  Slice index_block_contents;</span><br><span class="line">  std::unordered_map&lt;std::string, Slice&gt; meta_blocks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>区别在于：</p>
<ul>
<li><code>PartitionIndexBuiler</code> 有很多个partition，而且这个partition的数量和 PartitionFilterBuilder 中的 partition 的数量一致。而<code>HashIndexBuilder</code>可等效的看做只有一个partition；</li>
<li><code>IndexBuilder::IndexBlocks::meta_blocks</code> 字段仅有<code>HashIndexBuilder</code>使用。</li>
</ul>
<p>因此，<code>WriteIndexBlock</code> 函数的最终目的也是将所有<code>partitions</code>的内容写入sst。写入sst的所有信息都记录在<code>index_block_handle</code>中，这用于后续的<code>footer</code>。</p>
<p>下面，带着上述理解，并顺着代码注释来阅读源码。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param index_block_handle 用于记录 partition 的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteIndexBlock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MetaIndexBuilder* meta_index_builder, BlockHandle* index_block_handle)</span> </span>&#123;</span><br><span class="line">  IndexBuilder::IndexBlocks index_blocks;</span><br><span class="line">  <span class="comment">// 可等效看做获取 first partition 的内容</span></span><br><span class="line">  <span class="keyword">auto</span> index_builder_status = rep_-&gt;index_builder-&gt;<span class="built_in">Finish</span>(&amp;index_blocks);</span><br><span class="line">  <span class="keyword">if</span> (index_builder_status.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">    <span class="comment">// meta_blocks 仅用于 HashIndexBuilder，在 PartitionIndexBuilder 下不支持</span></span><br><span class="line">    <span class="built_in">assert</span>(index_blocks.meta_blocks.<span class="built_in">empty</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !index_builder_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    rep_-&gt;<span class="built_in">SetStatus</span>(index_builder_status);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 这一部分是针对 HashIndexBuilder</span></span><br><span class="line">    <span class="comment">// item: &#123;name, content&#125;</span></span><br><span class="line">    <span class="comment">//  + &#123;hashindex.prefixes, prefix_block_&#125;</span></span><br><span class="line">    <span class="comment">//  + &#123;&quot;rocksdb.hashindex.metadata&quot;, prefix_meta_block_&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : index_blocks.meta_blocks) &#123;</span><br><span class="line">      BlockHandle block_handle;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(item.second, &amp;block_handle, <span class="literal">false</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      meta_index_builder-&gt;<span class="built_in">Add</span>(item.first, block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这一部分是通用的</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// first patition </span></span><br><span class="line">    <span class="keyword">if</span> (rep_-&gt;table_options.enable_index_compression) &#123;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(index_blocks.index_block_contents, index_block_handle, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">WriteRawBlock</span>(index_blocks.index_block_contents, kNoCompression,</span><br><span class="line">                    index_block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面是针对 PartitionIndexBuiler </span></span><br><span class="line">  <span class="keyword">if</span> (index_builder_status.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">    Status s = Status::<span class="built_in">Incomplete</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ok</span>() &amp;&amp; s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">      <span class="comment">// index_block_handle 表示上一个 partition</span></span><br><span class="line">      s = rep_-&gt;index_builder-&gt;<span class="built_in">Finish</span>(&amp;index_blocks, *index_block_handle);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>() &amp;&amp; !s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">        rep_-&gt;<span class="built_in">SetStatus</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将每个partition写入sst文件</span></span><br><span class="line">      <span class="keyword">if</span> (rep_-&gt;table_options.enable_index_compression) &#123;</span><br><span class="line">        <span class="built_in">WriteBlock</span>(index_blocks.index_block_contents, index_block_handle,</span><br><span class="line">                   <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">WriteRawBlock</span>(index_blocks.index_block_contents, kNoCompression,</span><br><span class="line">                      index_block_handle);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The last index_block_handle will be for the partition index block</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WriteFooter"><a href="#WriteFooter" class="headerlink" title="WriteFooter"></a>WriteFooter</h4><p>最后就是写入footer。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteFooter</span><span class="params">(BlockHandle&amp; metaindex_block_handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         BlockHandle&amp; index_block_handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="type">bool</span> legacy = (r-&gt;table_options.format_version == <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;table_options.checksum == kCRC32c ||</span><br><span class="line">         r-&gt;table_options.format_version != <span class="number">0</span>);</span><br><span class="line">  <span class="function">Footer <span class="title">footer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      legacy ? kLegacyBlockBasedTableMagicNumber : kBlockBasedTableMagicNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">      r-&gt;table_options.format_version)</span></span>;</span><br><span class="line">  footer.<span class="built_in">set_metaindex_handle</span>(metaindex_block_handle);</span><br><span class="line">  footer.<span class="built_in">set_index_handle</span>(index_block_handle);</span><br><span class="line">  footer.<span class="built_in">set_checksum</span>(r-&gt;table_options.checksum);</span><br><span class="line">  std::string footer_encoding;</span><br><span class="line">  footer.<span class="built_in">EncodeTo</span>(&amp;footer_encoding);</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">ok</span>());</span><br><span class="line">  <span class="comment">// 最后在此写入</span></span><br><span class="line">  IOStatus ios = r-&gt;file-&gt;<span class="built_in">Append</span>(footer_encoding);</span><br><span class="line">  <span class="keyword">if</span> (ios.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    r-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>() + footer_encoding.<span class="built_in">size</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r-&gt;<span class="built_in">SetIOStatus</span>(ios);</span><br><span class="line">    r-&gt;<span class="built_in">SetStatus</span>(ios);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>








  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockBasedTableBuilder-ParallelCompressionRep"><span class="toc-number">1.</span> <span class="toc-text">BlockBasedTableBuilder::ParallelCompressionRep</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Keys"><span class="toc-number">1.1.</span> <span class="toc-text">Keys</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WorkQueue"><span class="toc-number">1.2.</span> <span class="toc-text">WorkQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#push"><span class="toc-number">1.2.1.</span> <span class="toc-text">push</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pop"><span class="toc-number">1.2.2.</span> <span class="toc-text">pop</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#waitUntilFinished"><span class="toc-number">1.2.3.</span> <span class="toc-text">waitUntilFinished</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#finish"><span class="toc-number">1.2.4.</span> <span class="toc-text">finish</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockRepSlot"><span class="toc-number">1.3.</span> <span class="toc-text">BlockRepSlot</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileSizeEstimator"><span class="toc-number">1.4.</span> <span class="toc-text">FileSizeEstimator</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EmitBlock"><span class="toc-number">1.4.1.</span> <span class="toc-text">EmitBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReapBlock"><span class="toc-number">1.4.2.</span> <span class="toc-text">ReapBlock</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ParallelCompressionRep"><span class="toc-number">1.5.</span> <span class="toc-text">ParallelCompressionRep</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PrepareBlockInternal"><span class="toc-number">1.5.1.</span> <span class="toc-text">PrepareBlockInternal</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TODO"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">TODO</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PrepareBlock"><span class="toc-number">1.5.2.</span> <span class="toc-text">PrepareBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PrepareBlock-1"><span class="toc-number">1.5.3.</span> <span class="toc-text">PrepareBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EmitBlock-1"><span class="toc-number">1.5.4.</span> <span class="toc-text">EmitBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ReapBlock-1"><span class="toc-number">1.5.5.</span> <span class="toc-text">ReapBlock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#TODO-1"><span class="toc-number">1.5.5.1.</span> <span class="toc-text">TODO</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BlockBasedTableBuilder"><span class="toc-number">2.</span> <span class="toc-text">BlockBasedTableBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ParallelCompression"><span class="toc-number">2.1.</span> <span class="toc-text">ParallelCompression</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#IsParallelCompressionEnabled"><span class="toc-number">2.1.1.</span> <span class="toc-text">IsParallelCompressionEnabled</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StartParallelCompression"><span class="toc-number">2.1.2.</span> <span class="toc-text">StartParallelCompression</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#BGWorkCompression"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">BGWorkCompression</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CompressAndVerifyBlock"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">CompressAndVerifyBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BGWorkWriteRawBlock"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">BGWorkWriteRawBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WriteRawBlock"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">WriteRawBlock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StopParallelCompression"><span class="toc-number">2.1.3.</span> <span class="toc-text">StopParallelCompression</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Add"><span class="toc-number">2.2.</span> <span class="toc-text">Add</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#State"><span class="toc-number">2.2.1.</span> <span class="toc-text">State</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#should-flush"><span class="toc-number">2.2.2.</span> <span class="toc-text">should_flush</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Flush"><span class="toc-number">2.2.3.</span> <span class="toc-text">Flush</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#WriteBlock"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">WriteBlock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#WriteBlock-1"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">WriteBlock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EnterUnbuffered"><span class="toc-number">2.2.4.</span> <span class="toc-text">EnterUnbuffered</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Finish"><span class="toc-number">2.3.</span> <span class="toc-text">Finish</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#MetaIndexBuilder"><span class="toc-number">2.3.1.</span> <span class="toc-text">MetaIndexBuilder</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WriteFilterBlock"><span class="toc-number">2.3.2.</span> <span class="toc-text">WriteFilterBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WriteIndexBlock"><span class="toc-number">2.3.3.</span> <span class="toc-text">WriteIndexBlock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WriteFooter"><span class="toc-number">2.3.4.</span> <span class="toc-text">WriteFooter</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&text=BlockBasedTableBuilder 源码分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&title=BlockBasedTableBuilder 源码分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&is_video=false&description=BlockBasedTableBuilder 源码分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=BlockBasedTableBuilder 源码分析&body=Check out this article: https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&title=BlockBasedTableBuilder 源码分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&title=BlockBasedTableBuilder 源码分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&title=BlockBasedTableBuilder 源码分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&title=BlockBasedTableBuilder 源码分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&name=BlockBasedTableBuilder 源码分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/&t=BlockBasedTableBuilder 源码分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2026
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
