<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="MorselQueue 用于存放本次待读取的数据源 Morsels 集合，继承派生体系如下：  convert_scan_range_to_morsel_queueconvert_scan_range_to_morsel_queue 函数将本次带查询的数据源 scan_ranges 转换成 std::vector&lt;pipeline::Morsel&gt; 对象 morsels，并根据是否能开">
<meta property="og:type" content="article">
<meta property="og:title" content="Morsel 和 OlapSourceOperator (1)">
<meta property="og:url" content="https://szza.github.io/2023/07/02/Pipeline/MorselQueue/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="MorselQueue 用于存放本次待读取的数据源 Morsels 集合，继承派生体系如下：  convert_scan_range_to_morsel_queueconvert_scan_range_to_morsel_queue 函数将本次带查询的数据源 scan_ranges 转换成 std::vector&lt;pipeline::Morsel&gt; 对象 morsels，并根据是否能开">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-morsel-3.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-morsel-2.svg?raw=true">
<meta property="article:published_time" content="2023-07-02T08:00:02.000Z">
<meta property="article:modified_time" content="2023-08-12T09:24:49.084Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Pipeline">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-morsel-3.svg?raw=true">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>Morsel 和 OlapSourceOperator (1)</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2023/06/15/Paper/Columbia-Query-Optimizer-1/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&text=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&title=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&is_video=false&description=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Morsel 和 OlapSourceOperator (1)&body=Check out this article: https://szza.github.io/2023/07/02/Pipeline/MorselQueue/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&title=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&title=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&title=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&title=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&name=Morsel 和 OlapSourceOperator (1)&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&t=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#convert-scan-range-to-morsel-queue"><span class="toc-number">1.</span> <span class="toc-text">convert_scan_range_to_morsel_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#could-tablet-internal-parallel"><span class="toc-number">2.</span> <span class="toc-text">_could_tablet_internal_parallel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FixedMorselQueue"><span class="toc-number"></span> <span class="toc-text">FixedMorselQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FixedMorselQueue-try-get"><span class="toc-number">1.</span> <span class="toc-text">FixedMorselQueue::try_get</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SplitMorselQueue"><span class="toc-number"></span> <span class="toc-text">SplitMorselQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PhysicalSplitMorselQueue-try-get"><span class="toc-number">1.</span> <span class="toc-text">PhysicalSplitMorselQueue::try_get</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#next-segment"><span class="toc-number">1.1.</span> <span class="toc-text">_next_segment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inti-segment"><span class="toc-number">1.2.</span> <span class="toc-text">_inti_segment</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MorselQueueFactory"><span class="toc-number"></span> <span class="toc-text">MorselQueueFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#convert-scan-range-to-morsel-queue-factory"><span class="toc-number">1.</span> <span class="toc-text">convert_scan_range_to_morsel_queue_factory</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Morsel 和 OlapSourceOperator (1)
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-07-02T08:00:02.000Z" itemprop="datePublished">2023-07-02</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Timeline/">Timeline</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Pipeline/" rel="tag">Pipeline</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>MorselQueue 用于存放本次待读取的数据源 Morsels 集合，继承派生体系如下：</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-morsel-3.svg?raw=true" alt="Morsel-Queue"></p>
<h3 id="convert-scan-range-to-morsel-queue"><a href="#convert-scan-range-to-morsel-queue" class="headerlink" title="convert_scan_range_to_morsel_queue"></a>convert_scan_range_to_morsel_queue</h3><p><code>convert_scan_range_to_morsel_queue</code> 函数将本次带查询的数据源 <code>scan_ranges</code> 转换成 <code>std::vector&lt;pipeline::Morsel&gt;</code> 对象 <code>morsels</code>，并根据是否能开启 <code>Tablet</code> 选择具体的 MorselQueue 子类。</p>
<p>因此，区别在于 <code>morsels</code> 在 MorselQueue 内部怎么划分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;pipeline::MorselQueuePtr&gt; <span class="title">OlapScanNode::convert_scan_range_to_morsel_queue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;TScanRangeParams&gt;&amp; scan_ranges, <span class="type">int</span> node_id, <span class="type">int32_t</span> pipeline_dop,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> enable_tablet_internal_parallel, TTabletInternalParallelMode::type tablet_internal_parallel_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> num_total_scan_ranges)</span> </span>&#123;</span><br><span class="line">    pipeline::Morsels morsels;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; scan_range : scan_ranges) &#123;</span><br><span class="line">        morsels.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;pipeline::ScanMorsel&gt;(node_id, scan_range));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// None tablet to read shouldn&#x27;t use tablet internal parallel.</span></span><br><span class="line">    <span class="keyword">if</span> (morsels.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::FixedMorselQueue&gt;(std::<span class="built_in">move</span>(morsels));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable by the session variable shouldn&#x27;t use tablet internal parallel.</span></span><br><span class="line">    <span class="keyword">if</span> (!enable_tablet_internal_parallel) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::FixedMorselQueue&gt;(std::<span class="built_in">move</span>(morsels));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> scan_dop;</span><br><span class="line">    <span class="type">int64_t</span> splitted_scan_rows;</span><br><span class="line">    <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> could,</span><br><span class="line">                     _could_tablet_internal_parallel(scan_ranges, pipeline_dop, num_total_scan_ranges,</span><br><span class="line">                                                     tablet_internal_parallel_mode, &amp;scan_dop, &amp;splitted_scan_rows));</span><br><span class="line">    <span class="keyword">if</span> (!could) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::FixedMorselQueue&gt;(std::<span class="built_in">move</span>(morsels));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split tablet physically.</span></span><br><span class="line">    <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="type">bool</span> ok, _could_split_tablet_physically(scan_ranges));</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::PhysicalSplitMorselQueue&gt;(std::<span class="built_in">move</span>(morsels), scan_dop, splitted_scan_rows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::LogicalSplitMorselQueue&gt;(std::<span class="built_in">move</span>(morsels), scan_dop, splitted_scan_rows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="could-tablet-internal-parallel"><a href="#could-tablet-internal-parallel" class="headerlink" title="_could_tablet_internal_parallel"></a>_could_tablet_internal_parallel</h3><p>变量 <code>enable_tablet_internal_parallel</code> 为 true 时，只是建议开启 tablet 并行，能不能真开启还要使用 <em>_could_tablet_internal_parallel</em> 函数根据实际多个因素判断。</p>
<ul>
<li><p>主键模型开启了持久化索引 use_pk_index 为 false</p>
</li>
<li><p>tablet_internal_parallel_mode 默认值是 TTabletInternalParallelMode::AUTO，如果不是主动设置为 FORCE_SPLIT，并且实际的读取的 num_total_scan_ranges  &gt;&#x3D; 本次 Pipeline 的并行度 pipeline_dop， 也返回 false</p>
<p>  如果 num_total_scan_ranges &gt;&#x3D; pipeline_dop，则说明当前有非常多的 tablet 待读取，不应该再把划分，否则会导致很多竞争。</p>
</li>
<li><p>统计本次需要读取的行数 num_table_rows</p>
<p>  config::tablet_internal_parallel_max_splitted_scan_bytes，默认是 512M，是单次从一个 segment 文件中读取的最大字节数，_estimated_scan_row_bytes 本次要读取的所有字段类型的大小（即一行数据的大小），二者相除的结果 splitted_scan_rows 即单次从 segment 文件中读取的最大行数。</p>
<p>  再将 <strong>splitted_scan_rows</strong> 限制在 <em>[min_splitted_scan_rows, max_splitted_scan_rows]</em> 区间，</p>
<p>  先估计本次的 <strong>scan_dop</strong> &#x3D; num_table_rows &#x2F; splitted_scan_rows，再将 scan_dop 限制到 [1, pipeline_dop] 区间。</p>
<p>  只要 scan_dop &gt; pipeline_dop 或者 config::tablet_internal_parallel_min_scan_dop 本函数就返回 true。</p>
</li>
</ul>
<p>因此，如果函数返回 false 上层就直接启用 FixedMorselQueue 来粗存储本次数据源 Morsels，返回 true 则会使用 SplitMorseQueue。</p>
<p><em>scan_dop</em>, <em>splitted_scan_rows</em> 两个参数输出后再作为 SplitMorselQueue 的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">StatusOr&lt;<span class="type">bool</span>&gt; OlapScanNode::_could_tablet_internal_parallel(</span><br><span class="line">        <span class="type">const</span> std::vector&lt;TScanRangeParams&gt;&amp; scan_ranges, <span class="type">int32_t</span> pipeline_dop, <span class="type">size_t</span> num_total_scan_ranges,</span><br><span class="line">        TTabletInternalParallelMode::type tablet_internal_parallel_mode, <span class="type">int64_t</span>* scan_dop,</span><br><span class="line">        <span class="type">int64_t</span>* splitted_scan_rows) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_olap_scan_node.use_pk_index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> force_split = tablet_internal_parallel_mode == TTabletInternalParallelMode::type::FORCE_SPLIT;</span><br><span class="line">    <span class="comment">// The enough number of tablets shouldn&#x27;t use tablet internal parallel.</span></span><br><span class="line">    <span class="keyword">if</span> (!force_split &amp;&amp; num_total_scan_ranges &gt;= pipeline_dop) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> num_table_rows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tablet_scan_range : scan_ranges) &#123;</span><br><span class="line">        <span class="built_in">ASSIGN_OR_RETURN</span>(TabletSharedPtr tablet, <span class="built_in">get_tablet</span>(&amp;(tablet_scan_range.scan_range.internal_scan_range)));</span><br><span class="line">        num_table_rows += <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(tablet-&gt;<span class="built_in">num_rows</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// splitted_scan_rows is restricted in the range [min_splitted_scan_rows, max_splitted_scan_rows].</span></span><br><span class="line">    *splitted_scan_rows = config::tablet_internal_parallel_max_splitted_scan_bytes / _estimated_scan_row_bytes;</span><br><span class="line">    *splitted_scan_rows =</span><br><span class="line">            std::<span class="built_in">max</span>(config::tablet_internal_parallel_min_splitted_scan_rows,</span><br><span class="line">                     std::<span class="built_in">min</span>(*splitted_scan_rows, config::tablet_internal_parallel_max_splitted_scan_rows));</span><br><span class="line">    <span class="comment">// scan_dop is restricted in the range [1, dop].</span></span><br><span class="line">    *scan_dop = num_table_rows / *splitted_scan_rows;</span><br><span class="line">    *scan_dop = std::<span class="built_in">max</span>&lt;<span class="type">int64_t</span>&gt;(<span class="number">1</span>, std::<span class="built_in">min</span>&lt;<span class="type">int64_t</span>&gt;(*scan_dop, pipeline_dop));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (force_split) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> could = *scan_dop &gt;= pipeline_dop || *scan_dop &gt;= config::tablet_internal_parallel_min_scan_dop;</span><br><span class="line">    <span class="keyword">return</span> could;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="FixedMorselQueue"><a href="#FixedMorselQueue" class="headerlink" title="FixedMorselQueue"></a>FixedMorselQueue</h2><p>顾名思义，<code>FixedMorselQueue</code> 存储是固定数据量的 Morsels，<code>FixedMorselQueue::_morsels</code> 都是 ScanMorsel 对象（不是 ScanMorsel 的子类），即是以 tablet 为级别，后续 TabletReader 要从存储层查询该 _morsels[i] 指向的数据时，是需要 FullScan。</p>
<p>当从 OlapScanOperator 从存储层获得数据后，才会调用 <code>FixedMorselQueue::set_tablet_rowsets</code> 函数将数据赋值给 <code>_tablet_rowsets</code>，进而 ScanOperator::pull 就可以从 <code>FixedMorselQueue::try_get</code> 函数从 _tablet_rowsets 中获得数据，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FixedMorselQueue</span> <span class="keyword">final</span> : <span class="keyword">public</span> MorselQueue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FixedMorselQueue</span><span class="params">(Morsels&amp;&amp; morsels)</span></span></span><br><span class="line"><span class="function">            : _morsels(std::move(morsels)), _num_morsels(_morsels.size()), _pop_index(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FixedMorselQueue</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;TInternalScanRange*&gt; <span class="title">olap_scan_ranges</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_tablet_rowsets</span><span class="params">(<span class="type">const</span> std::vector&lt;std::vector&lt;RowsetSharedPtr&gt;&gt;&amp; tablet_rowsets)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _tablet_rowsets = tablet_rowsets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">num_original_morsels</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> _num_morsels; &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">max_degree_of_parallelism</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> _num_morsels; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> _unget_morsel == <span class="literal">nullptr</span> &amp;&amp; _pop_index &gt;= _num_morsels; &#125;</span><br><span class="line">    <span class="function">StatusOr&lt;MorselPtr&gt; <span class="title">try_get</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;fixed_morsel_queue&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Morsels _morsels;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> _num_morsels;</span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; _pop_index;</span><br><span class="line">    std::vector&lt;std::vector&lt;RowsetSharedPtr&gt;&gt; _tablet_rowsets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="FixedMorselQueue-try-get"><a href="#FixedMorselQueue-try-get" class="headerlink" title="FixedMorselQueue::try_get"></a>FixedMorselQueue::try_get</h3><p>FixedMorselQueue 是有可能在多个 Pipeline 线程之间共享，即共享数据源，多个 Pipelines 同时从 FixedMorselQueue 获取数据源信息。而 FixedMorselQueue::_morsels 大小在构造函数已经确定，且 FixedMorselQueue 内部不会再细分每个 morsel（和 SplitMorselQueue 的对比），因此可以将 FixedMorselQueue 设计成 LookFree 的数据结构，因此使用 _pop_index 来指向当前已经分配的 morsel 就能满足要求。</p>
<p>在 FixedMorselQueue::try_get 中，通 <strong>std::move</strong> 将 _morsels[idx]、_tablet_rowsets[idx] 中的数据转移给上层，这样不会破坏 _morsels、_tablet_rowsets 结构，在多线程只读场景下就不用 mutex 保护。当 _pop_index &#x3D;&#x3D; _num_morsels, _tablet_rowsets 和 _morsels 就是大小为 _num_morsels 的空壳。如此，也就实现了 LookFree。</p>
<p>源码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;MorselPtr&gt; <span class="title">FixedMorselQueue::try_get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 和 QueryCache 有关</span></span><br><span class="line">    <span class="keyword">if</span> (_unget_morsel != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(_unget_morsel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> idx = _pop_index.<span class="built_in">load</span>();</span><br><span class="line">    <span class="comment">// prevent _num_morsels from superfluous addition</span></span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= _num_morsels) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    idx = _pop_index.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; _num_morsels) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_tablet_rowsets.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _morsels[idx]-&gt;<span class="built_in">set_rowsets</span>(std::<span class="built_in">move</span>(_tablet_rowsets[idx]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(_morsels[idx]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="SplitMorselQueue"><a href="#SplitMorselQueue" class="headerlink" title="SplitMorselQueue"></a>SplitMorselQueue</h2><p>scan_dop 传递给 SplitMorselQueue::_degree_of_parallelism，后续用于生成 MorselQueueFactory。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SplitMorselQueue::<span class="built_in">SplitMorselQueue</span>(Morsels&amp;&amp; morsels, <span class="type">int64_t</span> degree_of_parallelism, <span class="type">int64_t</span> splitted_scan_rows)</span><br><span class="line">  : _morsels(std::<span class="built_in">move</span>(morsels)),</span><br><span class="line">    _num_original_morsels(_morsels.<span class="built_in">size</span>()),</span><br><span class="line">    _degree_of_parallelism(degree_of_parallelism),</span><br><span class="line">    _splitted_scan_rows(splitted_scan_rows) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>SplitMorselQueue 有两个子类，根据 _could_split_tablet_physically 函数来选择。只有在表类型是聚合模型（即 AGG_KEYS 或者 UNIQUE_KEYS）且数据尚未聚合完成（skip_aggr 为 false）时，该函数才会返回 false。</p>
<p>返回 true 时，选择 PhysicalSplitMorselQueue，否则选择 LogicalSplitMorselQueue 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StatusOr&lt;<span class="type">bool</span>&gt; OlapScanNode::_could_split_tablet_physically(<span class="type">const</span> std::vector&lt;TScanRangeParams&gt;&amp; scan_ranges) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// Keys type needn&#x27;t merge or aggregate.</span></span><br><span class="line">    <span class="built_in">ASSIGN_OR_RETURN</span>(TabletSharedPtr first_tablet, <span class="built_in">get_tablet</span>(&amp;(scan_ranges[<span class="number">0</span>].scan_range.internal_scan_range)));</span><br><span class="line">    KeysType keys_type = first_tablet-&gt;<span class="built_in">tablet_schema</span>().<span class="built_in">keys_type</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> skip_aggr = <span class="built_in">thrift_olap_scan_node</span>().is_preaggregation;</span><br><span class="line">    <span class="keyword">return</span> keys_type == PRIMARY_KEYS || keys_type == DUP_KEYS ||</span><br><span class="line">           ((keys_type == UNIQUE_KEYS || keys_type == AGG_KEYS) &amp;&amp; skip_aggr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="PhysicalSplitMorselQueue-try-get"><a href="#PhysicalSplitMorselQueue-try-get" class="headerlink" title="PhysicalSplitMorselQueue::try_get"></a>PhysicalSplitMorselQueue::try_get</h3><p>StarRocks 中数据持久化后文件的基本单位是 Segment，一个 Tablet 数据组织结构是 Tablet&#x2F;Rowset&#x2F;Segment，每次从 Segment 中读取的行数是 _splitted_scan_rows，因此可以将 PhysicalSplitMorselQueue::try_get 分为两个部分:</p>
<ol>
<li><p>检测 _cur_segment 是否为空，以及 _cur_segment 是还有剩余可读数据</p>
<p> 如果没有，则需要从磁盘中能读取下一个 Segment 文件，将其加载到内存中，生成 SegemntIterator 对象 <strong>_segment_range_iter</strong>，再进行下一步</p>
   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;MorselPtr&gt; <span class="title">PhysicalSplitMorselQueue::try_get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_tablet_idx &gt;= _tablets.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When it hasn&#x27;t initialized any segment,</span></span><br><span class="line">    <span class="comment">// or _segment_idx exceeds the segments of the current rowset,</span></span><br><span class="line">    <span class="comment">// or current segment is empty or finished,</span></span><br><span class="line">    <span class="comment">// we should pick up the next segment and init it.</span></span><br><span class="line">    <span class="keyword">while</span> (!_has_init_any_segment || _cur_segment() == <span class="literal">nullptr</span> || _cur_segment()-&gt;<span class="built_in">num_rows</span>() == <span class="number">0</span> ||</span><br><span class="line">           !_segment_range_iter.<span class="built_in">has_more</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_next_segment()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> status = _init_segment(); !status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="comment">// Morsel_queue cannot generate morsels after errors occurring.</span></span><br><span class="line">            _tablet_idx = _tablets.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>当仍有待读取的数据，则通过 <em>_segment_range_iter</em> 获取下一个批次数据（即 _splitted_scan_rows 行），如果剩余的数据不足 _splitted_scan_rows 行，则将剩余的数据合并到当前批次，（合并）生成一个 PhysicalSplitScanMorsel 对象，其中本次读取的元信息 <strong>{rowset, segment_id, token_range}</strong> 精确指示了本次要读取的数据位置，最终在读取数据时，用于初始化 <em>OlapChunkSource::_params</em> 参数的 <strong>rowid_range_option</strong> 字段。</p>
<p> 这里的 _tablet_rowsets[_tablet_idx] 就不能用 std::move 赋值给 Morsel 了，因为其他线程也要使用。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">StatusOr&lt;MorselPtr&gt; <span class="title">PhysicalSplitMorselQueue::try_get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">     <span class="comment">//... above code</span></span><br><span class="line"></span><br><span class="line">    vectorized::SparseRange taken_range;</span><br><span class="line">    _segment_range_iter.<span class="built_in">next_range</span>(_splitted_scan_rows, &amp;taken_range);</span><br><span class="line">    _num_segment_rest_rows -= taken_range.<span class="built_in">span_size</span>();</span><br><span class="line">    <span class="keyword">if</span> (_num_segment_rest_rows &lt; _splitted_scan_rows) &#123;</span><br><span class="line">        <span class="comment">// If there are too few rows left in the segment, take them all this time.</span></span><br><span class="line">        _segment_range_iter.<span class="built_in">next_range</span>(_splitted_scan_rows, &amp;taken_range);</span><br><span class="line">        _num_segment_rest_rows = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* scan_morsel = _cur_scan_morsel();</span><br><span class="line">    <span class="keyword">auto</span>* rowset = _cur_rowset();</span><br><span class="line">    <span class="keyword">auto</span> rowid_range = std::<span class="built_in">make_shared</span>&lt;vectorized::RowidRangeOption&gt;(</span><br><span class="line">            rowset-&gt;<span class="built_in">rowset_id</span>(), rowset-&gt;<span class="built_in">segments</span>()[_segment_idx]-&gt;<span class="built_in">id</span>(), std::<span class="built_in">move</span>(taken_range));</span><br><span class="line"></span><br><span class="line">    MorselPtr morsel = std::<span class="built_in">make_unique</span>&lt;PhysicalSplitScanMorsel&gt;(</span><br><span class="line">            scan_morsel-&gt;<span class="built_in">get_plan_node_id</span>(), *(scan_morsel-&gt;<span class="built_in">get_scan_range</span>()), std::<span class="built_in">move</span>(rowid_range));</span><br><span class="line">    morsel-&gt;<span class="built_in">set_rowsets</span>(_tablet_rowsets[_tablet_idx]);</span><br><span class="line">    _inc_num_splits(_is_last_split_of_current_morsel());</span><br><span class="line">    <span class="keyword">return</span> morsel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="next-segment"><a href="#next-segment" class="headerlink" title="_next_segment"></a>_next_segment</h4><p>寻找下个 <em>segment</em> 是比较简单的，依次按照 _tablet_idx&#x2F;_rowset_idx&#x2F;segment_id 递增的顺序。比如，如果当前 rowset 的 segments 读取完，则 ++rowset_id，切换到当前 tablet 的下一个 rowset，如果当前 tablet 的所有 rowsets 都读取完毕，则 ++tablet_id，切换到下一个 tablet。</p>
<p>当 tablet_id &gt;&#x3D; _tablets.size()，_next_segment 函数返回 false，表示所有数据都已经读取完毕。</p>
<p>这部分代码比较简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Rowset* PhysicalSplitMorselQueue::_cur_rowset() &#123;</span><br><span class="line">    <span class="keyword">return</span> _tablet_rowsets[_tablet_idx][_rowset_idx].<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Segment* PhysicalSplitMorselQueue::_cur_segment() &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; segments = _cur_rowset()-&gt;<span class="built_in">segments</span>();</span><br><span class="line">    <span class="keyword">return</span> _segment_idx &gt;= segments.<span class="built_in">size</span>() ? <span class="literal">nullptr</span> : segments[_segment_idx].<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> PhysicalSplitMorselQueue::_next_segment() &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(_num_segment_rest_rows == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_has_init_any_segment) &#123;</span><br><span class="line">        _has_init_any_segment = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Read the next segment of the current rowset.</span></span><br><span class="line">        <span class="keyword">if</span> (++_segment_idx &gt;= _cur_rowset()-&gt;<span class="built_in">segments</span>().<span class="built_in">size</span>()) &#123;</span><br><span class="line">            _segment_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// Read the next rowset of the current tablet.</span></span><br><span class="line">            <span class="keyword">if</span> (++_rowset_idx &gt;= _tablet_rowsets[_tablet_idx].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                _rowset_idx = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// Read the next tablet.</span></span><br><span class="line">                ++_tablet_idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _tablet_idx &lt; _tablets.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="inti-segment"><a href="#inti-segment" class="headerlink" title="_inti_segment"></a>_inti_segment</h4><p>初始化 segment 要复杂点。但是也可以大致分为两个步骤：</p>
<ol>
<li><p>加载元数据</p>
<p> 针对每个 Tablet 都有一个查询范围 **{_range_start_key, _Range_end_key}**，两边是开闭还是闭区间由 <strong>{_range_start_op, _range_end_op}</strong> 表示。比如，如果 _range_xxx_op 中包含等于操作即闭区间，否则是开区间，这两个符号定义如下:</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">RangeStartOperation</span> &#123; GT = <span class="number">0</span>, GE, EQ &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">RangeEndOperation</span> &#123; LT = <span class="number">0</span>, LE, EQ &#125;;</span><br></pre></td></tr></table></figure>

<p> 第一步主要是将 OlapScanRange 类型的 {_range_start_key, _range_end_key} 转化为 SeekRange 类型的 _tablet_seek_ranges，这样方便后续遍历。</p>
<p> 注意：这里的 <em>_range_start_key</em> 和 <em>_range_end_key</em> 都是 std::vector 类型，可能包含多个查询范围，比如 1 &lt; x &lt;&#x3D; 2, 10 &lt; y &lt; 20，而起始条件都在 _range_start_key 中，终止条件都在 _Range_end_key 中。</p>
<p> <strong>顺带提下</strong>，在读过程中，数据的内存分配方式基本都是基于内存池 MemPool。这个 MemPool 只是缓存作用，实际内部分配内存的操作是由 ChunkAllocator 完成，其分配内存特点是先在线程所在 core 上分配，如果线程所在 core 上分配的内存超过了限制（默认2G）则会 cross-core 分配，这样可以减少线程跨 core 通信。</p>
<p>因为数据读取的单位是 Segment，当 segment &#x3D;&#x3D; 0 即表示需要从一个新的 Rowset 中读取数据，因此需要先调用 Rowset::load 函数初始化 Rowset::_segments，来获悉所有 semgnet 信息。</p>
<p>如果，当前 rowset 没有可读的数据，则 return。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Status PhysicalSplitMorselQueue::_init_segment() &#123;</span><br><span class="line">   <span class="comment">// Load the meta of the new rowset and the index of the new segment。</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="number">0</span> == _segment_idx) &#123;</span><br><span class="line">       <span class="comment">// Read a new tablet.</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> == _rowset_idx) &#123;</span><br><span class="line">           _tablet_seek_ranges.<span class="built_in">clear</span>();</span><br><span class="line">           _mempool.<span class="built_in">clear</span>();</span><br><span class="line">           <span class="built_in">RETURN_IF_ERROR</span>(vectorized::TabletReader::<span class="built_in">parse_seek_range</span>(</span><br><span class="line">               _tablets[_tablet_idx], _range_start_op, _range_end_op,</span><br><span class="line">               _range_start_key, _range_end_key, </span><br><span class="line">               &amp;_tablet_seek_ranges, &amp;_mempool));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Read a new rowset.</span></span><br><span class="line">       <span class="built_in">RETURN_IF_ERROR</span>(_cur_rowset()-&gt;<span class="built_in">load</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   _num_segment_rest_rows = <span class="number">0</span>;</span><br><span class="line">   _segment_scan_range.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">auto</span>* segment = _cur_segment();</span><br><span class="line">   <span class="comment">// The new rowset doesn&#x27;t contain any segment.</span></span><br><span class="line">   <span class="keyword">if</span> (segment == <span class="literal">nullptr</span> || segment-&gt;<span class="built_in">num_rows</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br></pre></td></tr></table></figure></li>
<li><p>step(1) 过后，得到可迭代的 <strong>_tablet_seek_ranges</strong>，下面就需要将其转化为在 Segment 中的所有读取范围，并合并到 <strong>_segment_scan_range</strong> 中。</p>
<p>而且 _segment_scan_range 中每一个 range 的起始位置 {lower_rowid, upper_rowid} 都待读取数据的行号，因此后续读取效率会非常高。 </p>
<p>比如找某个 key 在 segment 的上限位置，这是由于 _upper_bound_ordinal 函数：尝试将该 key 根据表的 short_keys 编码成 index_key，再在该 segment 中利用二分搜索定位到 key 在 segment 文件中的上限位置 <em>end</em>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rowid_t</span> PhysicalSplitMorselQueue::_upper_bound_ordinal(Segment* segment, <span class="type">const</span> vectorized::SeekTuple&amp; key, <span class="type">bool</span> lower,</span><br><span class="line">                                                       <span class="type">rowid_t</span> end) <span class="type">const</span> &#123;</span><br><span class="line">    std::string index_key =</span><br><span class="line">            key.<span class="built_in">short_key_encode</span>(segment-&gt;<span class="built_in">num_short_keys</span>(), lower ? KEY_MINIMAL_MARKER : KEY_MAXIMAL_MARKER);</span><br><span class="line">    <span class="comment">// 定位到 key 在 segment 中的上限</span></span><br><span class="line">    <span class="keyword">auto</span> end_iter = segment-&gt;<span class="built_in">upper_bound</span>(index_key);</span><br><span class="line">    <span class="keyword">if</span> (end_iter.<span class="built_in">valid</span>()) &#123;</span><br><span class="line">        end = end_iter.<span class="built_in">ordinal</span>() * segment-&gt;<span class="built_in">num_rows_per_block</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以， <em>_upper_bound_ordinal</em> 函数也说明了step(1) 中将 OlapScanRange 转为 SeekTuple 类型的原因，因为 SeekTuple 包含每一行的 Schema，可以对查找的 key 基于 short_keys 进行编码。最后得到的 <code>_segment_scan_range</code> 即表征了 curr_segment 要读取的数据范围。</p>
<p>第二部分完整的代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> Status PhysicalSplitMorselQueue::_init_segment() &#123;</span><br><span class="line">    <span class="comment">//...above code</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the rowid range of each key range in this segment.</span></span><br><span class="line">    <span class="keyword">if</span> (_tablet_seek_ranges.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _segment_scan_range.<span class="built_in">add</span>(vectorized::<span class="built_in">Range</span>(<span class="number">0</span>, segment-&gt;<span class="built_in">num_rows</span>()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(segment-&gt;<span class="built_in">load_index</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; range : _tablet_seek_ranges) &#123;</span><br><span class="line">            <span class="type">rowid_t</span> lower_rowid = <span class="number">0</span>;</span><br><span class="line">            <span class="type">rowid_t</span> upper_rowid = segment-&gt;<span class="built_in">num_rows</span>();</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 上限</span></span><br><span class="line">            <span class="keyword">if</span> (!range.<span class="built_in">upper</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                upper_rowid = _upper_bound_ordinal(segment,</span><br><span class="line">                                                   range.<span class="built_in">upper</span>(),</span><br><span class="line">                                                   !range.<span class="built_in">inclusive_upper</span>(),</span><br><span class="line">                                                   segment-&gt;<span class="built_in">num_rows</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下限</span></span><br><span class="line">            <span class="keyword">if</span> (!range.<span class="built_in">lower</span>().<span class="built_in">empty</span>() &amp;&amp; upper_rowid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lower_rowid = _lower_bound_ordinal(segment,</span><br><span class="line">                                                   range.<span class="built_in">lower</span>(),</span><br><span class="line">                                                   range.<span class="built_in">inclusive_lower</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在 segment 中， 一个可读取的 range 就产生了</span></span><br><span class="line">            <span class="keyword">if</span> (lower_rowid &lt;= upper_rowid) &#123;</span><br><span class="line">                _segment_scan_range.<span class="built_in">add</span>(vectorized::Range&#123;lower_rowid, upper_rowid&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _segment_range_iter = _segment_scan_range.<span class="built_in">new_iterator</span>();</span><br><span class="line">    _num_segment_rest_rows = _segment_scan_range.<span class="built_in">span_size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="MorselQueueFactory"><a href="#MorselQueueFactory" class="headerlink" title="MorselQueueFactory"></a>MorselQueueFactory</h2><p>MorselQueue 创建完后，就要准备创建 MorselQueueFactory。因为后续由 MorselQueueFactory 将 MorselQueue 分配给 PipelineDriver。</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-morsel-2.svg?raw=true" alt="pipeline-morsel-2"></p>
<p>顾名思义，<strong>SharedMorselQueueFactory</strong> 即所有的 PipelineDrivers 共享一个 MorselQueue，此时就要求该 MorselQueue 具有较好的并发性能，比如FixedMorselQueue，而 IndividualMorselQueueFactory 则为每个 PipelineDriver 都分配一个 MorselQueue。</p>
<p>通过 Factory 创建 MorselQueue 的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MorselQueue* <span class="title">SharedMorselQueueFactory::create</span><span class="params">(<span class="type">int</span> driver_sequence)</span> <span class="keyword">override</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> _queue.<span class="built_in">get</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个 PipelineDrvier 都有一个 driver_sequence</span></span><br><span class="line"><span class="function">MorselQueue* <span class="title">IndividualMorselQueueFactory::create</span><span class="params">(<span class="type">int</span> driver_sequence)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK_LT</span>(driver_sequence, _queue_per_driver_seq.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> _queue_per_driver_seq[driver_sequence].<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="convert-scan-range-to-morsel-queue-factory"><a href="#convert-scan-range-to-morsel-queue-factory" class="headerlink" title="convert_scan_range_to_morsel_queue_factory"></a>convert_scan_range_to_morsel_queue_factory</h3><p>在创建 Factory 前，需要先由 <em>convert_scan_range_to_morsel_queue</em> 函数获得 MorselQueue，再根据 frontend 优化器是否设置了 <code>scan_ranges_per_driver_seq</code> 来做一些决策。</p>
<ul>
<li><p>大多数情况下，<code>scan_ranges_per_driver_seq</code> 都不为空，即每个 PipelineDriver 已经分配好了自己要读取的 scan_range，则直接使用 convert_scan_range_to_morsel_queue 函数每个 PipelineDriver 生成 MorselQueue，并添加到 pipeline::IndividualMorselQueueFactory 对象中暂存。</p>
</li>
<li><p>如果 <code>scan_ranges_per_driver_seq</code> 为空，则为全局要读取的数据范围 global_scan_ranges 创建对应的 MorselQueue。</p>
<p>MorselQueue::max_degree_of_parallelism() 表征同时支持的读取并行度，比如 FixedMorseQueue 的 max_degree_of_parallelism 即 _morsel_size，最多只允许 _morsel_size 一起读取。而 SplitMorselQueue 的 max_degree_of_parallelism 则是在 _could_tablet_internal_parallel 函数中计算出来的 scan_dop。</p>
<blockquote>
<p>到底是什么规模想要用 FixedMorselQueue</p>
</blockquote>
</li>
</ul>
<p>这部分代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;pipeline::MorselQueueFactoryPtr&gt; <span class="title">ScanNode::convert_scan_range_to_morsel_queue_factory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;TScanRangeParams&gt;&amp; global_scan_ranges,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::map&lt;<span class="type">int32_t</span>, std::vector&lt;TScanRangeParams&gt;&gt;&amp; scan_ranges_per_driver_seq, <span class="type">int</span> node_id,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> pipeline_dop, <span class="type">bool</span> enable_tablet_internal_parallel,</span></span></span><br><span class="line"><span class="params"><span class="function">        TTabletInternalParallelMode::type tablet_internal_parallel_mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scan_ranges_per_driver_seq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> morsel_queue,</span><br><span class="line">                         <span class="built_in">convert_scan_range_to_morsel_queue</span>(global_scan_ranges, node_id, pipeline_dop,</span><br><span class="line">                                                            enable_tablet_internal_parallel,</span><br><span class="line">                                                            tablet_internal_parallel_mode, global_scan_ranges.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="type">int</span> scan_dop = std::<span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, morsel_queue-&gt;<span class="built_in">max_degree_of_parallelism</span>()), pipeline_dop);</span><br><span class="line">        <span class="type">int</span> io_parallelism = scan_dop * <span class="built_in">io_tasks_per_scan_operator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If not so much morsels, try to assign morsel uniformly among operators to avoid data skew</span></span><br><span class="line">        <span class="keyword">if</span> (scan_dop &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">dynamic_cast</span>&lt;pipeline::FixedMorselQueue*&gt;(morsel_queue.<span class="built_in">get</span>()) &amp;&amp;</span><br><span class="line">            morsel_queue-&gt;<span class="built_in">num_original_morsels</span>() &lt;= io_parallelism) &#123;</span><br><span class="line">            <span class="keyword">auto</span> morsel_queue_map = <span class="built_in">uniform_distribute_morsels</span>(std::<span class="built_in">move</span>(morsel_queue), scan_dop);</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::IndividualMorselQueueFactory&gt;(std::<span class="built_in">move</span>(morsel_queue_map),</span><br><span class="line">                                                                            <span class="comment">/*could_local_shuffle*/</span> <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::SharedMorselQueueFactory&gt;(std::<span class="built_in">move</span>(morsel_queue), scan_dop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> num_total_scan_ranges = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, scan_ranges] : scan_ranges_per_driver_seq) &#123;</span><br><span class="line">            num_total_scan_ranges += scan_ranges.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::map&lt;<span class="type">int</span>, pipeline::MorselQueuePtr&gt; queue_per_driver_seq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dop, scan_ranges] : scan_ranges_per_driver_seq) &#123;</span><br><span class="line">            <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> queue, <span class="built_in">convert_scan_range_to_morsel_queue</span>(</span><br><span class="line">                                                 scan_ranges, node_id, pipeline_dop, enable_tablet_internal_parallel,</span><br><span class="line">                                                 tablet_internal_parallel_mode, num_total_scan_ranges));</span><br><span class="line">            queue_per_driver_seq.<span class="built_in">emplace</span>(dop, std::<span class="built_in">move</span>(queue));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::IndividualMorselQueueFactory&gt;(std::<span class="built_in">move</span>(queue_per_driver_seq),</span><br><span class="line">                                                                        <span class="comment">/*could_local_shuffle*/</span> <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下一部分从 SourceOperator 角度看怎么获取 Morsels 去存储层获取数据。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#convert-scan-range-to-morsel-queue"><span class="toc-number">1.</span> <span class="toc-text">convert_scan_range_to_morsel_queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#could-tablet-internal-parallel"><span class="toc-number">2.</span> <span class="toc-text">_could_tablet_internal_parallel</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FixedMorselQueue"><span class="toc-number"></span> <span class="toc-text">FixedMorselQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#FixedMorselQueue-try-get"><span class="toc-number">1.</span> <span class="toc-text">FixedMorselQueue::try_get</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SplitMorselQueue"><span class="toc-number"></span> <span class="toc-text">SplitMorselQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PhysicalSplitMorselQueue-try-get"><span class="toc-number">1.</span> <span class="toc-text">PhysicalSplitMorselQueue::try_get</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#next-segment"><span class="toc-number">1.1.</span> <span class="toc-text">_next_segment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#inti-segment"><span class="toc-number">1.2.</span> <span class="toc-text">_inti_segment</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MorselQueueFactory"><span class="toc-number"></span> <span class="toc-text">MorselQueueFactory</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#convert-scan-range-to-morsel-queue-factory"><span class="toc-number">1.</span> <span class="toc-text">convert_scan_range_to_morsel_queue_factory</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&text=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&title=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&is_video=false&description=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Morsel 和 OlapSourceOperator (1)&body=Check out this article: https://szza.github.io/2023/07/02/Pipeline/MorselQueue/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&title=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&title=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&title=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&title=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&name=Morsel 和 OlapSourceOperator (1)&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/07/02/Pipeline/MorselQueue/&t=Morsel 和 OlapSourceOperator (1)"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
