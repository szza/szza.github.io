<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="输入数据源会被划分多个 Morsels，每个 morsel 都表征着一个要读取的数据源及其范围 {tablet_id, version}，这两个信息也包含在 scan_range 中。  enable_query_cache在 query_cache 没有失效的情况下，N 个 MultiLaneOperator 之间的 lane 是一一对应的，数据流如下。  一个 MultiLaneOperato">
<meta property="og:type" content="article">
<meta property="og:title" content="Pipeline: 查询加速: QueryCache">
<meta property="og:url" content="https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="输入数据源会被划分多个 Morsels，每个 morsel 都表征着一个要读取的数据源及其范围 {tablet_id, version}，这两个信息也包含在 scan_range 中。  enable_query_cache在 query_cache 没有失效的情况下，N 个 MultiLaneOperator 之间的 lane 是一一对应的，数据流如下。  一个 MultiLaneOperato">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-1.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-2.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-3.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-4.svg?raw=true">
<meta property="article:published_time" content="2023-08-05T02:00:01.000Z">
<meta property="article:modified_time" content="2023-10-19T03:14:49.223Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="StarRocks">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-1.svg?raw=true">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>Pipeline: 查询加速: QueryCache</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2023/08/06/Pipeline/Pipeline-profile/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2023/08/02/Pipeline/ExchangeNode_2/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&text=Pipeline: 查询加速: QueryCache"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&title=Pipeline: 查询加速: QueryCache"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&is_video=false&description=Pipeline: 查询加速: QueryCache"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Pipeline: 查询加速: QueryCache&body=Check out this article: https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&title=Pipeline: 查询加速: QueryCache"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&title=Pipeline: 查询加速: QueryCache"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&title=Pipeline: 查询加速: QueryCache"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&title=Pipeline: 查询加速: QueryCache"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&name=Pipeline: 查询加速: QueryCache&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&t=Pipeline: 查询加速: QueryCache"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#enable-query-cache"><span class="toc-number">1.</span> <span class="toc-text">enable_query_cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#disable-query-cache"><span class="toc-number">2.</span> <span class="toc-text">disable_query_cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#push-chunk"><span class="toc-number">3.</span> <span class="toc-text">push_chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#populate-cache"><span class="toc-number">3.1.</span> <span class="toc-text">populate_cache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pull-chunk"><span class="toc-number">4.</span> <span class="toc-text">pull_chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pull-chunk-from-per-lane-buffer"><span class="toc-number">4.1.</span> <span class="toc-text">_pull_chunk_from_per_lane_buffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pick-morsel"><span class="toc-number">5.</span> <span class="toc-text">_pick_morsel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#delta-version-and-rowsets"><span class="toc-number">5.1.</span> <span class="toc-text">delta_version_and_rowsets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OlapChunkSource-init-olap-reader"><span class="toc-number">5.2.</span> <span class="toc-text">OlapChunkSource::_init_olap_reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CacheOperator-probe-cache"><span class="toc-number">5.3.</span> <span class="toc-text">CacheOperator::probe_cache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#handle-stale-cache-value-for-non-pk"><span class="toc-number">5.3.1.</span> <span class="toc-text">_handle_stale_cache_value_for_non_pk</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LaneArbiter"><span class="toc-number">6.</span> <span class="toc-text">LaneArbiter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-acquire-lane"><span class="toc-number">6.1.</span> <span class="toc-text">try_acquire_lane</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#release-lane"><span class="toc-number">6.2.</span> <span class="toc-text">release_lane</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PipelineDriver-prepare"><span class="toc-number">6.3.</span> <span class="toc-text">PipelineDriver::prepare</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Pipeline: 查询加速: QueryCache
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-08-05T02:00:01.000Z" itemprop="datePublished">2023-08-05</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Pipeline/">Pipeline</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/StarRocks/" rel="tag">StarRocks</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>输入数据源会被划分多个 Morsels，每个 morsel 都表征着一个要读取的数据源及其范围 {tablet_id, version}，这两个信息也包含在 scan_range 中。</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-1.svg?raw=true" alt="QueryCache-1"></p>
<h2 id="enable-query-cache"><a href="#enable-query-cache" class="headerlink" title="enable_query_cache"></a>enable_query_cache</h2><p>在 query_cache 没有失效的情况下，N 个 MultiLaneOperator 之间的 lane 是一一对应的，数据流如下。</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-2.svg?raw=true" alt="QueryCache-2"></p>
<p>一个 MultiLaneOperator 包含多个 MultiOperator::Lane，每个 MultiOperator::Lane 中都包含了一个 operator：一个 lane-chain 用于处理一个 morsel  数据。<br>将原本的的 一个 Operator 子划分为 _num_lanes 个，实现 tablet 内的并行，每当一个 lane-chain 处理完一个morsel的数据及其后续操作时（ last_chunk_received &#x3D; true，eof_sent &#x3D; true）会将结果缓存到 CacheMgr，供后续操作共享结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Lane</span> &#123;</span><br><span class="line">    pipeline::OperatorPtr processor;</span><br><span class="line">    <span class="type">int64_t</span> lane_owner;  <span class="comment">// tablet_id</span></span><br><span class="line">    <span class="type">int</span> lane_id;</span><br><span class="line">    <span class="type">bool</span> last_chunk_received; </span><br><span class="line">    <span class="type">bool</span> eof_sent;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Lane</span>(pipeline::OperatorPtr&amp;&amp; op, <span class="type">int</span> id)</span><br><span class="line">     : <span class="built_in">processor</span>(std::<span class="built_in">move</span>(op)), </span><br><span class="line">       <span class="built_in">lane_owner</span>(<span class="number">-1</span>),</span><br><span class="line">       <span class="built_in">lane_id</span>(id),</span><br><span class="line">       <span class="built_in">last_chunk_received</span>(<span class="literal">false</span>), </span><br><span class="line">       <span class="built_in">eof_sent</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// MultilaneOperator</span></span><br><span class="line">MultilaneOperator::<span class="built_in">MultilaneOperator</span>(pipeline::OperatorFactory* factory, </span><br><span class="line">                                     <span class="type">int32_t</span> driver_sequence,</span><br><span class="line">                                     <span class="type">size_t</span> num_lanes,</span><br><span class="line">                                     pipeline::Operators&amp;&amp; processors, </span><br><span class="line">                                     <span class="type">bool</span> can_passthrough)</span><br><span class="line">: pipeline::<span class="built_in">Operator</span>(factory, factory-&gt;<span class="built_in">id</span>(),</span><br><span class="line">                     factory-&gt;<span class="built_in">get_raw_name</span>(), </span><br><span class="line">                     factory-&gt;<span class="built_in">plan_node_id</span>(),</span><br><span class="line">                     driver_sequence),</span><br><span class="line">  _num_lanes(num_lanes),</span><br><span class="line">  _can_passthrough(can_passthrough) &#123;</span><br><span class="line">     _lanes.<span class="built_in">reserve</span>(_num_lanes);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; _num_lanes; ++i) &#123;</span><br><span class="line">        <span class="comment">// 每个 lane 对应着一个 operator</span></span><br><span class="line">        _lanes.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(processors[i]), i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// MultilaneOperatorFactory</span></span><br><span class="line"><span class="function">pipeline::OperatorPtr <span class="title">MultilaneOperatorFactory::create</span><span class="params">(<span class="type">int32_t</span> degree_of_parallelism,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="type">int32_t</span> driver_sequence)</span> </span>&#123;</span><br><span class="line">    pipeline::Operators processors;</span><br><span class="line">    processors.<span class="built_in">reserve</span>(_num_lanes);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; _num_lanes; ++i) &#123;</span><br><span class="line">        processors.<span class="built_in">push_back</span>(_factory-&gt;<span class="built_in">create</span>(</span><br><span class="line">            degree_of_parallelism * _num_lanes,</span><br><span class="line">             driver_sequence * _num_lanes + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;MultilaneOperator&gt;(<span class="keyword">this</span>, driver_sequence,</span><br><span class="line">                                               _num_lanes,</span><br><span class="line">                                               std::<span class="built_in">move</span>(processors), </span><br><span class="line">                                               _can_passthrough);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="disable-query-cache"><a href="#disable-query-cache" class="headerlink" title="disable_query_cache"></a>disable_query_cache</h2><p>当 disable_query_cache 时，就退化为基本的状态，即此时每个 MultiLaneOperator 内部实际上只有一个 operator 在发挥作用，最后一个 MultiLaneOperator 中只有一个 passthrough_chunk 传递数据。</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-3.svg?raw=true" alt="QueryCache-3"></p>
<h2 id="push-chunk"><a href="#push-chunk" class="headerlink" title="push_chunk"></a>push_chunk</h2><p>CacheOperator 内部有个 CacheMgr。在 push chunk 时，根据 chunk 的 {rows, bytes} 大小来决定 query_cache 是否有效。</p>
<p>LaneArbiter 的作用类似于全局锁，在 ScanOperator、MultiLaneOperator、CacheOperator 之间共享，记录着当前 query_cache 是否失效。<br>每次向 CacheOperator 中 push chunk 之前，都会检测 chunk 的 rows 和 bytes 是否超过 {max_rows, max_bytes} 阈值：</p>
<ul>
<li><p>如果超过，则转变为 passthrough 模式，不再向 CacheMgr 中写入数据，直接使用 passthrough_chunk 来存储每次读取的数据</p>
<p>注意，变成 passthrough 模式后，CacheMgr 的数据仍在没有清除，仍可为后续的读取提供缓存。</p>
</li>
<li><p>没有超过，则继续向 CacheMgr 中写数据</p>
</li>
</ul>
<p>每个 chunk 都有一个 owner 信息：</p>
<ul>
<li>owner_id：即 tablet_id，从 哪个 table_id 读取到的，通过 owner_id 可以定位到具体的 lane。</li>
<li>is_last_chunk：是不是这个 morsel 的最后一个 chunk；</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> CacheOperator::_should_passthrough(<span class="type">size_t</span> num_rows, <span class="type">size_t</span> num_bytes) &#123;</span><br><span class="line">    <span class="keyword">return</span> _cache_param.entry_max_rows &lt;= <span class="number">0</span> || num_rows &gt; _cache_param.entry_max_rows ||</span><br><span class="line">           _cache_param.entry_max_bytes &lt;= <span class="number">0</span> || num_bytes &gt; _cache_param.entry_max_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CacheOperator::push_chunk</span><span class="params">(RuntimeState* state, <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(chunk != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (_lane_arbiter-&gt;<span class="built_in">in_passthrough_mode</span>()) &#123;</span><br><span class="line">        <span class="built_in">DCHECK</span>(_passthrough_chunk == <span class="literal">nullptr</span>);</span><br><span class="line">        _passthrough_chunk = chunk;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">auto</span> lane_owner = chunk-&gt;<span class="built_in">owner_info</span>().<span class="built_in">owner_id</span>();</span><br><span class="line">    <span class="built_in">DCHECK</span>(_owner_to_lanes.<span class="built_in">count</span>(lane_owner));</span><br><span class="line">    <span class="keyword">auto</span> lane_id = _owner_to_lanes[lane_owner];</span><br><span class="line">    <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane_id];</span><br><span class="line">    buffer-&gt;<span class="built_in">append_chunk</span>(chunk);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 检测是否超过限制</span></span><br><span class="line">    <span class="keyword">if</span> (_should_passthrough(buffer-&gt;num_rows, buffer-&gt;num_bytes)) &#123;</span><br><span class="line">        _lane_arbiter-&gt;<span class="built_in">enable_passthrough_mode</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, lane_id] : _owner_to_lanes) &#123;</span><br><span class="line">            _per_lane_buffers[lane_id]-&gt;<span class="built_in">set_passthrough</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;<span class="built_in">should_populate_cache</span>()) &#123;</span><br><span class="line">         <span class="comment">// 写入 cache</span></span><br><span class="line">        <span class="built_in">populate_cache</span>(lane_owner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="populate-cache"><a href="#populate-cache" class="headerlink" title="populate_cache"></a>populate_cache</h3><p>在 push chunk 时，每次都会尝试调用 PerLaneBuffer::should_populate_cache 函数来 check 是否需要将填充 cache：</p>
<ul>
<li>cached_version 是 cache_mgr 中目前 cache 的版本，required_version 是目前需要的版本，cached_version &lt; required_version 说明 cache_mgr 中缓存的数据过时，需要填充新的数据；</li>
<li>PLBS_TOTAL：表征这个 lane 的数据读取完毕，此时会把这个 per_lane_buff 的数据填充到 cache_mgr 中；</li>
</ul>
<p>完整的判断条件如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PerLaneBuffer::should_populate_cache</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cached_version &lt; required_version &amp;&amp; </span><br><span class="line">           (state == PLBS_HIT_TOTAL || state == PLBS_TOTAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>填充 cache 的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CacheOperator::populate_cache</span><span class="params">(<span class="type">int64_t</span> tablet_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lane = _owner_to_lanes[tablet_id];</span><br><span class="line">    <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cache_key_suffix_it = _cache_param.cache_key_prefixes.<span class="built_in">find</span>(tablet_id);</span><br><span class="line">    <span class="keyword">if</span> (cache_key_suffix_it == _cache_param.cache_key_prefixes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// uncacheable</span></span><br><span class="line">        buffer-&gt;state = PLBS_POPULATE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string cache_key = </span><br><span class="line">        _cache_param.digest + cache_key_suffix_it-&gt;second;</span><br><span class="line">    <span class="type">int64_t</span> current = <span class="built_in">GetMonoTimeMicros</span>();</span><br><span class="line">    <span class="keyword">auto</span> chunks = <span class="built_in">remap_chunks</span>(buffer-&gt;chunks, _cache_param.slot_remapping);</span><br><span class="line">    <span class="function">CacheValue <span class="title">cache_value</span><span class="params">(current, buffer-&gt;required_version, std::move(chunks))</span></span>;</span><br><span class="line">    <span class="comment">// If the cache implementation is global, </span></span><br><span class="line">    <span class="comment">// populate method must be asynchronous and try its best to</span></span><br><span class="line">    <span class="comment">// update the cache.</span></span><br><span class="line">    _cache_populate_bytes_counter-&gt;<span class="built_in">update</span>(buffer-&gt;num_bytes);</span><br><span class="line">    _cache_populate_chunks_counter-&gt;<span class="built_in">update</span>(buffer-&gt;chunks.<span class="built_in">size</span>());</span><br><span class="line">    _cache_populate_rows_counter-&gt;<span class="built_in">update</span>(buffer-&gt;num_rows);</span><br><span class="line">    _populate_tablets.<span class="built_in">insert</span>(tablet_id);</span><br><span class="line">     <span class="comment">// 缓存 mgr 中，超出容量时，kv会自动删除低优先级</span></span><br><span class="line">    _cache_mgr-&gt;<span class="built_in">populate</span>(cache_key, cache_value);</span><br><span class="line">    buffer-&gt;state = PLBS_POPULATE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pull-chunk"><a href="#pull-chunk" class="headerlink" title="pull_chunk"></a>pull_chunk</h2><p>从 CacheOperator 中获取数据时：</p>
<ul>
<li>如果 query_cache 未失效， 则从 PerLaneBuffer 中获取；</li>
<li>否则直接从 passthrough_chunk 读取</li>
</ul>
<p>代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;vectorized::ChunkPtr&gt; <span class="title">CacheOperator::pull_chunk</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> opt_lane = _lane_arbiter-&gt;<span class="built_in">preferred_lane</span>();</span><br><span class="line">    <span class="keyword">if</span> (opt_lane.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> lane = opt_lane.<span class="built_in">value</span>();</span><br><span class="line">        <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane];</span><br><span class="line">        <span class="keyword">auto</span> chunk = _pull_chunk_from_per_lane_buffer(buffer);</span><br><span class="line">        <span class="keyword">if</span> (chunk != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> chunk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, lane_id] : _owner_to_lanes) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane_id];</span><br><span class="line">        <span class="keyword">auto</span> chunk = _pull_chunk_from_per_lane_buffer(buffer);</span><br><span class="line">        <span class="keyword">if</span> (chunk != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> chunk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(_passthrough_chunk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="pull-chunk-from-per-lane-buffer"><a href="#pull-chunk-from-per-lane-buffer" class="headerlink" title="_pull_chunk_from_per_lane_buffer"></a>_pull_chunk_from_per_lane_buffer</h3><p>当从 CacheOperator 中获取数据时，会从 PerLaneBufferPtr  中获取，如果 lane_id 中的数据已经读取完，则释放该 lane，让后续的 morsel 继续复用该lane继续提交任务。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vectorized::ChunkPtr CacheOperator::_pull_chunk_from_per_lane_buffer(PerLaneBufferPtr&amp; buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;<span class="built_in">has_chunks</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> chunk = buffer-&gt;<span class="built_in">get_next_chunk</span>();</span><br><span class="line">        <span class="keyword">if</span> (buffer-&gt;<span class="built_in">can_release</span>()) &#123;</span><br><span class="line">            _lane_arbiter-&gt;<span class="built_in">release_lane</span>(chunk-&gt;<span class="built_in">owner_info</span>().<span class="built_in">owner_id</span>()); <span class="comment">// 类似于释放锁的逻辑</span></span><br><span class="line">            buffer-&gt;<span class="built_in">reset</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="pick-morsel"><a href="#pick-morsel" class="headerlink" title="_pick_morsel"></a>_pick_morsel</h2><p>在 <a href="https://szza.github.io/2023/07/07/Pipeline/MorselQueue_3/">Morsel 和 OlapScanOperator</a> 中讲过 pick_morsel 函数，但是省略了 QueryCache 部分。</p>
<p>从 MorselQueue 中获取一个  morsel 后，先要从 lane_arbiter 中获得一个 lane slot 才能执行。</p>
<ul>
<li>query_cache::AR_BUSY： 没有可执行的任务</li>
<li>query_cache::AR_PROBE：获得一个可用的 lane slot，先去 cache 中探测下，是否已经缓存过 {tablet_id, version} 的部分数据，如果已经缓存一部分，则后续只需要读取增量部分。</li>
<li>query_cache::AR_SKIP： 这个 lane 已经处理过；</li>
<li>query_cache::AR_IO：<ul>
<li>passthrough 模式，或者</li>
<li>query-cache 失效后进入 passthroguh 模式，此时可能仍有部分缓存数据，尝试读取。</li>
</ul>
</li>
</ul>
<p>这部分代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Status ScanOperator::_pickup_morsel(RuntimeState* state, <span class="type">int</span> chunk_source_index) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 根据 morsel_queue 的策略，获取一个 mosel</span></span><br><span class="line">    <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> morsel, _morsel_queue-&gt;<span class="built_in">try_get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_lane_arbiter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (morsel != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 这个 morsel 对应的 tablet_id 和 version</span></span><br><span class="line">            <span class="keyword">auto</span> [lane_owner, version] = morsel-&gt;<span class="built_in">get_lane_owner_and_version</span>();</span><br><span class="line">            <span class="comment">// 这个 tablet 对应的 lane 是否被占据</span></span><br><span class="line">            <span class="keyword">auto</span> acquire_result = _lane_arbiter-&gt;<span class="built_in">try_acquire_lane</span>(lane_owner);</span><br><span class="line">            <span class="keyword">if</span> (acquire_result == query_cache::AR_BUSY) &#123;</span><br><span class="line">                <span class="comment">// 无可用的 lane</span></span><br><span class="line">                _morsel_queue-&gt;<span class="built_in">unget</span>(std::<span class="built_in">move</span>(morsel)); </span><br><span class="line">                <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (acquire_result == query_cache::AR_PROBE) &#123;</span><br><span class="line">                <span class="comment">// 首次探测 &#123;tablet_id, version&#125;</span></span><br><span class="line">                <span class="keyword">auto</span> hit = _cache_operator-&gt;<span class="built_in">probe_cache</span>(lane_owner, version);   </span><br><span class="line">                <span class="comment">// 初始化</span></span><br><span class="line">                <span class="built_in">RETURN_IF_ERROR</span>(_cache_operator-&gt;<span class="built_in">reset_lane</span>(state, lane_owner));</span><br><span class="line">                <span class="keyword">if</span> (!hit) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// hit 则从 cache 中获取，尽早跳出循环</span></span><br><span class="line">                <span class="keyword">auto</span> [delta_version, delta_rowsets] = </span><br><span class="line">                    _cache_operator-&gt;<span class="built_in">delta_version_and_rowsets</span>(lane_owner);</span><br><span class="line">                <span class="keyword">if</span> (!delta_rowsets.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 已经缓存的 version</span></span><br><span class="line">                    morsel-&gt;<span class="built_in">set_from_version</span>(delta_version); </span><br><span class="line">                    <span class="comment">// 对应的 rowsets</span></span><br><span class="line">                    morsel-&gt;<span class="built_in">set_rowsets</span>(delta_rowsets);      </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">ASSIGN_OR_RETURN</span>(morsel, _morsel_queue-&gt;<span class="built_in">try_get</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (acquire_result == query_cache::AR_SKIP) &#123;</span><br><span class="line">                <span class="built_in">ASSIGN_OR_RETURN</span>(morsel, _morsel_queue-&gt;<span class="built_in">try_get</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (acquire_result == query_cache::AR_IO) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [delta_verrsion, delta_rowsets] = </span><br><span class="line">                    _cache_operator-&gt;<span class="built_in">delta_version_and_rowsets</span>(lane_owner);</span><br><span class="line">                <span class="keyword">if</span> (!delta_rowsets.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    morsel-&gt;<span class="built_in">set_from_version</span>(delta_verrsion);</span><br><span class="line">                    morsel-&gt;<span class="built_in">set_rowsets</span>(delta_rowsets);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="delta-version-and-rowsets"><a href="#delta-version-and-rowsets" class="headerlink" title="delta_version_and_rowsets"></a>delta_version_and_rowsets</h3><p>delta_version_and_rowsets 方法从 CacheOperator::_per_lane_buffers 中获得已经 scan 缓存的  {version, rowset} 。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int64_t</span>, vector&lt;RowsetSharedPtr&gt;&gt; </span><br><span class="line">CacheOperator::<span class="built_in">delta_version_and_rowsets</span>(<span class="type">int64_t</span> tablet_id) &#123;</span><br><span class="line">    <span class="keyword">auto</span> lane_it = _owner_to_lanes.<span class="built_in">find</span>(tablet_id);</span><br><span class="line">    <span class="keyword">if</span> (lane_it == _owner_to_lanes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">0</span>, vector&lt;RowsetSharedPtr&gt;&#123;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane_it-&gt;second];</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(</span><br><span class="line">            buffer-&gt;cached_version + <span class="number">1</span>, buffer-&gt;rowsets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OlapChunkSource-init-olap-reader"><a href="#OlapChunkSource-init-olap-reader" class="headerlink" title="OlapChunkSource::_init_olap_reader"></a>OlapChunkSource::_init_olap_reader</h3><p>TabletReader 初始化时，即只读取增量部分。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status OlapChunkSource::_init_olap_reader(RuntimeState* runtime_state) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 只读取增量数据部分</span></span><br><span class="line">    _reader = std::<span class="built_in">make_shared</span>&lt;TabletReader&gt;(_tablet, </span><br><span class="line">                                             <span class="built_in">Version</span>(_morsel-&gt;<span class="built_in">from_version</span>(), _version),</span><br><span class="line">                                             std::<span class="built_in">move</span>(child_schema),</span><br><span class="line">                                             _morsel-&gt;<span class="built_in">rowsets</span>());</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_reader-&gt;<span class="built_in">prepare</span>());</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_reader-&gt;<span class="built_in">open</span>(_params));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="CacheOperator-probe-cache"><a href="#CacheOperator-probe-cache" class="headerlink" title="CacheOperator::probe_cache"></a>CacheOperator::probe_cache</h3><p>CacheMgr 是全局唯一的，在开启 QueryCache 的情况下，每次执行都会尝试去填充 CacheMgr，隐藏 cache 数据来自于两部分：</p>
<ul>
<li>当前 scan 任务填充的</li>
<li>之前执行任务填充的</li>
</ul>
<p>从 MorselQueue 中获得一个 mosel 之后，使用 morsel的 {tablet_id, version} 到CacheMgr中查询是否有缓存部分数据，基于缓存结果再设置 TabletReader 的参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CacheOperator::probe_cache</span><span class="params">(<span class="type">int64_t</span> tablet_id, <span class="type">int64_t</span> version)</span> </span>&#123; </span><br><span class="line">    _all_tablets.<span class="built_in">insert</span>(tablet_id);</span><br><span class="line">    <span class="comment">// allocate lane and PerLaneBuffer for tablet_id</span></span><br><span class="line">    <span class="type">int64_t</span> lane = _lane_arbiter-&gt;<span class="built_in">must_acquire_lane</span>(tablet_id);</span><br><span class="line"></span><br><span class="line">    _owner_to_lanes[tablet_id] = lane;</span><br><span class="line">    <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane];</span><br><span class="line">    buffer-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    buffer-&gt;lane = lane;</span><br><span class="line">    buffer-&gt;required_version = version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_cache_param.force_populate </span><br><span class="line">        || !_cache_param.cache_key_prefixes.<span class="built_in">count</span>(tablet_id)) &#123;</span><br><span class="line">        buffer-&gt;state = PLBS_MISS;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// probe cache</span></span><br><span class="line">    <span class="type">const</span> std::string&amp; cache_key = </span><br><span class="line">        _cache_param.digest + _cache_param.cache_key_prefixes.<span class="built_in">at</span>(tablet_id);</span><br><span class="line">    <span class="keyword">auto</span> probe_status = _cache_mgr-&gt;<span class="built_in">probe</span>(cache_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache MISS when failed to probe</span></span><br><span class="line">    <span class="keyword">if</span> (!probe_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        buffer-&gt;state = PLBS_MISS;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; cache_value = probe_status.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">if</span> (cache_value.version == version) &#123;</span><br><span class="line">        <span class="comment">// Cache HIT_TOTAL when cached version equals to required version</span></span><br><span class="line">        buffer-&gt;state = PLBS_HIT_TOTAL;     <span class="comment">// 完全缓存</span></span><br><span class="line">        buffer-&gt;cached_version = cache_value.version;</span><br><span class="line">        <span class="keyword">auto</span> chunks = <span class="built_in">remap_chunks</span>(</span><br><span class="line">            cache_value.result, _cache_param.reverse_slot_remapping);</span><br><span class="line">        _update_probe_metrics(tablet_id, chunks);</span><br><span class="line">        buffer-&gt;chunks = std::<span class="built_in">move</span>(chunks);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache_value.version &gt; version) &#123;</span><br><span class="line">        <span class="comment">// It rarely happens that required version is less that cached version,</span></span><br><span class="line">        <span class="comment">// the required version become stale when the query is postponed to be</span></span><br><span class="line">        <span class="comment">// processed because of some reasons, </span></span><br><span class="line">        <span class="comment">// for examples, non-deterministic query scheduling, network congestion etc. </span></span><br><span class="line">        <span class="comment">// make queries be executed out-of-order. so we must prevent stale result </span></span><br><span class="line">        <span class="comment">// from replacing fresh cached result.</span></span><br><span class="line">        buffer-&gt;state = PLBS_MISS;</span><br><span class="line">        buffer-&gt;cached_version = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Incremental updating cause the cached value become stale, </span></span><br><span class="line">        <span class="comment">// It is a very critical and complex situation.</span></span><br><span class="line">        <span class="comment">// here we support a multi-version cache mechanism.</span></span><br><span class="line">        <span class="comment">// 处理部分缓存</span></span><br><span class="line">        _handle_stale_cache_value(tablet_id, cache_value, buffer, version); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return true on cache hit, false on cache miss</span></span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;state == PLBS_HIT_TOTAL) &#123;</span><br><span class="line">        _lane_arbiter-&gt;<span class="built_in">mark_processed</span>(tablet_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer-&gt;state == PLBS_HIT_PARTIAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="handle-stale-cache-value-for-non-pk"><a href="#handle-stale-cache-value-for-non-pk" class="headerlink" title="_handle_stale_cache_value_for_non_pk"></a>_handle_stale_cache_value_for_non_pk</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CacheOperator::_handle_stale_cache_value_for_non_pk(<span class="type">int64_t</span> tablet_id, CacheValue&amp; cache_value,</span><br><span class="line">                                                         PerLaneBufferPtr&amp; buffer, <span class="type">int64_t</span> version) &#123;</span><br><span class="line">    <span class="comment">// Try to reuse partial cache result when cached version is less than </span></span><br><span class="line">    <span class="comment">// required version, delta versions should be captured at first.</span></span><br><span class="line">    <span class="keyword">auto</span> status = StorageEngine::<span class="built_in">instance</span>()-&gt;<span class="built_in">tablet_manager</span>()-&gt;<span class="built_in">capture_tablet_and_rowsets</span>(</span><br><span class="line">            tablet_id, cache_value.version + <span class="number">1</span>, version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache MISS if delta versions are not captured,</span></span><br><span class="line">    <span class="comment">//  because aggressive cumulative compactions.</span></span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        buffer-&gt;state = PLBS_MISS;</span><br><span class="line">        buffer-&gt;cached_version = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delta versions are captured, several situations </span></span><br><span class="line">    <span class="comment">// should be taken into consideration.</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; [tablet, rowsets, rowsets_acq_rel] = status.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">auto</span> all_rs_empty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> min_version = std::numeric_limits&lt;<span class="type">int64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="keyword">auto</span> max_version = std::numeric_limits&lt;<span class="type">int64_t</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; rs : rowsets) &#123;</span><br><span class="line">        all_rs_empty &amp;= !rs-&gt;<span class="built_in">has_data_files</span>();</span><br><span class="line">        min_version = std::<span class="built_in">min</span>(min_version, rs-&gt;<span class="built_in">start_version</span>());</span><br><span class="line">        max_version = std::<span class="built_in">max</span>(max_version, rs-&gt;<span class="built_in">end_version</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Version <span class="title">delta_versions</span><span class="params">(min_version, max_version)</span></span>;</span><br><span class="line">    buffer-&gt;tablet = tablet;</span><br><span class="line">    <span class="keyword">auto</span> has_delete_predicates = tablet-&gt;<span class="built_in">has_delete_predicates</span>(delta_versions);</span><br><span class="line">    <span class="comment">// case 1: there exist delete predicates in delta versions, </span></span><br><span class="line">    <span class="comment">// or data model can not support multiversion cache and </span></span><br><span class="line">    <span class="comment">// the tablet has non-empty delta rowsets;</span></span><br><span class="line">    <span class="comment">// then cache result is not reuse, so cache miss.</span></span><br><span class="line">    <span class="keyword">if</span> (has_delete_predicates || (!_cache_param.can_use_multiversion &amp;&amp; !all_rs_empty)) &#123;</span><br><span class="line">        buffer-&gt;state = PLBS_MISS;</span><br><span class="line">        buffer-&gt;cached_version = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前cache的版本</span></span><br><span class="line">    buffer-&gt;cached_version = cache_value.version; </span><br><span class="line">    <span class="keyword">auto</span> chunks = <span class="built_in">remap_chunks</span>(cache_value.result, _cache_param.reverse_slot_remapping);</span><br><span class="line">    _update_probe_metrics(tablet_id, chunks);</span><br><span class="line">    <span class="comment">// 从 cache_mgr 中获得的存量</span></span><br><span class="line">    buffer-&gt;chunks = std::<span class="built_in">move</span>(chunks); </span><br><span class="line">    <span class="comment">// case 2: all delta versions are empty rowsets, so the cache result is hit totally.</span></span><br><span class="line">    <span class="keyword">if</span> (all_rs_empty) &#123;</span><br><span class="line">        buffer-&gt;state = PLBS_HIT_TOTAL;</span><br><span class="line">        buffer-&gt;chunks.<span class="built_in">back</span>()-&gt;<span class="built_in">owner_info</span>().<span class="built_in">set_last_chunk</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3: otherwise, the cache result is partial result of per-tablet computation,</span></span><br><span class="line">    <span class="comment">// so delta versions must be scanned and merged </span></span><br><span class="line">    <span class="comment">// with cache result to generate total result.</span></span><br><span class="line">    buffer-&gt;state = PLBS_HIT_PARTIAL;</span><br><span class="line">    <span class="comment">// 当前cache的版本</span></span><br><span class="line">    buffer-&gt;rowsets = std::<span class="built_in">move</span>(rowsets); </span><br><span class="line">    buffer-&gt;rowsets_acq_rel = std::<span class="built_in">move</span>(rowsets_acq_rel);</span><br><span class="line">    buffer-&gt;num_rows = <span class="number">0</span>;</span><br><span class="line">    buffer-&gt;num_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; chunk : buffer-&gt;chunks) &#123;</span><br><span class="line">        buffer-&gt;num_rows += chunk-&gt;<span class="built_in">num_rows</span>();</span><br><span class="line">        buffer-&gt;num_bytes += chunk-&gt;<span class="built_in">bytes_usage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    buffer-&gt;chunks.<span class="built_in">back</span>()-&gt;<span class="built_in">owner_info</span>().<span class="built_in">set_last_chunk</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LaneArbiter"><a href="#LaneArbiter" class="headerlink" title="LaneArbiter"></a>LaneArbiter</h2><p>在 CacheOperator 中创建，然后以指针形式分享给 ScanOperator、MultiLaneOperator。</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-4.svg?raw=true" alt="QueryCache-4"></p>
<p>LaneArbiter 类似于锁的作用，共有 _nun_lanes 个 slots，可以同时有 num_lane 个任务并发执行：</p>
<ul>
<li>try_acquire_lane： 执行任务前，先通过 try_acquire_lane 函数来获取 slot</li>
<li>release_lane： 执行任务结束，再使用 release_lane 函数来是否 slot</li>
</ul>
<h3 id="try-acquire-lane"><a href="#try-acquire-lane" class="headerlink" title="try_acquire_lane"></a>try_acquire_lane</h3><p>在获取scan任务之前，先通过 try_acquire_lane 来获得一个 slot：</p>
<ul>
<li>in_passthrough_mode &#x3D;&#x3D; true，则不考虑 query—cache</li>
<li>_processed.count(lane_owner) 为 1 则这个 lane_owner 已经处理完，不再考虑</li>
<li>_acquire_lane 函数从 _assignments 数组中获得一个处于 LANE_UNASSIGNED 状态的 lane，返回值<ul>
<li>NO_FREE_LANE: 表示没有可用的 slot，返回 AcquireResult::AR_BUSY</li>
<li>NEW_LANE_BIT: 则表示存在可用的 slot，返回 AcquireResult::AR_PROBE</li>
<li>otherwise，相同的 lane_onwer 再次获取 lane</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AcquireResult <span class="title">LaneArbiter::try_acquire_lane</span><span class="params">(LaneOwnerType lane_owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">in_passthrough_mode</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> AcquireResult::AR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 已处理过</span></span><br><span class="line">    <span class="keyword">if</span> (_processed.<span class="built_in">count</span>(lane_owner)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AcquireResult::AR_SKIP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 尚未处理</span></span><br><span class="line">    <span class="keyword">auto</span> lane = _acquire_lane(lane_owner);</span><br><span class="line">    <span class="keyword">if</span> (lane == NO_FREE_LANE) &#123;</span><br><span class="line">        <span class="keyword">return</span> AcquireResult::AR_BUSY;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> ((lane &amp; NEW_LANE_BIT) == NEW_LANE_BIT) &#123;</span><br><span class="line">        <span class="keyword">return</span> AcquireResult::AR_PROBE;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> AcquireResult::AR_IO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="release-lane"><a href="#release-lane" class="headerlink" title="release_lane"></a>release_lane</h3><p>当 CacheOperator::_per_lane_buffers 中的数据读完完毕，会调用  LaneArbiter::release_lane 函数，来标志某个 lane 已经处理完毕。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LaneArbiter::release_lane</span><span class="params">(LaneOwnerType lane_owner)</span> </span>&#123;</span><br><span class="line">    _processed.<span class="built_in">insert</span>(lane_owner);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; _assignment : _assignments) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_assignment.lane_owner == lane_owner) &#123;</span><br><span class="line">            _assignment = LANE_UNASSIGNED; <span class="comment">// 设置为初始化状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PipelineDriver-prepare"><a href="#PipelineDriver-prepare" class="headerlink" title="PipelineDriver::prepare"></a>PipelineDriver::prepare</h3><p>将 CacheOperator 融入到 PipelineDriver 中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PipelineDriver::prepare</span><span class="params">(RuntimeState* runtime_state)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> cache_op_idx = <span class="number">-1</span>;</span><br><span class="line">    query_cache::CacheOperatorPtr cache_op = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 在一个 pipeline 中寻找 CacheOperator 的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; _operators.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_op = std::<span class="built_in">dynamic_pointer_cast</span>&lt;query_cache::CacheOperator&gt;(_operators[i]);</span><br><span class="line">            cache_op != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cache_op_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache_op != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        query_cache::LaneArbiterPtr lane_arbiter = cache_op-&gt;<span class="built_in">lane_arbiter</span>();</span><br><span class="line">        query_cache::MultilaneOperators multilane_operators;</span><br><span class="line">        <span class="comment">// CacheOperator 之前的 operator 都被 wapper 在 MultilaneOperator 或者 OlapScanOperator</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; cache_op_idx; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; op = _operators[i];</span><br><span class="line">            <span class="comment">// 在 pipeline_builder 中构建的对应的 factory</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span>* multilane_op = <span class="built_in">dynamic_cast</span>&lt;query_cache::MultilaneOperator*&gt;(op.<span class="built_in">get</span>()); </span><br><span class="line">                multilane_op != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                multilane_op-&gt;<span class="built_in">set_lane_arbiter</span>(lane_arbiter);</span><br><span class="line">                multilane_operators.<span class="built_in">push_back</span>(multilane_op);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span>* olap_scan_op = <span class="built_in">dynamic_cast</span>&lt;OlapScanOperator*&gt;(op.<span class="built_in">get</span>()); </span><br><span class="line">                       olap_scan_op != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                olap_scan_op-&gt;<span class="built_in">set_lane_arbiter</span>(lane_arbiter);</span><br><span class="line">                <span class="comment">// 设置 cache_operator</span></span><br><span class="line">                olap_scan_op-&gt;<span class="built_in">set_cache_operator</span>(cache_op);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache_op-&gt;<span class="built_in">set_multilane_operators</span>(std::<span class="built_in">move</span>(multilane_operators));</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#enable-query-cache"><span class="toc-number">1.</span> <span class="toc-text">enable_query_cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#disable-query-cache"><span class="toc-number">2.</span> <span class="toc-text">disable_query_cache</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#push-chunk"><span class="toc-number">3.</span> <span class="toc-text">push_chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#populate-cache"><span class="toc-number">3.1.</span> <span class="toc-text">populate_cache</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pull-chunk"><span class="toc-number">4.</span> <span class="toc-text">pull_chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pull-chunk-from-per-lane-buffer"><span class="toc-number">4.1.</span> <span class="toc-text">_pull_chunk_from_per_lane_buffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#pick-morsel"><span class="toc-number">5.</span> <span class="toc-text">_pick_morsel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#delta-version-and-rowsets"><span class="toc-number">5.1.</span> <span class="toc-text">delta_version_and_rowsets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OlapChunkSource-init-olap-reader"><span class="toc-number">5.2.</span> <span class="toc-text">OlapChunkSource::_init_olap_reader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CacheOperator-probe-cache"><span class="toc-number">5.3.</span> <span class="toc-text">CacheOperator::probe_cache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#handle-stale-cache-value-for-non-pk"><span class="toc-number">5.3.1.</span> <span class="toc-text">_handle_stale_cache_value_for_non_pk</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LaneArbiter"><span class="toc-number">6.</span> <span class="toc-text">LaneArbiter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-acquire-lane"><span class="toc-number">6.1.</span> <span class="toc-text">try_acquire_lane</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#release-lane"><span class="toc-number">6.2.</span> <span class="toc-text">release_lane</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PipelineDriver-prepare"><span class="toc-number">6.3.</span> <span class="toc-text">PipelineDriver::prepare</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&text=Pipeline: 查询加速: QueryCache"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&title=Pipeline: 查询加速: QueryCache"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&is_video=false&description=Pipeline: 查询加速: QueryCache"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Pipeline: 查询加速: QueryCache&body=Check out this article: https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&title=Pipeline: 查询加速: QueryCache"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&title=Pipeline: 查询加速: QueryCache"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&title=Pipeline: 查询加速: QueryCache"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&title=Pipeline: 查询加速: QueryCache"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&name=Pipeline: 查询加速: QueryCache&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/08/05/Pipeline/StarRocks-QueryCache/&t=Pipeline: 查询加速: QueryCache"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
