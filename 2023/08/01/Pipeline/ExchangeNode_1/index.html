<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="前面几篇所述都单个 FragmentInstance 内的执行流。StarRocks 是 MPP 架构，并发执行多个 FragmentInstances。因此就涉及到多个 FragmentInstances 之间数据通信，FragmentExecutor 在构造每个 PipelineDriver 时，最后一个 Operator 肯定是 Sink。如果 Sink 的对端是另一个 FragmentIn">
<meta property="og:type" content="article">
<meta property="og:title" content="MPP: ExchangeSinkOperator 设计详解">
<meta property="og:url" content="https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="前面几篇所述都单个 FragmentInstance 内的执行流。StarRocks 是 MPP 架构，并发执行多个 FragmentInstances。因此就涉及到多个 FragmentInstances 之间数据通信，FragmentExecutor 在构造每个 PipelineDriver 时，最后一个 Operator 肯定是 Sink。如果 Sink 的对端是另一个 FragmentIn">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-FragmentInstance-1.svg?raw=true">
<meta property="article:published_time" content="2023-08-01T02:00:01.000Z">
<meta property="article:modified_time" content="2023-08-24T15:15:12.475Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Pipeline">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-FragmentInstance-1.svg?raw=true">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>MPP: ExchangeSinkOperator 设计详解</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2023/08/02/Pipeline/ExchangeNode_2/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2023/07/31/Pipeline/FragmentInstance/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&text=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&is_video=false&description=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MPP: ExchangeSinkOperator 设计详解&body=Check out this article: https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&name=MPP: ExchangeSinkOperator 设计详解&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&t=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-number">1.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-is-local"><span class="toc-number">1.1.</span> <span class="toc-text">Channel::is_local</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PTransmitChunkParams"><span class="toc-number">1.2.</span> <span class="toc-text">PTransmitChunkParams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-send-one-chunk"><span class="toc-number">1.3.</span> <span class="toc-text">Channel::send_one_chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SinkBuffer-add-request"><span class="toc-number">1.4.</span> <span class="toc-text">SinkBuffer::add_request</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SinkBuffer"><span class="toc-number">2.</span> <span class="toc-text">SinkBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-to-send-rpc"><span class="toc-number">2.1.</span> <span class="toc-text">_try_to_send_rpc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Part-callback"><span class="toc-number">2.1.1.</span> <span class="toc-text">Part: callback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part2-%E9%99%90%E6%B5%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">Part2: 限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part3-Order"><span class="toc-number">2.1.3.</span> <span class="toc-text">Part3: Order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part4-Send-RPC"><span class="toc-number">2.1.4.</span> <span class="toc-text">Part4: Send RPC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#send-rpc"><span class="toc-number">2.2.</span> <span class="toc-text">_send_rpc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#push-chunk"><span class="toc-number">3.</span> <span class="toc-text">push_chunk</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        MPP: ExchangeSinkOperator 设计详解
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-08-01T02:00:01.000Z" itemprop="datePublished">2023-08-01</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Timeline/">Timeline</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Pipeline/" rel="tag">Pipeline</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>前面几篇所述都单个 FragmentInstance 内的执行流。StarRocks 是 MPP 架构，并发执行多个 FragmentInstances。因此就涉及到多个 FragmentInstances 之间数据通信，FragmentExecutor 在构造每个 PipelineDriver 时，最后一个 Operator 肯定是 Sink。如果 Sink 的对端是另一个 FragmentInstance，则 Sink 会是 ExchangeSinkOperator，接受端使用 ExchangeSourceOperator 来接受数据。</p>
<blockquote>
<p>后续还有个优化版本 LocalExchangeSinkOperator、LocalExchangeSourceOperator</p>
</blockquote>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-FragmentInstance-1.svg?raw=true" alt="Pipeline-FragmentInstance-1"></p>
<p>StarRocks 输入输出的 Buffer 都是所有 PipelineDrivers 共享的，这也符合论文 <a href="https://szza.github.io/2023/04/02/Paper/Morsel-Driven-Parallelism">Morsel-Driven-Parallelism</a> 所述的设计。</p>
<p>同样，ExchangeSinkOperator 中的 SinkBuffer 也是在所有 PipelineDrivers 间共享。从构造 ExchangeSinkOperatorFactory 到 ExchangeSinkOperator 如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;ExchangeSinkOperatorFactory&gt; _create_exchange_sink_operator(</span><br><span class="line">    PipelineBuilderContext* context, <span class="type">const</span> TDataStreamSink&amp; stream_sink,</span><br><span class="line">    <span class="type">const</span> DataStreamSender* sender, <span class="type">size_t</span> dop) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fragment_ctx = context-&gt;<span class="built_in">fragment_context</span>();</span><br><span class="line">    <span class="type">bool</span> is_dest_merge = stream_sink.__isset.is_merge &amp;&amp; stream_sink.is_merge;</span><br><span class="line">    TPartitionType part_type = sender-&gt;<span class="built_in">get_partition_type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> is_pipeline_level_shuffle = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int32_t</span> dest_dop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">        part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">        dest_dop = stream_sink.dest_dop;</span><br><span class="line">        is_pipeline_level_shuffle = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">DCHECK_GT</span>(dest_dop, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 构造 sink_buffer </span></span><br><span class="line">    std::shared_ptr&lt;SinkBuffer&gt; sink_buffer = std::<span class="built_in">make_shared</span>&lt;SinkBuffer&gt;(</span><br><span class="line">        fragment_ctx, sender-&gt;<span class="built_in">destinations</span>(), is_dest_merge, dop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ExchangeSinkOperatorFactory&gt;(</span><br><span class="line">            context-&gt;<span class="built_in">next_operator_id</span>(), stream_sink.dest_node_id,</span><br><span class="line">            sink_buffer, <span class="comment">// 传递给 ExchangeSinkOperatorFactory</span></span><br><span class="line">            sender-&gt;<span class="built_in">get_partition_type</span>(),</span><br><span class="line">            sender-&gt;<span class="built_in">destinations</span>(), is_pipeline_level_shuffle,</span><br><span class="line">            dest_dop, sender-&gt;<span class="built_in">sender_id</span>(),</span><br><span class="line">            sender-&gt;<span class="built_in">get_dest_node_id</span>(), sender-&gt;<span class="built_in">get_partition_exprs</span>(),</span><br><span class="line">            !is_dest_merge &amp;&amp; sender-&gt;<span class="built_in">get_enable_exchange_pass_through</span>(),</span><br><span class="line">            sender-&gt;<span class="built_in">get_enable_exchange_perf</span>() &amp;&amp; !context-&gt;has_aggregation,</span><br><span class="line">            fragment_ctx, sender-&gt;<span class="built_in">output_columns</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ExchangeSinkOperator</span></span><br><span class="line"><span class="function">OperatorPtr <span class="title">ExchangeSinkOperatorFactory::create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> degree_of_parallelism, <span class="type">int32_t</span> driver_sequence)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ExchangeSinkOperator&gt;(</span><br><span class="line">            <span class="keyword">this</span>, _id, _plan_node_id,</span><br><span class="line">            driver_sequence,  <span class="comment">// 具体的 PipelineDriver</span></span><br><span class="line">            _buffer,          <span class="comment">// 传递给所有的 PipelineDrivers</span></span><br><span class="line">            _part_type,</span><br><span class="line">            _destinations,</span><br><span class="line">            _is_pipeline_level_shuffle,</span><br><span class="line">            _num_shuffles_per_channel,</span><br><span class="line">            _sender_id, _dest_node_id,</span><br><span class="line">            _partition_expr_ctxs,</span><br><span class="line">            _enable_exchange_pass_through,</span><br><span class="line">            _enable_exchange_perf,</span><br><span class="line">            _fragment_ctx,</span><br><span class="line">            _output_columns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>ExchangeSinkOperator 构造函数中的 <em>_destinations</em> 表示所有的对端，即 Sink 的接受者，每一个 _destinations[i] 都被封装为一个 ExchangeSinkOperator::Channel 对象，并通过 Channel 对象向对端发送 RPC，但是内部通过 SinkBuffer::_try_to_send_rpc 函数发出去的。</p>
<p>此外，Channel 对象还可以判断是否与对端在同一个BE进程中，如果在一个 BE 进程中，则不用 PRC 跨进程通信，转而使用共享内存的方式。</p>
<p>Channel 构造函数如下：</p>
<ul>
<li>_brpc_dest_addr: 对端 BE 的 bRPC 监听地址 ipport</li>
<li>_fragment_instance_id: 对端 BE 上的 fragment_instance</li>
<li>_dest_node_id: 接受数据的 ExchangeSourceOperator 所属的 ExchangeNode id</li>
</ul>
<p>这三个信息就可以唯一确定谁接受消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Channel</span>(ExchangeSinkOperator* parent, </span><br><span class="line">        <span class="type">const</span> TNetworkAddress&amp; brpc_dest,</span><br><span class="line">        <span class="type">const</span> TUniqueId&amp; fragment_instance_id,</span><br><span class="line">        PlanNodeId dest_node_id, </span><br><span class="line">        <span class="type">int32_t</span> num_shuffles,</span><br><span class="line">        <span class="type">bool</span> enable_exchange_pass_through,</span><br><span class="line">        <span class="type">bool</span> enable_exchange_perf,</span><br><span class="line">        PassThroughChunkBuffer* pass_through_chunk_buffer)</span><br><span class="line">        : _parent(parent),</span><br><span class="line">          _brpc_dest_addr(brpc_dest),</span><br><span class="line">          _fragment_instance_id(fragment_instance_id),</span><br><span class="line">          _dest_node_id(dest_node_id),</span><br><span class="line">          _enable_exchange_pass_through(enable_exchange_pass_through),</span><br><span class="line">          _enable_exchange_perf(enable_exchange_perf),</span><br><span class="line">          _pass_through_context(pass_through_chunk_buffer,</span><br><span class="line">                                fragment_instance_id,</span><br><span class="line">                                dest_node_id),</span><br><span class="line">          _chunks(num_shuffles) &#123; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Channel-is-local"><a href="#Channel-is-local" class="headerlink" title="Channel::is_local"></a>Channel::is_local</h3><p>is_local 函数用于判断和对端是否在 同一个 BE 进程中。此外，_enable_exchange_pass_through 是由于 FE 传递过来的参数，可以由用户更改是否开启 PassThrough 模式，默认值为 true。若 _enable_exchange_pass_through 为 true，且和对端在一个 BE 进程中，则 _use_pass_through 为 true，后续数据传输就不走 RPC 了，而是通过 <strong>_pass_through_context</strong> 在两个 FragmentInstance 之间传递数据。</p>
<blockquote>
<p>这个设计就是通过共享内存在多线程间传递数据</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> ExchangeSinkOperator::Channel::<span class="built_in">is_local</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (BackendOptions::<span class="built_in">get_localhost</span>() != _brpc_dest_addr.hostname) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config::brpc_port != _brpc_dest_addr.port) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ExchangeSinkOperator::Channel::_check_use_pass_through() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_enable_exchange_pass_through) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">is_local</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> ExchangeSinkOperator::Channel::_prepare_pass_through() &#123;</span><br><span class="line">    _pass_through_context.<span class="built_in">init</span>();</span><br><span class="line">    _use_pass_through = _check_use_pass_through();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PTransmitChunkParams"><a href="#PTransmitChunkParams" class="headerlink" title="PTransmitChunkParams"></a>PTransmitChunkParams</h3><p>在讲解 Channel::send_one_chunk 发送消息之前，先说下传输数据的 proto 格式。如下 PTransmitChunkParams 就是数据传输协议。</p>
<ul>
<li>eos: 表示本次 PRC 是否是最后一个 chunk</li>
<li>chunks: RPC 是批量发送模式，chunks 中包含了多次 RPC 数据</li>
<li>use_pass_through: false 时对端从 chunks 中反序列得到数据，true 时从共享内存中获得数据</li>
<li>is_pipeline_level_shuffle: 其赋值见上文的 _create_exchange_sink_operator 函数</li>
<li>driver_sequences: 在 <em>is_pipeline_level_shuffle</em> 为 true 时生效。此时和 driver_sequences_size 和 chunks_size 一样，每个 chunk[i] 直接写入 driver_sequences[i] 对应的 PipelineDriver 的输入源。</li>
</ul>
<p>全部字段如下。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">PTransmitChunkParams</span> &#123;</span><br><span class="line">    <span class="comment">// non-change member</span></span><br><span class="line">    <span class="keyword">optional</span> PUniqueId finst_id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> node_id = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Id of this fragment in its role as a sender.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> sender_id = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> be_number = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// If set to true, indicates that no more row batches will be sent</span></span><br><span class="line">    <span class="comment">// for this dest_node_id.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">bool</span> eos = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// RPC sequence number for the send channel.</span></span><br><span class="line">    <span class="comment">// Sever will check this number to see if some packet has lost.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int64</span> sequence = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The protobuf data structure for column chunk.</span></span><br><span class="line">    <span class="keyword">repeated</span> ChunkPB chunks = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some statistics for the runing query.</span></span><br><span class="line">    <span class="keyword">optional</span> PQueryStatistics query_statistics = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">bool</span> use_pass_through = <span class="number">9</span> [default = <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Whether enable pipeline level shuffle.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">bool</span> is_pipeline_level_shuffle = <span class="number">10</span> [default = <span class="literal">false</span>];</span><br><span class="line">    <span class="comment">// Driver sequences of pipeline level shuffle.</span></span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">int32</span> driver_sequences = <span class="number">11</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Channel-send-one-chunk"><a href="#Channel-send-one-chunk" class="headerlink" title="Channel::send_one_chunk"></a>Channel::send_one_chunk</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Status ExchangeSinkOperator::Channel::<span class="built_in">send_one_chunk</span>(RuntimeState* state,</span><br><span class="line">                                                     <span class="type">const</span> Chunk* chunk, </span><br><span class="line">                                                     <span class="type">int32_t</span> driver_sequence,</span><br><span class="line">                                                     <span class="type">bool</span> eos, </span><br><span class="line">                                                     <span class="type">bool</span>* is_real_sent) &#123;</span><br><span class="line"></span><br><span class="line">    *is_real_sent = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_ignore_local_data &amp;&amp; !eos, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_chunk_request == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        _chunk_request = std::<span class="built_in">make_shared</span>&lt;PTransmitChunkParams&gt;();</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_node_id</span>(_dest_node_id);</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_sender_id</span>(_parent-&gt;_sender_id);</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_be_number</span>(_parent-&gt;_be_number);</span><br><span class="line">        <span class="keyword">if</span> (_parent-&gt;_is_pipeline_level_shuffle) &#123;</span><br><span class="line">            _chunk_request-&gt;<span class="built_in">set_is_pipeline_level_shuffle</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. batch 数据</span></span><br><span class="line">    <span class="keyword">if</span> (chunk != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_use_pass_through) &#123;</span><br><span class="line">            <span class="comment">// 1.1 使用共享内存方式传递数据</span></span><br><span class="line">            <span class="comment">//     发送端没有序列化，对端接受到数据也不用反序列化</span></span><br><span class="line">            <span class="type">size_t</span> chunk_size = </span><br><span class="line">                serde::ProtobufChunkSerde::<span class="built_in">max_serialized_size</span>(*chunk);</span><br><span class="line">            <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(_pass_through_context.<span class="built_in">append_chunk</span>(</span><br><span class="line">                        _parent-&gt;_sender_id, chunk, chunk_size,</span><br><span class="line">                        _parent-&gt;_is_pipeline_level_shuffle </span><br><span class="line">                         ? driver_sequence : <span class="number">-1</span>));</span><br><span class="line">            _current_request_bytes += chunk_size;</span><br><span class="line">            <span class="built_in">COUNTER_UPDATE</span>(_parent-&gt;_bytes_pass_through_counter, chunk_size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2 RPC 方式通信，则攒批</span></span><br><span class="line">            <span class="keyword">if</span> (_parent-&gt;_is_pipeline_level_shuffle) &#123;</span><br><span class="line">                _chunk_request-&gt;<span class="built_in">add_driver_sequences</span>(driver_sequence);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 数据序列化后添加到 pchunk 中</span></span><br><span class="line">            <span class="keyword">auto</span> pchunk = _chunk_request-&gt;<span class="built_in">add_chunks</span>();</span><br><span class="line">            <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(<span class="built_in">RETURN_IF_ERROR</span>(_parent-&gt;<span class="built_in">serialize_chunk</span>(</span><br><span class="line">                chunk, pchunk, &amp;_is_first_chunk)));</span><br><span class="line">            _current_request_bytes += pchunk-&gt;<span class="built_in">data</span>().<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 真正的发送消息</span></span><br><span class="line">    <span class="comment">//    条件是: batched 的数据超过内存限制，或者是最后一条数据（eos 为 true）</span></span><br><span class="line">    <span class="keyword">if</span> (_current_request_bytes &gt; config::max_transmit_batched_bytes || eos) &#123;</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_eos</span>(eos);</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_use_pass_through</span>(_use_pass_through);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> delta_statistic = state-&gt;<span class="built_in">intermediate_query_statistic</span>()) &#123;</span><br><span class="line">            delta_statistic-&gt;<span class="built_in">to_pb</span>(_chunk_request-&gt;<span class="built_in">mutable_query_statistics</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        butil::IOBuf attachment;</span><br><span class="line">        <span class="type">int64_t</span> attachment_physical_bytes = </span><br><span class="line">            _parent-&gt;<span class="built_in">construct_brpc_attachment</span>(_chunk_request, attachment);</span><br><span class="line">        TransmitChunkInfo info &#123;_fragment_instance_id, _brpc_stub,</span><br><span class="line">                                 std::<span class="built_in">move</span>(_chunk_request),</span><br><span class="line">                                 attachment, attachment_physical_bytes,</span><br><span class="line">                                 _brpc_dest_addr&#125;;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_parent-&gt;_buffer-&gt;<span class="built_in">add_request</span>(info));</span><br><span class="line">        _current_request_bytes = <span class="number">0</span>;</span><br><span class="line">        *is_real_sent = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SinkBuffer-add-request"><a href="#SinkBuffer-add-request" class="headerlink" title="SinkBuffer::add_request"></a>SinkBuffer::add_request</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SinkBuffer::add_request</span><span class="params">(TransmitChunkInfo&amp; request)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_is_finishing, Status::<span class="built_in">OK</span>());</span><br><span class="line">    <span class="keyword">if</span> (!request.attachment.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _bytes_enqueued += request.attachment.<span class="built_in">size</span>();</span><br><span class="line">        _request_enqueued++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; instance_id = request.fragment_instance_id;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_try_to_send_rpc(instance_id, </span><br><span class="line">            [&amp;]() &#123; _buffers[instance_id.lo].<span class="built_in">push</span>(request); &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SinkBuffer"><a href="#SinkBuffer" class="headerlink" title="SinkBuffer"></a>SinkBuffer</h2><p>SinkBuffer 设计要稍微复杂点，因为要考虑顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">SinkBuffer::<span class="built_in">SinkBuffer</span>(FragmentContext* fragment_ctx,</span><br><span class="line">                       <span class="type">const</span> std::vector&lt;TPlanFragmentDestination&gt;&amp; destinations,</span><br><span class="line">                       <span class="type">bool</span> is_dest_merge, <span class="type">size_t</span> num_sinkers)</span><br><span class="line">        : _fragment_ctx(fragment_ctx),</span><br><span class="line">          _mem_tracker(fragment_ctx-&gt;<span class="built_in">runtime_state</span>()-&gt;<span class="built_in">instance_mem_tracker</span>()),</span><br><span class="line">          _brpc_timeout_ms(std::<span class="built_in">min</span>(<span class="number">3600</span>, fragment_ctx-&gt;<span class="built_in">runtime_state</span>()-&gt;<span class="built_in">query_options</span>().query_timeout) * <span class="number">1000</span>),</span><br><span class="line">          _is_dest_merge(is_dest_merge),</span><br><span class="line">          _num_uncancelled_sinkers(num_sinkers),</span><br><span class="line">          _rpc_http_min_size(fragment_ctx-&gt;<span class="built_in">runtime_state</span>()-&gt;<span class="built_in">get_rpc_http_min_size</span>()) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; dest : destinations) &#123;</span><br><span class="line">        <span class="type">const</span> <span class="keyword">auto</span>&amp; instance_id = dest.fragment_instance_id;</span><br><span class="line">        <span class="comment">// instance_id.lo == -1 indicates that the destination is pseudo for bucket shuffle join.</span></span><br><span class="line">        <span class="keyword">if</span> (instance_id.lo == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> it = _num_sinkers.<span class="built_in">find</span>(instance_id.lo);</span><br><span class="line">        <span class="keyword">if</span> (it == _num_sinkers.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            _num_sinkers[instance_id.lo] = num_sinkers;</span><br><span class="line"></span><br><span class="line">            _request_seqs[instance_id.lo] = <span class="number">-1</span>;</span><br><span class="line">            _max_continuous_acked_seqs[instance_id.lo] = <span class="number">-1</span>;</span><br><span class="line">            _discontinuous_acked_seqs[instance_id.lo] = std::<span class="built_in">unordered_set</span>&lt;<span class="type">int64_t</span>&gt;();</span><br><span class="line">            _buffers[instance_id.lo] = std::queue&lt;TransmitChunkInfo, std::list&lt;TransmitChunkInfo&gt;&gt;();</span><br><span class="line">            _num_finished_rpcs[instance_id.lo] = <span class="number">0</span>;</span><br><span class="line">            _num_in_flight_rpcs[instance_id.lo] = <span class="number">0</span>;</span><br><span class="line">            _network_times[instance_id.lo] = TimeTrace&#123;&#125;;</span><br><span class="line">            _mutexes[instance_id.lo] = std::<span class="built_in">make_unique</span>&lt;Mutex&gt;();</span><br><span class="line"></span><br><span class="line">            PUniqueId finst_id;</span><br><span class="line">            finst_id.<span class="built_in">set_hi</span>(instance_id.hi);</span><br><span class="line">            finst_id.<span class="built_in">set_lo</span>(instance_id.lo);</span><br><span class="line">            _instance_id2finst_id[instance_id.lo] = std::<span class="built_in">move</span>(finst_id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _num_remaining_eos = _num_sinkers.<span class="built_in">size</span>() * num_sinkers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="try-to-send-rpc"><a href="#try-to-send-rpc" class="headerlink" title="_try_to_send_rpc"></a>_try_to_send_rpc</h3><p>完整的 _try_to_send_rpc 代码见 <a target="_blank" rel="noopener" href="https://github.com/StarRocks/starrocks/blob/fbfb7ed80e284d349694adbb57d3f1c643e46e58/be/src/exec/pipeline/exchange/sink_buffer.cpp#L257C1-L257C1">_try_to_send_rpc</a> ，下面按照顺序拆分成四部分来讲解。</p>
<h4 id="Part-callback"><a href="#Part-callback" class="headerlink" title="Part: callback"></a>Part: callback</h4><p>_try_to_send_rpc 函数第二个参数 <em>pre_works_cb</em> 会在发送 RPC 之前执行，比如上面 add_request 函数传入的 cb 是将新增的 RPC 请求 request 添加到 _buffers[instance_id.lo] 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;Mutex&gt; <span class="title">l</span><span class="params">(*_mutexes[instance_id.lo])</span></span>;</span><br><span class="line">    <span class="built_in">pre_works_cb</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">DeferOp <span class="title">decrease_defer</span><span class="params">([<span class="keyword">this</span>]() &#123; --_num_sending_rpc; &#125;)</span></span>;</span><br><span class="line">    ++_num_sending_rpc;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part2-限流"><a href="#Part2-限流" class="headerlink" title="Part2: 限流"></a>Part2: 限流</h4><p>_try_to_send_rpc 会从 _buffers[instance_id.lo] 中取出所有待执行的 RPC，发送给 instance_id。这里做了一个限流:  _num_in_flight_rpcs[instance_id.lo] 记录的是已发送给 instance_id 但尚未收到 response 的 PRC 数量，该数据量不能超过阈值 config::pipeline_sink_brpc_dop（默认值 64），如果超过则暂停发送。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">    <span class="comment">//...above code</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// part2: start</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">RETURN_IF</span>(_is_finishing, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 限流</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; buffer = _buffers[instance_id.lo];</span><br><span class="line">        <span class="type">bool</span> too_much_rpc = </span><br><span class="line">            _num_in_flight_rpcs[instance_id.lo] &gt;= config::pipeline_sink_brpc_dop;</span><br><span class="line">        <span class="built_in">RETURN_IF</span> (buffer.<span class="built_in">empty</span>() || too_much_rpc, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br></pre></td></tr></table></figure>
<h4 id="Part3-Order"><a href="#Part3-Order" class="headerlink" title="Part3: Order"></a>Part3: Order</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 提取 request</span></span><br><span class="line">        TransmitChunkInfo&amp; request = buffer.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">bool</span> need_wait = <span class="literal">false</span>;</span><br><span class="line">        <span class="function">DeferOp <span class="title">pop_defer</span><span class="params">([&amp;need_wait, &amp;buffer, mem_tracker = _mem_tracker]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (need_wait) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            SCOPED_THREAD_LOCAL_MEM_TRACKER_SETTER(mem_tracker);</span></span></span><br><span class="line"><span class="params"><span class="function">            buffer.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 CHECK: 必须等待 submit 的第一个数据包返回了，才能继续发送</span></span><br><span class="line">        <span class="comment">// Reason ?</span></span><br><span class="line">        <span class="keyword">if</span> (_num_finished_rpcs[instance_id.lo] == <span class="number">0</span> </span><br><span class="line">            &amp;&amp; _num_in_flight_rpcs[instance_id.lo] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            need_wait = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 </span></span><br><span class="line">        <span class="keyword">auto</span>&amp; params = request.params;</span><br><span class="line">        <span class="keyword">if</span> (params-&gt;<span class="built_in">eos</span>()) &#123;</span><br><span class="line">            <span class="function">DeferOp <span class="title">eos_defer</span><span class="params">([<span class="keyword">this</span>, &amp;instance_id, &amp;need_wait]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (need_wait) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (--_num_remaining_eos == <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    _is_finishing = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                --_num_sinkers[instance_id.lo];</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (_num_sinkers[instance_id.lo] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                _try_to_merge_query_statistics(request);</span><br><span class="line">                <span class="keyword">if</span> (params-&gt;<span class="built_in">chunks_size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    params-&gt;<span class="built_in">set_eos</span>(<span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (_num_in_flight_rpcs[instance_id.lo] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    need_wait = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                _eos_query_stats-&gt;<span class="built_in">merge_pb</span>(params-&gt;<span class="built_in">query_statistics</span>());</span><br><span class="line">                params-&gt;<span class="built_in">clear_query_statistics</span>();</span><br><span class="line">                _eos_query_stats-&gt;<span class="built_in">to_pb</span>(params-&gt;<span class="built_in">mutable_query_statistics</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part4-Send-RPC"><a href="#Part4-Send-RPC" class="headerlink" title="Part4: Send RPC"></a>Part4: Send RPC</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//... above code</span></span><br><span class="line"></span><br><span class="line">        params-&gt;<span class="built_in">set_finst_id</span>(_instance_id2finst_id[instance_id.lo]);</span><br><span class="line">        params-&gt;<span class="built_in">set_sequence</span>(++_request_seqs[instance_id.lo]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!request.attachment.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _bytes_sent += request.attachment.<span class="built_in">size</span>();</span><br><span class="line">            _request_sent++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 callback</span></span><br><span class="line">        <span class="keyword">auto</span>* closure = <span class="keyword">new</span> <span class="built_in">DisposableClosure</span>&lt;PTransmitChunkResult, ClosureContext&gt;(</span><br><span class="line">                &#123;instance_id, params-&gt;<span class="built_in">sequence</span>(), <span class="built_in">MonotonicNanos</span>()&#125;);</span><br><span class="line">        <span class="keyword">if</span> (_first_send_time == <span class="number">-1</span>) &#123;</span><br><span class="line">            _first_send_time = <span class="built_in">MonotonicNanos</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        closure-&gt;<span class="built_in">addFailedHandler</span>(failed_cb);</span><br><span class="line">        closure-&gt;<span class="built_in">addSuccessHandler</span>(success_cb);</span><br><span class="line"></span><br><span class="line">        ++_total_in_flight_rpc;</span><br><span class="line">        ++_num_in_flight_rpcs[instance_id.lo];</span><br><span class="line"></span><br><span class="line">        _mem_tracker-&gt;<span class="built_in">release</span>(request.attachment_physical_bytes);</span><br><span class="line">        ExecEnv::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">process_mem_tracker</span>()-&gt;<span class="built_in">consume</span>(</span><br><span class="line">            request.attachment_physical_bytes);</span><br><span class="line"></span><br><span class="line">        closure-&gt;cntl.<span class="built_in">Reset</span>();</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">set_timeout_ms</span>(_brpc_timeout_ms);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bthread_self</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> _send_rpc(closure, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">SCOPED_THREAD_LOCAL_MEM_TRACKER_SETTER</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">return</span> _send_rpc(closure, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="send-rpc"><a href="#send-rpc" class="headerlink" title="_send_rpc"></a>_send_rpc</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_send_rpc(DisposableClosure&lt;PTransmitChunkResult,</span><br><span class="line">                             ClosureContext&gt;* closure,</span><br><span class="line">                             <span class="type">const</span> TransmitChunkInfo&amp; request) &#123;</span><br><span class="line">    <span class="keyword">auto</span> expected_iobuf_size = request.attachment.<span class="built_in">size</span>() </span><br><span class="line">                             + request.params-&gt;<span class="built_in">ByteSizeLong</span>() </span><br><span class="line">                             + <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(expected_iobuf_size &gt; _rpc_http_min_size)) &#123;</span><br><span class="line">        butil::IOBuf iobuf;</span><br><span class="line">        <span class="function">butil::IOBufAsZeroCopyOutputStream <span class="title">wrapper</span><span class="params">(&amp;iobuf)</span></span>;</span><br><span class="line">        request.params-&gt;<span class="built_in">SerializeToZeroCopyStream</span>(&amp;wrapper);</span><br><span class="line">        <span class="comment">// append params to iobuf</span></span><br><span class="line">        <span class="type">size_t</span> params_size = iobuf.<span class="built_in">size</span>();</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(</span><br><span class="line">            &amp;params_size, <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(iobuf);</span><br><span class="line">        <span class="comment">// append attachment</span></span><br><span class="line">        <span class="type">size_t</span> attachment_size = request.attachment.<span class="built_in">size</span>();</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(</span><br><span class="line">            &amp;attachment_size, <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(request.attachment);</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">http_request</span>().<span class="built_in">set_content_type</span>(<span class="string">&quot;application/proto&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> res = BrpcStubCache::<span class="built_in">create_http_stub</span>(request.brpc_addr);</span><br><span class="line">        <span class="built_in">RETURN_IF</span>(!res.<span class="built_in">ok</span>(), res.<span class="built_in">status</span>());</span><br><span class="line">        <span class="comment">// 异步 RPC </span></span><br><span class="line">        res.<span class="built_in">value</span>()-&gt;<span class="built_in">transmit_chunk_via_http</span>(</span><br><span class="line">            &amp;closure-&gt;cntl, <span class="literal">NULL</span>, &amp;closure-&gt;result, closure);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 异步 RPC</span></span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(request.attachment);</span><br><span class="line">        request.brpc_stub-&gt;<span class="built_in">transmit_chunk</span>(</span><br><span class="line">            &amp;closure-&gt;cntl, request.params.<span class="built_in">get</span>(), &amp;closure-&gt;result, closure);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="push-chunk"><a href="#push-chunk" class="headerlink" title="push_chunk"></a>push_chunk</h2>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-number">1.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-is-local"><span class="toc-number">1.1.</span> <span class="toc-text">Channel::is_local</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PTransmitChunkParams"><span class="toc-number">1.2.</span> <span class="toc-text">PTransmitChunkParams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-send-one-chunk"><span class="toc-number">1.3.</span> <span class="toc-text">Channel::send_one_chunk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SinkBuffer-add-request"><span class="toc-number">1.4.</span> <span class="toc-text">SinkBuffer::add_request</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SinkBuffer"><span class="toc-number">2.</span> <span class="toc-text">SinkBuffer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#try-to-send-rpc"><span class="toc-number">2.1.</span> <span class="toc-text">_try_to_send_rpc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Part-callback"><span class="toc-number">2.1.1.</span> <span class="toc-text">Part: callback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part2-%E9%99%90%E6%B5%81"><span class="toc-number">2.1.2.</span> <span class="toc-text">Part2: 限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part3-Order"><span class="toc-number">2.1.3.</span> <span class="toc-text">Part3: Order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part4-Send-RPC"><span class="toc-number">2.1.4.</span> <span class="toc-text">Part4: Send RPC</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#send-rpc"><span class="toc-number">2.2.</span> <span class="toc-text">_send_rpc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#push-chunk"><span class="toc-number">3.</span> <span class="toc-text">push_chunk</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&text=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&is_video=false&description=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MPP: ExchangeSinkOperator 设计详解&body=Check out this article: https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&name=MPP: ExchangeSinkOperator 设计详解&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&t=MPP: ExchangeSinkOperator 设计详解"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/about/">About</a></li>
         
          <li><a href="/categories/">categories</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
