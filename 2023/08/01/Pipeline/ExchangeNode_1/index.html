<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="前面几篇所述都单个 FragmentInstance 内的执行流。StarRocks 是 MPP 架构，并发执行多个 FragmentInstances。因此就涉及到多个 FragmentInstances 之间数据通信，FragmentExecutor 在构造每个 PipelineDriver 时，最后一个 Operator 肯定是 Sink。如果 Sink 的对端是另一个 FragmentIn">
<meta property="og:type" content="article">
<meta property="og:title" content="MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle">
<meta property="og:url" content="https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="前面几篇所述都单个 FragmentInstance 内的执行流。StarRocks 是 MPP 架构，并发执行多个 FragmentInstances。因此就涉及到多个 FragmentInstances 之间数据通信，FragmentExecutor 在构造每个 PipelineDriver 时，最后一个 Operator 肯定是 Sink。如果 Sink 的对端是另一个 FragmentIn">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-FragmentInstance-1.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-2.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-3.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-4.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-5.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-6.svg?raw=true">
<meta property="article:published_time" content="2023-08-01T02:00:01.000Z">
<meta property="article:modified_time" content="2023-09-26T02:32:10.445Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="StarRocks">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-FragmentInstance-1.svg?raw=true">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2023/08/02/Pipeline/ExchangeNode_2/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2023/07/31/Pipeline/FragmentInstance/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&text=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&is_video=false&description=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle&body=Check out this article: https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&name=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&t=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#create-exchange-sink"><span class="toc-number">1.</span> <span class="toc-text">create_exchange_sink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-number">2.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-is-local"><span class="toc-number">2.1.</span> <span class="toc-text">Channel::is_local</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PTransmitChunkParams"><span class="toc-number">2.2.</span> <span class="toc-text">PTransmitChunkParams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-send-one-chunk"><span class="toc-number">2.3.</span> <span class="toc-text">Channel::send_one_chunk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SinkBuffer-add-request"><span class="toc-number">3.</span> <span class="toc-text">SinkBuffer::add_request</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SinkBuffer-try-to-send-rpc"><span class="toc-number">3.1.</span> <span class="toc-text">SinkBuffer::_try_to_send_rpc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Part1-callback"><span class="toc-number">3.1.1.</span> <span class="toc-text">Part1: callback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part2-%E9%99%90%E6%B5%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">Part2: 限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part3-Order"><span class="toc-number">3.1.3.</span> <span class="toc-text">Part3: Order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part4-Send-RPC"><span class="toc-number">3.1.4.</span> <span class="toc-text">Part4: Send RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#process-send-window"><span class="toc-number">3.1.5.</span> <span class="toc-text">_process_send_window</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SinkBuffer-send-rpc"><span class="toc-number">3.2.</span> <span class="toc-text">SinkBuffer::_send_rpc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#push-chunk"><span class="toc-number">4.</span> <span class="toc-text">push_chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TPartitionType-UNPARTITIONED"><span class="toc-number">4.1.</span> <span class="toc-text">TPartitionType::UNPARTITIONED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TPartitionType-RANDOM"><span class="toc-number">4.2.</span> <span class="toc-text">TPartitionType::RANDOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TPartitionType-BUCKET-SHUFFLE-HASH-PARTITIONED"><span class="toc-number">4.3.</span> <span class="toc-text">TPartitionType::BUCKET_SHUFFLE&#x2F;HASH_PARTITIONED</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-values"><span class="toc-number">4.3.1.</span> <span class="toc-text">hash_values</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exchange-shuffle"><span class="toc-number">4.3.2.</span> <span class="toc-text">exchange_shuffle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel-row-idx-start-points"><span class="toc-number">4.3.3.</span> <span class="toc-text">channel_row_idx_start_points</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add-rows-selective"><span class="toc-number">4.3.4.</span> <span class="toc-text">add_rows_selective</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">5.</span> <span class="toc-text">Reference</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-08-01T02:00:01.000Z" itemprop="datePublished">2023-08-01</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/Pipeline/">Pipeline</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/StarRocks/" rel="tag">StarRocks</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>前面几篇所述都单个 FragmentInstance 内的执行流。StarRocks 是 MPP 架构，并发执行多个 FragmentInstances。因此就涉及到多个 FragmentInstances 之间数据通信，FragmentExecutor 在构造每个 PipelineDriver 时，最后一个 Operator 肯定是 Sink。如果 Sink 的对端是另一个 FragmentInstance，则 Sink 会是 ExchangeSinkOperator，接受端使用 ExchangeSourceOperator 来接受数据。</p>
<blockquote>
<p>后续还有个优化版本 LocalExchangeSinkOperator、LocalExchangeSourceOperator</p>
</blockquote>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-FragmentInstance-1.svg?raw=true" alt="Pipeline-FragmentInstance-1"></p>
<p>StarRocks 输入输出的 Buffer 都是所有 PipelineDrivers 共享的，这也符合论文 <a href="https://szza.github.io/2023/04/02/Paper/Morsel-Driven-Parallelism">Morsel-Driven-Parallelism</a> 所述的设计。</p>
<p>同样，ExchangeSinkOperator 中的 SinkBuffer 也是在所有 PipelineDrivers 间共享。从构造 ExchangeSinkOperatorFactory 到 ExchangeSinkOperator 如下。</p>
<h2 id="create-exchange-sink"><a href="#create-exchange-sink" class="headerlink" title="create_exchange_sink"></a>create_exchange_sink</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;ExchangeSinkOperatorFactory&gt; _create_exchange_sink_operator(</span><br><span class="line">    PipelineBuilderContext* context, <span class="type">const</span> TDataStreamSink&amp; stream_sink,</span><br><span class="line">    <span class="type">const</span> DataStreamSender* sender, <span class="type">size_t</span> dop) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fragment_ctx = context-&gt;<span class="built_in">fragment_context</span>();</span><br><span class="line">    <span class="type">bool</span> is_dest_merge = stream_sink.__isset.is_merge &amp;&amp; stream_sink.is_merge;</span><br><span class="line">    TPartitionType part_type = sender-&gt;<span class="built_in">get_partition_type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> is_pipeline_level_shuffle = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int32_t</span> dest_dop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">        part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">        dest_dop = stream_sink.dest_dop;</span><br><span class="line">        is_pipeline_level_shuffle = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">DCHECK_GT</span>(dest_dop, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 构造 sink_buffer </span></span><br><span class="line">    std::shared_ptr&lt;SinkBuffer&gt; sink_buffer = std::<span class="built_in">make_shared</span>&lt;SinkBuffer&gt;(</span><br><span class="line">        fragment_ctx, sender-&gt;<span class="built_in">destinations</span>(), is_dest_merge, dop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ExchangeSinkOperatorFactory&gt;(</span><br><span class="line">            context-&gt;<span class="built_in">next_operator_id</span>(), stream_sink.dest_node_id,</span><br><span class="line">            sink_buffer, <span class="comment">// 传递给 ExchangeSinkOperatorFactory</span></span><br><span class="line">            sender-&gt;<span class="built_in">get_partition_type</span>(),</span><br><span class="line">            sender-&gt;<span class="built_in">destinations</span>(), is_pipeline_level_shuffle,</span><br><span class="line">            dest_dop, sender-&gt;<span class="built_in">sender_id</span>(),</span><br><span class="line">            sender-&gt;<span class="built_in">get_dest_node_id</span>(), sender-&gt;<span class="built_in">get_partition_exprs</span>(),</span><br><span class="line">            !is_dest_merge &amp;&amp; sender-&gt;<span class="built_in">get_enable_exchange_pass_through</span>(),</span><br><span class="line">            sender-&gt;<span class="built_in">get_enable_exchange_perf</span>() &amp;&amp; !context-&gt;has_aggregation,</span><br><span class="line">            fragment_ctx, sender-&gt;<span class="built_in">output_columns</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ExchangeSinkOperator</span></span><br><span class="line"><span class="function">OperatorPtr <span class="title">ExchangeSinkOperatorFactory::create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> degree_of_parallelism, <span class="type">int32_t</span> driver_sequence)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ExchangeSinkOperator&gt;(</span><br><span class="line">            <span class="keyword">this</span>, _id, _plan_node_id,</span><br><span class="line">            driver_sequence,  <span class="comment">// 具体的 PipelineDriver</span></span><br><span class="line">            _buffer,          <span class="comment">// 传递给所有的 PipelineDrivers</span></span><br><span class="line">            _part_type,</span><br><span class="line">            _destinations,</span><br><span class="line">            _is_pipeline_level_shuffle,</span><br><span class="line">            _num_shuffles_per_channel,</span><br><span class="line">            _sender_id, _dest_node_id,</span><br><span class="line">            _partition_expr_ctxs,</span><br><span class="line">            _enable_exchange_pass_through,</span><br><span class="line">            _enable_exchange_perf,</span><br><span class="line">            _fragment_ctx,</span><br><span class="line">            _output_columns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>ExchangeSinkOperator 构造函数中的 <em>_destinations</em> 表示所有的对端，即 Sink 的接受者，每一个 _destinations[i] 都被封装为一个 ExchangeSinkOperator::Channel 对象，并通过 Channel 对象向对端发送 RPC，但是内部通过 SinkBuffer::_try_to_send_rpc 函数发出去的。</p>
<p>此外，Channel 对象还可以判断是否与对端在同一个BE进程中，如果在一个 BE 进程中，则不用 PRC 跨进程通信，转而使用共享内存的方式。</p>
<p>Channel 构造函数如下：</p>
<ul>
<li>_brpc_dest_addr: 对端 BE 的 bRPC 监听地址 ipport</li>
<li>_fragment_instance_id: 对端 BE 上的 fragment_instance</li>
<li>_dest_node_id: 接受数据的 ExchangeSourceOperator 所属的 ExchangeNode id</li>
</ul>
<p>这三个信息就可以唯一确定谁接受消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Channel</span>(ExchangeSinkOperator* parent, </span><br><span class="line">    <span class="type">const</span> TNetworkAddress&amp; brpc_dest,</span><br><span class="line">    <span class="type">const</span> TUniqueId&amp; fragment_instance_id,</span><br><span class="line">    PlanNodeId dest_node_id, </span><br><span class="line">    <span class="type">int32_t</span> num_shuffles,</span><br><span class="line">    <span class="type">bool</span> enable_exchange_pass_through,</span><br><span class="line">    <span class="type">bool</span> enable_exchange_perf,</span><br><span class="line">    PassThroughChunkBuffer* pass_through_chunk_buffer)</span><br><span class="line">    : _parent(parent),</span><br><span class="line">      _brpc_dest_addr(brpc_dest),</span><br><span class="line">      _fragment_instance_id(fragment_instance_id),</span><br><span class="line">      _dest_node_id(dest_node_id),</span><br><span class="line">      _enable_exchange_pass_through(enable_exchange_pass_through),</span><br><span class="line">      _enable_exchange_perf(enable_exchange_perf),</span><br><span class="line">      _pass_through_context(pass_through_chunk_buffer,</span><br><span class="line">                            fragment_instance_id,</span><br><span class="line">                            dest_node_id),</span><br><span class="line">      _chunks(num_shuffles) &#123; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Channel-is-local"><a href="#Channel-is-local" class="headerlink" title="Channel::is_local"></a>Channel::is_local</h3><p>is_local 函数用于判断和对端是否在 同一个 BE 进程中。此外，_enable_exchange_pass_through 是由于 FE 传递过来的参数，可以由用户更改是否开启 PassThrough 模式，默认值为 true。若 _enable_exchange_pass_through 为 true，且和对端在一个 BE 进程中，则 _use_pass_through 为 true，后续数据传输就不走 RPC 了，而是通过 <strong>_pass_through_context</strong> 在两个 FragmentInstance 之间传递数据。</p>
<blockquote>
<p>这个设计就是通过共享内存在多线程间传递数据</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> ExchangeSinkOperator::Channel::<span class="built_in">is_local</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (BackendOptions::<span class="built_in">get_localhost</span>() != _brpc_dest_addr.hostname) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config::brpc_port != _brpc_dest_addr.port) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ExchangeSinkOperator::Channel::_check_use_pass_through() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_enable_exchange_pass_through) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">is_local</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> ExchangeSinkOperator::Channel::_prepare_pass_through() &#123;</span><br><span class="line">    _pass_through_context.<span class="built_in">init</span>();</span><br><span class="line">    _use_pass_through = _check_use_pass_through();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="PTransmitChunkParams"><a href="#PTransmitChunkParams" class="headerlink" title="PTransmitChunkParams"></a>PTransmitChunkParams</h3><p>在讲解 Channel::send_one_chunk 发送消息之前，先说下传输数据的 proto 格式。如下 PTransmitChunkParams 就是数据传输协议。</p>
<ul>
<li>eos: 表示本次 PRC 是否是最后一个 chunk</li>
<li>sequence: 本次 RPC 请求的序号</li>
<li>chunks: RPC 是批量发送模式，chunks 中包含了多次 RPC 数据</li>
<li>use_pass_through: false 时对端从 chunks 中反序列得到数据，true 时从共享内存中获得数据</li>
<li>is_pipeline_level_shuffle: 其赋值见上文的 _create_exchange_sink_operator 函数</li>
<li>driver_sequences: 在 <em>is_pipeline_level_shuffle</em> 为 true 时生效。此时和 driver_sequences_size 和 chunks_size 一样，每个 chunk[i] 直接写入 driver_sequences[i] 对应的 PipelineDriver 的输入源。</li>
</ul>
<p>全部字段如下。</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">PTransmitChunkParams</span> &#123;</span><br><span class="line">    <span class="comment">// non-change member</span></span><br><span class="line">    <span class="keyword">optional</span> PUniqueId finst_id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> node_id = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Id of this fragment in its role as a sender.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> sender_id = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> be_number = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// If set to true, indicates that no more row batches will be sent</span></span><br><span class="line">    <span class="comment">// for this dest_node_id.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">bool</span> eos = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// RPC sequence number for the send channel.</span></span><br><span class="line">    <span class="comment">// Sever will check this number to see if some packet has lost.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int64</span> sequence = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The protobuf data structure for column chunk.</span></span><br><span class="line">    <span class="keyword">repeated</span> ChunkPB chunks = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some statistics for the runing query.</span></span><br><span class="line">    <span class="keyword">optional</span> PQueryStatistics query_statistics = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">bool</span> use_pass_through = <span class="number">9</span> [default = <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Whether enable pipeline level shuffle.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">bool</span> is_pipeline_level_shuffle = <span class="number">10</span> [default = <span class="literal">false</span>];</span><br><span class="line">    <span class="comment">// Driver sequences of pipeline level shuffle.</span></span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">int32</span> driver_sequences = <span class="number">11</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="Channel-send-one-chunk"><a href="#Channel-send-one-chunk" class="headerlink" title="Channel::send_one_chunk"></a>Channel::send_one_chunk</h3><p>Channel 有三种方式发送RPC 数据:</p>
<ul>
<li>send_chunk_request 是直接发送 RPC 请求，</li>
<li>send_one_chunk 是批量发送 RPC 数据，超过大小阈值或者最后一个 RPC 才会发送</li>
<li>add_rows_selective 也是批量模式，不过会先对输入 Chunk 进行筛选后再调用 send_one_chunk。</li>
</ul>
<p>这里以 send_one_chunk 为例。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Status ExchangeSinkOperator::Channel::<span class="built_in">send_one_chunk</span>(RuntimeState* state,</span><br><span class="line">                                                     <span class="type">const</span> Chunk* chunk, </span><br><span class="line">                                                     <span class="type">int32_t</span> driver_sequence,</span><br><span class="line">                                                     <span class="type">bool</span> eos, </span><br><span class="line">                                                     <span class="type">bool</span>* is_real_sent) &#123;</span><br><span class="line"></span><br><span class="line">    *is_real_sent = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_ignore_local_data &amp;&amp; !eos, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_chunk_request == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        _chunk_request = std::<span class="built_in">make_shared</span>&lt;PTransmitChunkParams&gt;();</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_node_id</span>(_dest_node_id);</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_sender_id</span>(_parent-&gt;_sender_id);</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_be_number</span>(_parent-&gt;_be_number);</span><br><span class="line">        <span class="keyword">if</span> (_parent-&gt;_is_pipeline_level_shuffle) &#123;</span><br><span class="line">            _chunk_request-&gt;<span class="built_in">set_is_pipeline_level_shuffle</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. batch 数据</span></span><br><span class="line">    <span class="keyword">if</span> (chunk != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_use_pass_through) &#123;</span><br><span class="line">            <span class="comment">// 1.1 使用共享内存方式传递数据</span></span><br><span class="line">            <span class="comment">//     发送端没有序列化，对端接受到数据也不用反序列化</span></span><br><span class="line">            <span class="type">size_t</span> chunk_size = </span><br><span class="line">                serde::ProtobufChunkSerde::<span class="built_in">max_serialized_size</span>(*chunk);</span><br><span class="line">            <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(_pass_through_context.<span class="built_in">append_chunk</span>(</span><br><span class="line">                        _parent-&gt;_sender_id, chunk, chunk_size,</span><br><span class="line">                        _parent-&gt;_is_pipeline_level_shuffle </span><br><span class="line">                         ? driver_sequence : <span class="number">-1</span>));</span><br><span class="line">            _current_request_bytes += chunk_size;</span><br><span class="line">            <span class="built_in">COUNTER_UPDATE</span>(_parent-&gt;_bytes_pass_through_counter, chunk_size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2 RPC 方式通信，则攒批</span></span><br><span class="line">            <span class="keyword">if</span> (_parent-&gt;_is_pipeline_level_shuffle) &#123;</span><br><span class="line">                _chunk_request-&gt;<span class="built_in">add_driver_sequences</span>(driver_sequence);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 数据序列化后添加到 pchunk 中</span></span><br><span class="line">            <span class="keyword">auto</span> pchunk = _chunk_request-&gt;<span class="built_in">add_chunks</span>();</span><br><span class="line">            <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(<span class="built_in">RETURN_IF_ERROR</span>(_parent-&gt;<span class="built_in">serialize_chunk</span>(</span><br><span class="line">                chunk, pchunk, &amp;_is_first_chunk)));</span><br><span class="line">            _current_request_bytes += pchunk-&gt;<span class="built_in">data</span>().<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 真正的发送消息</span></span><br><span class="line">    <span class="comment">//    条件是: batched 的数据超过内存限制，或者是最后一条数据（eos 为 true）</span></span><br><span class="line">    <span class="keyword">if</span> (_current_request_bytes &gt; config::max_transmit_batched_bytes || eos) &#123;</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_eos</span>(eos);</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_use_pass_through</span>(_use_pass_through);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> delta_statistic = state-&gt;<span class="built_in">intermediate_query_statistic</span>()) &#123;</span><br><span class="line">            delta_statistic-&gt;<span class="built_in">to_pb</span>(_chunk_request-&gt;<span class="built_in">mutable_query_statistics</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        butil::IOBuf attachment;</span><br><span class="line">        <span class="type">int64_t</span> attachment_physical_bytes = </span><br><span class="line">            _parent-&gt;<span class="built_in">construct_brpc_attachment</span>(_chunk_request, attachment);</span><br><span class="line">        TransmitChunkInfo info &#123;_fragment_instance_id, _brpc_stub,</span><br><span class="line">                                 std::<span class="built_in">move</span>(_chunk_request),</span><br><span class="line">                                 attachment, attachment_physical_bytes,</span><br><span class="line">                                 _brpc_dest_addr&#125;;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_parent-&gt;_buffer-&gt;<span class="built_in">add_request</span>(info));</span><br><span class="line">        _current_request_bytes = <span class="number">0</span>;</span><br><span class="line">        *is_real_sent = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="SinkBuffer-add-request"><a href="#SinkBuffer-add-request" class="headerlink" title="SinkBuffer::add_request"></a>SinkBuffer::add_request</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SinkBuffer::add_request</span><span class="params">(TransmitChunkInfo&amp; request)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_is_finishing, Status::<span class="built_in">OK</span>());</span><br><span class="line">    <span class="keyword">if</span> (!request.attachment.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _bytes_enqueued += request.attachment.<span class="built_in">size</span>();</span><br><span class="line">        _request_enqueued++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; instance_id = request.fragment_instance_id;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_try_to_send_rpc(instance_id, </span><br><span class="line">            [&amp;]() &#123; _buffers[instance_id.lo].<span class="built_in">push</span>(request); &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SinkBuffer-try-to-send-rpc"><a href="#SinkBuffer-try-to-send-rpc" class="headerlink" title="SinkBuffer::_try_to_send_rpc"></a>SinkBuffer::_try_to_send_rpc</h3><p>SinkBuffer 设计要稍微复杂点，因为要考虑顺序。下面将 _try_to_send_rpc 函数分解为4部分来剖析细节。完整代码见 <a target="_blank" rel="noopener" href="https://github.com/StarRocks/starrocks/blob/fbfb7ed80e284d349694adbb57d3f1c643e46e58/be/src/exec/pipeline/exchange/sink_buffer.cpp#L257C1-L257C1">_try_to_send_rpc</a>。</p>
<h4 id="Part1-callback"><a href="#Part1-callback" class="headerlink" title="Part1: callback"></a>Part1: callback</h4><p>_try_to_send_rpc 函数第二个参数 <em>pre_works_cb</em> 会在发送 RPC 之前执行，比如上面 add_request 函数传入的 cb 是将新增的 RPC 请求 request 添加到 _buffers[instance_id.lo] 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">    <span class="comment">//! 注意：这里是有 mutex</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;Mutex&gt; <span class="title">l</span><span class="params">(*_mutexes[instance_id.lo])</span></span>;</span><br><span class="line">    <span class="built_in">pre_works_cb</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">DeferOp <span class="title">decrease_defer</span><span class="params">([<span class="keyword">this</span>]() &#123; --_num_sending_rpc; &#125;)</span></span>;</span><br><span class="line">    ++_num_sending_rpc;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part2-限流"><a href="#Part2-限流" class="headerlink" title="Part2: 限流"></a>Part2: 限流</h4><p>_buffers[instance_id] 中存储的是所有待发送给 instance_id 的 RPCs。在发送 RPC 之前会先检测下是否需要限流:  </p>
<ul>
<li><p>_is_dest_merge 为 true，此时需要保证发送顺序性<br>  比如 SQL 中包含 ORDER BY，TOPN 等操作时，要求输出结果有序。在 FragmentInstances 之间交换数据时，需要发送端和接收端一起保证顺序性，实现方式类似 TCP 滑动窗口。</p>
<p>  如图，_request_seqs[instance_id] 记录的是给 instance_id 实例已发送 RPC 的最大序号，_max_continuous_acked_seqs[instance_id] 记录的是 instance_id 已回应 RPC 的最大连续序号，差值是不连续的窗口大小 <em>discontinuous_acked_window_size</em></p>
<p>  此时限流的标准是该 window_size 不能超过阈值 <em>config::pipeline_sink_brpc_dop</em>（默认值 64），<strong>防止乱序数据太多</strong>。</p>
<p>  <img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-2.svg?raw=true" alt="StarRocks/Pipeline-ExchangeNode-2"></p>
</li>
<li><p>_is_dest_merge 为 false，此时不需要保证发送的顺序性</p>
<p> _num_in_flight_rpcs[instance_id] 记录的是已发送给 instance_id 但尚未收到 response 的 PRC 数量，该数据量不能超过阈值 config::pipeline_sink_brpc_dop（默认值 64），如果超过则暂停发送，<strong>防止对端处理不过来</strong>。</p>
</li>
</ul>
<p>限流代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">  <span class="comment">//...above code</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// part2</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_is_finishing, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 限流</span></span><br><span class="line">    <span class="type">int64_t</span> too_much_rpc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_is_dest_merge) &#123;</span><br><span class="line">      <span class="type">int64_t</span> discontinuous_acked_window_size =</span><br><span class="line">        _request_seqs[instance_id.lo] - _max_continuous_acked_seqs[instance_id.lo];</span><br><span class="line">      too_much_brpc_process = </span><br><span class="line">        discontinuous_acked_window_size &gt;= config::pipeline_sink_brpc_dop;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      too_much_brpc_process = </span><br><span class="line">        _num_in_flight_rpcs[instance_id.lo] &gt;= config::pipeline_sink_brpc_dop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RETURN_IF</span> (buffer.<span class="built_in">empty</span>() || too_much_rpc, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br></pre></td></tr></table></figure>
<h4 id="Part3-Order"><a href="#Part3-Order" class="headerlink" title="Part3: Order"></a>Part3: Order</h4><p>顺序性保证，要求发送过程如下:</p>
<ul>
<li>必须等收到第一个 RPC 的 response 之后，后续 RPCs 才能发送出去，保证基准不会出问题</li>
<li>最后一个 RPC（即 eos 为 true 的 RPC）必须是最后一个发送给对端，用于通知对端后续不会再有数据发送，让对端做好 finishing 操作</li>
<li>中间 RPCs 可以一定程度的乱序，但是通过 _max_continuous_acked_seqs 来维护总体的有序性</li>
</ul>
<p>所以，一共有两处需要等待（need_wait 为 true):</p>
<ol>
<li><p>中间的 RPCs 需要等待收到第一个 RPC 的 response</p>
<p> _num_finished_rpcs[instance_id] &#x3D;&#x3D; 0 和 _num_in_flight_rpcs[instance_id] &gt; 0 就能说明还没收到第一个 RPC 的 response。</p>
</li>
<li><p>最后一个 RPC 需要等待前面所有的 RPCs 都都收到 response</p>
<p>_num_remaining_eos 和 _num_sinkers 可以用来确定当前 RPC 是否为发送给 instance_id 实例的最后一个 EOS RPC. 它们在构造函数中赋值如下：</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; dest : destinations) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; instance_id = dest.fragment_instance_id;</span><br><span class="line">  _num_sinkers[instance_id] = _num_sinkers; </span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line">_num_remaining_eos = _num_sinkers.<span class="built_in">size</span>() * num_sinkers;</span><br></pre></td></tr></table></figure>
<p> _num_sinkers 在 <em>_create_exchange_sink_operator</em> 函数中被赋值为 dop，如果 _num_sinkers[instance_id] 为 0，则表示当前 Sink 给 instance_id 对应的 FragmentInstance 实例的所有 PipelineDrivers ExchangeSourceOperator 该发送的数据都发送了，此时就需要给 RPC request 中的 eos 标志设为 true，告知对端不会再有数据了（即 ExchangeSourceOperator 即将进入 OperatorStage::FINISHING 阶段）。</p>
</li>
</ol>
<p>Part3 就是做上述两处检测。当 <em>need_wait</em> 为 true，当前 RPC 不会被发送给对端，即从 _buffer[instance_id] 中取出的 RPC request 不会被 pop 出去。</p>
<blockquote>
<p>DeferOp 是基于 RAII 设计的类，在 DeferOp 对象离开作用域时调用传入的回调函数。</p>
</blockquote>
<p>核心代码及其注释如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 提取待发送的 RPC request</span></span><br><span class="line">        TransmitChunkInfo&amp; request = buffer.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">bool</span> need_wait = <span class="literal">false</span>;</span><br><span class="line">        <span class="function">DeferOp <span class="title">pop_defer</span><span class="params">([&amp;need_wait, &amp;buffer, mem_tracker = _mem_tracker]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 如果需要等待</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (need_wait) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 能正常发送给对端</span></span></span></span><br><span class="line"><span class="params"><span class="function">            SCOPED_THREAD_LOCAL_MEM_TRACKER_SETTER(mem_tracker);</span></span></span><br><span class="line"><span class="params"><span class="function">            buffer.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 CHECK: 必须等待第一个 add_request 对应的 RPC 返回，才能继续发送</span></span><br><span class="line">        <span class="keyword">if</span> (_num_finished_rpcs[instance_id.lo] == <span class="number">0</span> </span><br><span class="line">            &amp;&amp; _num_in_flight_rpcs[instance_id.lo] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            need_wait = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 CHECK: 最后一个 RPC，必须是最后一个发送，且只发送一次</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; params = request.params;</span><br><span class="line">        <span class="keyword">if</span> (params-&gt;<span class="built_in">eos</span>()) &#123;</span><br><span class="line">            <span class="function">DeferOp <span class="title">eos_defer</span><span class="params">([<span class="keyword">this</span>, &amp;instance_id, &amp;need_wait]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (need_wait) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (--_num_remaining_eos == <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">// 所有对端的 FragmentInstances 该发送的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">// 都已发送完</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    _is_finishing = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="comment">// 给 instance_id 的一个 PipelineDriver 发送完数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                --_num_sinkers[instance_id.lo];</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// instance_id 对应的 FragmentInstance 中</span></span><br><span class="line">            <span class="comment">// 还有 PipelineDrviers 还没有接受到完整的数据</span></span><br><span class="line">            <span class="keyword">if</span> (_num_sinkers[instance_id.lo] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (params-&gt;<span class="built_in">chunks_size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                params-&gt;<span class="built_in">set_eos</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 仍有尚未收到 response 的 RPCs</span></span><br><span class="line">                <span class="comment">// 则需要 wait</span></span><br><span class="line">                <span class="keyword">if</span> (_num_in_flight_rpcs[instance_id.lo] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    need_wait = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// else-branch: _num_in_flight_rpcs[instance_id] 为 0</span></span><br><span class="line">                <span class="comment">// 此时 params-&gt;eos() 就是 true</span></span><br><span class="line">                <span class="comment">// 表示这个是该 FragmentInstance 最后一个 RPC 请求</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Part4-Send-RPC"><a href="#Part4-Send-RPC" class="headerlink" title="Part4: Send RPC"></a>Part4: Send RPC</h4><p>通过了上面的校验，下面就是真正发送 RPC request 的代码。 Part4 核心部分是设置 RPC 回调函数。</p>
<blockquote>
<p>bRPC 异步回调相关知识可以参考：<a target="_blank" rel="noopener" href="https://github.com/apache/brpc/blob/master/docs/cn/client.md">异步访问</a></p>
</blockquote>
<p>由于是异步发送 RPC 消息，因此要设置回调函数来处理返回结果。 通过 DisposableClosure 继承 google::protobuf::Closure 传递给 bRPC。在 RPC 返回时执行 <em>Closure::Run</em> 函数。这里就是根据 RPC 发送结果即 ctnl.Failed() 来判断调用哪个 callback。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisposableClosure</span> : <span class="keyword">public</span> google::protobuf::Closure &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> FailedFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> C&amp;)&gt;;</span><br><span class="line">    <span class="keyword">using</span> SuccessFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> C&amp;, <span class="type">const</span> T&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DisposableClosure</span>(<span class="type">const</span> C&amp; ctx) : _ctx(ctx) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFailedHandler</span><span class="params">(FailedFunc fn)</span> </span>&#123; _failed_handler = std::<span class="built_in">move</span>(fn); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addSuccessHandler</span><span class="params">(SuccessFunc fn)</span> </span>&#123; _success_handler = fn; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 自我释放内存</span></span><br><span class="line">      <span class="function">std::unique_ptr&lt;DisposableClosure&gt; <span class="title">self_guard</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cntl.<span class="built_in">Failed</span>()) &#123;</span><br><span class="line">          _failed_handler(_ctx);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          _success_handler(_ctx, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    brpc::Controller cntl;</span><br><span class="line">    T result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> C _ctx;</span><br><span class="line">    FailedFunc _failed_handler;</span><br><span class="line">    SuccessFunc _success_handler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>两个回调函数如下:</p>
<ol>
<li><p>SuccessFunc</p>
<p> ctnl.Failed() 为 false 只表明 RPC 请求确实发送给对端了，但是对端接受到 RPC 后真正的处理结果由 result.status() 来表征。如果对端处理失败，则取消当前 FragmentInstance，进而由 GloablDriverExecutor 取消整个 query。否则就 <strong>递归</strong> 执行 _try_to_send_rpc 函数，不断地从 _buffer[instance_id] 中取出 RPC request 发送给 instance_id 对应的 FragmentInstance。此时传入的 pre_work_cb 中有 <em>_process_send_window</em> 函数，这是用来处理滑动窗口的。</p>
<p> SuccessFunc 代码如下。 </p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">success_cb = [<span class="keyword">this</span>](<span class="type">const</span> ClosureContext&amp; ctx, </span><br><span class="line">                    <span class="type">const</span> PTransmitChunkResult&amp; result) &#123;</span><br><span class="line">  Status <span class="built_in">status</span>(result.<span class="built_in">status</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 更新记录</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;Mutex&gt; <span class="title">l</span><span class="params">(*_mutexes[ctx.instance_id.lo])</span></span>;</span><br><span class="line">    ++_num_finished_rpcs[ctx.instance_id.lo];</span><br><span class="line">    --_num_in_flight_rpcs[ctx.instance_id.lo];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 对端处理失败，则取消当前 FragmentInstance</span></span><br><span class="line">    _is_finishing = <span class="literal">true</span>;</span><br><span class="line">    _fragment_ctx-&gt;<span class="built_in">cancel</span>(status);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对端处理成功，则递归发送 RPC 给对端</span></span><br><span class="line">    _try_to_send_rpc(ctx.instance_id, [&amp;]() &#123;</span><br><span class="line">                _update_network_time(ctx.instance_id,</span><br><span class="line">                                     ctx.send_timestamp,</span><br><span class="line">                                     result.<span class="built_in">receiver_post_process_time</span>());</span><br><span class="line">                _process_send_window(ctx.instance_id, ctx.sequence); &#125;); </span><br><span class="line">  &#125;</span><br><span class="line">  --_total_in_flight_rpc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>FailedFunc</p>
<p> 如果因为网络等问题 RPC 无法发送给对端，则取消当前 FragmentInstance 的 PipelineDriver，并更新相关状态。</p>
 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">failed_cb = [<span class="keyword">this</span>](<span class="type">const</span> ClosureContext&amp; ctx) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// 算子完成</span></span><br><span class="line">  _is_finishing = <span class="literal">true</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 更新记录</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;Mutex&gt; <span class="title">l</span><span class="params">(*_mutexes[ctx.instance_id.lo])</span></span>;</span><br><span class="line">    ++_num_finished_rpcs[ctx.instance_id.lo];</span><br><span class="line">    --_num_in_flight_rpcs[ctx.instance_id.lo];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消当前 FragmentInstance 的 PipelineDrivers</span></span><br><span class="line">  std::string err_msg = fmt::format(</span><br><span class="line">     <span class="string">&quot;transmit chunk rpc failed:&#123;&#125;&quot;</span>, <span class="built_in">print_id</span>(ctx.instance_id));</span><br><span class="line">  _fragment_ctx-&gt;<span class="built_in">cancel</span>(Status::<span class="built_in">InternalError</span>(err_msg));</span><br><span class="line"></span><br><span class="line">  --_total_in_flight_rpc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>RPC 回调函数 closure 设置完毕，就可以将 RPC 真正发送出去了，这个由 <em>_send_rpc</em> 函数完成。完成代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//... above code</span></span><br><span class="line"></span><br><span class="line">        params-&gt;<span class="built_in">mutable_finst_id</span>()-&gt;<span class="built_in">CopyFrom</span>(_instance_id2finst_id[instance_id.lo]);</span><br><span class="line">        params-&gt;<span class="built_in">set_sequence</span>(++_request_seqs[instance_id.lo]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!request.attachment.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _bytes_sent += request.attachment.<span class="built_in">size</span>();</span><br><span class="line">            _request_sent++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 callback</span></span><br><span class="line">        <span class="keyword">auto</span>* closure = <span class="keyword">new</span> <span class="built_in">DisposableClosure</span>&lt;PTransmitChunkResult, ClosureContext&gt;(</span><br><span class="line">                &#123;instance_id, params-&gt;<span class="built_in">sequence</span>(), <span class="built_in">MonotonicNanos</span>()&#125;);</span><br><span class="line">        <span class="keyword">if</span> (_first_send_time == <span class="number">-1</span>) &#123;</span><br><span class="line">            _first_send_time = <span class="built_in">MonotonicNanos</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        closure-&gt;<span class="built_in">addFailedHandler</span>(failed_cb);</span><br><span class="line">        closure-&gt;<span class="built_in">addSuccessHandler</span>(success_cb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在发送 RPC 前，递增变量</span></span><br><span class="line">        ++_total_in_flight_rpc;</span><br><span class="line">        ++_num_in_flight_rpcs[instance_id.lo];</span><br><span class="line"></span><br><span class="line">        _mem_tracker-&gt;<span class="built_in">release</span>(request.attachment_physical_bytes);</span><br><span class="line">        ExecEnv::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">process_mem_tracker</span>()-&gt;<span class="built_in">consume</span>(</span><br><span class="line">            request.attachment_physical_bytes);</span><br><span class="line"></span><br><span class="line">        closure-&gt;cntl.<span class="built_in">Reset</span>();</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">set_timeout_ms</span>(_brpc_timeout_ms);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bthread_self</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> _send_rpc(closure, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">SCOPED_THREAD_LOCAL_MEM_TRACKER_SETTER</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">return</span> _send_rpc(closure, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="process-send-window"><a href="#process-send-window" class="headerlink" title="_process_send_window"></a>_process_send_window</h4><p>sequence 是本次成功的 RPC，下面用 sequence 来更新滑动窗口的逻辑也是比较简洁的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> SinkBuffer::_process_send_window(<span class="type">const</span> TUniqueId&amp; instance_id, <span class="type">const</span> <span class="type">int64_t</span> sequence) &#123;</span><br><span class="line">    <span class="comment">// Both sender side and receiver side can tolerate disorder of tranmission</span></span><br><span class="line">    <span class="comment">// if receiver side is not ExchangeMergeSortSourceOperator</span></span><br><span class="line">    <span class="keyword">if</span> (!_is_dest_merge) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; seqs = _discontinuous_acked_seqs[instance_id.lo];</span><br><span class="line">    seqs.<span class="built_in">insert</span>(sequence);</span><br><span class="line">    <span class="keyword">auto</span>&amp; max_continuous_acked_seq = _max_continuous_acked_seqs[instance_id.lo];</span><br><span class="line">    std::unordered_set&lt;<span class="type">int64_t</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">while</span> ((it = seqs.<span class="built_in">find</span>(max_continuous_acked_seq + <span class="number">1</span>)) != seqs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        seqs.<span class="built_in">erase</span>(it);</span><br><span class="line">        ++max_continuous_acked_seq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="SinkBuffer-send-rpc"><a href="#SinkBuffer-send-rpc" class="headerlink" title="SinkBuffer::_send_rpc"></a>SinkBuffer::_send_rpc</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_send_rpc(DisposableClosure&lt;PTransmitChunkResult,</span><br><span class="line">                             ClosureContext&gt;* closure,</span><br><span class="line">                             <span class="type">const</span> TransmitChunkInfo&amp; request) &#123;</span><br><span class="line">    <span class="keyword">auto</span> expected_iobuf_size = request.attachment.<span class="built_in">size</span>() </span><br><span class="line">                             + request.params-&gt;<span class="built_in">ByteSizeLong</span>() </span><br><span class="line">                             + <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(expected_iobuf_size &gt; _rpc_http_min_size)) &#123;</span><br><span class="line">        butil::IOBuf iobuf;</span><br><span class="line">        <span class="function">butil::IOBufAsZeroCopyOutputStream <span class="title">wrapper</span><span class="params">(&amp;iobuf)</span></span>;</span><br><span class="line">        request.params-&gt;<span class="built_in">SerializeToZeroCopyStream</span>(&amp;wrapper);</span><br><span class="line">        <span class="comment">// append params to iobuf</span></span><br><span class="line">        <span class="type">size_t</span> params_size = iobuf.<span class="built_in">size</span>();</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(</span><br><span class="line">            &amp;params_size, <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(iobuf);</span><br><span class="line">        <span class="comment">// append attachment</span></span><br><span class="line">        <span class="type">size_t</span> attachment_size = request.attachment.<span class="built_in">size</span>();</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(</span><br><span class="line">            &amp;attachment_size, <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(request.attachment);</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">http_request</span>().<span class="built_in">set_content_type</span>(<span class="string">&quot;application/proto&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> res = BrpcStubCache::<span class="built_in">create_http_stub</span>(request.brpc_addr);</span><br><span class="line">        <span class="built_in">RETURN_IF</span>(!res.<span class="built_in">ok</span>(), res.<span class="built_in">status</span>());</span><br><span class="line">        <span class="comment">// 异步 RPC </span></span><br><span class="line">        res.<span class="built_in">value</span>()-&gt;<span class="built_in">transmit_chunk_via_http</span>(</span><br><span class="line">            &amp;closure-&gt;cntl, <span class="literal">NULL</span>, &amp;closure-&gt;result, closure);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 异步 RPC</span></span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(request.attachment);</span><br><span class="line">        request.brpc_stub-&gt;<span class="built_in">transmit_chunk</span>(</span><br><span class="line">            &amp;closure-&gt;cntl, request.params.<span class="built_in">get</span>(), &amp;closure-&gt;result, closure);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="push-chunk"><a href="#push-chunk" class="headerlink" title="push_chunk"></a>push_chunk</h2><p>上面讲解了 Channel 是如何 batched RPCs 到真正发送 RPC 给对端。下面来讲解 ExchangeSinkOperator::push_chunk。</p>
<p>_output_columns 是当前 Sink 需要输出的列，当前一个 Operator 将数据 Chunk 推向 ExchangeSinkOperator 时，需要从 chunk 中提取出 _output_columns 中所必须的列数据即可，得到的即 send_chunk。</p>
<h3 id="TPartitionType-UNPARTITIONED"><a href="#TPartitionType-UNPARTITIONED" class="headerlink" title="TPartitionType::UNPARTITIONED"></a>TPartitionType::UNPARTITIONED</h3><p>当传输数据方式是 TPartitionType::UNPARTITIONED，即广播模式，给每个对端都发送一份完整的数据，如下图所示。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-3.svg?raw=true" alt="StarRocks/Pipeline-ExchangeNode-3"></p>
<p>即遍历 _channels 给所有的 Channel[idx] 发送数据。也正如前文所述，如果 Channel::use_pass_through() 为 true，则可以走共享内存模式，而不用 RPC 通信。反之，则需要先序列化再进行 RPC 发送。</p>
<blockquote>
<p>Channel 发现 ExchangeSinkOperator::_is_pipeline_level_shuffle 为 false 时，在 Channel::send_one_chunk 函数中不会处理 DEFAULT_DRIVER_SEQUENCE。</p>
</blockquote>
<p>代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ExchangeSinkOperator::push_chunk</span><span class="params">(RuntimeState* state, </span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint16_t</span> num_rows = chunk-&gt;<span class="built_in">num_rows</span>();</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(num_rows == <span class="number">0</span>, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    vectorized::Chunk temp_chunk;</span><br><span class="line">    vectorized::Chunk* send_chunk = chunk.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">if</span> (!_output_columns.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int32_t</span> cid : _output_columns) &#123;</span><br><span class="line">            temp_chunk.<span class="built_in">append_column</span>(chunk-&gt;<span class="built_in">get_column_by_slot_id</span>(cid), cid);</span><br><span class="line">        &#125;</span><br><span class="line">        send_chunk = &amp;temp_chunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_part_type == TPartitionType::UNPARTITIONED || _num_shuffles == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_chunk_request == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _chunk_request = std::<span class="built_in">make_shared</span>&lt;PTransmitChunkParams&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; not_pass_through_channles;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> idx : _channel_indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_channels[idx]-&gt;<span class="built_in">use_pass_through</span>()) &#123;</span><br><span class="line">               <span class="comment">// pass_through 模式，直接传递数据</span></span><br><span class="line">                <span class="built_in">RETURN_IF_ERROR</span>(_channels[idx]-&gt;<span class="built_in">send_one_chunk</span>(</span><br><span class="line">                    state, send_chunk, DEFAULT_DRIVER_SEQUENCE, <span class="literal">false</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//记录需要爱 RPC 通信的对端</span></span><br><span class="line">                not_pass_through_channles.<span class="built_in">emplace_back</span>(idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!not_pass_through_channles.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 1. create a new chunk PB to serialize</span></span><br><span class="line">            ChunkPB* pchunk = _chunk_request-&gt;<span class="built_in">add_chunks</span>();</span><br><span class="line">            <span class="comment">// 2. 将输入的 send_chunk 序列化到 pchunk 中</span></span><br><span class="line">            <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(<span class="built_in">RETURN_IF_ERROR</span>(<span class="built_in">serialize_chunk</span>(</span><br><span class="line">                send_chunk, pchunk, &amp;_is_first_chunk, _channels.<span class="built_in">size</span>())));</span><br><span class="line">            _current_request_bytes += pchunk-&gt;<span class="built_in">data</span>().<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// 3. 如果请求的字节数超过限制，再通过 Channel 发送</span></span><br><span class="line">            <span class="keyword">if</span> (_current_request_bytes &gt; config::max_transmit_batched_bytes) &#123;</span><br><span class="line">                butil::IOBuf attachment;</span><br><span class="line">                <span class="type">int64_t</span> attachment_physical_bytes =</span><br><span class="line">                     <span class="built_in">construct_brpc_attachment</span>(_chunk_request, attachment);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> idx : not_pass_through_channles) &#123;</span><br><span class="line">                    <span class="built_in">RETURN_IF_ERROR</span>(_channels[idx]-&gt;<span class="built_in">send_chunk_request</span>(</span><br><span class="line">                        state, </span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;PTransmitChunkParams&gt;(*_chunk_request),</span><br><span class="line">                        attachment, </span><br><span class="line">                        attachment_physical_bytes));</span><br><span class="line">                &#125;</span><br><span class="line">                _current_request_bytes = <span class="number">0</span>;</span><br><span class="line">                _chunk_request.<span class="built_in">reset</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="TPartitionType-RANDOM"><a href="#TPartitionType-RANDOM" class="headerlink" title="TPartitionType::RANDOM"></a>TPartitionType::RANDOM</h3><p>TPartitionType::RANDOM 的数据分发策略是 Round-robin，每次调用 ExchangeSinkOperator::push_chunk 都挑选一个同进程的 FragmentInstance 作为对端。如下图所示。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-4.svg?raw=true" alt="StarRocks/Pipeline-ExchangeNode-4"></p>
<p>_curr_random_channel_idx 指示当前发送给哪个 Local Channels。见代码注释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ExchangeSinkOperator::push_chunk</span><span class="params">(RuntimeState* state, <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (_part_type == TPartitionType::UNPARTITIONED || _num_shuffles == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_part_type == TPartitionType::RANDOM) &#123;</span><br><span class="line">        std::vector&lt;Channel*&gt; local_channels;</span><br><span class="line">        <span class="comment">// 1. 挑选处同进程的 FragmenInstance</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; channel : _channels) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel-&gt;<span class="built_in">is_local</span>()) &#123;</span><br><span class="line">                local_channels.<span class="built_in">emplace_back</span>(channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有 Local Channel，才选择 Remote Channel</span></span><br><span class="line">        <span class="keyword">if</span> (local_channels.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            local_channels = _channels;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span>&amp; channel = local_channels[_curr_random_channel_idx];</span><br><span class="line">        <span class="type">bool</span> real_sent = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 2. 发送</span></span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(channel-&gt;<span class="built_in">send_one_chunk</span>(</span><br><span class="line">                state, send_chunk,</span><br><span class="line">                DEFAULT_DRIVER_SEQUENCE,</span><br><span class="line">                <span class="literal">false</span>, &amp;real_sent));</span><br><span class="line">        <span class="comment">// 3. 只有在 RPC 真的发送出去了，才会切换到下一个 FragmentInstance</span></span><br><span class="line">        <span class="keyword">if</span> (real_sent) &#123;</span><br><span class="line">            _curr_random_channel_idx = </span><br><span class="line">                (_curr_random_channel_idx + <span class="number">1</span>) % local_channels.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// else if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TPartitionType-BUCKET-SHUFFLE-HASH-PARTITIONED"><a href="#TPartitionType-BUCKET-SHUFFLE-HASH-PARTITIONED" class="headerlink" title="TPartitionType::BUCKET_SHUFFLE&#x2F;HASH_PARTITIONED"></a>TPartitionType::BUCKET_SHUFFLE&#x2F;HASH_PARTITIONED</h3><p>这两种数据分发策略要复杂点，二者本质不同点在于使用的 Hash 函数。如下示意图。</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-5.svg?raw=true" alt="StarRocks/Pipeline-ExchangeNode-5"></p>
<h4 id="hash-values"><a href="#hash-values" class="headerlink" title="hash_values"></a>hash_values</h4><p>Shuffler::exchange_shuffle 函数用于将 chunk 的每一行都分发到具体的分区 {instance_id, driver_seq} 中。参数 hash_values 是对 chunk 中每一行的 join-key 进行 hash 值。BUCKET_SHUFFLE_HASH_PARTITIONED 和 HASH_PARTITIONED 两种策略根本区别也在于这里。</p>
<blockquote>
<p>这里的分区列的 “partition” 和建分区表时的 “partition” 不是一个含义。这里的是对端 {instnace_id, driver_seq} 处理的数据源。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ExchangeSinkOperator::push_chunk</span><span class="params">(RuntimeState* state, </span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (_part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">          _part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//1. 计算 hash 的分区列</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _partitions_columns.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">ASSIGN_OR_RETURN</span>(</span><br><span class="line">          _partitions_columns[i], _partition_expr_ctxs[i]-&gt;<span class="built_in">evaluate</span>(chunk.<span class="built_in">get</span>()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 为每个分区列计算 hash 值</span></span><br><span class="line">      <span class="keyword">if</span> (_part_type == TPartitionType::HASH_PARTITIONED) &#123;</span><br><span class="line">        _hash_values.<span class="built_in">assign</span>(num_rows, HashUtil::FNV_SEED);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vectorized::ColumnPtr&amp; column : _partitions_columns) &#123;</span><br><span class="line">           column-&gt;<span class="built_in">fnv_hash</span>(&amp;_hash_values[<span class="number">0</span>], <span class="number">0</span>, num_rows);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当 join-key 和分桶键一样</span></span><br><span class="line">        <span class="comment">// 则和分桶键使用一样的 Hash 函数</span></span><br><span class="line">        _hash_values.<span class="built_in">assign</span>(num_rows, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vectorized::ColumnPtr&amp; column : _partitions_columns) &#123;</span><br><span class="line">           column-&gt;<span class="built_in">crc32_hash</span>(&amp;_hash_values[<span class="number">0</span>], <span class="number">0</span>, num_rows);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br></pre></td></tr></table></figure>
<h4 id="exchange-shuffle"><a href="#exchange-shuffle" class="headerlink" title="exchange_shuffle"></a>exchange_shuffle</h4><p>TPartitionType::UNPARTITIONED 和 TPartitionType::RANDOM 两种策略的 shuffle 粒度是 chunk ，即可以直接将整个 chunk 发送给 FragmentInstance。而 (BUCKET_SHUFFLE_)HASH_PARTITIONED 策略，shuffle 的粒度是 row，需要把一个 chunk 分发到不同 {FragmentInstance, PipelineDriver} 中。 </p>
<p>因此，可以把 (channl_id, driver_sequence) 视为一个坐标，那么 exchange_shuffle 函数就是将 chunk 的 num_rows 行数据均匀分布在 channels_size * num_shuffles_per_channel 的平面上。其中 num_shuffles_per_channel 表征的是 dop。</p>
<p>shuffle 策略实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> two_level_shuffle, <span class="keyword">typename</span> ReduceOp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchange_shuffle</span><span class="params">(std::vector&lt;<span class="type">uint32_t</span>&gt;&amp; shuffle_channel_ids, </span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt;&amp; hash_values,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">size_t</span> num_rows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_rows; ++i) &#123;</span><br><span class="line">        <span class="type">size_t</span> channel_id = <span class="built_in">ReduceOp</span>()(hash_values[i], _num_channels);</span><br><span class="line">        <span class="type">size_t</span> shuffle_id;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!two_level_shuffle)</span> </span>&#123;</span><br><span class="line">            shuffle_id = channel_id;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 基于均匀分布将 hash_values 映射到 [0, _num_shuffles_per_channel) 区间</span></span><br><span class="line">            <span class="type">uint32_t</span> driver_sequence = <span class="built_in">ReduceOp</span>()(</span><br><span class="line">                HashUtil::<span class="built_in">xorshift32</span>(hash_values[i]), _num_shuffles_per_channel);</span><br><span class="line">            shuffle_id = </span><br><span class="line">                channel_id * _num_shuffles_per_channel + driver_sequence;</span><br><span class="line">        &#125;</span><br><span class="line">        shuffle_channel_ids[i] = shuffle_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到 chunk 每一行的 hash_values 后，并基于 Shuffler::exchange_shuffle 函数得到每一行所属的分区，结果存储于 _shuffle_channel_ids。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">         _part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">// 3. Compute row indexes for each channel&#x27;s each shuffle</span></span><br><span class="line">     _shuffler-&gt;<span class="built_in">exchange_shuffle</span>(_shuffle_channel_ids, _hash_values, num_rows);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="channel-row-idx-start-points"><a href="#channel-row-idx-start-points" class="headerlink" title="channel_row_idx_start_points"></a>channel_row_idx_start_points</h4><p>接下来就是 shuffle 之后的处理流程：_row_indexes 将 chunk 中所有发往同一个分区的 row_ids 连续存储在一起，并用 _channel_row_idx_start_points 记录每个分区起始偏移量。如下示意图:</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-6.svg?raw=true" alt="StarRocks/Pipeline-ExchangeNode-6"></p>
<p>这个流程分为如下三个 for-loop:</p>
<ol>
<li><p>计算每个分区的行数</p>
<p> _shuffle_channel_ids[i] 表征 partitions[i]，那么第一个 for-loop 计算完，_channel_row_idx_start_points[i] 即表征 chunk 落在 partitions[i] 的行数。</p>
<p> 比如有三个分区，分别是 9, 10, 11行，经过第一个 for-loop，start_points 中存储的值就是:</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 10 11</span><br></pre></td></tr></table></figure>
</li>
<li><p>计算每个分区最后的位置</p>
<p>上述例子，经过第二个 for-loop 后， start_points 中存储的值就是:</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 19 30</span><br></pre></td></tr></table></figure></li>
<li><p>将同一个分区的在chunk中的行号记录在 _row_indexes，同时将 _channel_row_idx_start_points 更新到每个分区的起始位置。</p>
<p> 此时 _row_indexes 和 start_points 的值变更结果如下:</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_row_indexes[0:8] = partition0</span><br><span class="line">_row_indexes[9:18] = partition1</span><br><span class="line">_row_indexes[19:29] = partition2</span><br><span class="line"></span><br><span class="line">start_points[0] = 0</span><br><span class="line">start_points[1] = 9</span><br><span class="line">start_points[2] = 19</span><br></pre></td></tr></table></figure></li>
</ol>
<p>三个 for-loop 的完成代码如下。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (_part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">          _part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// _num_shuffles = _channels.size() * _num_shuffles_per_channel</span></span><br><span class="line">      _channel_row_idx_start_points.<span class="built_in">assign</span>(_num_shuffles + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//4.1 </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_rows; ++i) &#123;</span><br><span class="line">          _channel_row_idx_start_points[_shuffle_channel_ids[i]]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.2</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">1</span>; i &lt;= _num_shuffles; ++i) &#123;</span><br><span class="line">          _channel_row_idx_start_points[i] += _channel_row_idx_start_points[i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.3</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int32_t</span> i = num_rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">          _row_indexes[_channel_row_idx_start_points[_shuffle_channel_ids[i]] - <span class="number">1</span>] = i;</span><br><span class="line">          _channel_row_idx_start_points[_shuffle_channel_ids[i]]--;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="add-rows-selective"><a href="#add-rows-selective" class="headerlink" title="add_rows_selective"></a>add_rows_selective</h4><p>上面四步对chunk完成了分区，并将结果记录在 _row_indexes 和 _start_points 中，最后一步就是将所有分区数据发送出去，只需要遍历 (_channel_indices, _num_shuffles_per_channel) 二维区间，再使用 Channel::add_rows_selective 函数发送数据，没啥可说，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (_part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">          _part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// above code</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int32_t</span> channel_id : _channel_indices) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_channels[channel_id]-&gt;<span class="built_in">get_fragment_instance_id</span>().lo == <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="comment">// dest bucket is no used, continue</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; _num_shuffles_per_channel; ++i) &#123;</span><br><span class="line">          <span class="type">int</span> shuffle_id = channel_id * _num_shuffles_per_channel + i;</span><br><span class="line">          <span class="type">int</span> driver_sequence = _driver_sequence_per_shuffle[shuffle_id];</span><br><span class="line"></span><br><span class="line">          <span class="type">size_t</span> from = _channel_row_idx_start_points[shuffle_id];</span><br><span class="line">          <span class="type">size_t</span> size = _channel_row_idx_start_points[shuffle_id + <span class="number">1</span>] - from;</span><br><span class="line">          <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// no data for this channel continue;</span></span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">RETURN_IF_ERROR</span>(_channels[channel_id]-&gt;<span class="built_in">add_rows_selective</span>(send_chunk,         </span><br><span class="line">                                                                    driver_sequence, </span><br><span class="line">                                                                    _row_indexes.<span class="built_in">data</span>(), </span><br><span class="line">                                                                    from, size,</span><br><span class="line">                                                                    state));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/collection/853861081">StarRocks Exchange 算子源码解析</a></li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#create-exchange-sink"><span class="toc-number">1.</span> <span class="toc-text">create_exchange_sink</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Channel"><span class="toc-number">2.</span> <span class="toc-text">Channel</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-is-local"><span class="toc-number">2.1.</span> <span class="toc-text">Channel::is_local</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PTransmitChunkParams"><span class="toc-number">2.2.</span> <span class="toc-text">PTransmitChunkParams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-send-one-chunk"><span class="toc-number">2.3.</span> <span class="toc-text">Channel::send_one_chunk</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SinkBuffer-add-request"><span class="toc-number">3.</span> <span class="toc-text">SinkBuffer::add_request</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SinkBuffer-try-to-send-rpc"><span class="toc-number">3.1.</span> <span class="toc-text">SinkBuffer::_try_to_send_rpc</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Part1-callback"><span class="toc-number">3.1.1.</span> <span class="toc-text">Part1: callback</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part2-%E9%99%90%E6%B5%81"><span class="toc-number">3.1.2.</span> <span class="toc-text">Part2: 限流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part3-Order"><span class="toc-number">3.1.3.</span> <span class="toc-text">Part3: Order</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Part4-Send-RPC"><span class="toc-number">3.1.4.</span> <span class="toc-text">Part4: Send RPC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#process-send-window"><span class="toc-number">3.1.5.</span> <span class="toc-text">_process_send_window</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SinkBuffer-send-rpc"><span class="toc-number">3.2.</span> <span class="toc-text">SinkBuffer::_send_rpc</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#push-chunk"><span class="toc-number">4.</span> <span class="toc-text">push_chunk</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TPartitionType-UNPARTITIONED"><span class="toc-number">4.1.</span> <span class="toc-text">TPartitionType::UNPARTITIONED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TPartitionType-RANDOM"><span class="toc-number">4.2.</span> <span class="toc-text">TPartitionType::RANDOM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TPartitionType-BUCKET-SHUFFLE-HASH-PARTITIONED"><span class="toc-number">4.3.</span> <span class="toc-text">TPartitionType::BUCKET_SHUFFLE&#x2F;HASH_PARTITIONED</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-values"><span class="toc-number">4.3.1.</span> <span class="toc-text">hash_values</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exchange-shuffle"><span class="toc-number">4.3.2.</span> <span class="toc-text">exchange_shuffle</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#channel-row-idx-start-points"><span class="toc-number">4.3.3.</span> <span class="toc-text">channel_row_idx_start_points</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#add-rows-selective"><span class="toc-number">4.3.4.</span> <span class="toc-text">add_rows_selective</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reference"><span class="toc-number">5.</span> <span class="toc-text">Reference</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&text=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&is_video=false&description=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle&body=Check out this article: https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&title=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&name=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/08/01/Pipeline/ExchangeNode_1/&t=MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
