<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="PhysicalPropertyPhysicalProperty 是个接口的，实现接口的类中比较重要是 DistributionProperty   DistributionSpec.DistributionType 表示 Operator 的输出数据分布 HashDistributionDesc.sourceType 表示 Operator 的数据来源  继承逻辑如下: TaskContextT">
<meta property="og:type" content="article">
<meta property="og:title" content="CBO: EnforceAndCostTask 寻找成本最低路径">
<meta property="og:url" content="https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="PhysicalPropertyPhysicalProperty 是个接口的，实现接口的类中比较重要是 DistributionProperty   DistributionSpec.DistributionType 表示 Operator 的输出数据分布 HashDistributionDesc.sourceType 表示 Operator 的数据来源  继承逻辑如下: TaskContextT">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/DistributionSpec.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/PropertyDeriver.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/DistributionSpec-4.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/groupExpression-1.svg?raw=true">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/DistributionSpec-2.svg?raw=true">
<meta property="article:published_time" content="2023-10-07T02:00:01.000Z">
<meta property="article:modified_time" content="2023-10-27T02:09:15.857Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="StarRocks">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/DistributionSpec.svg?raw=true">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>CBO: EnforceAndCostTask 寻找成本最低路径</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2023/10/12/Pipeline/OptimizerOverview/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2023/10/03/Pipeline/PlanFragment/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&text=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&title=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&is_video=false&description=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CBO: EnforceAndCostTask 寻找成本最低路径&body=Check out this article: https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&title=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&title=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&title=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&title=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&name=CBO: EnforceAndCostTask 寻找成本最低路径&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&t=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PhysicalProperty"><span class="toc-number">1.</span> <span class="toc-text">PhysicalProperty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TaskContext"><span class="toc-number">2.</span> <span class="toc-text">TaskContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequiredPropertyDeriver"><span class="toc-number">3.</span> <span class="toc-text">RequiredPropertyDeriver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#visitOperator"><span class="toc-number">3.1.</span> <span class="toc-text">visitOperator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#visitPhysicalHashJoin"><span class="toc-number">3.2.</span> <span class="toc-text">visitPhysicalHashJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertyDeriverBase-computeShuffleJoinRequiredProperties"><span class="toc-number">3.2.1.</span> <span class="toc-text">PropertyDeriverBase.computeShuffleJoinRequiredProperties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertyDeriverBase-getShuffleJoinHashDistributionDesc"><span class="toc-number">3.2.2.</span> <span class="toc-text">PropertyDeriverBase.getShuffleJoinHashDistributionDesc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertyDeriverBase-createShuffleJoinRequiredProperties"><span class="toc-number">3.2.3.</span> <span class="toc-text">PropertyDeriverBase.createShuffleJoinRequiredProperties</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EnforceAndCostTask"><span class="toc-number">4.</span> <span class="toc-text">EnforceAndCostTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initRequiredProperties"><span class="toc-number">4.1.</span> <span class="toc-text">initRequiredProperties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#optimizeChildGroup"><span class="toc-number">4.2.</span> <span class="toc-text">optimizeChildGroup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OutputPropertyDeriver"><span class="toc-number">5.</span> <span class="toc-text">OutputPropertyDeriver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputPropertyDeriver-visitPhysicalOlapScan"><span class="toc-number">5.1.</span> <span class="toc-text">OutputPropertyDeriver.visitPhysicalOlapScan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EnforceAndCostTask-recordCostsAndEnforce"><span class="toc-number">5.2.</span> <span class="toc-text">EnforceAndCostTask.recordCostsAndEnforce</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EnforceAndCostTask-setSatisfiedPropertyWithCost"><span class="toc-number">5.2.1.</span> <span class="toc-text">EnforceAndCostTask.setSatisfiedPropertyWithCost</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EnforceAndCostTask-setPropertyWithCost"><span class="toc-number">5.2.2.</span> <span class="toc-text">EnforceAndCostTask.setPropertyWithCost</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GroupExpression-updatePropertyWithCost"><span class="toc-number">5.2.3.</span> <span class="toc-text">GroupExpression.updatePropertyWithCost</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GroupExpression-setOutputPropertySatisfyRequiredProperty"><span class="toc-number">5.2.4.</span> <span class="toc-text">GroupExpression.setOutputPropertySatisfyRequiredProperty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Group-setBestExpression"><span class="toc-number">5.2.5.</span> <span class="toc-text">Group.setBestExpression</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EnforceAndCostTask-enforceDistribute"><span class="toc-number">5.3.</span> <span class="toc-text">EnforceAndCostTask.enforceDistribute</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DistributionProperty-appendEnforcers"><span class="toc-number">5.3.1.</span> <span class="toc-text">DistributionProperty.appendEnforcers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EnforceAndCostTask-updateCostWithEnforcer"><span class="toc-number">5.3.2.</span> <span class="toc-text">EnforceAndCostTask.updateCostWithEnforcer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memo-insertEnforceExpression"><span class="toc-number">5.3.3.</span> <span class="toc-text">Memo.insertEnforceExpression</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChildOutputPropertyGuarantor"><span class="toc-number">6.</span> <span class="toc-text">ChildOutputPropertyGuarantor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EnforceAndCostTask-execute"><span class="toc-number">6.1.</span> <span class="toc-text">EnforceAndCostTask.execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enforceLegalChildOutputProperty"><span class="toc-number">6.2.</span> <span class="toc-text">enforceLegalChildOutputProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#visitPhysicalJoin"><span class="toc-number">6.3.</span> <span class="toc-text">visitPhysicalJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BRANCH-0-BroadcastJoin"><span class="toc-number">6.3.1.</span> <span class="toc-text">BRANCH-0: BroadcastJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BRANCH-1-ColocateJoin"><span class="toc-number">6.3.2.</span> <span class="toc-text">BRANCH-1: ColocateJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BRANCH-2-BucketShuffleJoin"><span class="toc-number">6.3.3.</span> <span class="toc-text">BRANCH-2: BucketShuffleJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#transToBucketShuffleJoin"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">transToBucketShuffleJoin</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BRANCH-3-ShuffleJoin"><span class="toc-number">6.3.4.</span> <span class="toc-text">BRANCH-3: ShuffleJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enforceChildSatisfyShuffleJoin"><span class="toc-number">6.3.5.</span> <span class="toc-text">enforceChildSatisfyShuffleJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enforceChildShuffleDistribution"><span class="toc-number">6.3.6.</span> <span class="toc-text">enforceChildShuffleDistribution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enforceChildDistribution"><span class="toc-number">6.3.7.</span> <span class="toc-text">enforceChildDistribution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateChildCostWithEnforcer"><span class="toc-number">6.3.8.</span> <span class="toc-text">updateChildCostWithEnforcer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OutputPropertyDeriver-visitPhysicalJoin"><span class="toc-number">7.</span> <span class="toc-text">OutputPropertyDeriver.visitPhysicalJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#computeHashJoinDistributionPropertyInfo"><span class="toc-number">7.1.</span> <span class="toc-text">computeHashJoinDistributionPropertyInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRANCH-0-BROADCAST"><span class="toc-number">7.2.</span> <span class="toc-text">BRANCH-0: BROADCAST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRANCH-1-ColocateJoin-1"><span class="toc-number">7.3.</span> <span class="toc-text">BRANCH-1:ColocateJoin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRNACH-2-BucketShuffleJoin"><span class="toc-number">7.4.</span> <span class="toc-text">BRNACH-2: BucketShuffleJoin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRNACH-3-Shufflejoin"><span class="toc-number">7.5.</span> <span class="toc-text">BRNACH-3: Shufflejoin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#computeShuffleJoinOutputProperty"><span class="toc-number">7.5.1.</span> <span class="toc-text">computeShuffleJoinOutputProperty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getRequiredShuffleDesc"><span class="toc-number">7.5.2.</span> <span class="toc-text">getRequiredShuffleDesc</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        CBO: EnforceAndCostTask 寻找成本最低路径
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-10-07T02:00:01.000Z" itemprop="datePublished">2023-10-07</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/CBO/">CBO</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/StarRocks/" rel="tag">StarRocks</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="PhysicalProperty"><a href="#PhysicalProperty" class="headerlink" title="PhysicalProperty"></a>PhysicalProperty</h2><p>PhysicalProperty 是个接口的，实现接口的类中比较重要是 DistributionProperty </p>
<ul>
<li>DistributionSpec.DistributionType 表示 Operator 的输出数据分布</li>
<li>HashDistributionDesc.sourceType 表示 Operator 的数据来源</li>
</ul>
<p>继承逻辑如下:<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/DistributionSpec.svg?raw=true" alt="DistributionSpec-1"><br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/PropertyDeriver.svg?raw=true" alt="PropertyDeriver"></p>
<h2 id="TaskContext"><a href="#TaskContext" class="headerlink" title="TaskContext"></a>TaskContext</h2><p>TaskContext 作为优化一个 Group 时的上下文信息，主要有以下五个成员变量</p>
<ul>
<li>requiredProperty: 即父节点对当前 Grouo 所有 GroupExpressions 的输出必须满足的属性</li>
<li>requiredColumns: 父节点的输出要求当前 Group 输出的列</li>
</ul>
<p>比如，</p>
<ol>
<li><p>在 optimizeByCost 函数首次构造 TaskContext 对象，</p>
<ul>
<li>requiredProperty 是空的</li>
<li>requiredColumns 是最终输出的列</li>
</ul>
</li>
<li><p>在 <a href="https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/#optimizeChildGroup">EnforceAndCostTask.optimizeChildGroup</a> 中对 ChildGroup 进行递归初始化时:</p>
<ul>
<li><p>requiredProperty</p>
<p>当前节点 Group 先通过 RequiredPropertyDeriver.getRequiredProps 函数先计算出自己子节点 ChildernGroup 输出所需的属性，再将子节点输出所需满足的属性 inputProperty 用于构造 TaskContext，递归优化子节点 ChildGroup</p>
</li>
<li><p>requiredColumns 也是所需输出的列</p>
</li>
</ul>
</li>
</ol>
<p>先简略看下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TaskContext</span><span class="params">(OptimizerContext context,</span></span><br><span class="line"><span class="params">                   PhysicalPropertySet physicalPropertySet,</span></span><br><span class="line"><span class="params">                   ColumnRefSet requiredColumns,</span></span><br><span class="line"><span class="params">                   <span class="type">double</span> cost)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.optimizerContext = context;</span><br><span class="line">    <span class="built_in">this</span>.requiredProperty = physicalPropertySet;</span><br><span class="line">    <span class="built_in">this</span>.requiredColumns = requiredColumns;</span><br><span class="line">    <span class="built_in">this</span>.upperBoundCost = cost;</span><br><span class="line">    <span class="built_in">this</span>.allScanOperators = Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> OptExpression <span class="title function_">optimizeByCost</span><span class="params">(ConnectContext connectContext,</span></span><br><span class="line"><span class="params">                                     OptExpression logicOperatorTree,</span></span><br><span class="line"><span class="params">                                     PhysicalPropertySet requiredProperty,</span></span><br><span class="line"><span class="params">                                     ColumnRefSet requiredColumns)</span> &#123;</span><br><span class="line">    <span class="type">TaskContext</span> <span class="variable">rootTaskContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskContext</span>(</span><br><span class="line">        context, requiredProperty, requiredColumns.clone(), Double.MAX_VALUE);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RequiredPropertyDeriver"><a href="#RequiredPropertyDeriver" class="headerlink" title="RequiredPropertyDeriver"></a>RequiredPropertyDeriver</h2><p>RequiredPropertyDeriver 是用于计算每个 Operator 对子节点输出需要满足的属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;PhysicalPropertySet&gt;&gt; <span class="title function_">getRequiredProps</span><span class="params">(GroupExpression groupExpression)</span> &#123;</span><br><span class="line">    requiredProperties = Lists.newArrayList();</span><br><span class="line">    groupExpression.getOp().accept(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">ExpressionContext</span>(groupExpression));</span><br><span class="line">    deriveChildCTEProperty(groupExpression);</span><br><span class="line">    <span class="keyword">return</span> requiredProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="visitOperator"><a href="#visitOperator" class="headerlink" title="visitOperator"></a>visitOperator</h3><p>没有实现 visitPhysicalxxx 函数的 Operator，就会进入 visitOperator 函数，即根据节点的入度(arity) 生成包含 arity 个 PhysicalPropertySet.EMPTY 的 PhysicalPropertySet，也就是对每个子节点输出属性都没有要求。</p>
<p>比如，PhysicalHashJoinOperator 实现了 visitPhysicalHashJoin 函数，则会进入下文流程来获取属性，而 OlapScanNodeOperator 没有实现 visitOlapScanNodeOperator 函数则进入 visitOperator 函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visitOperator</span><span class="params">(Operator node, ExpressionContext context)</span> &#123;</span><br><span class="line">  List&lt;PhysicalPropertySet&gt; requiredProps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> <span class="number">0</span>; childIndex &lt; context.arity(); ++childIndex) &#123;</span><br><span class="line">      requiredProps.add(PhysicalPropertySet.EMPTY);</span><br><span class="line">  &#125;</span><br><span class="line">  requiredProperties.add(requiredProps);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="visitPhysicalHashJoin"><a href="#visitPhysicalHashJoin" class="headerlink" title="visitPhysicalHashJoin"></a>visitPhysicalHashJoin</h3><p>当遇到一个 PhysicalHashJoinOperator，则会进入 visitPhysicalHashJoin 函数，生成对左右子节点输出所需的属性。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/DistributionSpec-4.svg?raw=true" alt="DistributionSpec-4"></p>
<p>JOIN 的实现主要有两种：</p>
<ol>
<li>BroadcastJOIN<br> 将右子节点数据（Build-TABLE）的数据全部发送到左子节点（Probe-TABLE），在左子节点很丧构建 HashMap。这种实现对右表的行数有大小限制。</li>
<li>ShuffleJOIN<br>需要对子节点的数据进行Shuffle，根据 Shuffle 规则又可以细分。</li>
</ol>
<p>最终选择哪种作为物理计划，根据右表的大小、以及生成的物理计划的代价进行抉择。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visitPhysicalHashJoin</span><span class="params">(PhysicalHashJoinOperator node, ExpressionContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 1 For broadcast join</span></span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">rightBroadcastProperty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhysicalPropertySet</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DistributionProperty</span>(DistributionSpec.createReplicatedDistributionSpec()));</span><br><span class="line">    requiredProperties.add(Lists.newArrayList(</span><br><span class="line">        PhysicalPropertySet.EMPTY,  <span class="comment">// 对左子节点输出无要求</span></span><br><span class="line">        rightBroadcastProperty));   <span class="comment">// 对右子节点输出属性有分布要求</span></span><br><span class="line"></span><br><span class="line">    <span class="type">JoinHelper</span> <span class="variable">joinHelper</span> <span class="operator">=</span> JoinHelper.of(node, </span><br><span class="line">            context.getChildOutputColumns(<span class="number">0</span>),  <span class="comment">// 左子节点的输出列</span></span><br><span class="line">            context.getChildOutputColumns(<span class="number">1</span>)); <span class="comment">// 右子节点的输出列</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前 Operator 仅能通过 BroadcastJoin 来实现</span></span><br><span class="line">    <span class="keyword">if</span> (joinHelper.onlyBroadcast()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 Operator 仅能通过 ShuffleJoin 来实现</span></span><br><span class="line">    <span class="keyword">if</span> (joinHelper.onlyShuffle()) &#123;</span><br><span class="line">        requiredProperties.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 For shuffle join</span></span><br><span class="line">    List&lt;Integer&gt; leftOnPredicateColumns = joinHelper.getLeftOnColumns();</span><br><span class="line">    List&lt;Integer&gt; rightOnPredicateColumns = joinHelper.getRightOnColumns();</span><br><span class="line">    <span class="keyword">if</span> (leftOnPredicateColumns.isEmpty() || rightOnPredicateColumns.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将父节点对自己的输出要求 requirementsFromParent 传递给对子节点</span></span><br><span class="line">    <span class="comment">// 生成 ShuffleJoin 属性</span></span><br><span class="line">    requiredProperties.add(computeShuffleJoinRequiredProperties(</span><br><span class="line">        requirementsFromParent, leftOnPredicateColumns, rightOnPredicateColumns));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PropertyDeriverBase-computeShuffleJoinRequiredProperties"><a href="#PropertyDeriverBase-computeShuffleJoinRequiredProperties" class="headerlink" title="PropertyDeriverBase.computeShuffleJoinRequiredProperties"></a>PropertyDeriverBase.computeShuffleJoinRequiredProperties</h4><p>requiredFromParent 是 PhysicalHashJoinOperator 父节点对其输出需要满足的属性，leftShuffleColumns、rightShuffleColumns 是 JoinOperator 的两个子节点的 shuffle 列。 JoinOperator 需要在满足 requiredFromParent 的前提下，调整 shuffle 列的顺序，生成自己左右子节点的输出属性。</p>
<p>实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> List&lt;PhysicalPropertySet&gt; </span><br><span class="line"><span class="title function_">computeShuffleJoinRequiredProperties</span><span class="params">(PhysicalPropertySet requiredFromParent, </span></span><br><span class="line"><span class="params">                                     List&lt;Integer&gt; leftShuffleColumns,</span></span><br><span class="line"><span class="params">                                     List&lt;Integer&gt; rightShuffleColumns)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获得父节点的 ShuffleJoin 分布要求</span></span><br><span class="line">    Optional&lt;HashDistributionDesc&gt; requiredShuffleDescOptional =</span><br><span class="line">            getShuffleJoinHashDistributionDesc(requiredFromParent);</span><br><span class="line">    <span class="keyword">if</span> (!requiredShuffleDescOptional.isPresent()) &#123;</span><br><span class="line">        <span class="comment">// 2. requiredFromParent 不要求子节点是 ShufffleJOIN</span></span><br><span class="line">        <span class="keyword">return</span> createShuffleJoinRequiredProperties(</span><br><span class="line">            leftShuffleColumns, rightShuffleColumns);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 是否需要调整列的顺序</span></span><br><span class="line">        List&lt;Integer&gt; requiredColumns </span><br><span class="line">                = requiredShuffleDescOptional.get().getColumns();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">adjustBasedOnLeft</span></span><br><span class="line">                <span class="operator">=</span> leftShuffleColumns.size() == requiredColumns.size()</span><br><span class="line">                &amp;&amp; leftShuffleColumns.containsAll(requiredColumns)</span><br><span class="line">                &amp;&amp; requiredColumns.containsAll(leftShuffleColumns);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">adjustBasedOnRight</span> </span><br><span class="line">                <span class="operator">=</span> rightShuffleColumns.size() == requiredColumns.size()</span><br><span class="line">                &amp;&amp; rightShuffleColumns.containsAll(requiredColumns)</span><br><span class="line">                &amp;&amp; requiredColumns.containsAll(rightShuffleColumns);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于和 requiredColumns 完全相同的列进行选择</span></span><br><span class="line">        <span class="keyword">if</span> (adjustBasedOnLeft || adjustBasedOnRight) &#123;</span><br><span class="line">            List&lt;Integer&gt; requiredLeft = Lists.newArrayList();</span><br><span class="line">            List&lt;Integer&gt; requiredRight = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Integer cid : requiredColumns) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> adjustBasedOnLeft </span><br><span class="line">                        ? leftShuffleColumns.indexOf(cid) </span><br><span class="line">                        : rightShuffleColumns.indexOf(cid);</span><br><span class="line">                requiredLeft.add(leftShuffleColumns.get(idx));</span><br><span class="line">                requiredRight.add(rightShuffleColumns.get(idx));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> createShuffleJoinRequiredProperties(</span><br><span class="line">                requiredLeft, requiredRight);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createShuffleJoinRequiredProperties(</span><br><span class="line">                leftShuffleColumns, rightShuffleColumns);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="PropertyDeriverBase-getShuffleJoinHashDistributionDesc"><a href="#PropertyDeriverBase-getShuffleJoinHashDistributionDesc" class="headerlink" title="PropertyDeriverBase.getShuffleJoinHashDistributionDesc"></a>PropertyDeriverBase.getShuffleJoinHashDistributionDesc</h4><p>getShuffleJoinHashDistributionDesc 函数有两个作用：</p>
<ol>
<li>检测父节点是否要子节点输出为 SHUFFLE 方式。如果不是，则返回 Optional.empty()，即不强求子节点也必须有这个分布</li>
<li>否则，则返回父节点要求子节点满足的输出属性 requiredPropertySet</li>
</ol>
<p>代码如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Optional&lt;HashDistributionDesc&gt; </span><br><span class="line"><span class="title function_">getShuffleJoinHashDistributionDesc</span><span class="params">(PhysicalPropertySet requiredPropertySet)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 子节点输出方式 shuffle</span></span><br><span class="line">    <span class="keyword">if</span> (!requiredPropertySet.getDistributionProperty().isShuffle()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">HashDistributionDesc</span> <span class="variable">requireDistributionDesc</span> <span class="operator">=</span></span><br><span class="line">        ((HashDistributionSpec) requiredPropertySet.getDistributionProperty()</span><br><span class="line">            .getSpec()).getHashDistributionDesc();</span><br><span class="line">      <span class="comment">// 2. 子节点输入源是 SHUFFLE_JOIN</span></span><br><span class="line">    <span class="keyword">if</span> (!HashDistributionDesc.SourceType.SHUFFLE_JOIN</span><br><span class="line">        .equals(requireDistributionDesc.getSourceType())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Optional.of(requireDistributionDesc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="PropertyDeriverBase-createShuffleJoinRequiredProperties"><a href="#PropertyDeriverBase-createShuffleJoinRequiredProperties" class="headerlink" title="PropertyDeriverBase.createShuffleJoinRequiredProperties"></a>PropertyDeriverBase.createShuffleJoinRequiredProperties</h4><p>基于输入参数 &lt;leftColumns, rightColumns&gt; 生成 List&lt;PhysicalPropertySet&gt;。这里的 HashDistributionDesc.SourceType.SHUFFLE_JOIN 表示这个 hash 分布来源是 JOIN。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;PhysicalPropertySet&gt;</span><br><span class="line"><span class="title function_">createShuffleJoinRequiredProperties</span><span class="params">(List&lt;Integer&gt; leftColumns, List&lt;Integer&gt; rightColumns)</span> &#123;</span><br><span class="line">    <span class="type">HashDistributionSpec</span> <span class="variable">leftDistribution</span> <span class="operator">=</span> </span><br><span class="line">        DistributionSpec.createHashDistributionSpec(<span class="keyword">new</span> <span class="title class_">HashDistributionDesc</span>(</span><br><span class="line">        leftColumns,</span><br><span class="line">        HashDistributionDesc.SourceType.SHUFFLE_JOIN));</span><br><span class="line">    <span class="type">HashDistributionSpec</span> <span class="variable">rightDistribution</span> <span class="operator">=</span> </span><br><span class="line">        DistributionSpec.createHashDistributionSpec(<span class="keyword">new</span> <span class="title class_">HashDistributionDesc</span>(</span><br><span class="line">        rightColumns,</span><br><span class="line">        HashDistributionDesc.SourceType.SHUFFLE_JOIN));</span><br><span class="line"></span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">leftRequiredPropertySet</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">PhysicalPropertySet</span>(<span class="keyword">new</span> <span class="title class_">DistributionProperty</span>(leftDistribution));</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">rightRequiredPropertySet</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">PhysicalPropertySet</span>(<span class="keyword">new</span> <span class="title class_">DistributionProperty</span>(rightDistribution));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Lists.newArrayList(leftRequiredPropertySet, rightRequiredPropertySet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="EnforceAndCostTask"><a href="#EnforceAndCostTask" class="headerlink" title="EnforceAndCostTask"></a>EnforceAndCostTask</h2><p>EnforceAndCostTask 是用于优化一个 groupExpression 所属 Group 及其输入：从叶结点向根节点方向优化，bottom-up。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EnforceAndCostTask(TaskContext context, GroupExpression expression) &#123;</span><br><span class="line">  <span class="built_in">super</span>(context);</span><br><span class="line">  <span class="built_in">this</span>.groupExpression = expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="initRequiredProperties"><a href="#initRequiredProperties" class="headerlink" title="initRequiredProperties"></a>initRequiredProperties</h3><p>initRequiredProperties 函数中通过调用 RequiredPropertyDeriver.getRequiredProps 函数来获得 GroupExpression.op 要求子节点需要满足的输出属性，记录记录在 childrenRequiredPropertiesList。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initRequiredProperties</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (curChildIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  localCost = <span class="number">0</span>;</span><br><span class="line">  curTotalCost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子节点所需满足的输出属性</span></span><br><span class="line">  childrenRequiredPropertiesList = </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RequiredPropertyDeriver</span>(context).getRequiredProps(groupExpression);</span><br><span class="line">  curChildIndex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="optimizeChildGroup"><a href="#optimizeChildGroup" class="headerlink" title="optimizeChildGroup"></a>optimizeChildGroup</h3><p>optimizeChildGroup 函数对当前 groupExpression 的所有输入（即 ChildernGroup） 先优化，等输入都优化完毕，就能统计出从叶结点到当前 Group 的最佳路径了。</p>
<ul>
<li>inputProperty 是对当前 group 对 childGroup 输出属性的要求</li>
<li>newUpperBound 是以 childGroup 为根节点的子树中，cost 上界</li>
</ul>
<p>借助 pushTask 函数实现保护现场、现场恢复。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">optimizeChildGroup</span><span class="params">(PhysicalPropertySet inputProperty,</span></span><br><span class="line"><span class="params">                                Group childGroup)</span> &#123;</span><br><span class="line">  <span class="comment">// clone 函数实现保留现场</span></span><br><span class="line">  pushTask((EnforceAndCostTask) clone()); </span><br><span class="line">  <span class="type">double</span> <span class="variable">newUpperBound</span> <span class="operator">=</span> context.getUpperBoundCost() - curTotalCost;</span><br><span class="line">  <span class="type">TaskContext</span> <span class="variable">taskContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskContext</span>(</span><br><span class="line">        context.getOptimizerContext(), </span><br><span class="line">        inputProperty,</span><br><span class="line">        context.getRequiredColumns(),</span><br><span class="line">        newUpperBound);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本次执行的 ChildGroup</span></span><br><span class="line">  pushTask(<span class="keyword">new</span> <span class="title class_">OptimizeGroupTask</span>(taskContext, childGroup)); </span><br><span class="line">  <span class="comment">// 执行完再返回现场</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OutputPropertyDeriver"><a href="#OutputPropertyDeriver" class="headerlink" title="OutputPropertyDeriver"></a>OutputPropertyDeriver</h2><p>OutputPropertyDeriver 类用于生成当前节点的输出属性，ChildOutputPropertyGuarantor 用于生成子节点的输出属性</p>
<p>先来看没有输入的节点，比如 OlapScanNodeOperator，在执行 EnforceAndCostTask.execute 函数时会跳过 optimizeChildGroup 函数和 ChildOutputPropertyGuarantor，进入 OutputPropertyDeriver 中，来满足父节点的输出属性要求。</p>
<ul>
<li>context.getRequiredProperty() 是父节点所需要的属性</li>
<li>outputProperty 是本节点输出的属性</li>
<li>childrenOutputProperties 是子节点属性的属性</li>
</ul>
<p>这部分代码注释如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in EnforceAndCostTask.execute</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计完 ChildernGroup 的 cost 之后，再统计当前 groupExpression 的 cost</span></span><br><span class="line"><span class="keyword">if</span> (curChildIndex == <span class="number">0</span> &amp;&amp; prevChildIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">    localCost = CostModel.calculateCost(groupExpression);</span><br><span class="line">    curTotalCost += localCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChildernGroup 优化完毕，再考虑自己</span></span><br><span class="line"><span class="keyword">if</span> (curChildIndex == groupExpression.getInputs().size()) &#123;</span><br><span class="line">    <span class="type">ChildOutputPropertyGuarantor</span> <span class="variable">childOutputPropertyGuarantor</span> </span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildOutputPropertyGuarantor</span>(</span><br><span class="line">            context,</span><br><span class="line">            groupExpression,</span><br><span class="line">            context.getRequiredProperty(),</span><br><span class="line">            childrenBestExprList,</span><br><span class="line">            childrenRequiredProperties,</span><br><span class="line">            childrenOutputProperties,</span><br><span class="line">            curTotalCost);</span><br><span class="line">    <span class="comment">// 校验子节点输出属性是否满足当前节点对其输出属性要求</span></span><br><span class="line">    curTotalCost = childOutputPropertyGuarantor.enforceLegalChildOutputProperty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 裁剪: 当前 groupExpression 优化的代价已经高于 Group 中其他等价 GroupExpression</span></span><br><span class="line">    <span class="keyword">if</span> (curTotalCost &gt; context.getUpperBoundCost()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update current group statistics and re-compute costs</span></span><br><span class="line">    <span class="keyword">if</span> (!computeCurrentGroupStatistics()) &#123;</span><br><span class="line">        <span class="comment">// child group has been pruned</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the output property</span></span><br><span class="line">    <span class="comment">// 计算当前 GroupExpression 的输出属性，并满足父节点输出属性要求</span></span><br><span class="line">    <span class="type">OutputPropertyDeriver</span> <span class="variable">outputPropertyDeriver</span> </span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputPropertyDeriver</span>(groupExpression,</span><br><span class="line">                                    context.getRequiredProperty(),</span><br><span class="line">                                    childrenOutputProperties);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">outputProperty</span> <span class="operator">=</span> outputPropertyDeriver.getOutputProperty();</span><br><span class="line">    recordCostsAndEnforce(outputProperty, childrenRequiredProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="OutputPropertyDeriver-visitPhysicalOlapScan"><a href="#OutputPropertyDeriver-visitPhysicalOlapScan" class="headerlink" title="OutputPropertyDeriver.visitPhysicalOlapScan"></a>OutputPropertyDeriver.visitPhysicalOlapScan</h3><p>PhysicalOlapScanOperator 是个递归基，没有输入属性、只有输出属性，输出属性集中只有个分布属性 HashDistributionSpec，其中 <strong>HashDistributionDesc.SourceType.LOCAL</strong> 表示数据来源于本地。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PhysicalPropertySet <span class="title function_">visitPhysicalOlapScan</span><span class="params">(PhysicalOlapScanOperator node, </span></span><br><span class="line"><span class="params">                                                 ExpressionContext context)</span> &#123;</span><br><span class="line">    <span class="type">HashDistributionSpec</span> <span class="variable">olapDistributionSpec</span> <span class="operator">=</span> node.getDistributionSpec();</span><br><span class="line"></span><br><span class="line">    DistributionSpec.<span class="type">PropertyInfo</span> <span class="variable">physicalPropertyInfo</span> </span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributionSpec</span>.PropertyInfo();</span><br><span class="line"></span><br><span class="line">    physicalPropertyInfo.tableId = node.getTable().getId();</span><br><span class="line">    physicalPropertyInfo.partitionIds = node.getSelectedPartitionId();</span><br><span class="line">    <span class="keyword">return</span> createPropertySetByDistribution(<span class="keyword">new</span> <span class="title class_">HashDistributionSpec</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashDistributionDesc</span>(</span><br><span class="line">            olapDistributionSpec.getShuffleColumns(),</span><br><span class="line">            HashDistributionDesc.SourceType.LOCAL),</span><br><span class="line">        physicalPropertyInfo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EnforceAndCostTask-recordCostsAndEnforce"><a href="#EnforceAndCostTask-recordCostsAndEnforce" class="headerlink" title="EnforceAndCostTask.recordCostsAndEnforce"></a>EnforceAndCostTask.recordCostsAndEnforce</h3><p>outputProperty 是当前节点输出属性，context.getRequiredPropert() 是父节点对当前节点的输出属性要求，此时需要进一步校验 outputProperty –&gt; requiredPropert 链路是否满足，如果不满足则施加一个 enforcer: <strong>outputProperty –&gt; enforcer –&gt; requiredPropert</strong>。</p>
<p>recordCostsAndEnforce 函数的输入是当前节点输出属性 outputProperty、和子节点输入属性 childrenOutputProperties，函数执行完，一个 Group 的及其子 Group 的优化就结束了，并将最低成本记录在 <strong>curTotalCost</strong> 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> </span><br><span class="line"><span class="title function_">recordCostsAndEnforce</span><span class="params">(PhysicalPropertySet outputProperty,</span></span><br><span class="line"><span class="params">                      List&lt;PhysicalPropertySet&gt; childrenOutputProperties)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 重新计算 cost，并更新当前 groupExpression 的 totoal cost</span></span><br><span class="line">    curTotalCost -= localCost;</span><br><span class="line">    localCost = CostModel.calculateCostWithChildrenOutProperty(</span><br><span class="line">            groupExpression, childrenOutputProperties);</span><br><span class="line">    curTotalCost += localCost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 先假设满足本节点的输出属性 outputProperty 能满足父节点所需属性 requiredProperty</span></span><br><span class="line">    setSatisfiedPropertyWithCost(outputProperty, childrenOutputProperties);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">requiredProperty</span> <span class="operator">=</span> context.getRequiredProperty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outputProperty.isSatisfy(requiredProperty)) &#123;</span><br><span class="line">        <span class="comment">// 2. 如果不满足，则添加 Enforcer</span></span><br><span class="line">        <span class="comment">// outputProperty --&gt; enforcedProperty --&gt; requiredProperty</span></span><br><span class="line">        <span class="type">PhysicalPropertySet</span> <span class="variable">enforcedProperty</span> </span><br><span class="line">            <span class="operator">=</span> enforceProperty(outputProperty, requiredProperty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// enforcedProperty is superset of requiredProperty</span></span><br><span class="line">        <span class="keyword">if</span> (!enforcedProperty.equals(requiredProperty)) &#123;</span><br><span class="line">            <span class="comment">// 在 &#123;enforcedProperty, requiredProperty&#125; 之间映射</span></span><br><span class="line">            setPropertyWithCost(</span><br><span class="line">                <span class="comment">// enforcer</span></span><br><span class="line">                groupExpression.getGroup().getBestExpression(enforcedProperty), </span><br><span class="line">                enforcedProperty,</span><br><span class="line">                requiredProperty,</span><br><span class="line">                Lists.newArrayList(outputProperty));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 如果满足，且 outputProperty != requiredProperty</span></span><br><span class="line">        <span class="comment">//    outputProperty 是 requiredProperty 的子集，则更新记录</span></span><br><span class="line">        <span class="keyword">if</span> (!outputProperty.equals(requiredProperty)) &#123;</span><br><span class="line">            setPropertyWithCost(</span><br><span class="line">                groupExpression,</span><br><span class="line">                outputProperty,</span><br><span class="line">                requiredProperty,</span><br><span class="line">                childrenOutputProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 更新当前 groupExpression 所属的 Group 的 cost 上界</span></span><br><span class="line">    <span class="keyword">if</span> (curTotalCost &lt; context.getUpperBoundCost()) &#123;</span><br><span class="line">        context.setUpperBoundCost(curTotalCost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EnforceAndCostTask-setSatisfiedPropertyWithCost"><a href="#EnforceAndCostTask-setSatisfiedPropertyWithCost" class="headerlink" title="EnforceAndCostTask.setSatisfiedPropertyWithCost"></a>EnforceAndCostTask.setSatisfiedPropertyWithCost</h4><p>setSatisfiedPropertyWithCost 函数表示当前 groupExpression 的输出属性 outputProperty 父节点要求的属性 requiredProperty 完全一样了。因此，调用 setPropertyWithCost 函数时，直接使用 outputProperty 代替 requiredProperty。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setSatisfiedPropertyWithCost</span><span class="params">(</span></span><br><span class="line"><span class="params">                        PhysicalPropertySet outputProperty, </span></span><br><span class="line"><span class="params">                        List&lt;PhysicalPropertySet&gt; childrenOutputProperties)</span> &#123;</span><br><span class="line">    setPropertyWithCost(</span><br><span class="line">        groupExpression, outputProperty, childrenOutputProperties);</span><br><span class="line">    <span class="keyword">if</span> (outputProperty.getCteProperty().isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// groupExpression can satisfy the ANY type output property</span></span><br><span class="line">        setPropertyWithCost(groupExpression,</span><br><span class="line">                            outputProperty,</span><br><span class="line">                            PhysicalPropertySet.EMPTY,</span><br><span class="line">                            childrenOutputProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EnforceAndCostTask-setPropertyWithCost"><a href="#EnforceAndCostTask-setPropertyWithCost" class="headerlink" title="EnforceAndCostTask.setPropertyWithCost"></a>EnforceAndCostTask.setPropertyWithCost</h4><p>Group 与 GroupExpression：一个 Group 中包含了所有逻辑上等价的 GroupExpression（即输出一样），并记录了 lowestCost 的 GroupExpression，而 GroupExpression 输入输出都是 Group </p>
<ul>
<li><p>GroupExpression.lowestCostTable: 记录是得到 outputProperty 所需的成小成本 curTotalCost 以及对应的输入属性 childrenOutputProperties</p>
<p>  因此，如果本次更新 childrenOutputProperties –&gt; outputProperty 所需的成本 curTotalCost 更低，则更新 GroupExpression.lowestCostTable 中的记录（如果原本没有则插入）</p>
<blockquote>
<p>GroupExpression.updatePropertyWithCost 函数更新。</p>
</blockquote>
</li>
<li><p>GroupExpression.outputPropertyMap: 记录的是得到最佳路径时，满足 requiredPropertySet 的输出属性 outputProperty</p>
<p>  由于 updatePropertyWithCost 返回 true 时，才会更新 GroupExpression.outputPropertyMap，因此两个函数联动起来就是<u><strong>输入到输出的最佳路径信息</strong></u>：</p>
<ul>
<li>Group 中最佳表达式：this.groupExpression</li>
<li>最低的成本：curTotalCost</li>
<li>此时的输入属性：childrenOutputProperties</li>
<li>此时的输出属性：outputProperty</li>
<li>父节点要求属性：requiredProperty</li>
</ul>
<blockquote>
<p>GroupExpression.setOutputPropertySatisfyRequiredProperty 更新。</p>
</blockquote>
</li>
<li><p>Group.lowestCostExpressions: 记录的是 Group 所有等价的 GroupExpression 中，在满足 requiredProperty 属性要求的前提下，代价最低的 GroupExprssion 是哪个</p>
<ul>
<li>key: requiredProperty</li>
<li>value: &lt;cost, expression&gt; 最低的代价与对应的 GroupExpression</li>
</ul>
<blockquote>
<p>Group.setBestExpression 函数更新</p>
</blockquote>
</li>
</ul>
<p>因此，当优化结束，父节点可以通过 GroupExpression.getOutputProperty(requiredProperty) 函数得到最佳输入属性 outputProperty，再递归到 childrenOutputProperties，… 即可遍历所有最佳表达式。</p>
<p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/groupExpression-1.svg?raw=true" alt="groupExpression-1"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setPropertyWithCost</span><span class="params">(GroupExpression groupExpression,</span></span><br><span class="line"><span class="params">                                 PhysicalPropertySet outputProperty,</span></span><br><span class="line"><span class="params">                                 PhysicalPropertySet requiredProperty,</span></span><br><span class="line"><span class="params">                                 List&lt;PhysicalPropertySet&gt; childrenOutputProperties)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (groupExpression.updatePropertyWithCost(</span><br><span class="line">            requiredProperty, childrenOutputProperties, curTotalCost)) &#123;</span><br><span class="line">        groupExpression.setOutputPropertySatisfyRequiredProperty(</span><br><span class="line">            outputProperty, requiredProperty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.groupExpression.getGroup().setBestExpression(</span><br><span class="line">        groupExpression, curTotalCost, requiredProperty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GroupExpression-updatePropertyWithCost"><a href="#GroupExpression-updatePropertyWithCost" class="headerlink" title="GroupExpression.updatePropertyWithCost"></a>GroupExpression.updatePropertyWithCost</h4><p>当发现一个满足条件的 outputProperties，并且本次 new_cost 比之前的 old_cost 更小则更新 GroupExpression.lowestCostTable 记录（如果没有则插入），它是在 {outputProperties, &lt;cost, inputProperties&gt;} 之间建立映射关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updatePropertyWithCost</span><span class="params">(PhysicalPropertySet outputProperties,</span></span><br><span class="line"><span class="params">                                      List&lt;PhysicalPropertySet&gt; inputProperties,</span></span><br><span class="line"><span class="params">                                      <span class="type">double</span> cost)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lowestCostTable.containsKey(outputProperties)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lowestCostTable.get(outputProperties).first &gt; cost) &#123;</span><br><span class="line">            lowestCostTable.put(</span><br><span class="line">                outputProperties, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(cost, inputProperties));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lowestCostTable.put(</span><br><span class="line">            outputProperties, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(cost, inputProperties));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="GroupExpression-setOutputPropertySatisfyRequiredProperty"><a href="#GroupExpression-setOutputPropertySatisfyRequiredProperty" class="headerlink" title="GroupExpression.setOutputPropertySatisfyRequiredProperty"></a>GroupExpression.setOutputPropertySatisfyRequiredProperty</h4><p>setOutputPropertySatisfyRequiredProperty 是为了记录在父节点 parent 所需属性 requiredPropertySet 和本节点输出属性之间 outputPropertySet 的映射关系。</p>
<p>当 parent 执行 EnforceAndCostTask 函数时，会通过 GroupExpression.getOutputProperty 函数来获取子节点的输出属性，后面会仔细讲解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOutputPropertySatisfyRequiredProperty</span><span class="params">(PhysicalPropertySet outputPropertySet,</span></span><br><span class="line"><span class="params">                                                     PhysicalPropertySet requiredPropertySet)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.outputPropertyMap.put(requiredPropertySet, outputPropertySet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> PhysicalPropertySet <span class="title function_">getOutputProperty</span><span class="params">(PhysicalPropertySet requiredPropertySet)</span> &#123;</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">outputProperty</span> <span class="operator">=</span> outputPropertyMap.get(requiredPropertySet);</span><br><span class="line">    Preconditions.checkState(outputProperty != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> outputProperty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Group-setBestExpression"><a href="#Group-setBestExpression" class="headerlink" title="Group.setBestExpression"></a>Group.setBestExpression</h4><p>Group.lowestCostExpressions 的映射关系是 {RequeiredProperty, {cost, groupExpression}}，即 key 是父节点所需的属性，value 是代价最低的 groupExpression 及其 cost。Group.setBestExpression 函数实时更新代价最低的 Group.lowestCostExpressions</p>
<p>那么最终根节点的 group 获取代价最低的 groupExpression 时就可以通过 Group.getBestExpression 函数获得。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBestExpression</span><span class="params">(GroupExpression expression,</span></span><br><span class="line"><span class="params">                              <span class="type">double</span> cost,</span></span><br><span class="line"><span class="params">                              PhysicalPropertySet physicalPropertySet)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lowestCostExpressions.containsKey(physicalPropertySet)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lowestCostExpressions.get(physicalPropertySet).first &gt; cost) &#123;</span><br><span class="line">            lowestCostExpressions.put(</span><br><span class="line">                physicalPropertySet, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(cost, expression));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lowestCostExpressions.put(</span><br><span class="line">            physicalPropertySet, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(cost, expression));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> GroupExpression <span class="title function_">getBestExpression</span><span class="params">(PhysicalPropertySet physicalPropertySet)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBestExpression(physicalPropertySet)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCostExpressions.get(physicalPropertySet).second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="EnforceAndCostTask-enforceDistribute"><a href="#EnforceAndCostTask-enforceDistribute" class="headerlink" title="EnforceAndCostTask.enforceDistribute"></a>EnforceAndCostTask.enforceDistribute</h3><p>enforceProperty 函数会检测 outputPropertySet 中的 DistributionProperty、SortProperty 是否满足 requiredPropertySet。这里以 DistributionProperty 为例阐述 enforceDistribute 函数怎么添加 Enforcer。</p>
<ol>
<li>PhysicalPropertySet.setDistributionProperty 函数表示只更改 DistributionProperty，其他属性仍然保持不变，如此 newOutputProperty 的分布属性就和父节点的一致。</li>
<li>然后 DistributionProperty.appendEnforcers 函数将当前 group（即 groupExpression.getGroup()）作为输入生成一个新的 GroupExpression 对象 enforcer，enforcer 类似转换器，实现 oldOutputProperty -&gt;  newOutputProperty -&gt; requiredProperty 的转变。</li>
<li>最后，由于新生成的 enforcer 还没有所属的 Group，updateCostWithEnforcer 函数中将 enforcer 的所属 group 也设置为 groupExpression.getGroup()</li>
</ol>
<p>整体逻辑如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PhysicalPropertySet <span class="title function_">enforceDistribute</span><span class="params">(PhysicalPropertySet oldOutputProperty)</span> &#123;</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">newOutputProperty</span> <span class="operator">=</span> oldOutputProperty.copy();</span><br><span class="line">    <span class="comment">// 设置目标分布属性</span></span><br><span class="line">    newOutputProperty.setDistributionProperty(</span><br><span class="line">        context.getRequiredProperty().getDistributionProperty());</span><br><span class="line">    <span class="comment">// 增加一个 groupExpression</span></span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">enforcer</span> <span class="operator">=</span> context.getRequiredProperty()</span><br><span class="line">                               .getDistributionProperty()</span><br><span class="line">                               .appendEnforcers(groupExpression.getGroup());</span><br><span class="line">    <span class="comment">// 将 newOutputProperty --&gt; enforcer</span></span><br><span class="line">    updateCostWithEnforcer(enforcer, oldOutputProperty, newOutputProperty);</span><br><span class="line">    <span class="keyword">return</span> newOutputProperty;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h4 id="DistributionProperty-appendEnforcers"><a href="#DistributionProperty-appendEnforcers" class="headerlink" title="DistributionProperty.appendEnforcers"></a>DistributionProperty.appendEnforcers</h4><p>生成新的 GroupExpression 对象 enforer，其中包含的 Operator 是 PhysicalDistributionOperator 实现所需的数据分布。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GroupExpression <span class="title function_">appendEnforcers</span><span class="params">(Group child)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GroupExpression</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PhysicalDistributionOperator</span>(spec), Lists.newArrayList(child));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="EnforceAndCostTask-updateCostWithEnforcer"><a href="#EnforceAndCostTask-updateCostWithEnforcer" class="headerlink" title="EnforceAndCostTask.updateCostWithEnforcer"></a>EnforceAndCostTask.updateCostWithEnforcer</h4><p>updateCostWithEnforcer 函数设置 enforcer 所属的 Group，串联起 {oldOutputProperty, newOutputProperty} 之间的联系，并重新计算 enforcer 之后的代价。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateCostWithEnforcer</span><span class="params">(GroupExpression enforcer,</span></span><br><span class="line"><span class="params">                                    PhysicalPropertySet oldOutputProperty,</span></span><br><span class="line"><span class="params">                                    PhysicalPropertySet newOutputProperty)</span> &#123;</span><br><span class="line">    context.getOptimizerContext().getMemo().</span><br><span class="line">        insertEnforceExpression(enforcer, groupExpression.getGroup());</span><br><span class="line">    <span class="comment">// 记录增加的 enforcer 代价</span></span><br><span class="line">    curTotalCost += CostModel.calculateCost(enforcer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enforcer.updatePropertyWithCost(</span><br><span class="line">            newOutputProperty,</span><br><span class="line">            Lists.newArrayList(oldOutputProperty),</span><br><span class="line">            curTotalCost)) &#123;</span><br><span class="line">        enforcer.setOutputPropertySatisfyRequiredProperty(</span><br><span class="line">            newOutputProperty, newOutputProperty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    groupExpression.getGroup().setBestExpression(</span><br><span class="line">        enforcer, curTotalCost, newOutputProperty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Memo-insertEnforceExpression"><a href="#Memo-insertEnforceExpression" class="headerlink" title="Memo.insertEnforceExpression"></a>Memo.insertEnforceExpression</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEnforceExpression</span><span class="params">(GroupExpression groupExpression, Group targetGroup)</span> &#123;</span><br><span class="line">    groupExpression.setGroup(targetGroup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ChildOutputPropertyGuarantor"><a href="#ChildOutputPropertyGuarantor" class="headerlink" title="ChildOutputPropertyGuarantor"></a>ChildOutputPropertyGuarantor</h2><h3 id="EnforceAndCostTask-execute"><a href="#EnforceAndCostTask-execute" class="headerlink" title="EnforceAndCostTask.execute"></a>EnforceAndCostTask.execute</h3><p>上面的视角是以 PhysicalOlapScanOperator 为例讲解了优化一个 Group 的过程，因为 OlapScanNode 作为物理计划树中的叶结点，没有输入，因此是 EnforceAndCostTask.execute 函数的递归基，下面以 PhysicalHashJoinOperator 为例讲解一个子树优化的过程。</p>
<p>HashJoinNode 的左右子节点是 PhysicalOlapScanOperator or PhysicalDistributionOperator，并且 optimizeChildGroup 函数已递归两次将左右子节点都优化完，因此</p>
<ul>
<li>childGroup.getBestExpression() 获得的 childBestExpr 是在上面的 Group.setBestExpression 函数中设置的<br>如果 childBestExpr &#x3D;&#x3D; null 表示当前 childGroup 要么已经被裁剪了，要么还没优化，具体哪种取决于 prevChildIndex: prevChildIndex 记录正在优化的子节点索引，如果 prevChildIndex &lt; curChildIndex 则表示 childGroup 还没优化，则进入 optimizeChildGroup 函数递归完</li>
<li>childBestExpr.getOutputProperty() 获得的是也是上面 setOutputPropertySatisfyRequiredProperty 函数设置的最佳 GroupExpression 对象</li>
</ul>
<p>这部分代码逻辑及其解释如下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; curChildIndex &lt; groupExpression.getInputs().size(); curChildIndex++) &#123;</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">childRequiredProperty</span> </span><br><span class="line">        <span class="operator">=</span> childrenRequiredProperties.get(curChildIndex);</span><br><span class="line">    <span class="type">Group</span> <span class="variable">childGroup</span> <span class="operator">=</span> groupExpression.getInputs().get(curChildIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether the child group is already optimized for the property</span></span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">childBestExpr</span> <span class="operator">=</span> </span><br><span class="line">        childGroup.getBestExpression(childRequiredProperty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pruned</span></span><br><span class="line">    <span class="keyword">if</span> (childBestExpr == <span class="literal">null</span> &amp;&amp; prevChildIndex &gt;= curChildIndex) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尚未优化</span></span><br><span class="line">    <span class="keyword">if</span> (childBestExpr == <span class="literal">null</span>) &#123;</span><br><span class="line">        prevChildIndex = curChildIndex;</span><br><span class="line">        optimizeChildGroup(childRequiredProperty, childGroup);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// childOutputProperty 就是 childBestExpr 输出的</span></span><br><span class="line">    childrenBestExprList.add(childBestExpr);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">childOutputProperty</span> <span class="operator">=</span> </span><br><span class="line">        childBestExpr.getOutputProperty(childRequiredProperty);</span><br><span class="line">    childrenOutputProperties.add(childOutputProperty);</span><br><span class="line">    childrenRequiredProperties.set(curChildIndex, childOutputProperty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 裁剪: agg operator 不能生成一阶段聚合</span></span><br><span class="line">    <span class="keyword">if</span> (!canGenerateOneStageAgg(childBestExpr)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 裁剪: join operator 不能使用 brocast join</span></span><br><span class="line">    <span class="keyword">if</span> (!checkBroadcastRowCountLimit(childRequiredProperty, childBestExpr)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 裁剪: 当前成本已超过 group 中其他逻辑等价的 GroupExpression 成本的上界</span></span><br><span class="line">    curTotalCost += childBestExpr.getCost(childRequiredProperty);</span><br><span class="line">    <span class="keyword">if</span> (curTotalCost &gt; context.getUpperBoundCost()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="enforceLegalChildOutputProperty"><a href="#enforceLegalChildOutputProperty" class="headerlink" title="enforceLegalChildOutputProperty"></a>enforceLegalChildOutputProperty</h3><p>获得 ChildernGroup 信息后，就通过 ChildOutputPropertyGuarantor 来校验属性是否符合要求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in EnforceAndCostTask.execute</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curChildIndex == groupExpression.getInputs().size()) &#123;</span><br><span class="line">    <span class="comment">// before we compute the property, here need to make sure that the plan is legal</span></span><br><span class="line">    <span class="type">ChildOutputPropertyGuarantor</span> <span class="variable">childOutputPropertyGuarantor</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ChildOutputPropertyGuarantor</span>(</span><br><span class="line">            context,</span><br><span class="line">            groupExpression,</span><br><span class="line">            context.getRequiredProperty(),</span><br><span class="line">            childrenBestExprList,</span><br><span class="line">            childrenRequiredProperties,</span><br><span class="line">            childrenOutputProperties,</span><br><span class="line">            curTotalCost);</span><br><span class="line">    curTotalCost = </span><br><span class="line">        childOutputPropertyGuarantor.enforceLegalChildOutputProperty();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">enforceLegalChildOutputProperty</span><span class="params">()</span> &#123;</span><br><span class="line">    groupExpression.getOp().accept(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">ExpressionContext</span>(groupExpression));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.curTotalCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="visitPhysicalJoin"><a href="#visitPhysicalJoin" class="headerlink" title="visitPhysicalJoin"></a>visitPhysicalJoin</h3><p><a target="_blank" rel="noopener" href="https://github.com/StarRocks/starrocks/blob/669d53928ab88a946263fe7eaafdc9447ddd7903/fe/fe-core/src/main/java/com/starrocks/sql/optimizer/ChildOutputPropertyGuarantor.java#L300">visitPhysicalJoin</a> 函数完整的代码很长不全贴了，分段进行讲解。</p>
<h4 id="BRANCH-0-BroadcastJoin"><a href="#BRANCH-0-BroadcastJoin" class="headerlink" title="BRANCH-0: BroadcastJoin"></a>BRANCH-0: BroadcastJoin</h4><p>如果在 checkBroadcastRowCountLimit 函数中，BroadcastJoin 没有被裁剪，那么也会生成一个 BroadcastJoin PropertySet，至于最终是否被选择，就得看 BroadcastJoin 和 ShuffleJOIN 的 cost 谁更低。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visitPhysicalJoin</span><span class="params">(PhysicalJoinOperator node, ExpressionContext context)</span> &#123;</span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">leftChild</span> <span class="operator">=</span> childrenBestExprList.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">rightChild</span> <span class="operator">=</span> childrenBestExprList.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">leftChildOutputProperty</span> <span class="operator">=</span> childrenOutputProperties.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">rightChildOutputProperty</span> <span class="operator">=</span> childrenOutputProperties.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Distribution is broadcast</span></span><br><span class="line">    <span class="type">DistributionProperty</span> <span class="variable">rightDistribute</span> <span class="operator">=</span> rightChildOutputProperty.getDistributionProperty();</span><br><span class="line">    <span class="keyword">if</span> (rightDistribute.isBroadcast() || rightDistribute.isGather()) &#123;</span><br><span class="line">        <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ShuffleJoin</strong><br>此时，左右两个子节点的 <strong>输出分布属性</strong> 都需要是 <strong>DistributionType.SHUFFLE</strong>，如果不是则报错。</p>
<p>确定了输出分布属性之后，再根据子节点的 DistributionType.SourceType 来优化分布。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visitPhysicalJoin</span><span class="params">(PhysicalJoinOperator node, ExpressionContext context)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 2. Distribution is shuffle</span></span><br><span class="line">    <span class="type">JoinHelper</span> <span class="variable">joinHelper</span> <span class="operator">=</span> JoinHelper.of(</span><br><span class="line">        node, context.getChildOutputColumns(<span class="number">0</span>), context.getChildOutputColumns(<span class="number">1</span>));</span><br><span class="line">    List&lt;Integer&gt; leftOnPredicateColumns = joinHelper.getLeftOnColumns();</span><br><span class="line">    List&lt;Integer&gt; rightOnPredicateColumns = joinHelper.getRightOnColumns();</span><br><span class="line">    <span class="comment">// Get required properties for children.</span></span><br><span class="line">    List&lt;PhysicalPropertySet&gt; requiredProperties =</span><br><span class="line">        computeShuffleJoinRequiredProperties( </span><br><span class="line">            requirements, leftOnPredicateColumns, rightOnPredicateColumns);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; leftShuffleColumns =</span><br><span class="line">        ((HashDistributionSpec) requiredProperties.get(<span class="number">0</span>)</span><br><span class="line">        .getDistributionProperty().getSpec()).getShuffleColumns();</span><br><span class="line">    List&lt;Integer&gt; rightShuffleColumns = </span><br><span class="line">        ((HashDistributionSpec) requiredProperties.get(<span class="number">1</span>)</span><br><span class="line">        .getDistributionProperty().getSpec()).getShuffleColumns();</span><br><span class="line"></span><br><span class="line">    <span class="type">DistributionProperty</span> <span class="variable">leftChildDistributionProperty</span> <span class="operator">=</span> </span><br><span class="line">            leftChildOutputProperty.getDistributionProperty();</span><br><span class="line">    <span class="type">DistributionProperty</span> <span class="variable">rightChildDistributionProperty</span> <span class="operator">=</span> </span><br><span class="line">            rightChildOutputProperty.getDistributionProperty();</span><br><span class="line">    <span class="comment">// CHECK: 只有 broadcast 不需要 shuffle</span></span><br><span class="line">    <span class="keyword">if</span> (!leftChildDistributionProperty.isShuffle() </span><br><span class="line">        || !rightChildDistributionProperty.isShuffle()) &#123;</span><br><span class="line">        Preconditions.checkState(</span><br><span class="line">            <span class="literal">false</span>, <span class="string">&quot;Children output property distribution error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BRANCH-1-ColocateJoin"><a href="#BRANCH-1-ColocateJoin" class="headerlink" title="BRANCH-1: ColocateJoin"></a>BRANCH-1: ColocateJoin</h4><p>如果 JOIN 的左右子节点都是来自于 OlapScan，会再检测 ColocateJoin 函数来检测是否真的能通过 ColocateJoin 来完成。不能则通过 transToBucketShuffleJoin 函数转为 BucketShuffleJoin。</p>
<p>要转换为 BucketShuffleJoin 一般是 join-key 包含了 value-column。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftDistributionDesc.isLocal() &amp;&amp; rightDistributionDesc.isLocal()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (JoinOperator.HINT_BUCKET.equals(hint) || </span><br><span class="line">        !canColocateJoin(</span><br><span class="line">            leftDistributionSpec, rightDistributionSpec,</span><br><span class="line">            leftShuffleColumns, rightShuffleColumns)) &#123;</span><br><span class="line">        transToBucketShuffleJoin(</span><br><span class="line">            leftDistributionSpec, leftShuffleColumns, rightShuffleColumns);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="BRANCH-2-BucketShuffleJoin"><a href="#BRANCH-2-BucketShuffleJoin" class="headerlink" title="BRANCH-2: BucketShuffleJoin"></a>BRANCH-2: BucketShuffleJoin</h4><p>一般是左表（大表）的 bucket-key 命中了 join-key</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftDistributionDesc.isLocal() &amp;&amp; rightDistributionDesc.isShuffle()) &#123;</span><br><span class="line">    <span class="comment">// bucket join</span></span><br><span class="line">    transToBucketShuffleJoin(leftDistributionSpec, leftShuffleColumns, rightShuffleColumns);</span><br><span class="line">    <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="transToBucketShuffleJoin"><a href="#transToBucketShuffleJoin" class="headerlink" title="transToBucketShuffleJoin"></a>transToBucketShuffleJoin</h5><p>和 enforceChildSatisfyShuffleJoin 逻辑类似</p>
<h4 id="BRANCH-3-ShuffleJoin"><a href="#BRANCH-3-ShuffleJoin" class="headerlink" title="BRANCH-3: ShuffleJoin"></a>BRANCH-3: ShuffleJoin</h4><p>如果左侧是 Shuffle，而右侧是 Local，需要调整为 {Shuffle, Shuffle_Enforcer}，如果左右两侧都是 Shuffle，则需要检测是否满足 shffleJoin</p>
<p>如果左表的 join-key 不是 bucket-key，一般都是 shuffle</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftDistributionDesc.isShuffle() &amp;&amp; rightDistributionDesc.isLocal()) &#123;</span><br><span class="line">    <span class="comment">// coordinator can not bucket shuffle data from left to right, so we need to adjust to shuffle join</span></span><br><span class="line">    enforceChildSatisfyShuffleJoin(leftDistributionSpec, leftShuffleColumns, rightShuffleColumns,</span><br><span class="line">            rightChild, rightChildOutputProperty);</span><br><span class="line">    <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftDistributionDesc.isShuffle() &amp;&amp; rightDistributionDesc.isShuffle()) &#123;</span><br><span class="line">    <span class="comment">// 如果不满足 shuffle join</span></span><br><span class="line">    <span class="keyword">if</span> (!checkChildDistributionSatisfyShuffle(leftDistributionSpec, rightDistributionSpec,</span><br><span class="line">            leftShuffleColumns,</span><br><span class="line">            rightShuffleColumns)) &#123;</span><br><span class="line">        enforceChildSatisfyShuffleJoin(leftDistributionSpec, leftShuffleColumns, rightShuffleColumns,</span><br><span class="line">                rightChild, rightChildOutputProperty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enforceChildSatisfyShuffleJoin"><a href="#enforceChildSatisfyShuffleJoin" class="headerlink" title="enforceChildSatisfyShuffleJoin"></a>enforceChildSatisfyShuffleJoin</h4><p>transToBucketShuffleJoin 和 enforceChildSatisfyShuffleJoin 核心逻辑都一样，都是先需要生产 shuffle columns，再重新分布。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enforceChildSatisfyShuffleJoin</span><span class="params">(HashDistributionSpec leftDistributionSpec,</span></span><br><span class="line"><span class="params">                                            List&lt;Integer&gt; leftShuffleColumns,</span></span><br><span class="line"><span class="params">                                            List&lt;Integer&gt; rightShuffleColumns,</span></span><br><span class="line"><span class="params">                                            GroupExpression child,</span></span><br><span class="line"><span class="params">                                            PhysicalPropertySet childOutputProperty)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; newRightShuffleColumns = Lists.newArrayList();</span><br><span class="line">    <span class="type">HashDistributionDesc</span> <span class="variable">leftDistributionDesc</span> <span class="operator">=</span> leftDistributionSpec.getHashDistributionDesc();</span><br><span class="line">    DistributionSpec.<span class="type">PropertyInfo</span> <span class="variable">leftDistributionPropertyInfo</span> <span class="operator">=</span> leftDistributionSpec.getPropertyInfo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cid : leftDistributionDesc.getColumns()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftShuffleColumns.contains(cid)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> leftShuffleColumns.indexOf(cid);</span><br><span class="line">            newRightShuffleColumns.add(rightShuffleColumns.get(index));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// find equivalent columns for the hash distribution columns</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">equivalentColumn</span> <span class="operator">=</span></span><br><span class="line">                    Arrays.stream(leftDistributionPropertyInfo.getEquivalentColumns(cid).getColumnIds()).</span><br><span class="line">                            filter(leftShuffleColumns::contains).findAny().orElse(cid);</span><br><span class="line">            Preconditions.checkState(leftShuffleColumns.contains(equivalentColumn));</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> leftShuffleColumns.indexOf(equivalentColumn);</span><br><span class="line">            newRightShuffleColumns.add(rightShuffleColumns.get(index));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 都是更改啊右子节点的分布属性</span></span><br><span class="line">    enforceChildShuffleDistribution(newRightShuffleColumns, child, childOutputProperty, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enforceChildShuffleDistribution"><a href="#enforceChildShuffleDistribution" class="headerlink" title="enforceChildShuffleDistribution"></a>enforceChildShuffleDistribution</h4><p>构造 HashDistributionSpec 对象主要是需要构造 HashDistributionDesc.columns，上层函数传递 HashDistributionDesc.columns 后就可以得到所需的分布 enforceDistributionSpec。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> GroupExpression <span class="title function_">enforceChildShuffleDistribution</span><span class="params">(List&lt;Integer&gt; shuffleColumns, GroupExpression child,</span></span><br><span class="line"><span class="params">                                                        PhysicalPropertySet childOutputProperty,</span></span><br><span class="line"><span class="params">                                                        <span class="type">int</span> childIndex)</span> &#123;</span><br><span class="line">    <span class="type">DistributionSpec</span> <span class="variable">enforceDistributionSpec</span> <span class="operator">=</span></span><br><span class="line">            DistributionSpec.createHashDistributionSpec(<span class="keyword">new</span> <span class="title class_">HashDistributionDesc</span>(shuffleColumns,</span><br><span class="line">                    HashDistributionDesc.SourceType.SHUFFLE_ENFORCE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 enforceDistributionSpec 和 child 连接起来，</span></span><br><span class="line">    <span class="comment">// 并更新 cost 信息</span></span><br><span class="line">    Pair&lt;GroupExpression, PhysicalPropertySet&gt; pair =</span><br><span class="line">            enforceChildDistribution(enforceDistributionSpec, child, childOutputProperty);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">newChildInputProperty</span> <span class="operator">=</span> pair.second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新结果</span></span><br><span class="line">    requiredChildrenProperties.set(childIndex, newChildInputProperty);</span><br><span class="line">    childrenOutputProperties.set(childIndex, newChildInputProperty);</span><br><span class="line">    <span class="keyword">return</span> pair.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="enforceChildDistribution"><a href="#enforceChildDistribution" class="headerlink" title="enforceChildDistribution"></a>enforceChildDistribution</h4><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/DistributionSpec-2.svg?raw=true" alt="DistributionSpec-2"></p>
<p>enforceChildDistribution 函数也比较重要，是为了让子节点 child 的输出分布属性中满足父节点要求的 <em>distributionSpec</em> 的要求，。因此需要在输入和输出之间再增加个 enforcer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Pair&lt;GroupExpression, PhysicalPropertySet&gt; <span class="title function_">enforceChildDistribution</span><span class="params">(DistributionSpec distributionSpec,</span></span><br><span class="line"><span class="params">                                                                            GroupExpression child,</span></span><br><span class="line"><span class="params">                                                                            PhysicalPropertySet childOutputProperty)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">childCosts</span> <span class="operator">=</span> child.getCost(childOutputProperty);</span><br><span class="line">    <span class="type">Group</span> <span class="variable">childGroup</span> <span class="operator">=</span> child.getGroup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 基于新的分布要求，生成新的分布属性</span></span><br><span class="line">    <span class="type">DistributionProperty</span> <span class="variable">newDistributionProperty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributionProperty</span>(distributionSpec);</span><br><span class="line">    <span class="comment">// 2. 基于旧的输出属性集，复制构造一个新的 PhysicalPropertySet 对象</span></span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">newOutputProperty</span> <span class="operator">=</span> childOutputProperty.copy();</span><br><span class="line">    <span class="comment">// 3. 仅更改分布属性</span></span><br><span class="line">    newOutputProperty.setDistributionProperty(newDistributionProperty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 如果子节点对应 Operator 是 PhysicalDistributionOperator</span></span><br><span class="line">    <span class="keyword">if</span> (child.getOp() <span class="keyword">instanceof</span> PhysicalDistributionOperator) &#123;</span><br><span class="line">        <span class="type">GroupExpression</span> <span class="variable">enforcer</span> <span class="operator">=</span> newDistributionProperty.appendEnforcers(childGroup);</span><br><span class="line">        <span class="comment">// 记录映射关系</span></span><br><span class="line">        enforcer.setOutputPropertySatisfyRequiredProperty(newOutputProperty, newOutputProperty);</span><br><span class="line">        <span class="comment">// 设置 enforcer 所属的 Group</span></span><br><span class="line">        context.getMemo().insertEnforceExpression(enforcer, childGroup);</span><br><span class="line">        <span class="comment">// 记录本节点的输出属性 与 输入分布属性之间的映射</span></span><br><span class="line">        enforcer.updatePropertyWithCost(newOutputProperty,</span><br><span class="line">                child.getInputProperties(childOutputProperty),</span><br><span class="line">                childCosts);</span><br><span class="line">        <span class="comment">// 更新最佳路径</span></span><br><span class="line">        childGroup.setBestExpression(enforcer, childCosts, newOutputProperty);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(enforcer, newOutputProperty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.1 如果不是 PhysicalDistributionOperator </span></span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">enforcer</span> <span class="operator">=</span> newDistributionProperty.appendEnforcers(childGroup);</span><br><span class="line">    enforcer.setOutputPropertySatisfyRequiredProperty(</span><br><span class="line">        newOutputProperty, newOutputProperty);</span><br><span class="line">    updateChildCostWithEnforcer(</span><br><span class="line">        enforcer, childOutputProperty, newOutputProperty, childCosts, childGroup);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(enforcer, newOutputProperty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="updateChildCostWithEnforcer"><a href="#updateChildCostWithEnforcer" class="headerlink" title="updateChildCostWithEnforcer"></a>updateChildCostWithEnforcer</h4><p>当 child.getOp() 不是 PhysicalDistributionOperator 对象时，则进入 updateChildCostWithEnforcer 函数中，区别就是此函数会计算新增的 enforcer 的cost。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateChildCostWithEnforcer</span><span class="params">(GroupExpression enforcer,</span></span><br><span class="line"><span class="params">                                         PhysicalPropertySet oldOutputProperty,</span></span><br><span class="line"><span class="params">                                         PhysicalPropertySet newOutputProperty,</span></span><br><span class="line"><span class="params">                                         <span class="type">double</span> childCost, </span></span><br><span class="line"><span class="params">                                         Group childGroup)</span> &#123;</span><br><span class="line">    context.getMemo().insertEnforceExpression(enforcer, childGroup);</span><br><span class="line">    <span class="comment">// update current total cost</span></span><br><span class="line">    curTotalCost -= childCost;</span><br><span class="line">    <span class="comment">// add enforcer cost</span></span><br><span class="line">    childCost += CostModel.calculateCost(enforcer);</span><br><span class="line">    curTotalCost += childCost;</span><br><span class="line"></span><br><span class="line">    enforcer.updatePropertyWithCost(</span><br><span class="line">        newOutputProperty, </span><br><span class="line">        Lists.newArrayList(oldOutputProperty),</span><br><span class="line">        childCost);</span><br><span class="line">    childGroup.setBestExpression(enforcer, childCost, newOutputProperty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="OutputPropertyDeriver-visitPhysicalJoin"><a href="#OutputPropertyDeriver-visitPhysicalJoin" class="headerlink" title="OutputPropertyDeriver.visitPhysicalJoin"></a><a target="_blank" rel="noopener" href="https://github.com/StarRocks/starrocks/blob/4a2c85a904ea7e32707e926f96b4fa9b45b59d00/fe/fe-core/src/main/java/com/starrocks/sql/optimizer/OutputPropertyDeriver.java#L212">OutputPropertyDeriver.visitPhysicalJoin</a></h2><p>在前文 ChildOutputPropertyGuarantor.visitPhysicalJoin 中已经设置好右子节的输出属性，在 OutputPropertyDeriver.visitPhysicalJoin 中则根据左右子节点的输出属性，生成 PhysicalJoinOperator 自己的输出属性。</p>
<h3 id="computeHashJoinDistributionPropertyInfo"><a href="#computeHashJoinDistributionPropertyInfo" class="headerlink" title="computeHashJoinDistributionPropertyInfo"></a>computeHashJoinDistributionPropertyInfo</h3><p><a target="_blank" rel="noopener" href="https://github.com/StarRocks/starrocks/blob/4a2c85a904ea7e32707e926f96b4fa9b45b59d00/fe/fe-core/src/main/java/com/starrocks/sql/optimizer/OutputPropertyDeriver.java#L165">computeHashJoinDistributionPropertyInfo</a> 设置 physicalPropertySet 的 DistributionSpec.PropertyInfo，再返回 physicalPropertySet。因此 Join 输出的属性即传入的 physicalPropertySet。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PhysicalPropertySet <span class="title function_">computeHashJoinDistributionPropertyInfo</span><span class="params">(PhysicalJoinOperator node,</span></span><br><span class="line"><span class="params">                                                                    PhysicalPropertySet physicalPropertySet,</span></span><br><span class="line"><span class="params">                                                                    List&lt;Integer&gt; leftOnPredicateColumns,</span></span><br><span class="line"><span class="params">                                                                    List&lt;Integer&gt; rightOnPredicateColumns,</span></span><br><span class="line"><span class="params">                                                                    ExpressionContext context)</span> &#123;</span><br><span class="line">    DistributionSpec.<span class="type">PropertyInfo</span> <span class="variable">propertyInfo</span> <span class="operator">=</span></span><br><span class="line">            physicalPropertySet.getDistributionProperty().getSpec().getPropertyInfo();</span><br><span class="line"></span><br><span class="line">    <span class="type">ColumnRefSet</span> <span class="variable">leftChildColumns</span> <span class="operator">=</span> context.getChildOutputColumns(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ColumnRefSet</span> <span class="variable">rightChildColumns</span> <span class="operator">=</span> context.getChildOutputColumns(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (node.getJoinType().isLeftOuterJoin()) &#123;</span><br><span class="line">        propertyInfo.nullableColumns.union(rightChildColumns);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getJoinType().isRightOuterJoin()) &#123;</span><br><span class="line">        propertyInfo.nullableColumns.union(leftChildColumns);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getJoinType().isFullOuterJoin()) &#123;</span><br><span class="line">        propertyInfo.nullableColumns.union(leftChildColumns);</span><br><span class="line">        propertyInfo.nullableColumns.union(rightChildColumns);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getJoinType().isInnerJoin()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; leftOnPredicateColumns.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftColumn</span> <span class="operator">=</span> leftOnPredicateColumns.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightColumn</span> <span class="operator">=</span> rightOnPredicateColumns.get(i);</span><br><span class="line">            propertyInfo.addJoinEquivalentPair(leftColumn, rightColumn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> physicalPropertySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BRANCH-0-BROADCAST"><a href="#BRANCH-0-BROADCAST" class="headerlink" title="BRANCH-0: BROADCAST"></a>BRANCH-0: BROADCAST</h3><p>TODO: computeHashJoinDistributionPropertyInfo 函数左右传入的都是空集？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PhysicalPropertySet <span class="title function_">visitPhysicalJoin</span><span class="params">(PhysicalJoinOperator node, ExpressionContext context)</span> &#123;</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">leftChildOutputProperty</span> <span class="operator">=</span> childrenOutputProperties.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">rightChildOutputProperty</span> <span class="operator">=</span> childrenOutputProperties.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Distribution is broadcast</span></span><br><span class="line">    <span class="keyword">if</span> (rightChildOutputProperty.getDistributionProperty().isBroadcast()) &#123;</span><br><span class="line">        <span class="keyword">return</span> computeHashJoinDistributionPropertyInfo(</span><br><span class="line">            node,</span><br><span class="line">            leftChildOutputProperty,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BRANCH-1-ColocateJoin-1"><a href="#BRANCH-1-ColocateJoin-1" class="headerlink" title="BRANCH-1:ColocateJoin"></a>BRANCH-1:ColocateJoin</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftDistributionDesc.isLocal() &amp;&amp; rightDistributionDesc.isLocal()) &#123;</span><br><span class="line">    <span class="comment">// colocate join</span></span><br><span class="line">    <span class="keyword">return</span> computeHashJoinDistributionPropertyInfo(node,</span><br><span class="line">            computeColocateJoinOutputProperty(leftDistributionSpec, rightDistributionSpec),</span><br><span class="line">            leftOnPredicateColumns,</span><br><span class="line">            rightOnPredicateColumns, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BRNACH-2-BucketShuffleJoin"><a href="#BRNACH-2-BucketShuffleJoin" class="headerlink" title="BRNACH-2: BucketShuffleJoin"></a>BRNACH-2: BucketShuffleJoin</h3><p>leftChildOutputProperty 直接设置。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftDistributionDesc.isLocal() &amp;&amp; rightDistributionDesc.isBucketJoin()) &#123;</span><br><span class="line">    <span class="comment">// bucket join</span></span><br><span class="line">    <span class="keyword">return</span> computeHashJoinDistributionPropertyInfo(node,</span><br><span class="line">            leftChildOutputProperty,</span><br><span class="line">            leftOnPredicateColumns,</span><br><span class="line">            rightOnPredicateColumns,</span><br><span class="line">            context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="BRNACH-3-Shufflejoin"><a href="#BRNACH-3-Shufflejoin" class="headerlink" title="BRNACH-3: Shufflejoin"></a>BRNACH-3: Shufflejoin</h3><p>左右输入数据源都是 Shuffle（SourceType.SHUFFLE_AGG、SourceType.SHUFFLE_JOIN）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((leftDistributionDesc.isShuffle() || leftDistributionDesc.isShuffleEnforce()) &amp;&amp;</span><br><span class="line">    (rightDistributionDesc.isShuffle()) || rightDistributionDesc.isShuffleEnforce()) &#123;</span><br><span class="line">    <span class="comment">// shuffle join</span></span><br><span class="line">    <span class="keyword">return</span> computeHashJoinDistributionPropertyInfo(node,</span><br><span class="line">            computeShuffleJoinOutputProperty(leftDistributionDesc.getColumns()),</span><br><span class="line">            leftOnPredicateColumns,</span><br><span class="line">            rightOnPredicateColumns, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="computeShuffleJoinOutputProperty"><a href="#computeShuffleJoinOutputProperty" class="headerlink" title="computeShuffleJoinOutputProperty"></a>computeShuffleJoinOutputProperty</h4><p>基于左侧的 shuffle 列创建输出属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PhysicalPropertySet <span class="title function_">computeShuffleJoinOutputProperty</span><span class="params">(List&lt;Integer&gt; leftShuffleColumns)</span> &#123;</span><br><span class="line">    Optional&lt;HashDistributionDesc&gt; requiredShuffleDesc = getRequiredShuffleDesc();</span><br><span class="line">    <span class="keyword">if</span> (!requiredShuffleDesc.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> PhysicalPropertySet.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">HashDistributionSpec</span> <span class="variable">leftShuffleDistribution</span> <span class="operator">=</span> DistributionSpec.createHashDistributionSpec(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashDistributionDesc</span>(leftShuffleColumns, HashDistributionDesc.SourceType.SHUFFLE_JOIN));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createPropertySetByDistribution(leftShuffleDistribution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="getRequiredShuffleDesc"><a href="#getRequiredShuffleDesc" class="headerlink" title="getRequiredShuffleDesc"></a>getRequiredShuffleDesc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Optional&lt;HashDistributionDesc&gt; <span class="title function_">getRequiredShuffleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!requirements.getDistributionProperty().isShuffle()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">HashDistributionDesc</span> <span class="variable">requireDistributionDesc</span> <span class="operator">=</span> ((HashDistributionSpec)</span><br><span class="line">         requirements.getDistributionProperty().getSpec()).getHashDistributionDesc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HashDistributionDesc.SourceType.SHUFFLE_JOIN.equals(requireDistributionDesc.getSourceType()) ||</span><br><span class="line">        HashDistributionDesc.SourceType.SHUFFLE_AGG.equals(requireDistributionDesc.getSourceType())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(requireDistributionDesc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#PhysicalProperty"><span class="toc-number">1.</span> <span class="toc-text">PhysicalProperty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TaskContext"><span class="toc-number">2.</span> <span class="toc-text">TaskContext</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RequiredPropertyDeriver"><span class="toc-number">3.</span> <span class="toc-text">RequiredPropertyDeriver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#visitOperator"><span class="toc-number">3.1.</span> <span class="toc-text">visitOperator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#visitPhysicalHashJoin"><span class="toc-number">3.2.</span> <span class="toc-text">visitPhysicalHashJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertyDeriverBase-computeShuffleJoinRequiredProperties"><span class="toc-number">3.2.1.</span> <span class="toc-text">PropertyDeriverBase.computeShuffleJoinRequiredProperties</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertyDeriverBase-getShuffleJoinHashDistributionDesc"><span class="toc-number">3.2.2.</span> <span class="toc-text">PropertyDeriverBase.getShuffleJoinHashDistributionDesc</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PropertyDeriverBase-createShuffleJoinRequiredProperties"><span class="toc-number">3.2.3.</span> <span class="toc-text">PropertyDeriverBase.createShuffleJoinRequiredProperties</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EnforceAndCostTask"><span class="toc-number">4.</span> <span class="toc-text">EnforceAndCostTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#initRequiredProperties"><span class="toc-number">4.1.</span> <span class="toc-text">initRequiredProperties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#optimizeChildGroup"><span class="toc-number">4.2.</span> <span class="toc-text">optimizeChildGroup</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OutputPropertyDeriver"><span class="toc-number">5.</span> <span class="toc-text">OutputPropertyDeriver</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OutputPropertyDeriver-visitPhysicalOlapScan"><span class="toc-number">5.1.</span> <span class="toc-text">OutputPropertyDeriver.visitPhysicalOlapScan</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EnforceAndCostTask-recordCostsAndEnforce"><span class="toc-number">5.2.</span> <span class="toc-text">EnforceAndCostTask.recordCostsAndEnforce</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EnforceAndCostTask-setSatisfiedPropertyWithCost"><span class="toc-number">5.2.1.</span> <span class="toc-text">EnforceAndCostTask.setSatisfiedPropertyWithCost</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EnforceAndCostTask-setPropertyWithCost"><span class="toc-number">5.2.2.</span> <span class="toc-text">EnforceAndCostTask.setPropertyWithCost</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GroupExpression-updatePropertyWithCost"><span class="toc-number">5.2.3.</span> <span class="toc-text">GroupExpression.updatePropertyWithCost</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#GroupExpression-setOutputPropertySatisfyRequiredProperty"><span class="toc-number">5.2.4.</span> <span class="toc-text">GroupExpression.setOutputPropertySatisfyRequiredProperty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Group-setBestExpression"><span class="toc-number">5.2.5.</span> <span class="toc-text">Group.setBestExpression</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EnforceAndCostTask-enforceDistribute"><span class="toc-number">5.3.</span> <span class="toc-text">EnforceAndCostTask.enforceDistribute</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DistributionProperty-appendEnforcers"><span class="toc-number">5.3.1.</span> <span class="toc-text">DistributionProperty.appendEnforcers</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EnforceAndCostTask-updateCostWithEnforcer"><span class="toc-number">5.3.2.</span> <span class="toc-text">EnforceAndCostTask.updateCostWithEnforcer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Memo-insertEnforceExpression"><span class="toc-number">5.3.3.</span> <span class="toc-text">Memo.insertEnforceExpression</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChildOutputPropertyGuarantor"><span class="toc-number">6.</span> <span class="toc-text">ChildOutputPropertyGuarantor</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EnforceAndCostTask-execute"><span class="toc-number">6.1.</span> <span class="toc-text">EnforceAndCostTask.execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enforceLegalChildOutputProperty"><span class="toc-number">6.2.</span> <span class="toc-text">enforceLegalChildOutputProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#visitPhysicalJoin"><span class="toc-number">6.3.</span> <span class="toc-text">visitPhysicalJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BRANCH-0-BroadcastJoin"><span class="toc-number">6.3.1.</span> <span class="toc-text">BRANCH-0: BroadcastJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BRANCH-1-ColocateJoin"><span class="toc-number">6.3.2.</span> <span class="toc-text">BRANCH-1: ColocateJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BRANCH-2-BucketShuffleJoin"><span class="toc-number">6.3.3.</span> <span class="toc-text">BRANCH-2: BucketShuffleJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#transToBucketShuffleJoin"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">transToBucketShuffleJoin</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BRANCH-3-ShuffleJoin"><span class="toc-number">6.3.4.</span> <span class="toc-text">BRANCH-3: ShuffleJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enforceChildSatisfyShuffleJoin"><span class="toc-number">6.3.5.</span> <span class="toc-text">enforceChildSatisfyShuffleJoin</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enforceChildShuffleDistribution"><span class="toc-number">6.3.6.</span> <span class="toc-text">enforceChildShuffleDistribution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enforceChildDistribution"><span class="toc-number">6.3.7.</span> <span class="toc-text">enforceChildDistribution</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#updateChildCostWithEnforcer"><span class="toc-number">6.3.8.</span> <span class="toc-text">updateChildCostWithEnforcer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OutputPropertyDeriver-visitPhysicalJoin"><span class="toc-number">7.</span> <span class="toc-text">OutputPropertyDeriver.visitPhysicalJoin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#computeHashJoinDistributionPropertyInfo"><span class="toc-number">7.1.</span> <span class="toc-text">computeHashJoinDistributionPropertyInfo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRANCH-0-BROADCAST"><span class="toc-number">7.2.</span> <span class="toc-text">BRANCH-0: BROADCAST</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRANCH-1-ColocateJoin-1"><span class="toc-number">7.3.</span> <span class="toc-text">BRANCH-1:ColocateJoin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRNACH-2-BucketShuffleJoin"><span class="toc-number">7.4.</span> <span class="toc-text">BRNACH-2: BucketShuffleJoin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BRNACH-3-Shufflejoin"><span class="toc-number">7.5.</span> <span class="toc-text">BRNACH-3: Shufflejoin</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#computeShuffleJoinOutputProperty"><span class="toc-number">7.5.1.</span> <span class="toc-text">computeShuffleJoinOutputProperty</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getRequiredShuffleDesc"><span class="toc-number">7.5.2.</span> <span class="toc-text">getRequiredShuffleDesc</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&text=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&title=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&is_video=false&description=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=CBO: EnforceAndCostTask 寻找成本最低路径&body=Check out this article: https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&title=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&title=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&title=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&title=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&name=CBO: EnforceAndCostTask 寻找成本最低路径&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/&t=CBO: EnforceAndCostTask 寻找成本最低路径"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
