<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="PlanFragmentBuilder 将 PhysicalPlan 转化为 ExecPlan 后得到一堆 Fragments，需要在 Coordinator 中将 Fragment 实例化为 FragmentInstance，设置具体的执行计划与 BE 节点参数。 computeScanRangeAssignment computeFragmentHostscomputeFragmentHost">
<meta property="og:type" content="article">
<meta property="og:title" content="Coordinator: ExexPlan 的实例化">
<meta property="og:url" content="https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="PlanFragmentBuilder 将 PhysicalPlan 转化为 ExecPlan 后得到一堆 Fragments，需要在 Coordinator 中将 Fragment 实例化为 FragmentInstance，设置具体的执行计划与 BE 节点参数。 computeScanRangeAssignment computeFragmentHostscomputeFragmentHost">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/BackendSelector.svg?raw=true">
<meta property="article:published_time" content="2023-10-01T02:00:01.000Z">
<meta property="article:modified_time" content="2023-10-30T08:50:20.874Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="StarRocks">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/BackendSelector.svg?raw=true">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>Coordinator: ExexPlan 的实例化</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2023/10/03/StarRocks/CBO/PlanFragment/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2023/08/29/StarRocks/Pipeline/FragmentInstance/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&text=Coordinator: ExexPlan 的实例化"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&title=Coordinator: ExexPlan 的实例化"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&is_video=false&description=Coordinator: ExexPlan 的实例化"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Coordinator: ExexPlan 的实例化&body=Check out this article: https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&title=Coordinator: ExexPlan 的实例化"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&title=Coordinator: ExexPlan 的实例化"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&title=Coordinator: ExexPlan 的实例化"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&title=Coordinator: ExexPlan 的实例化"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&name=Coordinator: ExexPlan 的实例化&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&t=Coordinator: ExexPlan 的实例化"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#computeScanRangeAssignment"><span class="toc-number">1.</span> <span class="toc-text">computeScanRangeAssignment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computeFragmentHosts"><span class="toc-number">2.</span> <span class="toc-text">computeFragmentHosts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataPartition-UNPARTITIONED"><span class="toc-number">2.1.</span> <span class="toc-text">DataPartition.UNPARTITIONED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExchangeNode"><span class="toc-number">2.2.</span> <span class="toc-text">ExchangeNode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#T1-maxParallelism"><span class="toc-number">2.2.1.</span> <span class="toc-text">T1 maxParallelism</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T2-hostSet"><span class="toc-number">2.2.2.</span> <span class="toc-text">T2. hostSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T3-params-instanceExecParams"><span class="toc-number">2.2.3.</span> <span class="toc-text">T3 params.instanceExecParams</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OlapScanNode"><span class="toc-number">2.3.</span> <span class="toc-text">OlapScanNode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#computeColocatedJoinInstanceParam"><span class="toc-number">2.3.1.</span> <span class="toc-text">computeColocatedJoinInstanceParam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ShuffleJOIN"><span class="toc-number">2.3.2.</span> <span class="toc-text">ShuffleJOIN</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computeFragmentExecParams"><span class="toc-number">3.</span> <span class="toc-text">computeFragmentExecParams</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TUniqueId"><span class="toc-number">3.1.</span> <span class="toc-text">TUniqueId</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#params-instanceExecParams"><span class="toc-number">3.2.</span> <span class="toc-text">params.instanceExecParams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#params-destinations"><span class="toc-number">3.3.</span> <span class="toc-text">params.destinations</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Coordinator: ExexPlan 的实例化
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2023-10-01T02:00:01.000Z" itemprop="datePublished">2023-10-01</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fas fa-archive"></i>
        <a class="category-link" href="/categories/CBO/">CBO</a>
    </div>


      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/StarRocks/" rel="tag">StarRocks</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>PlanFragmentBuilder 将 PhysicalPlan 转化为 ExecPlan 后得到一堆 Fragments，需要在 Coordinator 中将 Fragment 实例化为 FragmentInstance，设置具体的执行计划与 BE 节点参数。</p>
<h2 id="computeScanRangeAssignment"><a href="#computeScanRangeAssignment" class="headerlink" title="computeScanRangeAssignment"></a>computeScanRangeAssignment</h2><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/BackendSelector.svg?raw=true" alt="BackendSelector"></p>
<h2 id="computeFragmentHosts"><a href="#computeFragmentHosts" class="headerlink" title="computeFragmentHosts"></a>computeFragmentHosts</h2><p>computeFragmentHosts 函数是为每个 Fragment 分配运行的 BE 节点。Fragment 的 root_node 要么是 ExchangeNode，要么是 OlapScanNode，具体还要设置一些信息。</p>
<p>computeFragmentHosts 是按照从 childFragment（叶结点） 到 rootFragment（根节点）逆序遍历，这样父节点可以根据子节点选择 BE。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">computeFragmentHosts</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// from children --&gt; parent</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fragments.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">PlanFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> fragments.get(i);</span><br><span class="line">        <span class="type">FragmentExecParams</span> <span class="variable">params</span> <span class="operator">=</span> </span><br><span class="line">            fragmentExecParamsMap.get(fragment.getFragmentId());</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dopAdaptionEnabled</span> <span class="operator">=</span> usePipeline &amp;&amp;</span><br><span class="line">            connectContext.getSessionVariable().isPipelineDopAdaptionEnabled();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. DataPartition.UNPARTITIONED</span></span><br><span class="line">        <span class="keyword">if</span> (fragment.getDataPartition() == DataPartition.UNPARTITIONED) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. ExchangeNode</span></span><br><span class="line">        <span class="type">PlanNode</span> <span class="variable">leftMostNode</span> <span class="operator">=</span> findLeftmostNode(fragment.getPlanRoot());</span><br><span class="line">        <span class="keyword">if</span> (!(leftMostNode <span class="keyword">instanceof</span> ScanNode)) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. OlapScanNode </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DataPartition-UNPARTITIONED"><a href="#DataPartition-UNPARTITIONED" class="headerlink" title="DataPartition.UNPARTITIONED"></a>DataPartition.UNPARTITIONED</h3><p>当 fragment 的 DataSink 分区方式是 DataPartition.UNPARTITIONED 时，表示将数据全部输出到 destinations，此时为这个 Fragment 选择在哪个BE节点执行时，通过 SimpleScheduler.getBackendHost 方法从 BE节点中选择一个。</p>
<blockquote>
<p>Sink 分区方式是 DataPartition.UNPARTITIONED，应该只有 BROADCAST-JOIN 和 ResultSink 等几种，为啥这里不需要考虑输入，随机选择一个 BE节点去执行 ?</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fragment.getDataPartition() == DataPartition.UNPARTITIONED) &#123;</span><br><span class="line">    Reference&lt;Long&gt; backendIdRef = <span class="keyword">new</span> <span class="title class_">Reference</span>&lt;&gt;();</span><br><span class="line">    TNetworkAddress execHostport;</span><br><span class="line">    <span class="keyword">if</span> (usedComputeNode) &#123;</span><br><span class="line">        execHostport = SimpleScheduler.getComputeNodeHost(</span><br><span class="line">            <span class="built_in">this</span>.idToComputeNode, backendIdRef);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        execHostport = SimpleScheduler.getBackendHost(</span><br><span class="line">            <span class="built_in">this</span>.idToBackend, backendIdRef);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (execHostport == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserException</span>(</span><br><span class="line">            <span class="string">&quot;Backend not found. Check if any backend is down or not. &quot;</span> + </span><br><span class="line">            backendInfosString(usedComputeNode));</span><br><span class="line">    &#125;</span><br><span class="line">    recordUsedBackend(execHostport, backendIdRef.getRef());</span><br><span class="line">    <span class="type">FInstanceExecParam</span> <span class="variable">instanceParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FInstanceExecParam</span>(</span><br><span class="line">                <span class="literal">null</span>, execHostport, <span class="number">0</span>, params);</span><br><span class="line">    params.instanceExecParams.add(instanceParam);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ExchangeNode"><a href="#ExchangeNode" class="headerlink" title="ExchangeNode"></a>ExchangeNode</h3><p>当 Fragment 的最左叶结点是 ExchangeNode 时，将当前 Fragment 执行节点设置为其 InputFragments 中 instance_num 最大的 inputFragment 所处的 BE 节点上。这样在 BE 端在 ragmentInstacne 之间 RPC 通信时，可以减少跨进行通信。主要有如下三步:</p>
<h4 id="T1-maxParallelism"><a href="#T1-maxParallelism" class="headerlink" title="T1 maxParallelism"></a>T1 maxParallelism</h4><p>寻找 InputFragments 中最大并行度 (maxParallelism) 的位置 (inputFragmentIndex)</p>
<p>currentChildFragmentParallelism 初始值是 instanceExecParams 的值，在 dopAdaptionEnabled 为 true 时（即 Fragment 的所有 Operator 都能 decompose_to_pipeline，目前应该所有的算子都支持了），currentChildFragmentParallelism 的真实 dop 需要考虑 fragment.pipelineDop。</p>
<p>开启 pipeline 时 numInstances * pipelineDop 的值等于开启 Pipeline 时的 numInstances 值，即总得并行度并不没有改变，只是之前没有 pipeline 时，并行度靠的是多个 Fragments 并行执行，现在开启 Pipeline 后，在一个 Fragment 中 dop 个线程去并发执行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">inputFragmentIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxParallelism</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; fragment.getChildren().size(); j++) &#123;</span><br><span class="line">    <span class="type">PlanFragment</span> <span class="variable">inputFragment</span> <span class="operator">=</span>fragment.getChild(j); </span><br><span class="line">    <span class="type">int</span> <span class="variable">currentChildFragmentParallelism</span> <span class="operator">=</span> fragmentExecParamsMap</span><br><span class="line">            .get(inputFragment.getFragmentId())</span><br><span class="line">            .instanceExecParams</span><br><span class="line">            .size();</span><br><span class="line">    <span class="keyword">if</span> (dopAdaptionEnabled) &#123;</span><br><span class="line">        currentChildFragmentParallelism *= </span><br><span class="line">            inputFragment.getPipelineDop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentChildFragmentParallelism &gt; maxParallelism) &#123;</span><br><span class="line">        maxParallelism = currentChildFragmentParallelism;</span><br><span class="line">        inputFragmentIndex = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="T2-hostSet"><a href="#T2-hostSet" class="headerlink" title="T2. hostSet"></a>T2. hostSet</h4><p>计算 inputFragmentIndex 所处的 BE 集合 hostSet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PlanFragmentId</span> <span class="variable">inputFragmentId</span></span><br><span class="line">    <span class="operator">=</span> fragment.getChild(inputFragmentIndex).getFragmentId();</span><br><span class="line"><span class="type">FragmentExecParams</span> <span class="variable">maxParallelismFragmentExecParams</span> </span><br><span class="line">    <span class="operator">=</span> fragmentExecParamsMap.get(inputFragmentId);</span><br><span class="line">Set&lt;TNetworkAddress&gt; hostSet = Sets.newHashSet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usedComputeNode) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnionFragment(fragment) &amp;&amp; isGatherOutput) &#123;</span><br><span class="line">        <span class="comment">// union fragment use all children&#x27;s host</span></span><br><span class="line">        <span class="comment">// if output fragment isn&#x27;t gather, all fragment must keep 1 instance</span></span><br><span class="line">        <span class="keyword">for</span> (PlanFragment child : fragment.getChildren()) &#123;</span><br><span class="line">            <span class="type">FragmentExecParams</span> <span class="variable">childParams</span> <span class="operator">=</span> </span><br><span class="line">                fragmentExecParamsMap.get(child.getFragmentId());</span><br><span class="line">            childParams.instanceExecParams</span><br><span class="line">                .stream().map(e -&gt; e.host).forEach(hostSet::add);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//make olapScan maxParallelism equals prefer compute node number</span></span><br><span class="line">        maxParallelism = hostSet.size() * fragment.getParallelExecNum();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (FInstanceExecParam execParams :</span><br><span class="line">                maxParallelismFragmentExecParams.instanceExecParams) &#123;</span><br><span class="line">            hostSet.add(execParams.host);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dopAdaptionEnabled) &#123;</span><br><span class="line">    Preconditions.checkArgument(leftMostNode <span class="keyword">instanceof</span> ExchangeNode);</span><br><span class="line">    maxParallelism = hostSet.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="T3-params-instanceExecParams"><a href="#T3-params-instanceExecParams" class="headerlink" title="T3 params.instanceExecParams"></a>T3 params.instanceExecParams</h4><p>现在需要根据 maxParallelism、parallel_exchange_instance_num 确定当前 PlanFragment 实例化为多少个(dop) FragmentInstance 对象：dop 取为 exchangeInstances（默认值是 4, 可以由 parallel_exchange_instance_num 更改）和子节点最大的并行度是 maxParallelism 中的较小值。</p>
<p>然后从 hostSet 中选出 dop 个 host 来作为每个 FragmentInsance 执行的 BE 节点。每个 FragmentInstance 的执行参数由 FInstanceExecParam 对象记录，params.instanceExecParams 的大小就是 PlanFragment 实例化为 FragmentInstance 的个数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">exchangeInstances</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (connectContext != <span class="literal">null</span> &amp;&amp; connectContext.getSessionVariable() != <span class="literal">null</span>) &#123;</span><br><span class="line">    exchangeInstances = </span><br><span class="line">        connectContext.getSessionVariable().getExchangeInstanceParallel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exchangeInstances &gt; <span class="number">0</span> &amp;&amp; maxParallelism &gt; exchangeInstances) &#123;</span><br><span class="line">    List&lt;TNetworkAddress&gt; hosts = Lists.newArrayList(hostSet);</span><br><span class="line">    Collections.shuffle(hosts, random);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; exchangeInstances; index++) &#123;</span><br><span class="line">        <span class="type">TNetworkAddress</span> <span class="variable">host</span> <span class="operator">=</span> hosts.get(index % hosts.size());</span><br><span class="line">        <span class="type">FInstanceExecParam</span> <span class="variable">instanceParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FInstanceExecParam</span>(</span><br><span class="line">            <span class="literal">null</span>, host, <span class="number">0</span>, params);</span><br><span class="line">        params.instanceExecParams.add(instanceParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    List&lt;TNetworkAddress&gt; hosts = Lists.newArrayList(hostSet);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; maxParallelism; ++index) &#123;</span><br><span class="line">        <span class="type">TNetworkAddress</span> <span class="variable">host</span> <span class="operator">=</span> hosts.get(index % hosts.size());</span><br><span class="line">        <span class="type">FInstanceExecParam</span> <span class="variable">instanceParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FInstanceExecParam</span>(</span><br><span class="line">            <span class="literal">null</span>, host, <span class="number">0</span>, params);</span><br><span class="line">        params.instanceExecParams.add(instanceParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collections.shuffle(params.instanceExecParams, random);</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<h3 id="OlapScanNode"><a href="#OlapScanNode" class="headerlink" title="OlapScanNode"></a>OlapScanNode</h3><p>以 ExchangeNode 为 Souce 的 Fragment 的执行节点依赖于其 InputFragment 的 HostSet，最终依赖的都是以 OlapScanNode 为 Source 的 leftFragment。</p>
<p>由于 ColocateJOIN 和 BucketShuffleJOIN Fragment 的最左侧节点 leftMostNode 也是 OlapSacnNode，因此对于这种情况需要特殊处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">parallelExecInstanceNum</span> <span class="operator">=</span> fragment.getParallelExecNum();</span><br><span class="line"><span class="type">int</span> <span class="variable">pipelineDop</span> <span class="operator">=</span> fragment.getPipelineDop();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasColocate</span> <span class="operator">=</span> </span><br><span class="line">    isColocateFragment(fragment.getPlanRoot()) &amp;&amp;</span><br><span class="line">    fragmentIdToSeqToAddressMap.containsKey(fragment.getFragmentId()) &amp;&amp; </span><br><span class="line">    fragmentIdToSeqToAddressMap.get(fragment.getFragmentId()).size() &gt; <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasBucketShuffle</span> <span class="operator">=</span> isBucketShuffleJoin(fragment.getFragmentId().asInt());</span><br><span class="line"><span class="keyword">if</span> (hasColocate || hasBucketShuffle) &#123;</span><br><span class="line">    computeColocatedJoinInstanceParam(</span><br><span class="line">        fragmentIdToSeqToAddressMap.get(fragment.getFragmentId()),</span><br><span class="line">        fragmentIdBucketSeqToScanRangeMap.get(fragment.getFragmentId()),</span><br><span class="line">        parallelExecInstanceNum, pipelineDop, usePipeline, params);</span><br><span class="line">    computeBucketSeq2InstanceOrdinal(</span><br><span class="line">        params, fragmentIdToBucketNumMap.get(fragment.getFragmentId()));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="computeColocatedJoinInstanceParam"><a href="#computeColocatedJoinInstanceParam" class="headerlink" title="computeColocatedJoinInstanceParam"></a>computeColocatedJoinInstanceParam</h4><ol>
<li><p>计算出每个 BE 节点上所有需要读取的 Tablet<br> 这是将所有待读取的 bucket 按照 BE 节点进行分类（即每个 BE 节点需要读取的 Tablets）存储于 addressToScanRanges。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">auto</span> <span class="variable">addressToScanRanges</span> <span class="operator">=</span> Maps.newHashMap();</span><br><span class="line"><span class="keyword">for</span> (auto bucketSeqAndScanRanges : bucketSeqToScanRange.entrySet()) &#123;</span><br><span class="line">  <span class="type">TNetworkAddress</span> <span class="variable">address</span> <span class="operator">=</span> </span><br><span class="line">      bucketSeqToAddress.get(bucketSeqAndScanRanges.getKey());</span><br><span class="line">  addressToScanRanges</span><br><span class="line">      .computeIfAbsent(address, k -&gt; Lists.newArrayList())</span><br><span class="line">      .add(bucketSeqAndScanRanges);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>每个节点上都有个 expectedInstanceNum，均分 addressToScanRange，使得每个 FragmentInstance 读取的 tablets 即 scanRangePerInstance</p>
<p> 开启了 pipeline 时，parallelExecInstanceNum 总是为 1，即只有一个 FragmentInstance 去执行 OlapScan，因此 scanRangesPerInstance 的大小还是 1。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (auto addressScanRange : addressToScanRanges.entrySet()) &#123;</span><br><span class="line">    <span class="type">auto</span> <span class="variable">scanRange</span> <span class="operator">=</span> addressScanRange.getValue();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedInstanceNum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelExecInstanceNum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        expectedInstanceNum = </span><br><span class="line">            Math.min(scanRange.size(), parallelExecInstanceNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. split how many scanRange one instance should scan</span></span><br><span class="line">    <span class="type">auto</span> <span class="variable">scanRangesPerInstance</span> <span class="operator">=</span> </span><br><span class="line">        ListUtil.splitBySize(scanRange, expectedInstanceNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.construct instanceExecParam add the scanRange should be scan by instance</span></span><br><span class="line">    <span class="keyword">for</span> (auto scanRangePerInstance : scanRangesPerInstance) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>enableAssignScanRangesPerDriverSeq</p>
<p>预设的 pipelineDop（即 fragment.pipelineDop）默认值是 CPU 核心数的一半，真实的并行度 expectedDop 取值为 scanRangePerInstance 和 pipelineDop 的最小值，再将 scanRangePerInstance 按照 expectedDop 均分，确保每个线程读取的 scanRange 尽可能均衡读取，数据不至于倾斜太多。</p>
<p><strong>enableAssignScanRangesPerDriverSeq</strong> 函数用于确定是否直接为每个 PipelineDriver 赋值对应的 Bucket 去读取，这样可以避免 LocalShuffle（即不用计算从 bucket 中读取的数据该发送到哪个 PipelineDriver）。只有当每个 BE 节点上的 scanRanges 都不小于 pipelineDop &#x2F; 2 时，才该函数才会返回 true（也就是数据量较大时才会开启）。assignPerDriverSeq 为 true 时，下面两个对象生效：</p>
<ul>
<li><p>bucketSeqToDriverSeq: 记录每个 bucket 对应的 PipelineDriver</p>
</li>
<li><p>nodeToPerDriverSeqScanRanges 映射关系是 {scanId, driverSeq, scanRange}</p>
<p>一个 scanId 对应一个 OlapScanNode，将多个 OlapScanNode 要读取的scanRangePerInstance 就被划分为 expectedDop 份，每个 PipelineDriver 对应一个 Tablet 的 scanRange。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">boolean</span> <span class="variable">assignPerDriverSeq</span> <span class="operator">=</span> </span><br><span class="line">     enablePipeline &amp;&amp; </span><br><span class="line">     addressToScanRanges.values().stream().allMatch(scanRanges -&gt; </span><br><span class="line">         enableAssignScanRangesPerDriverSeq(scanRanges, pipelineDop));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (auto scanRangePerInstance : scanRangesPerInstance) &#123;</span><br><span class="line">   <span class="type">FInstanceExecParam</span> <span class="variable">instanceParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FInstanceExecParam</span>(</span><br><span class="line">             <span class="literal">null</span>, addressScanRange.getKey(), <span class="number">0</span>, params);</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="variable">expectedDop</span> <span class="operator">=</span> Math.min(scanRangePerInstance.size(), pipelineDop);</span><br><span class="line">   <span class="type">auto</span> <span class="variable">scanRangesPerDriverSeq</span> <span class="operator">=</span> </span><br><span class="line">          ListUtil.splitBySize(scanRangePerInstance, expectedDop);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 并行度比较高时</span></span><br><span class="line">   <span class="keyword">if</span> (assignPerDriverSeq) &#123;</span><br><span class="line">       instanceParam.pipelineDop = scanRangesPerDriverSeq.size();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 针对每个 PipelineDriver</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">driverSeq</span> <span class="operator">=</span> <span class="number">0</span>; driverSeq &lt; scanRangesPerDriverSeq.size(); ++driverSeq) &#123;</span><br><span class="line">     scanRangesPerDriverSeq.get(driverSeq).forEach(bucketSeqAndScanRanges -&gt; </span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (assignPerDriverSeq) &#123;</span><br><span class="line">            <span class="comment">// bucketSeqAndScanRanges 记录了每个 bucket 对应的 PiplineDriver</span></span><br><span class="line">            instanceParam.bucketSeqToDriverSeq.putIfAbsent(</span><br><span class="line">                bucketSeqAndScanRanges.getKey(), driverSeq);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            instanceParam.bucketSeqToDriverSeq.putIfAbsent(</span><br><span class="line">                bucketSeqAndScanRanges.getKey(), -<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         bucketSeqAndScanRanges.getValue().forEach((scanId, scanRanges) -&gt; &#123;</span><br><span class="line">           <span class="comment">// 记录了每个 OlapScanNode 细分到每个 PipelineDriver 需要读取的 scanRange</span></span><br><span class="line">           <span class="keyword">if</span> (assignPerDriverSeq) &#123;</span><br><span class="line">              instanceParam.nodeToPerDriverSeqScanRanges</span><br><span class="line">                 .computeIfAbsent(scanId, k -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;())</span><br><span class="line">                 .computeIfAbsent(driverSeq, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">                 .addAll(scanRanges);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             instanceParam.perNodeScanRanges</span><br><span class="line">                 .computeIfAbsent(scanId, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">                 .addAll(scanRanges);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (assignPerDriverSeq) &#123;</span><br><span class="line">     instanceParam.nodeToPerDriverSeqScanRanges.forEach((scanId, perDriverSeqScanRanges) -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">driverSeq</span> <span class="operator">=</span> <span class="number">0</span>; driverSeq &lt; instanceParam.pipelineDop; ++driverSeq) &#123;</span><br><span class="line">         perDriverSeqScanRanges.computeIfAbsent(driverSeq, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   params.instanceExecParams.add(instanceParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="ShuffleJOIN"><a href="#ShuffleJOIN" class="headerlink" title="ShuffleJOIN"></a>ShuffleJOIN</h4><p>和上面的逻辑差不多，区别：这里一个 OlapScanNode 对应一个 FragmentInstance</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">assignScanRangesPerDriverSeq</span> <span class="operator">=</span> </span><br><span class="line">       usePipeline &amp;&amp;</span><br><span class="line">      (fragment.isAssignScanRangesPerDriverSeq() || </span><br><span class="line">       fragment.isForceAssignScanRangesPerDriverSeq());</span><br><span class="line"><span class="type">auto</span> <span class="variable">scanRangeAssignment</span> <span class="operator">=</span> </span><br><span class="line">   fragmentExecParamsMap.get(fragment.getFragmentId()).scanRangeAssignment;</span><br><span class="line"><span class="keyword">for</span> (auto tNetworkAddressMapEntry : scanRangeAssignment.entrySet()) &#123;</span><br><span class="line">  <span class="type">TNetworkAddress</span> <span class="variable">host</span> <span class="operator">=</span> tNetworkAddressMapEntry.getKey();</span><br><span class="line">  Map&lt;Integer, List&lt;TScanRangeParams&gt;&gt; NodeAndScanRanges =</span><br><span class="line">     tNetworkAddressMapEntry.getValue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. Handle normal scan node firstly</span></span><br><span class="line">  <span class="keyword">for</span> (Integer planNodeId : NodeAndScanRanges.keySet()) &#123;</span><br><span class="line">    List&lt;TScanRangeParams&gt; perNodeScanRanges = NodeAndScanRanges.get(planNodeId);</span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedInstanceNum</span> <span class="operator">=</span> </span><br><span class="line">       Math.min(perNodeScanRanges.size(), parallelExecInstanceNum);</span><br><span class="line">    <span class="type">auto</span> <span class="variable">perInstanceScanRanges</span> <span class="operator">=</span> </span><br><span class="line">       ListUtil.splitBySize(perNodeScanRanges, expectedInstanceNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;TScanRangeParams&gt; scanRangeParams : perInstanceScanRanges) &#123;</span><br><span class="line">        <span class="type">FInstanceExecParam</span> <span class="variable">instanceParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FInstanceExecParam</span>(</span><br><span class="line">             <span class="literal">null</span>, host, <span class="number">0</span>, params);</span><br><span class="line">        params.instanceExecParams.add(instanceParam);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">assignPerDriverSeq</span> <span class="operator">=</span> </span><br><span class="line">          assignScanRangesPerDriverSeq &amp;&amp;</span><br><span class="line">          (enableAssignScanRangesPerDriverSeq(scanRangeParams, pipelineDop) || </span><br><span class="line">           fragment.isForceAssignScanRangesPerDriverSeq());</span><br><span class="line">        <span class="keyword">if</span> (!assignPerDriverSeq) &#123;</span><br><span class="line">          instanceParam.perNodeScanRanges.put(planNodeId, scanRangeParams);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 消除 localShuffle</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">expectedDop</span> <span class="operator">=</span> Math.max(</span><br><span class="line">               <span class="number">1</span>, Math.min(pipelineDop, scanRangeParams.size()));</span><br><span class="line">          List&lt;List&lt;TScanRangeParams&gt;&gt; scanRangeParamsPerDriverSeq =</span><br><span class="line">                ListUtil.splitBySize(scanRangeParams, expectedDop);</span><br><span class="line">          instanceParam.pipelineDop = scanRangeParamsPerDriverSeq.size();</span><br><span class="line">          Map&lt;Integer, List&lt;TScanRangeParams&gt;&gt; scanRangesPerDriverSeq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">          instanceParam.nodeToPerDriverSeqScanRanges.put(</span><br><span class="line">                 planNodeId, scanRangesPerDriverSeq);</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">driverSeq</span> <span class="operator">=</span> <span class="number">0</span>; driverSeq &lt; instanceParam.pipelineDop; ++driverSeq) &#123;</span><br><span class="line">                scanRangesPerDriverSeq.put(</span><br><span class="line">                   driverSeq, scanRangeParamsPerDriverSeq.get(driverSeq));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="computeFragmentExecParams"><a href="#computeFragmentExecParams" class="headerlink" title="computeFragmentExecParams"></a>computeFragmentExecParams</h2><h3 id="TUniqueId"><a href="#TUniqueId" class="headerlink" title="TUniqueId"></a>TUniqueId</h3><p>生成 TUniqueId</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">instanceIds.clear();</span><br><span class="line"><span class="keyword">for</span> (FragmentExecParams params : fragmentExecParamsMap.values()) &#123;</span><br><span class="line">   <span class="keyword">if</span> (params.fragment.getSink() <span class="keyword">instanceof</span> ResultSink &amp;&amp; </span><br><span class="line">       params.instanceExecParams.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StarRocksPlannerException</span>(</span><br><span class="line">            <span class="string">&quot;This sql plan has multi result sinks&quot;</span>,</span><br><span class="line">            ErrorType.INTERNAL_ERROR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; params.instanceExecParams.size(); ++j) &#123;</span><br><span class="line">       <span class="type">TUniqueId</span> <span class="variable">instanceId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TUniqueId</span>();</span><br><span class="line">       instanceId.setHi(queryId.hi);</span><br><span class="line">       instanceId.setLo(queryId.lo + instanceIds.size() + <span class="number">1</span>);</span><br><span class="line">       params.instanceExecParams.get(j).instanceId = instanceId;</span><br><span class="line">       instanceIds.add(instanceId);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="params-instanceExecParams"><a href="#params-instanceExecParams" class="headerlink" title="params.instanceExecParams"></a>params.instanceExecParams</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (FragmentExecParams params : fragmentExecParamsMap.values()) &#123;</span><br><span class="line">   <span class="keyword">if</span> (params.fragment <span class="keyword">instanceof</span> MultiCastPlanFragment) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (params.fragment.getDestFragment() == <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">PlanFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> params.fragment;</span><br><span class="line">   <span class="type">PlanFragment</span> <span class="variable">destFragment</span> <span class="operator">=</span> fragment.getDestFragment();</span><br><span class="line">   <span class="type">FragmentExecParams</span> <span class="variable">destParams</span> <span class="operator">=</span> </span><br><span class="line">      fragmentExecParamsMap.get(destFragment.getFragmentId());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// set # of senders</span></span><br><span class="line">   fragment.getDestNode().setPartitionType(</span><br><span class="line">        fragment.getOutputPartition().getType());</span><br><span class="line">   <span class="type">DataSink</span> <span class="variable">sink</span> <span class="operator">=</span> fragment.getSink();</span><br><span class="line">   <span class="keyword">if</span> (sink <span class="keyword">instanceof</span> DataStreamSink) &#123;</span><br><span class="line">       <span class="type">DataStreamSink</span> <span class="variable">dataStreamSink</span> <span class="operator">=</span> (DataStreamSink) sink;</span><br><span class="line">       dataStreamSink.setExchDop(destParams.fragment.getPipelineDop());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">PlanNodeId</span> <span class="variable">exchId</span> <span class="operator">=</span> sink.getExchNodeId();</span><br><span class="line">   <span class="keyword">if</span> (destParams.perExchNumSenders.get(exchId.asInt()) == <span class="literal">null</span>) &#123;</span><br><span class="line">       destParams.perExchNumSenders.put(</span><br><span class="line">            exchId.asInt(), params.instanceExecParams.size());</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       destParams.perExchNumSenders.put(exchId.asInt(),</span><br><span class="line">            params.instanceExecParams.size() + </span><br><span class="line">              destParams.perExchNumSenders.get(exchId.asInt()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="params-destinations"><a href="#params-destinations" class="headerlink" title="params.destinations"></a>params.destinations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (needScheduleByShuffleJoin(destFragment.getFragmentId().asInt(), sink)) &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">bucketSeq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">bucketNum</span> <span class="operator">=</span> getFragmentBucketNum(destFragment.getFragmentId());</span><br><span class="line">   <span class="type">TNetworkAddress</span> <span class="variable">dummyServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TNetworkAddress</span>(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (bucketSeq &lt; bucketNum) &#123;</span><br><span class="line">       <span class="type">TPlanFragmentDestination</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TPlanFragmentDestination</span>();</span><br><span class="line">       dest.fragment_instance_id = <span class="keyword">new</span> <span class="title class_">TUniqueId</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">       dest.server = dummyServer;</span><br><span class="line">       dest.setBrpc_server(dummyServer);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (FInstanceExecParam instanceExecParams : destParams.instanceExecParams) &#123;</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">driverSeq</span> <span class="operator">=</span> instanceExecParams.bucketSeqToDriverSeq.get(bucketSeq);</span><br><span class="line">           <span class="keyword">if</span> (driverSeq != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 设置目标 &#123;fragment_instance_id, driverSeq&#125;</span></span><br><span class="line">               dest.fragment_instance_id = instanceExecParams.instanceId;</span><br><span class="line">               dest.server = toRpcHost(instanceExecParams.host);</span><br><span class="line">               dest.setBrpc_server(toBrpcHost(instanceExecParams.host));</span><br><span class="line">               <span class="keyword">if</span> (driverSeq != FInstanceExecParam.ABSENT_DRIVER_SEQUENCE) &#123;</span><br><span class="line">                   dest.setPipeline_driver_sequence(driverSeq);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       bucketSeq++;</span><br><span class="line">       params.destinations.add(dest);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; destParams.instanceExecParams.size(); ++j) &#123;</span><br><span class="line">       <span class="type">TPlanFragmentDestination</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TPlanFragmentDestination</span>();</span><br><span class="line">       dest.fragment_instance_id = destParams.instanceExecParams.get(j).instanceId;</span><br><span class="line">       dest.server = toRpcHost(destParams.instanceExecParams.get(j).host);</span><br><span class="line">       dest.setBrpc_server(toBrpcHost(destParams.instanceExecParams.get(j).host));</span><br><span class="line">       params.destinations.add(dest);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>






  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#computeScanRangeAssignment"><span class="toc-number">1.</span> <span class="toc-text">computeScanRangeAssignment</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computeFragmentHosts"><span class="toc-number">2.</span> <span class="toc-text">computeFragmentHosts</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DataPartition-UNPARTITIONED"><span class="toc-number">2.1.</span> <span class="toc-text">DataPartition.UNPARTITIONED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ExchangeNode"><span class="toc-number">2.2.</span> <span class="toc-text">ExchangeNode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#T1-maxParallelism"><span class="toc-number">2.2.1.</span> <span class="toc-text">T1 maxParallelism</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T2-hostSet"><span class="toc-number">2.2.2.</span> <span class="toc-text">T2. hostSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#T3-params-instanceExecParams"><span class="toc-number">2.2.3.</span> <span class="toc-text">T3 params.instanceExecParams</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OlapScanNode"><span class="toc-number">2.3.</span> <span class="toc-text">OlapScanNode</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#computeColocatedJoinInstanceParam"><span class="toc-number">2.3.1.</span> <span class="toc-text">computeColocatedJoinInstanceParam</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ShuffleJOIN"><span class="toc-number">2.3.2.</span> <span class="toc-text">ShuffleJOIN</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#computeFragmentExecParams"><span class="toc-number">3.</span> <span class="toc-text">computeFragmentExecParams</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TUniqueId"><span class="toc-number">3.1.</span> <span class="toc-text">TUniqueId</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#params-instanceExecParams"><span class="toc-number">3.2.</span> <span class="toc-text">params.instanceExecParams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#params-destinations"><span class="toc-number">3.3.</span> <span class="toc-text">params.destinations</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&text=Coordinator: ExexPlan 的实例化"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&title=Coordinator: ExexPlan 的实例化"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&is_video=false&description=Coordinator: ExexPlan 的实例化"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Coordinator: ExexPlan 的实例化&body=Check out this article: https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&title=Coordinator: ExexPlan 的实例化"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&title=Coordinator: ExexPlan 的实例化"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&title=Coordinator: ExexPlan 的实例化"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&title=Coordinator: ExexPlan 的实例化"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&name=Coordinator: ExexPlan 的实例化&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/&t=Coordinator: ExexPlan 的实例化"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
