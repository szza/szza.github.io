<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>szza</title>
  
  <subtitle>look code art</subtitle>
  <link href="https://szza.github.io/atom.xml" rel="self"/>
  
  <link href="https://szza.github.io/"/>
  <updated>2023-08-07T09:17:10.228Z</updated>
  <id>https://szza.github.io/</id>
  
  <author>
    <name>fibonaccii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Overview: StarRocks Pipeline Query Executor</title>
    <link href="https://szza.github.io/2023/05/07/Pipeline/Overview/"/>
    <id>https://szza.github.io/2023/05/07/Pipeline/Overview/</id>
    <published>2023-05-07T08:00:02.000Z</published>
    <updated>2023-08-07T09:17:10.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="GlobalDriverExecutor"><a href="#GlobalDriverExecutor" class="headerlink" title="GlobalDriverExecutor"></a>GlobalDriverExecutor</h1><p>如图 是 StarRocks Pipeline 的整体执行结构:</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-1.svg?raw=true" alt="pipeline-1"></p><p>所有的任务都是在一组固定的线程池 <code>GlobalDriverExecutor::_thread_pool</code> 中执行。默认是使用当前CPU的核数 <em>CpuInfo::num_cores()<em>，也可以设置参数</em>config::pipeline_exec_thread_pool_thread_num</em> 指定线程池数目。 在 <code>GlobalDriverExecutor::initialize</code> 函数中启动 _max_executor_threads 个线程，函数入口 是 <code>GlobalDriverExecutor::work_thread</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ExecEnv::_init(const std::vector&lt;StorePath&gt;&amp; store_paths)</span></span><br><span class="line">std::unique_ptr&lt;ThreadPool&gt; driver_executor_thread_pool;</span><br><span class="line">_max_executor_threads = CpuInfo::<span class="built_in">num_cores</span>();</span><br><span class="line"><span class="keyword">if</span> (config::pipeline_exec_thread_pool_thread_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    _max_executor_threads = config::pipeline_exec_thread_pool_thread_num;</span><br><span class="line">&#125;</span><br><span class="line">_max_executor_threads = std::<span class="built_in">max</span>&lt;<span class="type">int64_t</span>&gt;(<span class="number">1</span>, _max_executor_threads);</span><br><span class="line"><span class="built_in">RETURN_IF_ERROR</span>(<span class="built_in">ThreadPoolBuilder</span>(<span class="string">&quot;pip_executor&quot;</span>) <span class="comment">// pipeline executor</span></span><br><span class="line">                        .<span class="built_in">set_min_threads</span>(<span class="number">0</span>)</span><br><span class="line">                        .<span class="built_in">set_max_threads</span>(_max_executor_threads)</span><br><span class="line">                        .<span class="built_in">set_max_queue_size</span>(<span class="number">1000</span>)</span><br><span class="line">                        .<span class="built_in">set_idle_timeout</span>(MonoDelta::<span class="built_in">FromMilliseconds</span>(<span class="number">2000</span>))</span><br><span class="line">                        .<span class="built_in">build</span>(&amp;driver_executor_thread_pool));</span><br><span class="line">_driver_executor = <span class="keyword">new</span> pipeline::<span class="built_in">GlobalDriverExecutor</span>(<span class="string">&quot;pip_exe&quot;</span>, std::<span class="built_in">move</span>(driver_executor_thread_pool), <span class="literal">false</span>);</span><br><span class="line">_driver_executor-&gt;<span class="built_in">initialize</span>(_max_executor_threads);</span><br></pre></td></tr></table></figure><p>由 <a href="https://db.in.tum.de/~leis/papers/morsels.pdf">Morsel-Driven Parallelism</a> 这篇论文可知，一个可执行的 Task 分为两个部分：输入（Morsel） + 处理流（Pipeline），在 StarRocks 的实现中，Task 就是 <em>PipelineDriver</em>。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/573181686">StarRocks Pipeline 执行框架（上)</a></li><li><a href="https://zhuanlan.zhihu.com/p/575526096">StarRocks Pipeline 执行框架（下)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;GlobalDriverExecutor&quot;&gt;&lt;a href=&quot;#GlobalDriverExecutor&quot; class=&quot;headerlink&quot; title=&quot;GlobalDriverExecutor&quot;&gt;&lt;/a&gt;GlobalDriverExecutor&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Pipeline" scheme="https://szza.github.io/categories/Pipeline/"/>
    
    
    <category term="Pipeline" scheme="https://szza.github.io/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>Radix-Join Cluster Algorithm</title>
    <link href="https://szza.github.io/2023/04/22/Paper/Radix-Join/"/>
    <id>https://szza.github.io/2023/04/22/Paper/Radix-Join/</id>
    <published>2023-04-22T02:12:01.000Z</published>
    <updated>2023-08-07T09:15:08.348Z</updated>
    
    <content type="html"><![CDATA[<p>现在很多 JOIN 算法在进行 JOIN 操作之前，会先将输入划分成多个 clusters&#x2F;partitions，再在每个 cluster 内部进行 JOIN，以便使用多线程等来加速 JOIN。现在主流的分区算法大都是基于 radix-cluster algorithm[1] 及其衍生对输入进行分区。</p><blockquote><p>现在的 join 算法为提高性能，基本都是想着如何充分发挥硬件的特性，比如线程，NUMA 内存分配特性，SIMD，TLB entries、cache lines等。</p></blockquote><p>本文只是作为后续 JOIN 算法的一个铺垫，因此主要介绍 radix-cluster algorithm 本身，其他部分可参考原文[1]。</p><h2 id="PARTITIONED-HASH-JOIN"><a href="#PARTITIONED-HASH-JOIN" class="headerlink" title="PARTITIONED HASH-JOIN"></a>PARTITIONED HASH-JOIN</h2><p>Shatdal et al.[2] 提出了一种在 main-memory 下 Grace Join 算法的变体。</p><p>该算法先基于一个 hash-number 将两个输入划分都分别为 H 个不同的 clusters，使得每个分区都能纳入 memory cache，这种方式比常规基于 bucket-chained hash join 性能更好。该算法简单明了，直接使用了一个分簇算法(clustering-algorithm)： <strong>只扫描输入一次，并将每个被扫描的 tuple 插入到输出中一个 cluster</strong></p><p>如图-8所示，将左侧的输入随机的划分到 H 个单独的 cluster 中。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-1.jpg?raw=true" alt="radix-join-1"></p><p>这个算法，问题就出在随机上，因为会破坏内存访问的局部性，这点从图-8可以看出，输出的H个 clusters 和输入分布基本没啥关系。而且由于需要把每个 cluster 都尽可能纳入 memory-cache 中，就需要 H 尽可能大，使得产生的每个 cluster 就会尽可能小才能一次性纳入cpu cache。那么当 H 非常大时，又有两个因素会导致性能退化：</p><ul><li>如果 H 超过 TLB entries 的数量，那么每次访问内存（memory reference）都会产生一次 TLB miss；</li><li>如果 H 超过了 L1 or L2 可用的 cache lines 数量，cache thrashing 现象就会出现，进而导致 cache miss 次数激增。</li></ul><p>为解决这两个问题，提出了 Radix-Cluster Algorithm ，使得即便H非常大，也具有非常低的随机访问，进而提高性能。</p><h2 id="Radix-Cluster-Algorithm"><a href="#Radix-Cluster-Algorithm" class="headerlink" title="Radix-Cluster Algorithm"></a>Radix-Cluster Algorithm</h2><p>如图 9 所示，radix-cluster algorithm 使用多个阶段（论文中叫 pass）将输入划分为 H 个 clusters，</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-2.jpg?raw=true" alt="radix-join-2"></p><p>下面会先阐述下算法，然后以图-9为例进行说明算法。</p><p>radix-clustering 算法是基于某列生成的整数 hash value 的低 $B$ bits 上实现的：<br>该算法有连续的 P 个 pass ，每个 pass 都基于输入 tuple 的 $B_p$ 个 bits 对输入进行分区，且该 $B_p$ 个 bits 的位置是从最左侧开始计算的 $\sum_1^pB_p$ bits。</p><p>比如图-9中 $B &#x3D; 3$，其中 $P&#x3D;2$，$B_1 &#x3D; 2$，$B_2&#x3D;1$：</p><ul><li>第一个 pass 先使用 $B_1$ bits，目前总共使用的是从最左侧开始计算的 $2&#x3D;\sum^{p&#x3D;1}_1B_p$ 个 bits 进行对一个 pass 输入进行分区；</li><li>第二个 pass 再使用 $B_2$ bits，目前总共使用的是从最左侧开始计算的 $3&#x3D;\sum^{p&#x3D;2}_1B_p$ 个 bits 对第二个 pass 输入进行分区</li></ul><blockquote><p>第二个 pass 是在第一个 pass 的基础上再进行分区，因此看似只使用了一个 bit，实际上包含了第一个 pass 中两个bits的影响，因此说第二个 pass 使用从最左侧开始的 3 个 bits也没问题。</p></blockquote><p>radix-cluster 算法创建的 clusters 数量 $H &#x3D; \prod^p_1 H_p$，其中后一个 pass 会基于上一个 pass 输出的每个 cluster 继续子划分为 $H_p &#x3D; 2^{B_p}$ 个新的 cluster。</p><p>因此当算法开始时，整个输入就被视为一个完整的 cluster，第一个 pass 就被划分为 $H_1 &#x3D; 2^{B_1}$ 个新的 clusters，然后在下一个 pass 继续基于 $H_1$ 个 clusters 再次划分，每个 cluster 又产生 $H_2 &#x3D; 2^{B_2}$ 个新的 clusters，因此两个 pass 就一共产生了 $H_1 * H_2$ 个 clusters。</p><p>特别地，当 $P &#x3D; 1$ 时，radix-cluster 算法即类似上述简单明了的划分算法。</p><blockquote><ul><li>为什么说 radix-cluster 算法在 H 很大时局部性更好？这个观察图-9两个pass的输出应该能得出结论。</li><li>此外，为便于演示，在图-9所示的整数值表中没有使用哈希函数。然而，在实际中，即便是整数值，最好也使用一个hash函数，来确保值的所有位数都能发挥作用。</li></ul></blockquote><p>radix-cluster 算法有诸多好处：</p><ol><li>通过多个 pass 可以实现在具有非常大 H 的情况下，还可以将随机访问的 $H_x$ 数量保持在很低的水平。更具体地说，就是如果我们能保证 $H_x &#x3D; 2^{B_x}$ 同时小于 cache lines 的数量和 TLB entries 的数量，那么我们就可以在每个pass的分区中完全避免 TLB  miss 和 cache miss。</li><li>在基于某列（一般是 join-key cloumn）的 $B$ bits 进行 radix-clustering 之后，该列的hash值中具有相同 $B$ bits 的所有 tuples 表现出连续性，通常会形成每 $C&#x2F;2^B$ tuples 为一组的 chunks，其中 C 是输入的基数（cardinality）。因此，就没有必要使用额外的数据结构来记录这些 cluster 的边界：<strong>只需查看这些 clusters 的低 $B$ bits，就可以确定每个 cluster 的边界</strong>，这样就引入任何额外的开销。</li><li>此外，这种 radix-cluster 算法得到的输出还是基于 radix-bits 排序的。</li></ol><p>图-9 中：</p><ul><li>在第一个 pass 中，取最左侧 2 bits 来划分，能得到 $4 &#x3D; 2^2$ 个 clusters；</li><li>在第二个 pass 中，此时取从最左侧开始的 $3^{th}$ bit，对第一个 pass 输出的每个 cluster 再进子行划分，此时总共得到 $8 &#x3D; 2^1 * 4$ 个 clusters</li></ul><p>对输出的 clusters 进行观察可得：</p><ul><li>有界性：即不需要额外的数据结构就可以确定每个 cluster 的边界。比如，我们可以观察最终输出数组中的hash值的低 $B&#x3D;3$ bits 就能确定 <code>&#123;57, 17, 81, 75&#125;</code> 属于一个 cluster，而 96 和他们不是一个 cluster，并且这四个数字仍然保持原始输入中的顺序；</li><li>有序性：最终输出的8个cluster是基于 3bits 进行排序的，即按照 <code>000 --&gt; 001 --&gt;... --&gt; 111</code> 顺序递增</li></ul><h2 id="Experimental"><a href="#Experimental" class="headerlink" title="Experimental"></a>Experimental</h2><p>radix-cluster 算法有三个参数会对性能造成影响，${B, P, B_p}$，论文进行试验，保持其中一个参数不变，变化另外两个参数对算法进行量化分析。</p><h3 id="radix-bits"><a href="#radix-bits" class="headerlink" title="radix-bits"></a>radix-bits</h3><p>图-10展示了不同 CPU 架构下 1-pass 时不同 radix-bits 时执行时间分布细节。结论：</p><ul><li>纯CPU消耗的时间基本是恒定的，具体的数值在不同CPU架构上略有不同；</li><li>radix-bits 越小， memory 和 TLB 耗时越低，两者成正相关，即 radix-bits 增加，相应的耗时也会增加，比如当 radix-bits 超过 6 时，生成的 clusters 则超过了 TLB entries 的数量（$64 &#x3D; 2^6）$，此时造成的 TLB miss 次数增加了，对应的耗时也会激增。cache miss 也类似。</li></ul><blockquote><p>不同 CPU 的 TLB entries 和 cache lines 数量都不一样，所以图 10 显示的 radix-bits 影响不同；</p></blockquote><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-3.jpg?raw=true" alt="radix-join-3"></p><h3 id="multi-pass"><a href="#multi-pass" class="headerlink" title="multi-pass"></a>multi-pass</h3><p>图-11 展示了不同 passs 数量的影响。multipass radix-cluster 的核心思想是以增加 CPU 耗时来保证每个pass生成的 clusters 数量比较低，并降低内存耗。从图-11可得：</p><ul><li>在 radix-bits &gt; 6 时，即便通过 2-pass 设计，CPU 的耗时成本过高以至于无法避免 TLB 的耗时；</li><li>只有当 radix-bits &gt; 15 时，即 内存耗时超过 CPU 耗时，2-passes 才超过 1-pass<blockquote><p>by the way，关于这两点的原文不知道是我理解错了，还是原文写错了，似乎结论和图-11不匹配，且这两点就互相矛盾。原文如下：</p><ul><li>Obviously, the CPU costs are too high to avoid the TLB costs by using two passes with more than 6 radix-bits. </li><li>Only with more than 15 radix-bits (i.e., when the memory costs exceed the CPU costs) will two passes win over one pass</li></ul></blockquote></li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-4.jpg?raw=true" alt="radix-join-4"></p><p>注意：图-11 展示的仅是分区这一个操作的耗时，当分区数据增多这个耗时不可避免的增加，但是分区 + join 操作的总体耗时不一定会增加，甚至可能会锐减。这里引用论文[3]中的一个分区和join操作总体耗时的图，更能说明问题。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-4-1.jpg?raw=true" alt="radix-join-4-1"></p><p>论文认为唯一改善图-11中问题的方法是降低 CPU 开销，图12是论文 1-pass 的 radix-cluster 算法源码，multi-pass 也是类似，所做的一个优化（图-12中的右侧两行代码）就是去掉了两个函数调用：</p><ul><li>将 hashFcn 变成宏；</li><li>将 memcpy 替换为复制操作</li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-5.jpg?raw=true" alt="radix-join-5"></p><p>如图-13所示，优化之后，CPU 开销几乎降低了接近4倍，论文给出的两个理由是：</p><ul><li>some CPU cycles are saved;</li><li>the CPUs can benefit more from the internal parallel capabilities using speculative execution as the code has become simpler and parallelization options more predictable</li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-6.jpg?raw=true" alt="radix-join-6"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://ir.cwi.nl/pub/11143/11143B.pdf">Optimizing Main-Memory Join on Modern Hardware</a></li><li><a href>Cache Conscious Algorithms for Relational Query Processing</a></li><li><a href="https://15721.courses.cs.cmu.edu/spring2016/papers/kim-vldb2009.pdf">Sort vs. Hash Revisited: Fast Join Implementation on Modern Multi-Core CPUs</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在很多 JOIN 算法在进行 JOIN 操作之前，会先将输入划分成多个 clusters&amp;#x2F;partitions，再在每个 cluster 内部进行 JOIN，以便使用多线程等来加速 JOIN。现在主流的分区算法大都是基于 radix-cluster algori</summary>
      
    
    
    
    <category term="Papers" scheme="https://szza.github.io/categories/Papers/"/>
    
    
    <category term="Papers" scheme="https://szza.github.io/tags/Papers/"/>
    
  </entry>
  
  <entry>
    <title>Morsel-Driven Parallelism: A NUMA-Aware Query Evaluation Framework</title>
    <link href="https://szza.github.io/2023/04/02/Paper/morsel-driven/"/>
    <id>https://szza.github.io/2023/04/02/Paper/morsel-driven/</id>
    <published>2023-04-02T13:58:02.000Z</published>
    <updated>2023-08-04T06:56:23.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>随着现代计算机架构的演进，与并行查询执行引擎中两个问题产生了矛盾：</p><ol><li>为了充分利用多核，所有的查询工作必须很快均匀地分布在数百个线程中才能实现良好的性能加速；</li><li>然而，由于现代 CPU out-of-order 的复杂性，即使有准确的数据统计，也很难将工作均匀分配</li></ol><p>因此，现有的针对 Volcano 的 <code>&quot;Plan Driven&quot;</code> 的并行方法遇到了负载均衡问题（load balancing） 和 上下文切换 （context switch）瓶颈，无法随着CPU架构的升级进行伸缩。许多多核架构面临的第三个问题就是 Memory controller 的去中心化，进而引起 NUMA（Non-Uniform Memory Access）问题。</p><p>因此，本文提出了一种 <code>&quot;Morsel Driven&quot;</code> 查询引擎执行框架，调度变成了一个细粒度的 runtime 任务，且能利用 NUMA 特性。Morsel- Driven 查询处理引擎接受输入数据的一小片段（”morsels”），然后将 morsels 调度给 work 线程，这些 work 线程运行着完整的 operator pipeline，直到遇到下一个 pipeline 才会中断。</p><p>每个 work 线程运行着一个 pipeline，pipeline 中填充着不同的 operators 来操作数据。只要输入 morsels，就会依次从 SourceOperator 向 SinkOperator 流去。</p><p>并行度（degree of parallelism, dop）并不是个固定值，是可以在查询执行期间弹性地更改，因此 dispatcher 可以对不同 morsels 的执行速度作出反应，也可以动态地调整资源以响应工作负载中的新查询。此外。dispatcher 是能感知到 NUMA-local morsels 和算子状态（operator state）的数据局部性，以便绝大多数任务执行发生了 NUMA-Local 内存上。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h2><p>硬件都朝着提升多核性能的方向发展，本文使用术语 “many-cores” 来描述具有数十上百线程的CPU架构。与此同时，每台服务器的内存容量能增加到几TB，这也带动了内存数据库系统的发展。在这样的系统中，查询处理不再受 I&#x2F;O 限制，并且可以真正利用多核的巨大并行计算资源。不幸的是，将 Memory Controller 转移至芯片中，以及将吞吐量拓展到几TB的巨大内存所需的内存访问分散化（decentralization of memory access）的趋势，产生的 NUMA。本质上，计算机本身已经成为一个网络，因为数据项的访问成本取决于数据和访问线程所在的芯片。因此，”many-cores” 并行化需要将 RAM 和cache 的层次结构纳入考虑范围，尤其要仔细考虑 RAM 的 NUMA 划分，以确保大部分线程在 NUMA-Local 数据上工作。</p><blockquote><p>核心思想就是如何减少跨 core 通信：每个线程尽量访问自己核上的数据。RocksDB 中有个数据d结构 <a href="https://github.com/facebook/rocksdb/blob/9a2a6db2a9c5e628b38a5c8cceb90e1e5dbc39a4/util/core_local.h#L23">CoreLocalArray</a>，给每个 core 分配一个对象，让线程访问数据时直接访问线程所在core，减少与 remote core 之间的跨核通信</p></blockquote><p>在此之前的并发模型是 <strong>Volcano</strong> 模型，这种模型中 operators 是没有并行度可言的。因为并行的概念被封装成 Exchange Operator，这个算子在多线程间路由数据流，每个线程都执行着查询计划中完全相同的 pipelined 部分。这种设计就是 <em>plan driven</em>: 基于统计数据优化器在生成执行计划的编译期就确定需要启动多少线程，为每个线程实例化一个查询算子（query operator）并通过 exchange operators 实现这些 operators 间的通信。</p><p>本文提出 <em>morsel driven</em> 查询执行框架，如 fig-1 是执行三表 join 查询 $R \Join_A S \Join_B T$ 的示意图，并行性是通过并行处理不同 cores 上的每个pipeline 实现的。如图所示，有红色和蓝色两个 pipelines。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-1.jpg?raw=true" alt="morsel-driven-1"></p><p>该框架的核心是调度机制（scheduling mechanism）即图中的 <em>dispatcher</em>，使得可以灵活地并行执行 operator pipleine，甚至可以在查询执行期间改变并行度。</p><p>一个 query 会划分成多个 segments，每个可执行的 segments 都会接受输入的一小部分（即 morsel）作为数据源，然后执行，直到遇到下一个 pipeline 才会输出具体的结果。</p><p>如 fig-1 中的红蓝所示，该 morsel 框架也支持 NUMA 局部处理：线程 T1 在一个 NUMA-Local 上输出输入，并且将其结果写入 NUMA-Local 存储区域，全程都没有跨 NUMA 结构。</p><p>fig-1 中的 <em>dispatcher</em> 运行着与机器相关的固定数量的线程，这样即便新的 queries 到来，也不会出现资源的过度消耗，并且这些工作线程与 cpu core 绑在一起，这样就不会因为操作系统将线程移动到其他CPU core 导致 NUMA 局部性失效。</p><blockquote><p>一般工作线程数和 <a href="https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency">std::thread::hardware_concurrency()</a> 函数返回值一致，而这个函数的返回值一般和机器有关。</p></blockquote><p>morsel-driven 的调度机制核心特性是 task 的分配在 runtime 时完成的，并且完全弹性的，即可以通过增加或者降低正在执行的查询的并行度，来处理运行时变化的 workloads，这样就能实现完美的负载均衡（load balancing）。</p><p>morsel-driven 框架的思想从调度拓展到整个查询执行框架，即所有的物理查询算子都必须在他们所有的执行阶段都能实现 morsel 级别（morsel-wise）的并行，比如 HashJoin 的 build 和 probe 阶段。根据 Amdahl 定律，这对实现 many-core 可伸缩性至关重要。</p><p>morsel-wise 框架的一个重要特性就是能感知到数据局部性（data locality），这个起始于输入 morsels 和输出 buffer 的的局部性，并且拓展到 operator state 的局部性（operator state，一般是数据结构，比如 Aggregator 中的 HashTable）。尽管 operator state 是个可能被任何 cores 都访问到的共享数据结构，但是 operator state 确实仍有高度的 NUMA 局部性。</p><p>在为了实现 load balance 时，会需要从其他 core 获取一小部分 morsels，这时才会发生 remote NUMA 访问，即损失了 NUMA 局部性。</p><p>也就是说，通过主要访问 NUMA-Local 内存，可以优化内存延迟（memory latency），并将可能减慢其他线程速度的 cross-socket 内存流量降到最低。</p><p>本文，主要贡献是以下三点：</p><ol><li><p>Morsel-driven query execution</p><p> 这是一个新的查新计算框架，与传统的 Volcano 模型的不同点主要是使用 work-stealing 方式在线程间动态分配任务。这可以防止由于负载不均衡（load imbalance）导致CPU资源未被使用，并且可以实现弹性，即可以随时在不同查询之间重新分配 CPU 资源。</p></li><li><p>一些并行算法。见后文的 HashJon、Aggregate、Sort 并行算法</p></li><li><p>将 NUMA-Awareness 融入到数据库的方法</p></li></ol><h2 id="2-MORSEL-DRIVEN-EXECUTION"><a href="#2-MORSEL-DRIVEN-EXECUTION" class="headerlink" title="2. MORSEL-DRIVEN EXECUTION"></a>2. MORSEL-DRIVEN EXECUTION</h2><p>使用 fig-1 中的 $\sigma(R) \Join \sigma(S) \Join \sigma(R)$ 来展示本文并行 pipeline 查询引擎的执行流程。假设 $R$ 是过滤之后最大的表，优化器将选择 $R$ 作为 HashJoin 的 probe 侧输入，而使用 $S$ 和 $T$ 来 build HashTable。</p><p>如fig-2左侧，根据 cost-based 优化器得到的查询计划由三条 pipelines 组成：</p><ol><li>扫描、过滤表 T 后，构建 T 的 HashTable $HT(T)$</li><li>扫描、过滤表 S 后，构建 S 的 HashTable $HT(S)$</li><li>扫描、过滤表 R 后，再 probe $HT(S)$ 和 $HT(T)$，将结果存在输出区域</li></ol><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-2.jpg?raw=true" alt="morsel-driven-2"></p><!-- HyPer 使用 JIT 技术生成高效的机器码（machine code）。每个 pipeline 都被编译到 code fragment，这实现了非常高的性能。此外，pipeline 中的 operators 也不会产生中间结果，这都已经由 VectorWise 实现了。 --><p>morsel-driven 框架中，代数计划的执行是由 <em>QEPobject</em> 来控制的，它会将可执行的 pipelines 传递给 <em>dispatcher</em>。因此，<em>QEPobject</em> 需要爱去检测数据的的前置依赖， 比如fig-2的例子中，只有在前两个 pipelines 执行完，3-rd pipeline 才能执行。在具体的每个 pipeline 中，<em>QEPobject</em> 会分配临时存储区（temporary storage areas），执行 pipeline 的并行线程会将结果写入到这个临时存储区。</p><p>在整个 pipeline 执行完后，临时存储区在逻辑上会被重新分割为同等大小的 morsels，这样后续的 pipeline 就可以从大小均等的新 morsels 上启动，而不是在 pipelines 之间保留 morsels 边界（容易导致数据倾斜）。任意时刻执行 pipelines 的线程数都受处理器硬件线程数量的限制，即上限是 <code>std::thread::hardware_concurrency()</code>。</p><p>为了写入 NUMUA-Local 并避免在输出中间结果时线程同步，<em>QEPobject</em> 为每个执行 pipeline 的 thread&#x2F;core 分配一个存储区域。</p><p>$HT(T)$ pipeline 的并行处理如 fig-3 所示。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-3.jpg?raw=true" alt="morsel-driven-3"></p><p>先重点关注第一阶段：每个线程先过滤输入 T，然后将过滤后得数据 tuples 存放在临时存储区。</p><p>在图中，有三个并行线程，每个线程一次操作一个 morsel。由于表 T 是以 morsel 为单位存储在多个 NUMA Node 的内存中，那么只要有可能（比如内存足够）那么 scheduler 就会将线程 T 所属的 NUMA Node 上的 morsel 分配给线程T。</p><p>比如在 fig-3 中颜色所表征的意思：在红色 Numa Node 上的 core 运行着红色线程，被赋予的任务就是处理红色 morsel。</p><p>只要线程 T 处理完了赋予的 morsel，要么被委托去执行其他任务（即work-steal 其他颜色的 morsels）或者获取同一个 Numa Node 上的 morsel（即相同颜色）来作为下一个任务。</p><p>fig-3 左侧标记了该 pipeline 被划分后的两个阶段。</p><ol><li><p>在第一阶段，过滤后的数据直接写入了 NUMA-Local 存储区域，也就是说对于每个 core 都有个单独存储区域来避免线程同步。</p><p>为了保持后续处理阶段的的 NUMA 局部性，在同一个socket上本地分配特定 core 的存储区域。即该core的存储区域总是在一个 socket 上分配。</p><blockquote><p>这里的 socket 是插槽。</p></blockquote></li><li><p>当表 T 的所有 morsels 在第一阶段都已经处理完，在第二阶段会被位于相同 core 上的线程再次扫描，并且插入一个指向 $HT(T)$ 的指针。</p></li></ol><p>之所以将构建 HashTable 分成两个阶段，是因为第一阶段完成后，数据的准确数据是已知的，就可以完美地确定全局 hashtable 的大小。这个大小确定的 gloabl hashtable 将会被系统中不同 NUMA Node 上的线程探测（probe）。因此，为避免竞争，这个 gloabl hashtable 就不应该位于特定的 NUMA 区域，而是应该分散在所有的 NUMA node上。由于许多线程都竞争着将输入插入 gloabl hashtable，那么必不可少地要实现一个 lock-free hashtable。</p><p>在 $HT(T)$ 和 $HT(S)$ 都构建完之后，probe pipeline 就可以被调度执行了。probe pipeline 的详细处理见 fig-4.</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-4.jpg?raw=true" alt="morsel-driven-4"></p><p>一个线程会向 dispatcher 请求任务，dispatcher 会在对应的 NUMA Node上 赋予该线程一个 morsel。也就是，如果线程位于红色 NUMA Node 上的 core，就会被分配表 R 在红色 NUMA Node 上的 morsel。Probe pipeline 的结果也会存储在 Numa 局部区域来保留后续处理阶段的局部性（这部分并没在图中画出）。</p><p>总得来说，morsel-driven 并行执行多个 pipelines 有点类似经典的 Volcano 模型实现，但是不同点在于 pipeline 是独立的，没有依赖的。也就是说，pipeline 共享数据结构并且 operators 能感知到并行执行的，因此最终必须执行线程同步（这一步需要通过有效的 lock-free 机制）。</p><p>未来可能的不同点，是执行 pipelines 的线程数也是完全弹性。也就是说，不仅在不同的 pipelines 之间的线程数不同，如 fig-2 所示，而且在查询执行期间，同一个 pipelien 内部也可能不同。</p><h2 id="3-DISPATCHER"><a href="#3-DISPATCHER" class="headerlink" title="3. DISPATCHER"></a>3. DISPATCHER</h2><p><em>dispatcher</em> 管控并将计算资源分配给并行的 pipelines。我们为每个机器提供的硬件线程（预）创建一个工作线程（work thread），并将每个工作线程永久地和他绑定在一起。</p><p>一个赋给 work thread 的 <code>task</code> 由两部分组成：pipeline job 和 pipeline job 的操作对象 morsel。由于 Task 的抢占发生在碎片边界，从而消除了可能代价高昂的中断机制。通过实验确定，morsel 大约在 100,000 个元组时，可以在即时弹性调整、负载平衡和低维护开销之间产生良好的权衡。</p><p>给指定 core 上运行的线程分配 Task 时，有三个主要目标:</p><ol><li>Locality: 保留 NUMA-Locality</li><li>Full elasticity: 关于查询的并行度，具有完全的弹性</li><li>Load balance: 要求所有参与 query pipeline 的核同时完成工作，防止先完成工作的 (fast)cores 等待其他的 (slow)cores。这个通过 worksteal 线程模型实现。</li></ol><p><em>dispatcher</em> 的架构如图 fig-5 所示，它维持了一个指向 pending pipeline jobs 的链表，这个链表中的 pipeline job 的前置依赖都已经处理完成。比如上面的 join 查询案例中，buidc pipeline job 会先插入到 pending jobs，只有在前两个 build pipelines 完成后，才会插入 proeb pipeline。正如前文所述，每个活跃的 queries 都是由 <em>QEPobject</em> 控制，它负责将可执行的 pipelines 传递给 <em>dispatcher</em>。 因此，<em>dispatcher</em> 只需要维护一个前置依赖都处理完成的 pipeline jobs 链表。</p><p>通常来说，<em>dispatcher</em> 的链表中包含的 pending pipeline jobs 是来自于并行执行的不同 queries，来适应 inter-query 的并行性。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-5.jpg?raw=true" alt="morsel-driven-5"></p><blockquote><p>和 StarRocks 中的类关系映射:</p><ul><li>PipelineDriver –&gt; pipeline job</li><li>QEPobject –&gt; PipelineDriverPoller: 负责将前置都已经有序的 pipeline 传递给 dispatcher</li><li>Dispatcher –&gt; DriverQueue: 存储 pipelin job 的任务队列，可以根据优先级（Resource Group）或者 FIFO 方式任务分发</li><li>GlobalDriverExecutor -&gt; 基于 WorkSteal 模型的 work thread</li></ul></blockquote><h3 id="3-1-Elasticity"><a href="#3-1-Elasticity" class="headerlink" title="3.1 Elasticity"></a>3.1 Elasticity</h3><p>通过 “morsel-at-a-time” 分发 pipeline jobs 来实现完全弹性并行性（fully elastic parallelism），允许根据服务质量模型智能调度这些查询间并行的 pipeline jobs。这样就能够在查询处理的任何阶段，优雅地降低长时间运行的查询Q1的并行度，以便优先考虑可能更重要的交互式查询Q2。一旦高优先级的 Q2 完成了，就会将时间片切给 Q2，这时候就可以给大多数甚至全部 cores 都分发 Q1 的 Tasks。会在 5.4 节展示弹性实验。</p><blockquote><p>当前的实现中，所有的查询都是相同优先级，因此线程是均匀分发给当前所有查询，基于优先级的调度机制不在本文介绍之列。</p></blockquote><p>对于每个 <strong>pipeline job</strong>，dispatcher 也为每个 pipeline job 维护了多个 moersls 链表，这是该 pipeline jobs 本次需要处理的数据源。对于每个 <em>core</em>，也存在一个单独的链表来实现局部性，比如对于 <code>core0</code> 上的任务请求一个 morsel，确保返回的 morsel 是来自于 <code>core0</code> 所在的 Numa Node 上。这两点可以从 fig-5 中的不同颜色看出。只要 <code>core0</code>  完成了分配的 morsel 及其 pipeline job 处理流程，就会请求一个新的任务，既可能来自于相同的 pipeline job，当然也可能不一定。这取决于正在执行的不同查询的不同 pipeline jobs 的优先级。比如，如果一个更高优先级的查询进入系统，那么就可能导致当前查询并行度降低。<code>&quot;Morsel-wise&quot;</code> 框架可以在不剧烈中断任务的情况下给不同的 pipeline jobs 重新分配不同的 cores。</p><blockquote><p>StarRocks 中分别是 DriverQueue 和 MorselQueue</p></blockquote><h3 id="3-2-Implementation-Overview"><a href="#3-2-Implementation-Overview" class="headerlink" title="3.2 Implementation Overview"></a>3.2 Implementation Overview</h3><p>出于说明目的，fig-5 中我们直接给每个 core 都分配了一长串 morsels，但是实际上，我们为每个 core&#x2F;NUMA Node 都维护了一个存储区域并且按需将这个大的存储区域划分小的 morsels，即当 core 向 dispatcher 请求 Task 时。</p><p>此外，fig-5 中的 dispatcher 看起来像个独立运行的的线程，但是这会带来两个问题：</p><ol><li>dispatcher 本身需要一个 core 来运行，这可能会和执行 queries 的线程产生竞争；</li><li>因为 dispatcher 要分发任务，因此 dispatcher 本身可能会变成一个产生竞争的源泉（source of contention），成为性能热点，尤其当 morsels sized 被配置得特别小时</li></ol><p>因此，dispatcher 仅被实现为一个数据结构，dispatcher 的代码被 work thread 自己来执行，即由 work-thread 自己从 dispatcher 中取出 Task，那么dispatcher 就很自然地和这个 work thread 在一个 core 上执行。</p><blockquote><p>RocksDB 的 WriteThread 也是这个设计，WriteThread 本身就是 dispatcher 作用，并不会内部再启动一个线程来维护写入的 pending_writes。</p></blockquote><p>因此，基于 lock-free 实现 pipeline jobs queue 和 morsels queue，即便同时有多个查询工作线程同时向 dispatcher 请求 Task，也能降低竞争。类似地，QEPobject 被实现为被动状态机，即通过观察 pipeline 数据之间的依赖关系来推动查询进度，比如在 probe hashtable 之前必须先之前 buid hashtable。只要一个 pipeline job 执行完了，QEPobject 就会被调用，因为某些 Task 无法向 dispatcher 申请到新的 morsel，需要判断该完成的 pipelin job 是不是其他 pipeline jobs 的前置依赖。而此状态机，是在最初向 dispatcher 请求 Task 的 work thread 的不再使用的 core 上执行的。</p><p>除了能在任意时刻将一个 core 赋值给不同 queries 的能力（即 Elasticit），该 morsel-wise 处理流程也能保证 load balance 和 skew resistance。如果一个 core 完成了自己 NUMA-Local 上的所有 Morsels，则 dispatcher 会将 NUMA-Remote 上的 Morsels 分配给他，即 WorkSteal。在有些 NUMA 系统中，不是所有 NUMA Node 都是直连的，因此应该优先从较近的 NUMA-Node 上的 steal。尽管在正常的环境下，从 NUMA-Remote steal work 发生的概率很低，但是仍有必要去避免线程处于空闲状态。由于总是将结果写入 NUMA-Local 的存储区域，因此在 WorkSteal 场景下，coreA 从 coreB 窃取任务，执行完结果还是写入 coreA 的 NUMA-Local 区域。</p><p>目前主要讨论了 pipeline 的内部并行实现，但是我们的并行机制也支持多个 pipelines 并行。比如上面的三表 join 案例中，由于 HT(S) 和 HS(T) 之间没有依赖关系，可以同时并发执行。但是这种形式的并行带来的收益是有限的：因为独立没有依赖的关系的 pipelines 的数量是远小于 CPU cores 的数量，并且每个 pipeline 中的工作量通常也不相同。此外，pipelines 间并行可能会因为破坏 cache locality 导致性能降低。因此，当前的实现中会避免一个查询中同时并发执行多个 pipelines。在本文的JOIN案例中，会先执行 pipeline T，T 执行完了再将 pipeline S 添加到 dispatcher 的 pending pipeline jobs 中。</p><p>除了 Elasticity，本文的 morsel-driven 查询处理框架也实现了简单而又优雅地查询取消功能（query canceling）。无论是因为用户中止了查询，还是因为OOM等系统故障，被取消的查询会在 dispatcher 中被标记 marker。只要该 query 的一个 morsel 处理完，就会去检测 marker，因此很快该查询的所有 work threads 都会停止。这个方式比让操作系统去 kill 所有线程更加合理，可以去执行每个 work threads 的 CleanUp 操作（比如，释放内存等）。</p><h3 id="3-3-Morsel-Size"><a href="#3-3-Morsel-Size" class="headerlink" title="3.3 Morsel Size"></a>3.3 Morsel Size</h3><p>与 Vectorwise 和 IBM’s BLU 数据库不同，这些数据库以 vector 为单位在 operators 间传递，本文数据库不会因为 morsel 无法填充到 cache 中带来性能惩罚。Morsels 是用于将大型任务分解为小的、大小恒定的工作单元（work unit），这样便于 work steal。因此，Morsel 大小对于性能来说并不是很关键，它只需要足够大以分摊调度开销，同时提供良好的响应时间。在第五章会通过实验来衡量 morsel size 对查询 <code>select min(a) from R</code> 性能的影响。因为这个query非常简单，因此会尽可能突显出 work-stealing 数据结构的重要性。</p><p>fig-6 显示，在开销可以忽略不计的情况下，Morsel 大小应设置为尽可能小的值，在本例中，设置高于 1000 的值即可。尽管最优的设置依赖于硬件，但是很容易通过试验的方式获得。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-6.jpg?raw=true" alt="morsel-driven-6"></p><p>在多核系统中，共享的数据结构即便是通过 LOCK-FREE 的方式实现，最终也很可能会成为性能瓶颈。然而，在我们的 WorkSteal 数据结构中，有许多方面因素可以阻止这个问题。</p><ol><li><p>在论文的实现中，完整的任务在最初就在所有的线程间完成分解，因此每个线程都临时拥有着一份 local range。由于我们将 cacheline 对齐到每个 range，因此在 cacheline 层不可能存在冲突。只有当 local range 处理完，尝试从另一个线程窃取 range 时才会发生冲突。</p></li><li><p>如果多个查询同时并发执行，对这个数据结构的压力则进一步减少。？？？</p></li><li><p>总是可以增加 morsel 的大小，来减少竞争</p><p> 这就导致非常小的几率访问 work-stealing 数据结构。即便在最坏的情况，morsel size 非常大会造成无法充分利用线程资源，但是如果当前系统有足够多的查询，则也不会影响系统的吞吐量。</p><p> 即一个查询虽然不会充分利用线程资源，多个查询一起就行了。</p></li></ol><h2 id="4-PARALLEL-OPERATOR-DETAILS"><a href="#4-PARALLEL-OPERATOR-DETAILS" class="headerlink" title="4. PARALLEL OPERATOR DETAILS"></a>4. PARALLEL OPERATOR DETAILS</h2><p>为了能够完整地并行每个 pipeline，pipeline 中的每个 operator 都需要满足：1）既能并行地读取 tuple；2）也需要能够并行地输出 tuple。在这一章，会讨论最重要的几个并行算子。</p><h2 id="4-1-HashJoin"><a href="#4-1-HashJoin" class="headerlink" title="4.1 HashJoin"></a>4.1 HashJoin</h2><p>正如第二节 fig-3 中所示，HashJoin 的 HashTable 的构建由两个阶段组成。</p><p>OuterJoin 是上述算法的小变动: 在每个 tuple 中，会额外分配一个 marker 来表征这个 tuple 是否已经有匹配了。来 probe 阶段如果有相匹配的就会设置该 marker，因此在设置该 marker 之前，先检查下该 marker 是否尚未被设置，有利于减少不必要的竞争。Semi&#x2F;Anti Joins 实现也是类似。</p><p>尽管 Balkesen 等[1]使用了大量的 single-operator benchmark 来表明一个高度优化的 radix-join 比 single-table join 达到个更高的性能。但是相比 radix-join，本文的 single-table join 具有以下特点：</p><ul><li>对于较大的输入表，single-table join 是可以完全 pipelined，因此可以使用更少的空间（因为可以就地处理 probe input）</li><li>是个 “good team player”</li><li>可以从倾斜的key分布中获益</li><li>对 tuple size 不敏感</li><li>没有硬件相关的参数</li></ul><p>由于上述实践中的优点，single-table join 在复杂查询中是要优于 radix-join。</p><blockquote><p>radix-join 可以参考我的另一篇博客: <a href>JOIN 分区算法：Radix-Cluster Algorithm</a>。但是我不太明白这里 single-table join 的含义，论文提及的几篇 HashJoin 论文都是 15721 中的论文，后续会再阅读一次，也可能会继续翻译，来加深理解。</p></blockquote><h3 id="4-2-Lock-Free-Tagged-Hash-Table"><a href="#4-2-Lock-Free-Tagged-Hash-Table" class="headerlink" title="4.2 Lock-Free Tagged Hash Table"></a>4.2 Lock-Free Tagged Hash Table</h3><p>本文 HashJoin 使用的 HashTable 有个优化：提前过滤（early-filter）。核心思想就是使用一个小的filter来标记 HashTable 的 bucket list（一个 bucket 实现为一个list），该 list 的所有元素都被 hash 来设置其中 1 bit。</p><p>如 fig-7 所示的插入过程，带插入的元素 <code>entry-&gt;hash</code> 基于某个算法预计算好，在 <code>insert</code> 函数中，需要基于 <code>entry-&gt;hash</code> 计算 entry 所属的 slot&#x2F;bucket。</p><p>并采用头插法，将 <code>entry-&gt;next = removeTag(old)</code>，其中 old 是 slot 当前的头节点，removeTag(old) 才是当前 head 节点真正地址。</p><p>完成上述操作后，就需要给当前首节点加上 Tag 信息:</p><ol><li>old &amp; TagMask 需要取出当前已有的 Tag 信息，其中 TagMask 即 <em>0xFF000000</em></li><li>计算新节点的 Tag 信息: tag(entry-&gt;hash)</li><li>将所有的的 Tag 信息存在 entry 的前 16bit 中</li></ol><p>结合起来，就是 fig-7 中第9行的计算公式。再通过 CAS 操作将 new 插入到 HashTable[slot] 中。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-7.jpg?raw=true" alt="morsel-driven-7"></p><p>这样就相当于首节点中使用 16 bit 就实现了一个微型 BloomFilter，可以在 O(1) 探测出来 unmatched 情况。相比较单独实现一个 BloomFilter 开销小很多，比如：</p><ol><li>没有带来多余的内存访问，而单独的 BloomFilter 会引入额外的内存访问，甚至多次 IO；</li><li>对于大表，一个单独的 BloomFilter 数据结构难以填充到 CPU Cache;</li><li>不依赖优化器决策，是否需要走 BloomFilter 索引；</li><li>除了 join，这对于聚合场景也是有效的</li></ol><p>实现中，我们对 HashTable 和 tuple 的存储区都使用 2MB 的 virtual memory page，这样的好处点：</p><p>降低了 TLB miss 的次数，page table 能保证填入到 L1 Cache，在 build 阶段产生的太多 kernel page 中断导致的拓展性问题也可以避免；</p><p>此外，我们使用 <code>mmap</code> 为 HashTable 分配内存。因为现代操作系统并不会立即分配内存，而是在第一次某个page有数据写入时才会触发。这样的好处是：1）不需要额外再添加一个阶段手动将 HashTable 内存初始化为 0；2）其次，HashTable 会自适应分布在 NUMA Node 上，因为这些 page 位于的 Numa Node，与首次写入该 page 的线程处在相同的 NUMA Node 上。</p><p>如果所有线程并发构建 HashTable，则会伪随机地分布在所有 Numa Node 上。如果只有来自单个 NUMA Node 上线程构建 HashTable，则该表就位于一个 Numa Node 上 – 这就是预期的情况。</p><blockquote><p>说实在的，我感觉这篇论文夸大了 Lock-Free 的作用，似乎在这篇论文中是神器，但是 Lock-Free 也是有适用场景的。</p></blockquote><h3 id="4-3-NUMA-Aware-Table-Partitioning"><a href="#4-3-NUMA-Aware-Table-Partitioning" class="headerlink" title="4.3 NUMA-Aware Table Partitioning"></a>4.3 NUMA-Aware Table Partitioning</h3><p>为了实现 NUMA-Local Table Scan，表必须在所有的 Memory Nodes 上。最直接的方式即 round-robin。更好的方式是使用一些重要属性列的 Hash 值来对表进行分区。这样的好处是，如果JOIN的两个表都以 join-key 进行分区，那么匹配的 tuples 就通常位于同一个 NUMA Node 上。尽管 work-stealing 和 load imbalance 还是可能导致 remote-Numa 内存访问，但是大多数参与 JOIN 的pair 还是来自于同一个 NUMA Node。</p><p>比如，经典的 TPCH benchmakr 中，<code>orders</code> 和 <code>lineitem</code> 两个表都是按照 <code>orderkey</code> 进行分区，那么这两个表在基于 <code>orderkey</code> 进行 join 时，就能有很好的优化。</p><p>比如 Doris&#x2F;StarRocks 针对这种情况，就提了个 Colocate Join 优化，他们在 TPCH 测试中这两个表的建表 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> lineitem (</span><br><span class="line">    l_shipdate    <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_orderkey    <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_linenumber  <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    l_partkey     <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_suppkey     <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    l_quantity    <span class="type">decimal</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_extendedprice  <span class="type">decimal</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_discount    <span class="type">decimal</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_tax         <span class="type">decimal</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_returnflag  <span class="type">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_linestatus  <span class="type">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_commitdate  <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_receiptdate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_shipinstruct <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_shipmode     <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_comment      <span class="type">VARCHAR</span>(<span class="number">44</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)ENGINE<span class="operator">=</span>OLAP</span><br><span class="line">DUPLICATE KEY(`l_shipdate`, `l_orderkey`)</span><br><span class="line">COMMENT &quot;OLAP&quot;</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`l_orderkey`) BUCKETS <span class="number">96</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">    &quot;replication_num&quot; <span class="operator">=</span> &quot;1&quot;,</span><br><span class="line">    &quot;colocate_with&quot; <span class="operator">=</span> &quot;lineitem_orders&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders  (</span><br><span class="line">    o_orderkey       <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_orderdate      <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_custkey        <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_orderstatus    <span class="type">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_totalprice     <span class="type">decimal</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_orderpriority  <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_clerk          <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_shippriority   <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_comment        <span class="type">VARCHAR</span>(<span class="number">79</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)ENGINE<span class="operator">=</span>OLAP</span><br><span class="line">DUPLICATE KEY(`o_orderkey`, `o_orderdate`)</span><br><span class="line">COMMENT &quot;OLAP&quot;</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`o_orderkey`) BUCKETS <span class="number">96</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">    &quot;replication_num&quot; <span class="operator">=</span> &quot;1&quot;,</span><br><span class="line">    &quot;colocate_with&quot; <span class="operator">=</span> &quot;lineitem_orders&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h2&gt;&lt;p&gt;随着现代计算机架构的演进，与并行查询执行引擎中两个问题产生了矛盾：&lt;/p&gt;
&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    <category term="Papers" scheme="https://szza.github.io/categories/Papers/"/>
    
    
    <category term="Papers" scheme="https://szza.github.io/tags/Papers/"/>
    
  </entry>
  
  <entry>
    <title>WAL、MemTable 的生命周期管理(3)</title>
    <link href="https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/"/>
    <id>https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/</id>
    <published>2022-04-16T06:15:35.000Z</published>
    <updated>2023-08-03T04:46:36.289Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 WAL&#x2F;MemTable 生命周期的完结篇，主要关注 FlushJob 执行流程以及如何确定哪些 WAL&#x2F;MmmTable 可以安全地删除。</p><h2 id="PickMemTable"><a href="#PickMemTable" class="headerlink" title="PickMemTable"></a>PickMemTable</h2><p>FlushJob 首先需要从 <em>ColumnFamilyData::imm_</em> 中挑选出本次所需的 <em>FlushJob::mems_</em> ，这部分功能由 <code>PickMemTable</code> 函数实现。最大可以选择的 MemTable::id_ 是 <em>max_memtable_id_</em> ，该参数值的设置见由上一节 <a href="https://szza.github.io/2022/04/05/rocksdb/WritePath/WAL_2">WAL、MemTable 的生命周期管理(2)</a>。</p><p>每个 FlushJob 选中的 <em>mems_</em> 是基于 MemTable 的创建时间排序，即 <code>mems_[0]</code> 是最早创建的，<code>mems.back()</code> 是最晚创建的。具体从 imm_ 获取 <em>mems_</em> 的逻辑由 <code>PickMemtablesToFlush</code> 函数实现。</p><p>每次 Flush 操作都产生一个 VersionEdit。FlushJob 将 VersionEdit 信息记录在 <code>mems_[0]-&gt;edit_</code> 中，edit_ 中 <code>log_number_</code> 主要是用于追踪 WAL 的生命周期，其值是<code>max_next_log_number</code>，如何与WAL生命周期产生联系可见后文分析。</p><p>此外，<code>FlushJob::meta_</code> 中记录着成功 Flush 后生成的 level0 SST 文件的元信息数据。</p><p>PickMemTable 核心代码逻辑如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlushJob::PickMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  pick_memtable_called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> max_next_log_number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the earliest memtable as a new Table</span></span><br><span class="line">  cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">PickMemtablesToFlush</span>(max_memtable_id_, &amp;mems_,</span><br><span class="line">                                    &amp;max_next_log_number);</span><br><span class="line">  <span class="keyword">if</span> (mems_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* m = mems_[<span class="number">0</span>];</span><br><span class="line">  edit_ = m-&gt;<span class="built_in">GetEdits</span>();</span><br><span class="line">  edit_-&gt;<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);</span><br><span class="line">  edit_-&gt;<span class="built_in">SetLogNumber</span>(max_next_log_number);</span><br><span class="line">  edit_-&gt;<span class="built_in">SetColumnFamily</span>(cfd_-&gt;<span class="built_in">GetID</span>());</span><br><span class="line"></span><br><span class="line">  meta_.fd = <span class="built_in">FileDescriptor</span>(versions_-&gt;<span class="built_in">NewFileNumber</span>(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  meta_.epoch_number = cfd_-&gt;<span class="built_in">NewEpochNumber</span>();</span><br><span class="line"></span><br><span class="line">  base_ = cfd_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  base_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PickMemtablesToFlush"><a href="#PickMemtablesToFlush" class="headerlink" title="PickMemtablesToFlush"></a>PickMemtablesToFlush</h3><p>SwitchMemTable 函数在调用 <code>MemTableList::Add</code> 函数向 imm_ 中插入新的 ImmtableMemTable 时，是在 <code>current-&gt;memlist_</code> 头部插入节点，因此 memlist_ 尾部是最旧的 ImmutableMemTable，头部是最新的。因此需要逆序遍历 memlist_，才能获得按照 MemTable 创建顺序的 <code>FlushJob::mems_</code>。</p><p>当前可能多个 FlushJob 在并发地执行，因此从 <code>current-&gt;memtables_</code> 选择 MemTable 时，需要过滤掉不符合条件的:</p><ul><li><p>MemTable::id_ &lt; max_memtable_id</p></li><li><p>MemTable::flush_in_progress_ 为 false: 即当前没有被其他 FlushJob 选中</p><p>由于 Flush MemTable 以及后续的 COMMIT 操作都需要保持顺序，因此，如果发现 flush_in_progress_ 为 true，则中断本次 Pick 操作，这样能保证选中的 <code>mems_</code> 是连续创建的。</p></li></ul><p>在 SwitchMemTable 函数中，将 old_mem 添加到 <code>current-&gt;memlist_</code> 之前会先调用 <code>MemTableList::FlushRequested</code>，将 <em>flush_requested_</em> 设置为 true，表示该 CF 的 memlist_ 当前等待 Flush 操作。接着在 <code>MemTable::Add</code> 函数中会递增 <em>num_flush_not_started_</em> ，表示 memlist_ 中尚未被 Picked 的 MemTable 数量。</p><p>当 flush_requested_ 为 true 并且 num_flush_not_started_ &gt; 0，则 <code>IsFlushPending</code> 返回 true，则该 CF 可以触发下一次 FlushJob。</p><p>直到 <code>PickMemtablesToFlush</code> 函数执行完，如果 <em>num_flush_not_started_</em> 为 0， 会将 <code>flush_requested_</code> 设置为 false，表示已经所有待 Picked 的 MemTable 都已选中了，准备进行 Flush。如果后续 Flush 流程失败，会调用 <code>RollbackMemtableFlush</code> 函数进行回滚，恢复状态。</p><p>最后，有个基于 RAII 设计的类 <code>AutoThreadOperationStageUpdater</code>，用来表征当前 FlushJob 线程的执行状态。 该函数核心代码及注释如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTableList::PickMemtablesToFlush</span><span class="params">(<span class="type">uint64_t</span> max_memtable_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        autovector&lt;MemTable*&gt;* ret,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint64_t</span>* max_next_log_number)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_PICK_MEMTABLES_TO_FLUSH)</span></span>;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; memlist = current_-&gt;memlist_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = memlist.<span class="built_in">rbegin</span>(); it != memlist.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    MemTable* m = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤超过 max_memtable_id 的 MemTable</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;<span class="built_in">GetID</span>() &gt; max_memtable_id) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;flush_in_progress_) &#123;</span><br><span class="line">      <span class="comment">// 还没被添加到某个 Flush 任务中</span></span><br><span class="line">      num_flush_not_started_--;</span><br><span class="line">      <span class="keyword">if</span> (num_flush_not_started_ == <span class="number">0</span>) &#123;</span><br><span class="line">        imm_flush_needed.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置标志位: 表示被 Picked</span></span><br><span class="line">      m-&gt;flush_in_progress_ = <span class="literal">true</span>;  </span><br><span class="line">      <span class="keyword">if</span> (max_next_log_number) &#123;</span><br><span class="line">        *max_next_log_number =</span><br><span class="line">            std::<span class="built_in">max</span>(m-&gt;<span class="built_in">GetNextLogNumber</span>(), *max_next_log_number);</span><br><span class="line">      &#125;</span><br><span class="line">      ret-&gt;<span class="built_in">push_back</span>(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ret-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// 遇到已经被其他 Flush 线程选中的 memtable，中断</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (num_flush_not_started_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// start-flush request is complete</span></span><br><span class="line">    flush_requested_ = <span class="literal">false</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RollbackMemtableFlush"><a href="#RollbackMemtableFlush" class="headerlink" title="RollbackMemtableFlush"></a>RollbackMemtableFlush</h3><p>如果后续的 Flush 任务执行失败，<em>mems_</em> 不会从 <code>memlist_</code> 中删除，则只需要把 PickMemtablesToFlush 中修改的状态重置即可，等待下一次 Flush。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTableList::RollbackMemtableFlush</span><span class="params">(<span class="type">const</span> autovector&lt;MemTable*&gt;&amp; mems,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">uint64_t</span> <span class="comment">/*file_number*/</span>)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_MEMTABLE_ROLLBACK)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置状态</span></span><br><span class="line">  <span class="keyword">for</span> (MemTable* m : mems) &#123;</span><br><span class="line">    m-&gt;flush_in_progress_ = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;flush_completed_ = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;edit_.<span class="built_in">Clear</span>();</span><br><span class="line">    num_flush_not_started_++;</span><br><span class="line">  &#125;</span><br><span class="line">  imm_flush_needed.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FlushJob-Run"><a href="#FlushJob-Run" class="headerlink" title="FlushJob::Run"></a>FlushJob::Run</h2><p>FlushJob 目前（branch-8.2.fb）有两种实现：</p><ul><li>默认将 MemTables 中的数据写入 level0，</li><li>设置 <em>experimental_mempurge_threshold &gt; 0</em>，开启内存裁剪（Memory Purge）。</li></ul><p>本文只讲解默认实现，MemoryPurge 后续有空再说。默认的 FlushJob::Run 流程主要有两个部分：</p><ol><li>根据选中的 <em>mems_</em> 生成 SST 并写入 level0，由 <code>file_meta</code> 记录该 SST 文件元数据</li><li>如果 step(1) 成功则更新 CF 的 version，并将本次更新记录 <em>FlushJob::edit_</em> 序列化后写入到 MANIFEST 中</li><li>如果 step(1) 不成功，则 <code>RollbackMemtableFlush</code> 进行回滚。</li></ol><p><code>FlushJob::Run</code> 核心代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FlushJob::Run</span><span class="params">(LogsWithPrepTracker* prep_tracker, FileMetaData* file_meta,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">bool</span>* switched_to_mempurge)</span> </span>&#123;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_run</span><span class="params">(ThreadStatus::STAGE_FLUSH_RUN)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mems_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 1. 将 mems_ 写入 level0</span></span><br><span class="line">  Status s = <span class="built_in">WriteLevel0Table</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 2. 判断 Flush 结果</span></span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">RollbackMemtableFlush</span>(mems_, meta_.fd.<span class="built_in">GetNumber</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (write_manifest_) &#123;</span><br><span class="line">    <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">    s = cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">TryInstallMemtableFlushResults</span>(</span><br><span class="line">        cfd_, mutable_cf_options_, mems_, prep_tracker, versions_, db_mutex_,</span><br><span class="line">        meta_.fd.<span class="built_in">GetNumber</span>(), &amp;job_context_-&gt;memtables_to_free, db_directory_,</span><br><span class="line">        log_buffer_, &amp;committed_flush_jobs_info_, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; file_meta != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *file_meta = meta_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteLevel0Table"><a href="#WriteLevel0Table" class="headerlink" title="WriteLevel0Table"></a>WriteLevel0Table</h3><p>WriteLevel0Table 核心部分主要有三个部分，每个部分都很复杂，值得单独开一期讲解，这里主要讲解下每个部分的作用：</p><ul><li><p>NewMergingIterator: 用于将输入的多个 MemTable&#x2F;SST 合并成一个有序的数据流</p><p>在 <code>merger_test.cc</code> 的测试用例中，对于多批次随机数据，<code>NewMergingIterator</code> 合并多个数据流后表现和 <code>VectorIterator</code> 表现的一致，都是有序输出。</p><p>多批输入数据流打平后再输入给 VectorIterator，在 VectorIterator 构造函数中对输入的数据流基于 <code>std::sort</code> 排序，因此 VectorIterator 的输出是全局有序的。而 NewMergingIterator 的输出和 VectorIterator 是一致的，则说明 NewMergingIterator 的作用是合并输入流并使输出有序，不过更加高效。</p></li><li><p>range_del_iter</p><p>NewMergingIterator 只是将输入数据排序好，但是通常上层应用也会进行删除操作。在 MemTable 中，专门为 <em>DeleteRange</em> 操作单独分配了个 range_del_table_。当插入数据是 kTypeRangeDeletion 类型时，则将数据写入 range_del_table_。因此，在遍历 MemTable 时，也需要考虑 range_del_iter 来过滤那些已经被删除的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in MemTable::Add function</span></span><br><span class="line">std::unique_ptr&lt;MemTableRep&gt;&amp; table =</span><br><span class="line">    type == kTypeRangeDeletion </span><br><span class="line">    ? range_del_table_ </span><br><span class="line">    : table_;</span><br></pre></td></tr></table></figure><p>关于 range_delete 操作的详细设计可以参考 <a href="https://github.com/facebook/rocksdb/wiki/DeleteRange-Implementation">DeleteRange-Implementation</a>，后续有时间再讲解其中细节。</p></li><li><p>BuildTable</p><p>内部流程：<code>CompactionIterator</code> 基于 {NewMergingIterator, range_del_iter} 过滤已删除数据并输出全局有序的数据，可以通过 CompactionIterator::Next 进行迭代遍历，获得输出 <code>&#123;key, value&#125;</code>，再用 TableBuilder::Add 函数将该 {key, value} 添加到 level0 的新 SST 文件中。运行结束，新生成的 level0 SST 的元信息保存在 <em>meta_</em> 中。</p></li></ul><p>实际上，Compaction 的核心流程也是这三个部分，逻辑流程都是一样的，后续会专注分析每个具体的部分。<code>WriteLevel0Table</code> 核心流程如下代码注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FlushJob::WriteLevel0Table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_FLUSH_WRITE_L0)</span></span>;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  std::vector&lt;BlobFileAddition&gt; blob_file_additions;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> write_hint = cfd_-&gt;<span class="built_in">CalculateSSTWriteHint</span>(<span class="number">0</span>);</span><br><span class="line">    Env::IOPriority io_priority = <span class="built_in">GetRateLimiterPriorityForWrite</span>();</span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;InternalIterator*&gt; memtables;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;FragmentedRangeTombstoneIterator&gt;&gt;</span><br><span class="line">        range_del_iters;</span><br><span class="line">    ReadOptions ro;</span><br><span class="line">    ro.total_order_seek = <span class="literal">true</span>;</span><br><span class="line">    ro.io_activity = Env::IOActivity::kFlush;</span><br><span class="line">    Arena arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从 MemTables 构建 range_delete_iter，获悉哪些 keys 已被删除</span></span><br><span class="line">    <span class="keyword">for</span> (MemTable* m : mems_) &#123;</span><br><span class="line">      <span class="keyword">auto</span>* range_del_iter = m-&gt;<span class="built_in">NewRangeTombstoneIterator</span>(</span><br><span class="line">          ro, kMaxSequenceNumber, <span class="literal">true</span> <span class="comment">/* immutable_memtable */</span>);</span><br><span class="line">      <span class="keyword">if</span> (range_del_iter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        range_del_iters.<span class="built_in">emplace_back</span>(range_del_iter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 2. 合并多个 memtable 迭代器，使得 memtables 能有序输出</span></span><br><span class="line">      <span class="function">ScopedArenaIterator <span class="title">iter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          NewMergingIterator(&amp;cfd_-&gt;internal_comparator(), memtables.data(),</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">static_cast</span>&lt;<span class="type">int</span>&gt;(memtables.size()), &amp;arena))</span></span>;</span><br><span class="line">      <span class="type">int64_t</span> _current_time = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">auto</span> status = clock_-&gt;<span class="built_in">GetCurrentTime</span>(&amp;_current_time);</span><br><span class="line">      <span class="type">const</span> <span class="type">uint64_t</span> current_time = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(_current_time);</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> oldest_key_time = mems_.<span class="built_in">front</span>()-&gt;<span class="built_in">ApproximateOldestKeyTime</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// It&#x27;s not clear whether oldest_key_time is always available. In case</span></span><br><span class="line">      <span class="comment">// it is not available, use current_time.</span></span><br><span class="line">      <span class="type">uint64_t</span> oldest_ancester_time = std::<span class="built_in">min</span>(current_time, oldest_key_time);</span><br><span class="line"></span><br><span class="line">      meta_.oldest_ancester_time = oldest_ancester_time;</span><br><span class="line">      meta_.file_creation_time = current_time;</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> num_input_entries = <span class="number">0</span>;</span><br><span class="line">      <span class="type">uint64_t</span> memtable_payload_bytes = <span class="number">0</span>;</span><br><span class="line">      <span class="type">uint64_t</span> memtable_garbage_bytes = <span class="number">0</span>;</span><br><span class="line">      IOStatus io_s;</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> std::string* <span class="type">const</span> full_history_ts_low =</span><br><span class="line">          (full_history_ts_low_.<span class="built_in">empty</span>()) ? <span class="literal">nullptr</span> : &amp;full_history_ts_low_;</span><br><span class="line">      <span class="function">TableBuilderOptions <span class="title">tboptions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          *cfd_-&gt;ioptions(), mutable_cf_options_, cfd_-&gt;internal_comparator(),</span></span></span><br><span class="line"><span class="params"><span class="function">          cfd_-&gt;int_tbl_prop_collector_factories(), output_compression_,</span></span></span><br><span class="line"><span class="params"><span class="function">          mutable_cf_options_.compression_opts, cfd_-&gt;GetID(), cfd_-&gt;GetName(),</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="number">0</span> <span class="comment">/* level */</span>, <span class="literal">false</span> <span class="comment">/* is_bottommost */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          TableFileCreationReason::kFlush, oldest_key_time, current_time,</span></span></span><br><span class="line"><span class="params"><span class="function">          db_id_, db_session_id_, <span class="number">0</span> <span class="comment">/* target_file_size */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          meta_.fd.GetNumber())</span></span>;</span><br><span class="line">      <span class="type">const</span> SequenceNumber job_snapshot_seq =</span><br><span class="line">          job_context_-&gt;<span class="built_in">GetJobSnapshotSequence</span>();</span><br><span class="line">      <span class="function"><span class="type">const</span> ReadOptions <span class="title">read_options</span><span class="params">(Env::IOActivity::kFlush)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 合并多个 memtables 的数据，输出到 level0 sst 中</span></span><br><span class="line">      s = <span class="built_in">BuildTable</span>(dbname_, versions_, db_options_, tboptions, file_options_,</span><br><span class="line">                     read_options, cfd_-&gt;<span class="built_in">table_cache</span>(), iter.<span class="built_in">get</span>(),</span><br><span class="line">                     std::<span class="built_in">move</span>(range_del_iters), &amp;meta_, &amp;blob_file_additions,</span><br><span class="line">                     existing_snapshots_, earliest_write_conflict_snapshot_,</span><br><span class="line">                     job_snapshot_seq, snapshot_checker_,</span><br><span class="line">                     mutable_cf_options_.paranoid_file_checks,</span><br><span class="line">                     cfd_-&gt;<span class="built_in">internal_stats</span>(), &amp;io_s, io_tracer_,</span><br><span class="line">                     BlobFileCreationReason::kFlush, seqno_to_time_mapping_,</span><br><span class="line">                     event_logger_, job_context_-&gt;job_id, io_priority,</span><br><span class="line">                     &amp;table_properties_, write_hint, full_history_ts_low,</span><br><span class="line">                     blob_callback_, base_, &amp;num_input_entries,</span><br><span class="line">                     &amp;memtable_payload_bytes, &amp;memtable_garbage_bytes);</span><br><span class="line">     <span class="comment">//... handle error</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 4. 尝试 SYNC SST 目录</span></span><br><span class="line">     <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; output_file_directory_ != <span class="literal">nullptr</span> &amp;&amp; sync_output_directory_) &#123;</span><br><span class="line">      s = output_file_directory_-&gt;<span class="built_in">FsyncWithDirOptions</span>(</span><br><span class="line">          <span class="built_in">IOOptions</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">          <span class="built_in">DirFsyncOptions</span>(DirFsyncOptions::FsyncReason::kNewFileSynced));</span><br><span class="line">    &#125;</span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  base_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> has_output = meta_.fd.<span class="built_in">GetFileSize</span>() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 将生成的 level0 文件元数据信息写入 VersionEdit </span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; has_output) &#123;</span><br><span class="line">    <span class="comment">// Add file to L0</span></span><br><span class="line">    edit_-&gt;<span class="built_in">AddFile</span>(<span class="number">0</span> <span class="comment">/* level */</span>, meta_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Piggyback FlushJobInfo on the first first flushed memtable.</span></span><br><span class="line">  mems_[<span class="number">0</span>]-&gt;<span class="built_in">SetFlushJobInfo</span>(<span class="built_in">GetFlushJobInfo</span>());</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TryInstallMemtableFlushResults"><a href="#TryInstallMemtableFlushResults" class="headerlink" title="TryInstallMemtableFlushResults"></a>TryInstallMemtableFlushResults</h3><p>如果上一步 <code>WriteLevel0Table</code> 成功，则需要将 Flush 的信息 COMMIT 到 MANIFEST。实际上 MANIFEST 可以视为 transaction log，保存着每次 Flush&#x2F;Compaction 的记录。</p><p>当前可能有多个线程在并发执行 Flush 操作，但是只能有一个线程能 COMMIT：率先进入的此函数的线程，它先将 <code>commit_in_progress_</code> 设置为 true，来阻止后来的线程。因此判断 commit_in_progress_ 是否为 true 是个分界点：</p><ul><li><p>之前：所有 Flush 线程都都先更新 mems[i] 的 {flush_completed_, file_number_} 状态</p><p> flush_completed_ 表示 mems[i] 已经成功 Flush，file_number_ 则是指向 Flush 后生成的 SST 文件。 由于 mems 是 Flush 线程的局部变量，因此这一步操作线程安全。</p></li><li><p>之后</p><p>由于只有一个线程能进行 COMMIT。因此 COMMIT 对象是 <em>memlist_</em> 中所有已经 Flushed MemTable，即进入此函数的线程会将所有 Flush 线程中的 mems 一起 COMMIT。 后面进入此函数的线程发现 commit_in_progress_ 为 false 则直接返回。</p><p>其次，COMMIT 也需要按照 MemTable 的创建顺序，即 <code>MemTable::id_</code> 递增的顺序，因此需要逆序遍历 memlist_，并且如果中途某个 MemTable 在 WriteLevel0Table 中失败了，则需要中断当前 COMMIT 操作，只能将前面成功 Flush 的连续 MemTables 的 VersionEdit 写入 MANIFEST，并在回调函数 <code>RemoveMemTablesOrRestoreFlags</code> 中将这部分 MemTable 从 memlist_ 中删除。</p><p>因此，Flush 失败的 MemTable 就会变成 oldeest memtable，等待下一次 FlushJob 再次选择它，重复上述执行流程。</p></li></ul><p>这部分代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MemTableList::TryInstallMemtableFlushResults</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ColumnFamilyData* cfd, <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> autovector&lt;MemTable*&gt;&amp; mems, LogsWithPrepTracker* prep_tracker,</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionSet* vset, InstrumentedMutex* mu, <span class="type">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">    autovector&lt;MemTable*&gt;* to_delete, FSDirectory* db_directory,</span></span></span><br><span class="line"><span class="params"><span class="function">    LogBuffer* log_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::list&lt;std::unique_ptr&lt;FlushJobInfo&gt;&gt;* committed_flush_jobs_info,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> write_edits)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_MEMTABLE_INSTALL_FLUSH_RESULTS)</span></span>;</span><br><span class="line">  mu-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> ReadOptions <span class="title">read_options</span><span class="params">(Env::IOActivity::kFlush)</span></span>;</span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 更改所有成功 Flush 的 MemTable 状态</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mems.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    mems[i]-&gt;flush_completed_ = <span class="literal">true</span>;</span><br><span class="line">    mems[i]-&gt;file_number_ = file_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 分界点: 只有一个线程可以 commit</span></span><br><span class="line">  <span class="keyword">if</span> (commit_in_progress_) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 commit 流程</span></span><br><span class="line">  commit_in_progress_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; memlist = current_-&gt;memlist_;</span><br><span class="line">    <span class="comment">// 3. 遇到 Flush 失败的 memtable 则中断</span></span><br><span class="line">    <span class="keyword">if</span> (memlist.<span class="built_in">empty</span>() || !memlist.<span class="built_in">back</span>()-&gt;flush_completed_) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> batch_file_number = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> batch_count = <span class="number">0</span>;</span><br><span class="line">    autovector&lt;VersionEdit*&gt; edit_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照 memtable 创建的顺序 scan and commit</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = memlist.<span class="built_in">rbegin</span>(); it != memlist.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">      MemTable* m = *it;</span><br><span class="line">      <span class="comment">// 3.1 遇到 Flush 失败的 memtable 则中断</span></span><br><span class="line">      <span class="keyword">if</span> (!m-&gt;flush_completed_) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遇到一个新的 FlushJob</span></span><br><span class="line">      <span class="comment">// 此时 file_number_ 和 edit 都是新的</span></span><br><span class="line">      <span class="keyword">if</span> (it == memlist.<span class="built_in">rbegin</span>() || batch_file_number != m-&gt;file_number_) &#123;</span><br><span class="line">        batch_file_number = m-&gt;file_number_;</span><br><span class="line">        edit_list.<span class="built_in">push_back</span>(&amp;m-&gt;edit_);</span><br><span class="line">        std::unique_ptr&lt;FlushJobInfo&gt; info = m-&gt;<span class="built_in">ReleaseFlushJobInfo</span>();</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          committed_flush_jobs_info-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(info));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      batch_count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 commit 已经 Flush 成功的</span></span><br><span class="line">    <span class="keyword">if</span> (batch_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 计算当前 oldest_wal</span></span><br><span class="line">      <span class="type">uint64_t</span> min_wal_number_to_keep =</span><br><span class="line">          <span class="built_in">PrecomputeMinLogNumberToKeepNon2PC</span>(vset, *cfd, edit_list);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// logfile_num &lt; min_wal_number_to_keep 都应该删除</span></span><br><span class="line">      VersionEdit wal_deletion;</span><br><span class="line">      wal_deletion.<span class="built_in">SetMinLogNumberToKeep</span>(min_wal_number_to_keep);</span><br><span class="line">      <span class="keyword">if</span> (vset-&gt;<span class="built_in">db_options</span>()-&gt;track_and_verify_wals_in_manifest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_wal_number_to_keep &gt;</span><br><span class="line">            vset-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">GetMinWalNumberToKeep</span>()) &#123;</span><br><span class="line">          wal_deletion.<span class="built_in">DeleteWalsBefore</span>(min_wal_number_to_keep);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      edit_list.<span class="built_in">push_back</span>(&amp;wal_deletion);</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> manifest_write_cb = [<span class="keyword">this</span>, cfd, batch_count, log_buffer,</span><br><span class="line">                                      to_delete, mu](<span class="type">const</span> Status&amp; status) &#123;</span><br><span class="line">        <span class="comment">// 从 memlist_ 中删除 flushed memtable</span></span><br><span class="line">        <span class="built_in">RemoveMemTablesOrRestoreFlags</span>(status, cfd, batch_count, log_buffer,</span><br><span class="line">                                      to_delete, mu);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 写入 MANIFEST</span></span><br><span class="line">      s = vset-&gt;<span class="built_in">LogAndApply</span>(cfd, mutable_cf_options, read_options, edit_list,</span><br><span class="line">                            mu, db_directory, <span class="comment">/*new_descriptor_log=*/</span><span class="literal">false</span>,</span><br><span class="line">                            <span class="comment">/*column_family_options=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">                            manifest_write_cb);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 退出 commit 流程</span></span><br><span class="line">  commit_in_progress_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PrecomputeMinLogNumberToKeepNon2PC"><a href="#PrecomputeMinLogNumberToKeepNon2PC" class="headerlink" title="PrecomputeMinLogNumberToKeepNon2PC"></a>PrecomputeMinLogNumberToKeepNon2PC</h3><p>PrecomputeMinLogNumberToKeepNon2PC 函数返回的 <code>min_wal_number_to_keep</code> 用来删除满足 logfile_num &lt; min_wal_number_to_keep 条件的 WAL。由于 min_wal_number_to_keep 也写入 VersionEdit 并最终序列化到 MANIFEST，因此在 Recovery 过程中，如果磁盘上存在部分这些 WAL 也会被忽略，不会被加载。</p><p>min_log_number_to_keep 的计算分为三个阶段：</p><ol><li>每个 <code>FlushJob::edit_</code> 中记录的 <code>log_number_</code> 是在 <code>FlushJob::PickMemTable</code> 函数中设置，指向了每个 CF 最大可以删除的 WAL</li></ol><p>  因为 CF memlist_ 指向的 WAL 对于当前 CF 来说都是可以删除的，因此 FlushJob::mems_[-1]-&gt;GetNextLogNumber() 就是FlushJob::edit_::log_numer_ 能取到的最大值。通过迭代不同 FlushJob 的 edit_，则可以获得所有 FlushJobs 中最小的 log_number_ ，作为 min_log_number_to_keep</p><ol start="2"><li><p>ColumnFamilyData::log_number_ 字段记录了 CF 当前指向的 WAL 文件。因此小于 <code>ColumnFamilyData::log_number_</code> 的 WAL 对于当前 CF 来说都可以删除。</p><p>这一步和 step(1) 是互斥的，如果没有成功执行的 FlushJobs，则 step(1) 中不会修改 min_log_number_to_keep 的值，此时就会进入 step(2)，来获得他们中最小的 <code>min_log_number_to_keep</code>；</p></li><li><p>再检查没有执行 Flush 的或者 Flush 失败的的 CFs 的 <code>ColumnFamilyData::log_number_</code> 字段，和 <code>min_log_number_to_keep</code> 进行比较最小值</p></li></ol><p>上述三步结束，所得的 <code>min_log_number_to_keep</code> 即生命周期没有结束的最小 WAL：所有满足 <code>logfile_num &lt; min_log_number_to_keep</code> 的 WAL 可以安全地从磁盘上删除了，Recovery 期间也不会被加载了，即生命周期可以结束了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">PrecomputeMinLogNumberToKeepNon2PC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionSet* vset, <span class="type">const</span> autovector&lt;ColumnFamilyData*&gt;&amp; cfds_to_flush,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> autovector&lt;autovector&lt;VersionEdit*&gt;&gt;&amp; edit_lists)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> min_log_number_to_keep = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 检测 min_log_number_to_keep</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edit_list : edit_lists) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> log = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edit_list) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e-&gt;<span class="built_in">HasLogNumber</span>()) &#123;</span><br><span class="line">        log = std::<span class="built_in">max</span>(log, e-&gt;<span class="built_in">GetLogNumber</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (log != <span class="number">0</span>) &#123;</span><br><span class="line">      min_log_number_to_keep = std::<span class="built_in">min</span>(min_log_number_to_keep, log);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如果 edit_lists 为空</span></span><br><span class="line">  <span class="keyword">if</span> (min_log_number_to_keep == std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">    min_log_number_to_keep = cfds_to_flush[<span class="number">0</span>]-&gt;<span class="built_in">GetLogNumber</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; cfds_to_flush.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      min_log_number_to_keep =</span><br><span class="line">          std::<span class="built_in">min</span>(min_log_number_to_keep, cfds_to_flush[i]-&gt;<span class="built_in">GetLogNumber</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 检测没有 Flush 或者 Flush 失败的 CFs</span></span><br><span class="line">  <span class="function">std::unordered_set&lt;<span class="type">const</span> ColumnFamilyData*&gt; <span class="title">flushed_cfds</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      cfds_to_flush.begin(), cfds_to_flush.end())</span></span>;</span><br><span class="line">  min_log_number_to_keep =</span><br><span class="line">      std::<span class="built_in">min</span>(min_log_number_to_keep,</span><br><span class="line">               vset-&gt;<span class="built_in">PreComputeMinLogNumberWithUnflushedData</span>(flushed_cfds));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> min_log_number_to_keep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">PreComputeMinLogNumberWithUnflushedData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">const</span> ColumnFamilyData* cfd_to_skip)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="type">uint64_t</span> min_log_num = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> cfd : *column_family_set_) &#123;</span><br><span class="line">   <span class="comment">// 跳过 step(2) 中处理过的 CF</span></span><br><span class="line">   <span class="keyword">if</span> (cfd == cfd_to_skip) &#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 和 min_log_num 取较小值</span></span><br><span class="line">   <span class="keyword">if</span> (min_log_num &gt; cfd-&gt;<span class="built_in">GetLogNumber</span>() &amp;&amp; !cfd-&gt;<span class="built_in">IsDropped</span>()) &#123;</span><br><span class="line">     min_log_num = cfd-&gt;<span class="built_in">GetLogNumber</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> min_log_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FindObsoleteFiles"><a href="#FindObsoleteFiles" class="headerlink" title="FindObsoleteFiles"></a>FindObsoleteFiles</h2><p>上述获得 <code>min_log_number_to_keep</code> 后，会生成一个 VersionEdit 对象 wal_deletion，它写入 MANIFEST 的过程中，会更新<code>VersionSet::min_log_number_to_keep_</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in function: VersionSet::ProcessManifestWrites</span></span><br><span class="line"><span class="type">uint64_t</span> last_min_log_number_to_keep = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : batch_edits) &#123;</span><br><span class="line">  <span class="comment">//... other code</span></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;has_min_log_number_to_keep_) &#123;</span><br><span class="line">    last_min_log_number_to_keep =</span><br><span class="line">        std::<span class="built_in">max</span>(last_min_log_number_to_keep, e-&gt;min_log_number_to_keep_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (last_min_log_number_to_keep != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">MarkMinLogNumberToKeep</span>(last_min_log_number_to_keep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 FindObsoleteFiles 函数中，会根据 <code>VersionSet::min_log_number_to_keep_</code> 来判断一个 WAL 的生命周期是否已经结束：已经结束的则加入 <code>JobContextl::log_delete_files</code> 中，在 <code>PurgeObsoleteFiles</code> 函数中从磁盘上删除该文件，再释放 <code>JobContextl::logs_to_free_</code> 中记录的 <code>LogWriter</code> 内存。</p><p>到此，一个 WAL 生命周期才算结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VersionSet::MarkMinLogNumberToKeep</span><span class="params">(<span class="type">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (min_log_number_to_keep_.<span class="built_in">load</span>(std::memory_order_relaxed) &lt; number) &#123;</span><br><span class="line">   min_log_number_to_keep_.<span class="built_in">store</span>(number, std::memory_order_relaxed);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::FindObsoleteFiles</span><span class="params">(JobContext* job_context, <span class="type">bool</span> force,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> no_full_scan)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//... ignore other code...</span></span><br><span class="line">  job_context-&gt;log_number = versions_-&gt;<span class="built_in">min_log_number_to_keep</span>();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (alive_log_files_.<span class="built_in">empty</span>() || logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!alive_log_files_.<span class="built_in">empty</span>() &amp;&amp; !logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// logfile_num &lt;= min_log_number 都应该删除</span></span><br><span class="line">    <span class="type">uint64_t</span> min_log_number = job_context-&gt;log_number;</span><br><span class="line">    <span class="type">size_t</span> num_alive_log_files = alive_log_files_.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检测新的 obsoleted WAL files，即生命周期已结束的</span></span><br><span class="line">    <span class="keyword">while</span> (alive_log_files_.<span class="built_in">begin</span>()-&gt;number &lt; min_log_number) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; earliest = *alive_log_files_.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否回收，不收回则加入待删除队列</span></span><br><span class="line">      <span class="keyword">if</span> (immutable_db_options_.recycle_log_file_num &gt; log_recycle_files_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        log_recycle_files_.<span class="built_in">push_back</span>(earliest.number);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        job_context-&gt;log_delete_files.<span class="built_in">push_back</span>(earliest.number);</span><br><span class="line">      &#125;</span><br><span class="line">      alive_log_files_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检测待释的 LogWriter</span></span><br><span class="line">    log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    <span class="keyword">while</span> (!logs_.<span class="built_in">empty</span>() &amp;&amp; logs_.<span class="built_in">front</span>().number &lt; min_log_number) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; log = logs_.<span class="built_in">front</span>();</span><br><span class="line">      <span class="keyword">if</span> (log.<span class="built_in">IsSyncing</span>()) &#123;</span><br><span class="line">        log_sync_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      logs_to_free_.<span class="built_in">push_back</span>(log.<span class="built_in">ReleaseWriter</span>());</span><br><span class="line">      logs_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job_context-&gt;logs_to_free = logs_to_free_;</span><br><span class="line">  logs_to_free_.<span class="built_in">clear</span>();</span><br><span class="line">  log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 回收</span></span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  job_context-&gt;log_recycle_files.<span class="built_in">assign</span>(log_recycle_files_.<span class="built_in">begin</span>(),</span><br><span class="line">                                        log_recycle_files_.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是 WAL&amp;#x2F;MemTable 生命周期的完结篇，主要关注 FlushJob 执行流程以及如何确定哪些 WAL&amp;#x2F;MmmTable 可以安全地删除。&lt;/p&gt;
&lt;h2 id=&quot;PickMemTable&quot;&gt;&lt;a href=&quot;#PickMemTable&quot; cl</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WAL、MemTable 的生命周期管理(2)</title>
    <link href="https://szza.github.io/2022/04/05/rocksdb/WritePath/WAL_2/"/>
    <id>https://szza.github.io/2022/04/05/rocksdb/WritePath/WAL_2/</id>
    <published>2022-04-05T06:15:35.000Z</published>
    <updated>2023-08-03T04:21:15.020Z</updated>
    
    <content type="html"><![CDATA[<p>本文简要讲下在 Flush  MemTable 之前，WAL 需要进行 SYNC 的原因。更多设计思考可以阅读 <a href="https://github.com/facebook/rocksdb/wiki/Track-WAL-in-MANIFEST">Track-WAL-in-MANIFEST</a></p><h3 id="WHY-NEED-to-SYNC-WAL"><a href="#WHY-NEED-to-SYNC-WAL" class="headerlink" title="WHY NEED to SYNC WAL"></a>WHY NEED to SYNC WAL</h3><p>出于性能考虑，默认情况下 RocksDB 不会每写入一次数据就进行一次 SYNC WAL 操作。但没有 SYNC WAL 会带来两个影响：</p><ol><li><p>在 recovery 时，就无法检查 WAL 是否存在磁盘上，这是因为当机器挂了，WAL 的 innode 元数据可能尚未持久化到磁盘。</p><p>除此之外，默认情况下误删 WAL 目录下的 log 文件，也没有机制来检测是否有 WAL 丢失以及哪个文件丢失。此时 DB::Open 是会成功，但是 log 中对应的数据 <em>“悄悄地”</em> 丢失了。</p></li><li><p>在 recovery 期间也无法判断 WAL 的大小是否正常，因为如果不主动 SYNC，则 SYNC WAL 操作则由操作系统来完成的，这对 RocksDB 并不透明：无法知道在 RocksDB 退出前， WAL 持久化到磁盘的大小。</p></li></ol><p>目前 SYNC WAL 有四种场景：</p><ol><li>上层应用调用 <code>DB::SyncWAL</code> 函数，会主动 SYNC 所有生命周期还没结束的 WALs</li><li>上层应用调用 <code>DB::FlushWAL(true)</code> 函数，内部也是调用 SyncWAL 函数</li><li>写入数据时，设置 <code>WriteOption::sync</code> 为 <em>true</em>，即每写入一次数据，就会进行一次 SYNC WAL</li><li>在 Flush MemTable 前，如果不止一个 ColumnFamily ，会 SYNC 所有 <em>closed_wals</em>，即除了当前WAL之外的所有生命周期尚未结束的 WALs</li></ol><p>case(1,2) 交给应用层调用，case(3) 虽然安全但是效率太低，一般不会开启。因此，交给 RocksDB 自己需要 SYNC WAL 的场景就剩下case(4)。 SYNC WAL 主要是为了防止机器宕机，而不是进程crash。虽然 case(4) 还是有丢数据的风险，但是在生产环境中，一般都会配备多副本来冗余。除非是一个副本的数据在一个机房，一个机房的数据又全部挂了，为了防止这种情况，又搞出来了跨机房部署。</p><blockquote><p>BUT, 该挂的还是会挂。</p></blockquote><p>因此，在执行 FlushJob 前，会将本次 <em>synced_wals</em> 大小信息记录到 <code>VersionEdit</code> 中，再序列化到 MANIFEST 中，在 recovery 期间可以对 WALs 进行强制检查：1）MANIFEST 中记录的 WAL 也应该存在磁盘上；2）磁盘上 WAL 的大小不应该小于 MANIFEST 中记录的 WAL 大小。</p><p>case(4) 是否需要 SYNC 的判断条件如下: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 判断本次 Flush 前是否需要 sync closed_wals</span></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> needs_to_sync_closed_wals =</span><br><span class="line">    logfile_number_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    versions_-&gt;<span class="built_in">GetColumnFamilySet</span>()-&gt;<span class="built_in">NumberOfColumnFamilies</span>() &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><p><em>needs_to_sync_closed_wals</em> 为 true 时，需要记录当前 CF 的 <em>max_memtable_id</em>，这样后续 FlushJob::PickMemTable 函数选择待 Flush 的MemTable时，会过滤掉满足 MemTable::id_ &gt; max_memtable_id 的 memtable。</p><p>这是因为在执行 <code>SyncClosedLogs</code> 函数会 DBImpl::mutex_.Unlock，而当前 CF 的 SwitchMemTable 函数可能会在这个期间执行，新增 new_mem，通过 max_memtable_id 来过滤掉这个期间新增的 new_mm。</p></li><li><p><em>needs_to_sync_closed_wals</em> 为 false，会使得 max_memtable_id 为 UINT64_MAX，表示要 Flush 所有的 ImmutableMemtables</p></li></ul><p>这部分代码上下文逻辑如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 设置 max_memtable_id</span></span><br><span class="line"><span class="type">uint64_t</span> max_memtable_id = needs_to_sync_closed_wals</span><br><span class="line">    ? cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">GetLatestMemTableID</span>()</span><br><span class="line">    : std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//... other middle codes</span></span><br><span class="line">IOStatus log_io_s = IOStatus::<span class="built_in">OK</span>();</span><br><span class="line"><span class="keyword">if</span> (needs_to_sync_closed_wals) &#123;</span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 释放 mutex_, 再进行 sync</span></span><br><span class="line">  VersionEdit synced_wals;</span><br><span class="line">  log_io_s = <span class="built_in">SyncClosedLogs</span>(job_context, &amp;synced_wals);</span><br><span class="line">  </span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  <span class="comment">// 4. write to MANIFEST</span></span><br><span class="line">  <span class="keyword">if</span> (log_io_s.<span class="built_in">ok</span>() &amp;&amp; synced_wals.<span class="built_in">IsWalAddition</span>()) &#123;</span><br><span class="line">    log_io_s = <span class="built_in">status_to_io_status</span>(<span class="built_in">ApplyWALToManifest</span>(</span><br><span class="line">          <span class="built_in">ReadOptions</span>(Env::IOActivity::kFlush), &amp;synced_wals));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SyncClosedLogs"><a href="#SyncClosedLogs" class="headerlink" title="SyncClosedLogs"></a>SyncClosedLogs</h3><p>SyncClosedLogs 函数需要在 <em>log_write_mutex_</em> 保护下。如果此时仍持有 <code>DBImpl::mutex_</code> 会影响增加其他其线程阻塞时间，比如写路径过程中的 <code>PreprocessWrite</code>，因此在进入 SyncClosedLogs 函数前会释放 <code>DBImpl::mutex_</code>，让其他的线程可以执行。</p><p>SyncClosedLogs 函数的目标是 [logs_.front().number, logfile_number_) 区间的 WALs，其中 logfile_number_ 指向当前最新的 WAL。由于在后台线程池中可能会同时执行多个 FlushMemTable 任务，只要一个 WAL 的生命周期还没结束，那么每次 FlushMemTables 前都会 SYNC WAL 一次，并使用 VersionEdit 记录该 WAL 的元信息再写入 MANIFEST。 因此在 SyncClosedLogs 函数开始，会先尝试阻塞等待其他线程完成对该 WAL 的 SYNC 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOStatus <span class="title">DBImpl::SyncClosedLogs</span><span class="params">(JobContext* job_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                                VersionEdit* synced_wals)</span> </span>&#123;</span><br><span class="line">  <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;log_write_mutex_)</span></span>;</span><br><span class="line">  autovector&lt;log::Writer*, <span class="number">1</span>&gt; logs_to_sync;</span><br><span class="line">  <span class="type">uint64_t</span> current_log_number = logfile_number_;</span><br><span class="line">  <span class="comment">// 1. 阻塞等待其他线程完成 SYNC</span></span><br><span class="line">  <span class="keyword">while</span> (logs_.<span class="built_in">front</span>().number &lt; current_log_number &amp;&amp;</span><br><span class="line">         logs_.<span class="built_in">front</span>().<span class="built_in">IsSyncing</span>()) &#123;</span><br><span class="line">    log_sync_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2. 获取所有待 SYNC 的对象: logs_to_sync</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = logs_.<span class="built_in">begin</span>();</span><br><span class="line">       it != logs_.<span class="built_in">end</span>() &amp;&amp; it-&gt;number &lt; current_log_number; ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; log = *it;</span><br><span class="line">    log.<span class="built_in">PrepareForSync</span>();</span><br><span class="line">    logs_to_sync.<span class="built_in">push_back</span>(log.writer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  IOStatus io_s;</span><br><span class="line">   <span class="comment">// 3. SYNC</span></span><br><span class="line">  <span class="keyword">if</span> (!logs_to_sync.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 操作局部变量 logs_to_sync 不需要 log_write_mutex_</span></span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">for</span> (log::Writer* log : logs_to_sync) &#123;</span><br><span class="line">      <span class="comment">// 每个文件进行 SYNC</span></span><br><span class="line">      io_s = log-&gt;<span class="built_in">file</span>()-&gt;<span class="built_in">Sync</span>(immutable_db_options_.use_fsync);</span><br><span class="line">      <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 关闭</span></span><br><span class="line">      <span class="keyword">if</span> (immutable_db_options_.recycle_log_file_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        io_s = log-&gt;<span class="built_in">Close</span>();</span><br><span class="line">        <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只要有一个 WAL 需要 SYNC ，整个目录都需要 SYNC</span></span><br><span class="line">    <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      io_s = directories_.<span class="built_in">GetWalDir</span>()-&gt;<span class="built_in">FsyncWithDirOptions</span>(</span><br><span class="line">          <span class="built_in">IOOptions</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">          <span class="built_in">DirFsyncOptions</span>(DirFsyncOptions::FsyncReason::kNewFileSynced));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要操作 active_logs_, logs_ 因此需要 log_write_mutex_</span></span><br><span class="line">    log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 标记是否完成</span></span><br><span class="line">    <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">MarkLogsSynced</span>(current_log_number - <span class="number">1</span>, <span class="literal">true</span>, synced_wals);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">MarkLogsNotSynced</span>(current_log_number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> io_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MarkLogsSynced"><a href="#MarkLogsSynced" class="headerlink" title="MarkLogsSynced"></a>MarkLogsSynced</h4><p><code>MarkLogsSynced</code> 函数记录 SYNCed WALs 信息:</p><p>选项 <em>DBOptions.track_and_verify_wals_in_manifest</em> 用于追踪 WAL 大小信息便于在 Recovery 期间进行校验。默认值为 false，但是 RocksDB 建议在生产环境设置为 true，防止误删或者损坏 WAL 目录下的文件而无法察觉。因此每次 Flush MemTable 前会记录 WAL 的 <code>&#123;wal.number, prev_synced_szie&#125;</code> 信息，那么当 recovery 时，存放 WAL 的目录下必须存在 <code>wal.number</code> 文件，且文件大小至少是 <code>prev_synced_szie</code>。</p><p>此外，还会更新 <code>logs_</code>：</p><ul><li>由于 WAL 在 SyncClosedLogs 函数中再次 SYNC。如果最新一次 SYNC 完成后 WAL 大小和上次 SYNC 的大小 prev_sync_size 相同，表示该 WAL 已完成持久化，则可以从 <code>logs_</code> 中删除，加入 <code>logs_to_free_</code> 队列，在 FlushJob 完成后，在 <code>FindObsoleteFiles</code> 函数中删除。</li><li>否则，还需要进行下一次 SYNC，将本次 SYNC 操作标记为完成，等待下一次 Flush 后台任务；</li></ul><p>由于 <code>MarkLogsSynced</code> 函数会对 <code>logs_</code> 和 <code>logs_to_free_</code> 进行操作，因此需要在 <code>log_write_mutex_</code> 保护下执行，执行完再阻塞唤醒所有阻塞等待在 <code>log_sync_cv_</code> 的地方。</p><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MarkLogsSynced</span><span class="params">(<span class="type">uint64_t</span> up_to, <span class="type">bool</span> synced_dir,</span></span></span><br><span class="line"><span class="params"><span class="function">                            VersionEdit* synced_wals)</span> </span>&#123;</span><br><span class="line">  log_write_mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = logs_.<span class="built_in">begin</span>(); it != logs_.<span class="built_in">end</span>() &amp;&amp; it-&gt;number &lt;= up_to;) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; wal = *it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wal.number &lt; logs_.<span class="built_in">back</span>().number) &#123;</span><br><span class="line">      <span class="comment">// Inactive WAL</span></span><br><span class="line">      <span class="keyword">if</span> (immutable_db_options_.track_and_verify_wals_in_manifest &amp;&amp;</span><br><span class="line">          wal.<span class="built_in">GetPreSyncSize</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        synced_wals-&gt;<span class="built_in">AddWal</span>(wal.number, <span class="built_in">WalMetadata</span>(wal.<span class="built_in">GetPreSyncSize</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (wal.<span class="built_in">GetPreSyncSize</span>() == wal.writer-&gt;<span class="built_in">file</span>()-&gt;<span class="built_in">GetFlushedSize</span>()) &#123;</span><br><span class="line">        <span class="comment">// Fully synced</span></span><br><span class="line">        logs_to_free_.<span class="built_in">push_back</span>(wal.<span class="built_in">ReleaseWriter</span>());</span><br><span class="line">        it = logs_.<span class="built_in">erase</span>(it);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(wal.<span class="built_in">GetPreSyncSize</span>() &lt; wal.writer-&gt;<span class="built_in">file</span>()-&gt;<span class="built_in">GetFlushedSize</span>());</span><br><span class="line">        wal.<span class="built_in">FinishSync</span>();</span><br><span class="line">        ++it;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Active WAL</span></span><br><span class="line">      <span class="built_in">assert</span>(wal.number == logs_.<span class="built_in">back</span>().number);</span><br><span class="line">      wal.<span class="built_in">FinishSync</span>();</span><br><span class="line">      ++it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  log_sync_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplyWALToManifest"><a href="#ApplyWALToManifest" class="headerlink" title="ApplyWALToManifest"></a>ApplyWALToManifest</h3><p><code>ApplyWALToManifest</code> 函数是将 <code>MarkLogsSynced</code> 函数中获得 synced_wals 序列化写入到 MANIFEST，写入 MANIFEST 的数据都需要指定一个所属 CF，由于 WAL 是RocksDB 中所有 CFs 共享的，而 DefaultCF 是第一个 ColumnFamily，因此将 WAL 的数据归属给 default_cf。</p><p>至于 <code>LogAndApplyToDefaultColumnFamily</code> 内部怎么 MANIFEST 交互，后面会讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::ApplyWALToManifest</span><span class="params">(<span class="type">const</span> ReadOptions&amp; read_options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  VersionEdit* synced_wals)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// not empty, write to MANIFEST.</span></span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  Status status = versions_-&gt;<span class="built_in">LogAndApplyToDefaultColumnFamily</span>(</span><br><span class="line">      read_options, synced_wals, &amp;mutex_, directories_.<span class="built_in">GetDbDir</span>());</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>() &amp;&amp; versions_-&gt;<span class="built_in">io_status</span>().<span class="built_in">IsIOError</span>()) &#123;</span><br><span class="line">    status = error_handler_.<span class="built_in">SetBGError</span>(versions_-&gt;<span class="built_in">io_status</span>(),</span><br><span class="line">                                       BackgroundErrorReason::kManifestWrite);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h3><p>在开启了 <em>track_and_verify_wals_in_manifest</em> 后，在 <code>DBImpl::Recover</code> 中，VersionSet 从 MANIFEST 恢复过来后，会将 MANIFEST 中记录的 WAL 元信息和 WAL 目录下的文件进行对比校验。如果该标志没有开启，则需要删除 MANIFEST 中记录的 WAL 信息，防止后续开启后，MANIFEST 中的记录的 WAL 文件已经被删除了，导致校验失败，无法恢复 RocksDB 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (immutable_db_options_.track_and_verify_wals_in_manifest) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!immutable_db_options_.best_efforts_recovery) &#123;</span><br><span class="line">    <span class="comment">// Verify WALs in MANIFEST.</span></span><br><span class="line">    s = versions_-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">CheckWals</span>(env_, wal_files);</span><br><span class="line">  &#125; <span class="comment">// else since best effort recovery does not recover from WALs, no need</span></span><br><span class="line">    <span class="comment">// to check WALs.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!versions_-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">GetWals</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  WalNumber max_wal_number =</span><br><span class="line">      versions_-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">GetWals</span>().<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">  edit.<span class="built_in">DeleteWalsBefore</span>(max_wal_number + <span class="number">1</span>);</span><br><span class="line">  recovery_ctx-&gt;<span class="built_in">UpdateVersionEdits</span>(</span><br><span class="line">      versions_-&gt;<span class="built_in">GetColumnFamilySet</span>()-&gt;<span class="built_in">GetDefault</span>(), edit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckWals"><a href="#CheckWals" class="headerlink" title="CheckWals"></a>CheckWals</h4><p><code>CheckWals</code> 函数是将从 MANIFEST 中获得的 WAL 最后一次 SYNC 大小 <code>synced_size</code> 和实际磁盘上的 WAL 文件大小 <code>log_file_size</code> 进行对比校验，起码要满足 <code>synced_size &lt;= log_file_size</code>，校验才能通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WalSet::CheckWals</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Env* env,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::unordered_map&lt;WalNumber, std::string&gt;&amp; logs_on_disk)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [log_number, wal_meta] : wals_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!wal_meta.<span class="built_in">HasSyncedSize</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. MANIFEST 中有存在的 WALs，磁盘上也必须存在</span></span><br><span class="line">    <span class="keyword">if</span> (logs_on_disk.<span class="built_in">find</span>(log_number) == logs_on_disk.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(fmt::format(</span><br><span class="line">        <span class="string">&quot;Missing WAL with log number: &#123;&#125;&quot;</span>, log_number));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 磁盘上的 WAL 文件大小 &gt;= 最后一次 SYNC 大小</span></span><br><span class="line">    <span class="type">uint64_t</span> log_file_size = <span class="number">0</span>;</span><br><span class="line">    s = env-&gt;<span class="built_in">GetFileSize</span>(logs_on_disk.<span class="built_in">at</span>(log_number), &amp;log_file_size);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log_file_size &lt; wal_meta.<span class="built_in">GetSyncedSizeInBytes</span>()) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(fmt::format(</span><br><span class="line">        <span class="string">&quot;Size mismatch: WAL (log number: &#123;&#125; ) in MANIFEST is &#123;&#125; bytes, &quot;</span></span><br><span class="line">        <span class="string">&quot;but actually is  &#123;&#125; bytes on disk.&quot;</span>,</span><br><span class="line">        log_number, wal_meta.<span class="built_in">GetSyncedSizeInBytes</span>(), log_file_size));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文简要讲下在 Flush  MemTable 之前，WAL 需要进行 SYNC 的原因。更多设计思考可以阅读 &lt;a href=&quot;https://github.com/facebook/rocksdb/wiki/Track-WAL-in-MANIFEST&quot;&gt;Track-WA</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WAL、MemTable 的生命周期管理(1)</title>
    <link href="https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/"/>
    <id>https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/</id>
    <published>2022-03-01T06:15:35.000Z</published>
    <updated>2023-08-03T04:21:02.488Z</updated>
    
    <content type="html"><![CDATA[<p>WAL 在 DB::Open 时就会创建，用于持久化 MemTable 中尚未 Flush 的数据。具体写入 WAL 的格式可以参考 <a href="https://github.com/facebook/rocksdb/wiki/Write-Ahead-Log-File-Format">Write-Ahead-Log-File-Format</a> 及其对应实现 DBImpl::WriteToWAL 函数，本文及后续几期主要关注 WAL&#x2F;MemTable 的生命周期管理。</p><h3 id="PreprocessWrite"><a href="#PreprocessWrite" class="headerlink" title="PreprocessWrite"></a>PreprocessWrite</h3><p>在写 WAL&#x2F;MemTable 之前，会先在 <code>DBImpl::PreprocessWrite</code> 函数中基于当前 RocksDB 的一些指标判断是否需要 Flush MemTable，创建新的 WAL&#x2F;MemTable 再接受本次写入：</p><ol><li>当前 WAL 的大小 <code>total_log_size_</code> 是否超过阈值 <code>DBOptions::max_total_wal_size</code></li><li>根据 write_buffer_manager_ 判断当前 MemTable 是否需要 Flush</li><li>flush_scheduler_.empty() 为 false，则说明上次某个 CF MemTable 写满了</li></ol><p>上述三种触发条件的处理方式，都需要先创建新的 WAL&#x2F;MemTable，然后生成 Flush 请求 flush_request，并且触发后台线程去消费该 flush_request。</p><ul><li>正常情况下，发起 Flush 请求后，不用等待后台 Flush 完成，新的 WAL&#x2F;MemTable 就可以继续接受后续读写请求，</li><li>但是如果写的压力过大，则会进一步限制，比如 DelayWrite，WriteStall，恢复正常后才会继续接受新的写入。</li></ul><p>上述三种的不同触发条件，不同在于如何选择 ColumnFamily。比如 条件（1）WAL 的大小超过阈值，则所有 ColumnFamilys 都需要进行更换 WAL&#x2F;MemTable；而条件（3）则只是需要某个具体的 CF MemTable 满了。因此只是 FlushReason 不同，处理过程都类似。</p><p>下面针对核心处理流程开始讲解。</p><h3 id="SwitchMemTable"><a href="#SwitchMemTable" class="headerlink" title="SwitchMemTable"></a>SwitchMemTable</h3><p>SwitchMemtable 函数是针对具体的 ColumnFamily 创建 WAL&#x2F;MemTable ，因此需要上层先筛选出需要切换 MemTable 的 CF，再传递给此函数。</p><p>由前文可知，进入 PreprocessWrite 函数时已经是单线程操作，而 SwitchMemtable 函数仍需要在 <code>DBImpl::_mutex</code> 的保护下才能调用，这是为了与后台 Flush 线程互斥。</p><p>根据 <code>log_empty_</code> 字段来判断是否需要创建新的 WAL，即当前 WAL 是否有数据写入，如果没有则不创建新的 WAL。主要是可能要为多个 CFs 创建新的 WAL&#x2F;MemTable，但是 WAL 是共享的，只需要第一次创建 WAL 即可，后续的 ColumnFamily 检测到 <code>log_empty_</code> 为空，则不再重复创建。</p><p>每个 WAL 都有一个对应的编号 <code>logfile_num</code>，由 <code>VersionSet::NewFileNumber</code> 函数来生成。</p><p><em>DBOptions::recycle_log_file_num</em> 决定是否复用生命周期已结束的 WALs，<code>log_recycle_files_</code> 字段用于保存生命周期已结束待删除的 WALs。此如果 <code>recycle_log_file_num &gt; 0</code> 则按照 FIFO 规则从 <code>log_recycle_files_</code> 取出生命周期最早结束的 WAL 的 logfile_number，因此可以 truncate 旧 WAL 文件再接受新数据。</p><p>在 RocksDB 中，数据存储目录在 <em>DBOptions::wal_dir</em>，其值就是 db_name，每个 WAL 文件名就是<code>wal_dir</code>+<code>logfile_number</code>+<code>.log</code>。因此，后文一般提及 log 都是指 WAL 文件。</p><p>比如：编译完 RocksDB，并执行 <em>build&#x2F;examples&#x2F;simple_example</em>，在 <em>&#x2F;tmp&#x2F;rocksdb_simple_example</em> 目录下会有如下以 log 为后缀的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ll /tmp/rocksdb_simple_example</span><br><span class="line">total 1832</span><br><span class="line">-rw-r--r-- 1 root root  1045 Jul 10 08:27 000326.sst</span><br><span class="line">-rw-r--r-- 1 root root   999 Jul 24 14:17 000331.sst</span><br><span class="line">-rw-r--r-- 1 root root    68 Jul 24 14:18 000332.<span class="built_in">log</span></span><br><span class="line">-rw-r--r-- 1 root root   999 Jul 24 14:18 000336.sst</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p><code>log_recycle_files_</code> 等字段会收到 FlushJob 的影响，因此需要在 <code>DBImpl::mutex_</code> 的保护下调用。而 CreateWAL 只是影响局部变量 new_log，不需要 mutex_ 保护，同理构建新的 MemTable 对象 new_mem 也不需要 mutex_。</p><p>下面是创建 new_log 和 new_mem 的核心代码及其注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::SwitchMemtable</span><span class="params">(ColumnFamilyData* cfd, WriteContext* context)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  log::Writer* new_log = <span class="literal">nullptr</span>;</span><br><span class="line">  MemTable* new_mem = <span class="literal">nullptr</span>;</span><br><span class="line">  IOStatus io_s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免多个 CFs 创建不同的 WAL</span></span><br><span class="line">  <span class="type">bool</span> creating_new_log = !log_empty_;</span><br><span class="line">  <span class="type">uint64_t</span> recycle_log_number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (creating_new_log &amp;&amp; immutable_db_options_.recycle_log_file_num &amp;&amp;</span><br><span class="line">      !log_recycle_files_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    recycle_log_number = log_recycle_files_.<span class="built_in">front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint64_t</span> new_log_number =</span><br><span class="line">      creating_new_log ? versions_-&gt;<span class="built_in">NewFileNumber</span>() : logfile_number_;</span><br><span class="line">  <span class="type">const</span> MutableCFOptions mutable_cf_options = *cfd-&gt;<span class="built_in">GetLatestMutableCFOptions</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为啥这个函数也需要保护 ???</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> preallocate_block_size =</span><br><span class="line">      <span class="built_in">GetWalPreallocateBlockSize</span>(mutable_cf_options.write_buffer_size);</span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 WAL</span></span><br><span class="line">  <span class="keyword">if</span> (creating_new_log) &#123;</span><br><span class="line">    io_s = <span class="built_in">CreateWAL</span>(new_log_number, recycle_log_number, preallocate_block_size,</span><br><span class="line">                     &amp;new_log);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// WAL 创建成功后，再创建 MemTable</span></span><br><span class="line"> <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    SequenceNumber seq = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">    new_mem = cfd-&gt;<span class="built_in">ConstructNewMemtable</span>(mutable_cf_options, seq);</span><br><span class="line">    context-&gt;superversion_context.<span class="built_in">NewSuperVersion</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用于 delete_range</span></span><br><span class="line">  cfd-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">ConstructFragmentedRangeTombstones</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// mutex_.Lock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CreateWAL"><a href="#CreateWAL" class="headerlink" title="CreateWAL"></a>CreateWAL</h4><p>WAL 的创建也比较简单，如代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOStatus <span class="title">DBImpl::CreateWAL</span><span class="params">(<span class="type">uint64_t</span> log_file_num, <span class="type">uint64_t</span> recycle_log_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">size_t</span> preallocate_block_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                           log::Writer** new_log)</span> </span>&#123;</span><br><span class="line">  IOStatus io_s;</span><br><span class="line">  std::unique_ptr&lt;FSWritableFile&gt; lfile;</span><br><span class="line"></span><br><span class="line">  DBOptions db_options =</span><br><span class="line">      <span class="built_in">BuildDBOptions</span>(immutable_db_options_, mutable_db_options_);</span><br><span class="line">  FileOptions opt_file_options =</span><br><span class="line">      fs_-&gt;<span class="built_in">OptimizeForLogWrite</span>(file_options_, db_options);</span><br><span class="line">  std::string wal_dir = immutable_db_options_.<span class="built_in">GetWalDir</span>();</span><br><span class="line">  std::string log_fname = <span class="built_in">LogFileName</span>(wal_dir, log_file_num);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 生成底层 wal 文件</span></span><br><span class="line">  <span class="keyword">if</span> (recycle_log_number) &#123;</span><br><span class="line">    std::string old_log_fname = <span class="built_in">LogFileName</span>(wal_dir, recycle_log_number);</span><br><span class="line">    io_s = fs_-&gt;<span class="built_in">ReuseWritableFile</span>(log_fname, old_log_fname, opt_file_options,</span><br><span class="line">                                  &amp;lfile, <span class="comment">/*dbg=*/</span><span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    io_s = <span class="built_in">NewWritableFile</span>(fs_.<span class="built_in">get</span>(), log_fname, &amp;lfile, opt_file_options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    lfile-&gt;<span class="built_in">SetWriteLifeTimeHint</span>(<span class="built_in">CalculateWALWriteHint</span>());</span><br><span class="line">    lfile-&gt;<span class="built_in">SetPreallocationBlockSize</span>(preallocate_block_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; listeners = immutable_db_options_.listeners;</span><br><span class="line">    FileTypeSet tmp_set = immutable_db_options_.checksum_handoff_file_types;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建写 wal 的 writer</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;WritableFileWriter&gt; <span class="title">file_writer</span><span class="params">(<span class="keyword">new</span> WritableFileWriter(</span></span></span><br><span class="line"><span class="params"><span class="function">        std::move(lfile), log_fname, opt_file_options,</span></span></span><br><span class="line"><span class="params"><span class="function">        immutable_db_options_.clock, io_tracer_, <span class="literal">nullptr</span> <span class="comment">/* stats */</span>, listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="literal">nullptr</span>, tmp_set.Contains(FileType::kWalFile),</span></span></span><br><span class="line"><span class="params"><span class="function">        tmp_set.Contains(FileType::kWalFile)))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 封装 log_writer</span></span><br><span class="line">    *new_log = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(std::<span class="built_in">move</span>(file_writer), log_file_num,</span><br><span class="line">                               immutable_db_options_.recycle_log_file_num &gt; <span class="number">0</span>,</span><br><span class="line">                               immutable_db_options_.manual_wal_flush,</span><br><span class="line">                               immutable_db_options_.wal_compression);</span><br><span class="line">    io_s = (*new_log)-&gt;<span class="built_in">AddCompressionTypeRecord</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> io_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConstructNewMemtable"><a href="#ConstructNewMemtable" class="headerlink" title="ConstructNewMemtable"></a>ConstructNewMemtable</h4><p>WAL 创建成功后，由 MemTable 所属的 ColumnFamily 构建 MemTable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MemTable* <span class="title">ColumnFamilyData::ConstructNewMemtable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options, SequenceNumber earliest_seq)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_, ioptions_, mutable_cf_options,</span><br><span class="line">                      write_buffer_manager_, earliest_seq, id_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ColumnFamily"><a href="#ColumnFamily" class="headerlink" title="ColumnFamily"></a>ColumnFamily</h3><p>上面 new_log, new_mem 成功创建完后，下面对 ColumnFamily 的 WAL&#x2F;MemTable 相关的元信息进行更新。</p><p>首先需要将当前 cur_log_writer 中已有的数据 flush 到操作系统中。实际上在 LogWriter::AddRecord 内部，每次写完都会进行一次 flush，将数据刷操作系统page cache 中，由操作系统决定何时将数据写入文件。flush 只能保证 RocksDB 进程中途挂了再重启数据不会丢，但是如果机器挂了数据还是有丢的可能，如果想要进一步保证安全就需要 sync 操作，将操作系统缓存层的数据同步到磁盘，很显然这个操作会拖慢写入速度。RocksDB 也配置了开启选项 <em>WriteOptions::sync: bool</em>，默认 false。</p><p><code>logs_</code>字段是个map，映射关系是{logfile_number_, log_writer}，记录了每一个log_writer及其对应的logfile_number，<code>alive_log_files_</code>记录是 logfile_number及其log_writer写入的数据量大小。由于 WAL 的生命周期和 ColumnFamily 有关，因此需要 <code>logs_</code> 和 <code>alive_log_files_</code> 来记录一个 RocksDB 实例中所有生命周期尚未结束的 WALs。</p><p>因此，当创建了新的 WAL ，需要在 log_write_mutex_ 的保护下添加新的记录。后续 FLushJob 完成了，也会相应删除生命周期结束的 WAL 记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//... above code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面 Unlock, 现在恢复 Lock</span></span><br><span class="line">mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"><span class="keyword">if</span> (recycle_log_number != <span class="number">0</span>) &#123;</span><br><span class="line">  log_recycle_files_.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; creating_new_log) &#123;</span><br><span class="line">  <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;log_write_mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 1. Flush</span></span><br><span class="line">  <span class="keyword">if</span> (!logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    log::Writer* cur_log_writer = logs_.<span class="built_in">back</span>().writer;</span><br><span class="line">    io_s = cur_log_writer-&gt;<span class="built_in">WriteBuffer</span>();</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. Flush 成功后，更新 log 相关元信息</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    logfile_number_ = new_log_number;</span><br><span class="line">    log_empty_ = <span class="literal">true</span>;</span><br><span class="line">    log_dir_synced_ = <span class="literal">false</span>;</span><br><span class="line">    logs_.<span class="built_in">emplace_back</span>(logfile_number_, new_log);</span><br><span class="line">    alive_log_files_.<span class="built_in">push_back</span>(<span class="built_in">LogFileNumberSize</span>(logfile_number_));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前置工作已经完成，下面要开始更新 ColumnFaimly了。</p><p>由于传递给 SwitchMemTable 的 CF 并非都是因为自己的 MemTable 满了，可能是因为某个 CF0 把 WAL 写满了，导致所有的 MmeTable 都要切换，比如上述条件（1）。有些 CF1 可能仍然是空的，此时就需要更新 CF1 当前的 LogNumber。 这样就可以删除 CF1 之前指向的 WAL。</p><p>比如：CF0，CF1 当前都指向 log1，由于 CF0 一直写入数据，导致 log1 满了。此时需要创建新的 WAL 文件 log2。但是 CF1 一直没有写入数据，此时同步将 CF1 当前 log 指针 <code>log_number_</code> 指向 log2，使得指向 log1 的引用就是0，因此就可以在 MemTable 完成 Flush 完成后，将 log1 删除。</p><p>其余解释见代码，这部分代码简化如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...above code</span></span><br><span class="line"><span class="type">bool</span> empty_cf_updated = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!empty_cf_updated) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> cf : *versions_-&gt;<span class="built_in">GetColumnFamilySet</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cf-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (creating_new_log) &#123;</span><br><span class="line">        cf-&gt;<span class="built_in">SetLogNumber</span>(logfile_number_);</span><br><span class="line">      &#125;</span><br><span class="line">      cf-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">SetCreationSeq</span>(versions_-&gt;<span class="built_in">LastSequence</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CF 当前 Memtable 下一个活跃的 logfile_numer_，</span></span><br><span class="line"><span class="comment">// 选择需要 Flush 的 ImmutableMemTables 使用</span></span><br><span class="line">cfd-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">SetNextLogNumber</span>(logfile_number_);</span><br><span class="line"><span class="comment">// 将当前 Memtable 添加到 ImmutableMemTable 链表中，等待 Flush 删除。</span></span><br><span class="line">cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">Add</span>(cfd-&gt;<span class="built_in">mem</span>(), &amp;context-&gt;memtables_to_free_);</span><br><span class="line"><span class="comment">// 设置新的 MemTable</span></span><br><span class="line">new_mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">cfd-&gt;<span class="built_in">SetMemtable</span>(new_mem);</span><br><span class="line"><span class="comment">// 更新 superversion</span></span><br><span class="line"><span class="built_in">InstallSuperVersionAndScheduleWork</span>(cfd, &amp;context-&gt;superversion_context,</span><br><span class="line">                                   mutable_cf_options);</span><br></pre></td></tr></table></figure><h4 id="GenerateFlushRequest"><a href="#GenerateFlushRequest" class="headerlink" title="GenerateFlushRequest"></a>GenerateFlushRequest</h4><p>SwitchMemTable，完成了 WAL&#x2F;MemTable 的切换。紧接着就会尝试发起一次 flush 请求。Flush 的对象是从每个 CF 的 ImmutableMemtables 中提取的，因此 FlushRequest 需要保存每个 CF 的 max_memtable_id。</p><p>CF 中的每个 MemTable 都有一个单增的 <code>id_</code>，用于追踪 Flush。在使用 <code>ColumnFamilyData::SetMemtable</code> 函数添加到 CF 中时更新 <code>MemTable::id_</code> 字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::GenerateFlushRequest</span><span class="params">(<span class="type">const</span> autovector&lt;ColumnFamilyData*&gt;&amp; cfds,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  FlushReason flush_reason, FlushRequest* req)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(req != <span class="literal">nullptr</span>);</span><br><span class="line">  req-&gt;flush_reason = flush_reason;</span><br><span class="line">  req-&gt;cfd_to_max_mem_id_to_persist.<span class="built_in">reserve</span>(cfds.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> cfd : cfds) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == cfd) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// max_memtable_id 即最新加入 ImmutableMemtables 的 memtable 的 Id</span></span><br><span class="line">    <span class="type">uint64_t</span> max_memtable_id = cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">GetLatestMemTableID</span>();</span><br><span class="line">    req-&gt;cfd_to_max_mem_id_to_persist.<span class="built_in">emplace</span>(cfd, max_memtable_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SchedulePendingFlush"><a href="#SchedulePendingFlush" class="headerlink" title="SchedulePendingFlush"></a>SchedulePendingFlush</h4><p> <code>flush_queue_</code> 用于保存MemTables的Flush请求，<code>SchedulePendingFlush</code> 将上述生成的flush请求压入flush_queue_，再调度后台任务线程从 flush_queue_中取出FlushRequest执行。</p><p>这里也有个设计，如果开启了 <em>DBOptions::atomic_flush</em> 则会让多个 CFs 的 Flush 请求放到一个线程去执行，这样就可以保证 Flush 的原子性。否则，每次只 flush。但是其默认值为 false，因为只要开启了 WAL，就能保证跨多个 CFs 的写操作是原子性的，即便 flush 操作挂了也还有 WAL 可以恢复。</p><p>部分代码如下。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::SchedulePendingFlush</span><span class="params">(<span class="type">const</span> FlushRequest&amp; flush_req)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">if</span> (flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!immutable_db_options_.atomic_flush) &#123;</span><br><span class="line">    <span class="comment">// only one</span></span><br><span class="line">    <span class="built_in">assert</span>(flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">size</span>() == <span class="number">1</span>);</span><br><span class="line">    ColumnFamilyData* cfd =</span><br><span class="line">        flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">begin</span>()-&gt;first;</span><br><span class="line">    <span class="keyword">if</span> (!cfd-&gt;<span class="built_in">queued_for_flush</span>() &amp;&amp; cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">IsFlushPending</span>()) &#123;</span><br><span class="line">      cfd-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">      cfd-&gt;<span class="built_in">set_queued_for_flush</span>(<span class="literal">true</span>);</span><br><span class="line">      ++unscheduled_flushes_;</span><br><span class="line">      flush_queue_.<span class="built_in">push_back</span>(flush_req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [cfd, _] : flush_req.cfd_to_max_mem_id_to_persist) &#123;</span><br><span class="line">      cfd-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ++unscheduled_flushes_;</span><br><span class="line">    flush_queue_.<span class="built_in">push_back</span>(flush_req);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MaybeScheduleFlushOrCompaction"><a href="#MaybeScheduleFlushOrCompaction" class="headerlink" title="MaybeScheduleFlushOrCompaction"></a>MaybeScheduleFlushOrCompaction</h4><p>RocksDB 的后台任务线程调度是主动触发的，并没有 loop 线程在阻塞等待 <code>flush_queue_</code> 加入新元素后就从 <code>flush_queue_</code> 提取请求去执行。</p><p>因此，在向 <code>flush_req</code> 加入有新请求后，需要主动通过 <code>MaybeScheduleFlushOrCompaction</code> 函数调度后台线程执行 <code>DBImpl::BackgroundCallFlush</code> 函数执行 FlushRequest 请求。</p><p>最大后台任务有 <code>bg_job_limits</code> 限制，<code>unscheduled_flushes_</code> 表征当前有多少待 flush 的请求，<code>bg_flush_scheduled_</code> 表征当前已经调度了多少 flush 请求，配合 <code>bg_job_limits</code> 参数限制后台 flush 任务。</p><p><code>DBImpl::BGWorkFlush</code> 函数用于执行 FlushRequest，<code>DBImpl::UnscheduleFlushCallback</code> 函数则是执行 FlushRequest 完的回调函数，用于释放 <code>FlushThreadArg</code> 对象。</p><p><code>MaybeScheduleFlushOrCompaction</code> 函数执行，是个分界点：</p><ul><li>提交完 Flush 请求后，如果没有触发 DelayWrite，WriteStall，就会接受新的读写请求了；</li><li>后台线程池接受到 <code>BGWorkFlush</code> 请求后，就开始执行 FlushReqeust</li></ul><p>这部分相关代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MaybeScheduleFlushOrCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="comment">//... precondition check</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bg_job_limits = <span class="built_in">GetBGJobLimits</span>();</span><br><span class="line">  <span class="type">bool</span> is_flush_pool_empty =</span><br><span class="line">      env_-&gt;<span class="built_in">GetBackgroundThreads</span>(Env::Priority::HIGH) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!is_flush_pool_empty &amp;&amp; unscheduled_flushes_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         bg_flush_scheduled_ &lt; bg_job_limits.max_flushes) &#123;</span><br><span class="line">    bg_flush_scheduled_++;</span><br><span class="line">    FlushThreadArg* fta = <span class="keyword">new</span> FlushThreadArg;</span><br><span class="line">    fta-&gt;db_ = <span class="keyword">this</span>;</span><br><span class="line">    fta-&gt;thread_pri_ = Env::Priority::HIGH;</span><br><span class="line">    env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWorkFlush, fta, Env::Priority::HIGH, <span class="keyword">this</span>,</span><br><span class="line">                   &amp;DBImpl::UnscheduleFlushCallback);</span><br><span class="line">    --unscheduled_flushes_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_flush_pool_empty) &#123;</span><br><span class="line">    <span class="keyword">while</span> (unscheduled_flushes_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           bg_flush_scheduled_ + bg_compaction_scheduled_ &lt;</span><br><span class="line">               bg_job_limits.max_flushes) &#123;</span><br><span class="line">      bg_flush_scheduled_++;</span><br><span class="line">      FlushThreadArg* fta = <span class="keyword">new</span> FlushThreadArg;</span><br><span class="line">      fta-&gt;db_ = <span class="keyword">this</span>;</span><br><span class="line">      fta-&gt;thread_pri_ = Env::Priority::LOW;</span><br><span class="line">      env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWorkFlush, fta, Env::Priority::LOW, <span class="keyword">this</span>,</span><br><span class="line">                     &amp;DBImpl::UnscheduleFlushCallback);</span><br><span class="line">      --unscheduled_flushes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//.. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BackgroundCallFlush"><a href="#BackgroundCallFlush" class="headerlink" title="BackgroundCallFlush"></a>BackgroundCallFlush</h3><p>DBImpl::BGWorkFlush 只是个 <code>BackgroundCallFlush</code> 的 wrapper。 进入 <code>BackgroundCallFlush</code> 函数后，需要获取 <code>DBImpl::mutex_</code> 来执行 <code>BackgroundFlush</code>，执行成功后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::BackgroundCallFlush</span><span class="params">(Env::Priority thread_pri)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> made_progress = <span class="literal">false</span>;</span><br><span class="line">  <span class="function">JobContext <span class="title">job_context</span><span class="params">(next_job_id_.fetch_add(<span class="number">1</span>), <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 需要 DBImpl::mutex_</span></span><br><span class="line">    <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>; </span><br><span class="line">    num_running_flushes_++;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;std::list&lt;<span class="type">uint64_t</span>&gt;::iterator&gt;</span><br><span class="line">        <span class="built_in">pending_outputs_inserted_elem</span>(<span class="keyword">new</span> std::list&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">iterator</span>(</span><br><span class="line">            <span class="built_in">CaptureCurrentFileNumberInPendingOutputs</span>()));</span><br><span class="line">    FlushReason reason;</span><br><span class="line"></span><br><span class="line">    Status s = <span class="built_in">BackgroundFlush</span>(&amp;made_progress, &amp;job_context, &amp;log_buffer,</span><br><span class="line">                               &amp;reason, thread_pri);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(num_running_flushes_ &gt; <span class="number">0</span>);</span><br><span class="line">    num_running_flushes_--;</span><br><span class="line">    bg_flush_scheduled_--;</span><br><span class="line">    <span class="comment">// See if there&#x27;s more work to be done</span></span><br><span class="line">    <span class="built_in">MaybeScheduleFlushOrCompaction</span>();</span><br><span class="line">    atomic_flush_install_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">    bg_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BackgroundFlush"><a href="#BackgroundFlush" class="headerlink" title="BackgroundFlush"></a>BackgroundFlush</h4><p><code>PopFirstFromFlushQueue</code> 函数从 <code>flush_request_</code> 中取出待 Flush 的请求，过滤掉不符合条件的的CF，符合结果的存在 <code>bg_flush_args</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::BackgroundFlush</span><span class="params">(<span class="type">bool</span>* made_progress, JobContext* job_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                               LogBuffer* log_buffer, FlushReason* reason,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Env::Priority thread_pri)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  autovector&lt;BGFlushArg&gt; bg_flush_args;</span><br><span class="line">  std::vector&lt;SuperVersionContext&gt;&amp; superversion_contexts =</span><br><span class="line">      job_context-&gt;superversion_contexts;</span><br><span class="line">  autovector&lt;ColumnFamilyData*&gt; column_families_not_to_flush;</span><br><span class="line">  <span class="keyword">while</span> (!flush_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// This cfd is already referenced</span></span><br><span class="line">    <span class="keyword">auto</span> [flush_reason, cfd_to_max_mem_id_to_persist] =</span><br><span class="line">        <span class="built_in">PopFirstFromFlushQueue</span>();</span><br><span class="line">    superversion_contexts.<span class="built_in">clear</span>();</span><br><span class="line">    superversion_contexts.<span class="built_in">reserve</span>(cfd_to_max_mem_id_to_persist.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [cfd, max_mem_id] : cfd_to_max_mem_id_to_persist) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cfd-&gt;<span class="built_in">GetMempurgeUsed</span>()) &#123;</span><br><span class="line">        cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">FlushRequested</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cfd-&gt;<span class="built_in">IsDropped</span>() || !cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">IsFlushPending</span>()) &#123;</span><br><span class="line">        <span class="comment">// can&#x27;t flush this CF, try next one</span></span><br><span class="line">        column_families_not_to_flush.<span class="built_in">push_back</span>(cfd);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      superversion_contexts.<span class="built_in">emplace_back</span>(<span class="built_in">SuperVersionContext</span>(<span class="literal">true</span>));</span><br><span class="line">      bg_flush_args.<span class="built_in">emplace_back</span>(cfd, max_mem_id,</span><br><span class="line">                                 &amp;(superversion_contexts.<span class="built_in">back</span>()), flush_reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有待 Flush 的 CF</span></span><br><span class="line">    <span class="keyword">if</span> (!bg_flush_args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得具有 Flush 条件的 <code>bg_flush_args</code>，下面就是真正的准备执行 FlushJob。<code>FlushJob</code> 由 <code>FlushMemTablesToOutputFiles</code> 函数执行，这个后续再讲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (!bg_flush_args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span> bg_job_limits = <span class="built_in">GetBGJobLimits</span>();</span><br><span class="line">  status = <span class="built_in">FlushMemTablesToOutputFiles</span>(bg_flush_args, made_progress,</span><br><span class="line">                                       job_context, log_buffer, thread_pri);</span><br><span class="line">  *reason = bg_flush_args[<span class="number">0</span>].flush_reason_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; arg : bg_flush_args) &#123;</span><br><span class="line">    ColumnFamilyData* cfd = arg.cfd_;</span><br><span class="line">    <span class="keyword">if</span> (cfd-&gt;<span class="built_in">UnrefAndTryDelete</span>()) &#123;</span><br><span class="line">      arg.cfd_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> cfd : column_families_not_to_flush) &#123;</span><br><span class="line">  cfd-&gt;<span class="built_in">UnrefAndTryDelete</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;WAL 在 DB::Open 时就会创建，用于持久化 MemTable 中尚未 Flush 的数据。具体写入 WAL 的格式可以参考 &lt;a href=&quot;https://github.com/facebook/rocksdb/wiki/Write-Ahead-Log-File</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WriteThread 如何使用 Pipeline 提升写入吞吐，降低延迟</title>
    <link href="https://szza.github.io/2022/02/13/rocksdb/WritePath/write_thread_4/"/>
    <id>https://szza.github.io/2022/02/13/rocksdb/WritePath/write_thread_4/</id>
    <published>2022-02-13T06:15:35.000Z</published>
    <updated>2023-08-03T04:44:19.930Z</updated>
    
    <content type="html"><![CDATA[<p>在前面几篇讲解了从 WriteBatch 的内部序列化流程 和 WriteThread 如何控制并发写入的基本流程，本文进一步讲解 WriteThread 如何使用 PipelinedWrite 来提升写吞吐，其中和前文相似的逻辑不再细说。</p><p>通过设置选项 <code>DBOptions::enable_pipelined_write = true</code> 来开启，开启后整个db的 WriteThread 都是通过 PipelinedWrite 方式控制写入流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (immutable_db_options_.enable_pipelined_write) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">PipelinedWriteImpl</span>(write_options, my_batch, callback, log_used,</span><br><span class="line">                            log_ref, disable_memtable, seq_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WAL-Pipelined-Write"><a href="#WAL-Pipelined-Write" class="headerlink" title="WAL: Pipelined Write"></a>WAL: Pipelined Write</h4><p>在之前的 WriteThread 写入控制流程中， 是依次有序地将数据写入 WAL 和 MemTable，那么如何使得 WAL 和 MemTable 的写入操作并行起来？</p><p>在多个 writers 并发写入同一个 RocksdB 实例时，只要前一个 <code>writer_group0</code> 将数据写入 WAL 了，那么下一个 <code>writer_group1</code> 就不必等待 writer_group0 完成 MemTable 写入流程，writer_group1 就可以开始自己的 WAL 写入流程: 因此 writer_group0 的 MemTable 写流程和 writer_group1 的 WAL 写流程就可以并行起来。</p><p>上述就是 <code>PipelinedWrite</code> 的核心思想。因此 PipelinedWrite 需要开启 WAL，来保证 writer_group0 写入 WAL 的数据不会丢。</p><h4 id="MemTable-Concurrent-Write"><a href="#MemTable-Concurrent-Write" class="headerlink" title="MemTable: Concurrent Write"></a>MemTable: Concurrent Write</h4><p>已经写入 WAL 的数据不会丢，那么是否可以在写入 MemTable 时，允许多个 writers 并发地写 MemTable，而不是原先由 leader-writer 来完成 memtable_write_group 的写入？</p><p>选项 <code>DBOptions::allow_concurrent_memtable_write</code> 默认值为 true，即默认支持并发写入 MemTable，但实际上当前只有基于 skiplist 实现的 MemTable 才支持这一特性（ <code>SkipListRep</code> 也是 MemTable 的默认实现）。</p><p>因此，在写路径使用 <code>PipelineWrite</code> 实现时，实际上就有了两种优化：</p><ul><li>WriteGroup 之间可以 Pipeline</li><li>MemTable 可以并发写入</li></ul><p>从实现角度，可以粗略地将有 <code>PipelinedWriteImpl</code> 函数划分成三个阶段（任务）:</p><ul><li><p>T1：完成当前 write_group0 的 WAL 写入流程，</p></li><li><p>T2：通知 write_group1 开启 WAL 写入流程，即 write_group1 无需等待 write_group0 完成 MemTable 写入流程才开启自己的 WAL 写入流程；</p></li><li><p>T3：write_group0 的 WAL 写入流程完成后，需要启动 write_group0 的并发写 MemTable 流程。</p><p>实际上，在 T3 阶段可能会携带其他 write_group 的 writers 一起进入 T3 阶段，来提升性能，详情见后文。</p></li></ul><p>由于后两个任务都需要等待第一个任务完成，因此三个任务的分界点就可以设置在 <code>WrriteThread::ExitAsBatchGroupLeader</code> 函数中: T1 在写 WAL 期间需要整个 RocksDB 只有一个 leader-writer，在 T1 任务结束后就可以不再担任 leader 角色。此时有两件事需要做 <em>1）</em> 挑选出下一个 WriteGroup 中的 leader-writer，让 T2 任务可以 pipeline 执行；<em>2）</em> 开启当前 WriteGroup 并发写入 MemTable 流程。</p><p>整个设计如下图：</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_write_thread_4_1.png?raw=true" alt="write_path_4_1"></p><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>T1 任务的流程和 <a href="https://szza.github.io/2022/01/15/rocksdb/WritePath/write_thread_2/">WriteThread 如何控制并发写入流程</a> 的基本一致，都需要经过 <code>JoinBatchGroup</code> -&gt; <code>EnterAsBatchGroupLeader</code> -&gt; <code>ExitAsBatchGroupLeader</code>， 只是将原来 leader-writer 作用范围（WriteToWAL 和 MemTable::Add） 范围缩小到了仅有 WALs。</p><p>因此，只有当 <code>JoinBatchGroup</code> 函数返回的 writer 是 leader-writer 时才会进入 WAL 写流程，而且当前 write_group0 的其他 writers 和后续 write_group1 等都会阻塞在 <code>JoinBatchGroupl</code> 函数处。</p><p>具体的阻塞逻辑可以参考 <a href="https://szza.github.io/2022/02/02/rocksdb/WritePath/write_thread_3/">WriteThread 如何自适应优化线程同步</a>。PipelineWriteImpl 的函数入口代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WriteThread::Writer <span class="title">w</span><span class="params">(write_options, my_batch, callback, log_ref,</span></span></span><br><span class="line"><span class="params"><span class="function">                      disable_memtable, <span class="comment">/*_batch_cnt=*/</span><span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="comment">/*_pre_release_callback=*/</span><span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">write_thread_.<span class="built_in">JoinBatchGroup</span>(&amp;w);</span><br><span class="line"><span class="keyword">if</span> (w.state == WriteThread::STATE_GROUP_LEADER) &#123;</span><br><span class="line">  WriteThread::WriteGroup wal_write_group;</span><br><span class="line">  last_batch_group_size_ =</span><br><span class="line">      write_thread_.<span class="built_in">EnterAsBatchGroupLeader</span>(&amp;w, &amp;wal_write_group);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w.status.<span class="built_in">ok</span>() &amp;&amp; !write_options.disableWAL) &#123;</span><br><span class="line">    <span class="comment">// 将当前 wal_write_group 数据写入 WAL</span></span><br><span class="line">    io_s =</span><br><span class="line">        <span class="built_in">WriteToWAL</span>(wal_write_group, log_context.writer, log_used,</span><br><span class="line">                   log_context.need_log_sync, log_context.need_log_dir_sync,</span><br><span class="line">                   current_sequence, log_file_number_size);</span><br><span class="line">    w.status = io_s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  write_thread_.<span class="built_in">ExitAsBatchGroupLeader</span>(wal_write_group, w.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，PipelinedWrite 如何关联前后 writer_group 的核心就在 <code>ExitAsBatchGroupLeader</code> 函数中了。</p><h4 id="ExitAsBatchGroupLeader"><a href="#ExitAsBatchGroupLeader" class="headerlink" title="ExitAsBatchGroupLeader"></a>ExitAsBatchGroupLeader</h4><p>在前文 <a href="https://szza.github.io/2022/01/15/rocksdb/WritePath/write_thread_2">WriteThread 如何控制并发写入流程</a> 已经详细讲解了 <code>ExitAsBatchGroupLeader</code> 函数在 <code>enable_pipelined_write == false</code> 时的执行流程，下面来讲另一个分支。主要有两个任务：</p><ul><li><p>T2：选出下一个 write_group1 中的 leader-writer，使其也进入写 WAL 流程</p></li><li><p>T3：由 <code>CompleteLeader</code> 和 <code>CompleteFollower</code> 函数提前将不用写入 MemTable 的 writrs 从 write_group0 链表中删除。将 <code>write_group0</code> 中剩余的 writers 移动到 <code>newest_memtable_writer_</code> 指向的链表。</p><p>只有 leader-memtable-writer 才能开启并发写 MemTable 的流程，<code>w-&gt;state</code> 状态会变成 <code>STATE_MEMTABLE_WRITER_LEADER</code>。</p><p>如果此时多个 write_group（wg0，wg1）的 leader-writer 都想变成 leader-memtable-writer，假设最终 wg0-&gt;leader 成功，则新的 memtable_write_group 实际上会包含 (wg0, wg1)，并且 wg1-&gt;link_older &#x3D; wg0 的方式串联起来。</p><p>接着，leader-memtable-writer 通过 <code>LaunchParallelMemTableWriters</code> 函数来启动 <code>memtable_write_group</code> 并发写 MemTables 的流程，follower-writer 才会解除阻塞等待， 进入 MemTable::Add 写入流程。</p></li></ul><p>整体代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::ExitAsBatchGroupLeader</span><span class="params">(WriteGroup&amp; write_group,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Status&amp; status)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enable_pipelined_write_) &#123;</span><br><span class="line">    Writer dummy;</span><br><span class="line">    Writer* head = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="comment">// 1. 在当前 write_group0 和下一个 write_group1 中间插入一个 dummy 节点</span></span><br><span class="line">    <span class="keyword">if</span> (head != last_writer ||</span><br><span class="line">        !newest_writer_.<span class="built_in">compare_exchange_strong</span>(head, &amp;dummy)) &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">CreateMissingNewerLinks</span>(head);</span><br><span class="line">      <span class="built_in">assert</span>(last_writer-&gt;link_newer != <span class="literal">nullptr</span>);</span><br><span class="line">      last_writer-&gt;link_newer-&gt;link_older = &amp;dummy;</span><br><span class="line">      dummy.link_newer = last_writer-&gt;link_newer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提前删除不用写 MemTable 的 writers 节点</span></span><br><span class="line">    <span class="keyword">for</span> (Writer* w = last_writer; w != leader;) &#123;</span><br><span class="line">      Writer* next = w-&gt;link_older;</span><br><span class="line">      w-&gt;status = status;</span><br><span class="line">      <span class="keyword">if</span> (!w-&gt;<span class="built_in">ShouldWriteToMemtable</span>()) &#123;</span><br><span class="line">        <span class="built_in">CompleteFollower</span>(w, write_group);</span><br><span class="line">      &#125;</span><br><span class="line">      w = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!leader-&gt;<span class="built_in">ShouldWriteToMemtable</span>()) &#123;</span><br><span class="line">      <span class="built_in">CompleteLeader</span>(write_group);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 (T3) 将 write_group0 中剩余的 writers 转移到</span></span><br><span class="line">    <span class="comment">//     newest_memtable_writer_  指向的链表</span></span><br><span class="line">    <span class="keyword">if</span> (write_group.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">LinkGroup</span>(write_group, &amp;newest_memtable_writer_)) &#123;</span><br><span class="line">        <span class="comment">// 设置 leader-memtable-writer</span></span><br><span class="line">        <span class="built_in">SetState</span>(write_group.leader, STATE_MEMTABLE_WRITER_LEADER);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. (T2) 选取 writ_group1 中 leader-writer</span></span><br><span class="line">    head = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (head != &amp;dummy ||</span><br><span class="line">        !newest_writer_.<span class="built_in">compare_exchange_strong</span>(head, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      <span class="built_in">CreateMissingNewerLinks</span>(head);</span><br><span class="line">      Writer* new_leader = dummy.link_newer;</span><br><span class="line">      <span class="built_in">assert</span>(new_leader != <span class="literal">nullptr</span>);</span><br><span class="line">      new_leader-&gt;link_older = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="built_in">SetState</span>(new_leader, STATE_GROUP_LEADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 等待 leader-memtable-writer 调用 LaunchParallelMemTableWriters</span></span><br><span class="line">    <span class="built_in">AwaitState</span>(leader,</span><br><span class="line">               STATE_MEMTABLE_WRITER_LEADER | STATE_PARALLEL_MEMTABLE_WRITER |</span><br><span class="line">                   STATE_COMPLETED,</span><br><span class="line">               &amp;eabgl_ctx);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//... enable_pipelined_write_ == false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompleteFollower"><a href="#CompleteFollower" class="headerlink" title="CompleteFollower"></a>CompleteFollower</h4><p>WriteThread 是逆序从 <code>[last_writer, leader)</code> 来删除不需要写入 MemTable 的 writers-follower 节点。这个 write_group 的 writers list 首尾节点是 <code>leader</code> 和 <code>last_writer</code>。 CompleteFollower 删除的都是 followers 节点，因此在删除时需要注意下是不是尾部节点 last_writer 即可。</p><p>这里只需要将 w 从 write_group 中剔除即可，并不需要 delete w，而是将 <code>w-&gt;state</code> 状态设置为 <code>STATE_COMPLETED</code>。这是因为 w 这份资源由 w 所属的线程去释放，将其状态更改为 <code>STATE_COMPLETED</code> 后，w 所属的线程就会解除阻塞，去释放这份资源，回到应用层。</p><p><code>CompleteLeader</code> 逻辑也类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::CompleteFollower</span><span class="params">(Writer* w, WriteGroup&amp; write_group)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(write_group.size &gt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">assert</span>(w != write_group.leader);</span><br><span class="line">  <span class="keyword">if</span> (w == write_group.last_writer) &#123;</span><br><span class="line">    w-&gt;link_older-&gt;link_newer = <span class="literal">nullptr</span>;</span><br><span class="line">    write_group.last_writer = w-&gt;link_older;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    w-&gt;link_older-&gt;link_newer = w-&gt;link_newer;</span><br><span class="line">    w-&gt;link_newer-&gt;link_older = w-&gt;link_older;</span><br><span class="line">  &#125;</span><br><span class="line">  write_group.size -= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">SetState</span>(w, STATE_COMPLETED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkGroup"><a href="#LinkGroup" class="headerlink" title="LinkGroup"></a>LinkGroup</h4><p><code>LinkGroup</code> 函数的作用是将当前 write_group0 中需要向 MemTable 写数据的 writers 转移到 <code>newest_memtable_writer_</code> 中来，并且保持 write_group0 中的顺序。</p><ol><li><p>先断开 <code>(leader, last_writer]</code> 区间所有的 <code>w-&gt;link_newer/prev</code> 指针（leader-&gt;link_newer 已经是 NULL)。这是因为 <code>LinkGroup</code> 可能会将多个 WriteGroup 的 writers 串到一个 <code>newest_memtable_writer_</code> 指针中，后续需要重新建立 prev 指针。</p></li><li><p>通过 <code>compare_exchange_weak</code> 尝试让 <code>newest_memtable_writer_</code> 指向 <code>last_writer</code>。多个并发的 WriteGroup 通过 link_older 指针串联起来。</p><p> 因此，在 <code>ExitAsBatchGroupLeader</code> 函数末尾会有个 <code>AwaitState(leader, state)</code> 代码，用于阻塞那些被串在 memtable_write_group 中的 follower-memtable-writers，等待 leader-memtable-writer 调用 <code>LaunchParallelMemTableWriters</code> 函数才能解除阻塞。</p></li></ol><p>原理和 <code>LinkOne</code> 函数差不多，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteThread::LinkGroup</span><span class="params">(WriteGroup&amp; write_group,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::atomic&lt;Writer*&gt;* newest_writer)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader; <span class="comment">// head</span></span><br><span class="line">  Writer* last_writer = write_group.last_writer; <span class="comment">// tail</span></span><br><span class="line">  Writer* w = last_writer;</span><br><span class="line">  <span class="comment">// 1. 断开 [last_writer, leader) 区间 w-&gt;link_newer 指针</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    w-&gt;link_newer = <span class="literal">nullptr</span>;</span><br><span class="line">    w-&gt;write_group = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (w == leader) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    w = w-&gt;link_older;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 将 newest_writer 指向 last_writer</span></span><br><span class="line">  Writer* newest = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    leader-&gt;link_older = newest; <span class="comment">// leader-&gt;next = newest</span></span><br><span class="line">    <span class="keyword">if</span> (newest_writer-&gt;<span class="built_in">compare_exchange_weak</span>(newest, last_writer)) &#123;</span><br><span class="line">      <span class="comment">// newest_writer = last_writer</span></span><br><span class="line">      <span class="keyword">return</span> (newest == <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>T1 在 <code>ExitAsBatchGroupLeader</code> 函数中已经选出 write_group1 的 leader-writer， 因此不会等待 write_group0 完成，T2 就会直接启动。重复write_group0 的 T1 流程。</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>write_group0 执行完 T1 任务后就进入 T3 阶段，准备并发写 MemTables 操作。这个阶段的写流程如下:</p><p>leader-memtable-writer 会通过 <code>EnterAsMemTableWriter</code> 获取 <code>memtable_write_group</code>，</p><ul><li><p>如果 memtable_write_group 的 writers 数量大于 1 则调用 <code>LaunchParallelMemTableWriters</code> 函数启动所有的 writers 进入 MemTable::Add 阶段。</p></li><li><p>否则，当前 leader-memtable-writer 就直接写 MemTable。</p><p>写 MemTable 的操作是由 <code>WriteBatchInternal::InsertInto</code> 函数完成。</p></li></ul><p>而 follower-memtable-writers 会一直阻塞等待在两个的地方:</p><ul><li>当前 write_group0 的 followers 会阻塞在 PipelineWriteImpl 函数开始的 JoinBatchGroup 处</li><li>其他 write_group1 的 followers 会阻塞在 ExitAsBatchGroupLeader 函数末尾的 AwaitState 处</li></ul><p>因此，当 leader-memtable-writer 调用 <code>LaunchParallelMemTableWriters</code> 函数，则会解除上述两处阻塞状态的 writers，进入 T3 阶段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">WriteThread::WriteGroup memtable_write_group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (w.state == WriteThread::STATE_MEMTABLE_WRITER_LEADER) &#123;</span><br><span class="line">  <span class="comment">// memtable-writer-leader reach here</span></span><br><span class="line">  write_thread_.<span class="built_in">EnterAsMemTableWriter</span>(&amp;w, &amp;memtable_write_group);</span><br><span class="line">  <span class="keyword">if</span> (memtable_write_group.size &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">      immutable_db_options_.allow_concurrent_memtable_write) &#123;</span><br><span class="line">    write_thread_.<span class="built_in">LaunchParallelMemTableWriters</span>(&amp;memtable_write_group);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    memtable_write_group.status = WriteBatchInternal::<span class="built_in">InsertInto</span>(</span><br><span class="line">        memtable_write_group, w.sequence, column_family_memtables_.<span class="built_in">get</span>(),</span><br><span class="line">        &amp;flush_scheduler_, &amp;trim_history_scheduler_,</span><br><span class="line">        write_options.ignore_missing_column_families, <span class="number">0</span> <span class="comment">/*log_number*/</span>, <span class="keyword">this</span>,</span><br><span class="line">        <span class="literal">false</span> <span class="comment">/*concurrent_memtable_writes*/</span>, seq_per_batch_, batch_per_txn_);</span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(memtable_write_group.last_sequence);</span><br><span class="line">    write_thread_.<span class="built_in">ExitAsMemTableWriter</span>(&amp;w, memtable_write_group);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// memtable-writer-follower reach here</span></span><br><span class="line">  memtable_write_group.status.<span class="built_in">PermitUncheckedError</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EnterAsMemTableWriter"><a href="#EnterAsMemTableWriter" class="headerlink" title="EnterAsMemTableWriter"></a>EnterAsMemTableWriter</h4><p><code>EnterAsMemTableWriter</code> 函数和 <code>EnterAsBatchGroupLeader</code> 工作逻辑类似，从 <code>newest_memtable_writer_</code> 中取出memtable-writers，组成一个由 <code>[leader, last_writer]</code> 组成的 memtable_write_group。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::EnterAsMemTableWriter</span><span class="params">(Writer* leader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        WriteGroup* write_group)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> size = WriteBatchInternal::<span class="built_in">ByteSize</span>(leader-&gt;batch);</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  leader-&gt;write_group = write_group;</span><br><span class="line">  write_group-&gt;leader = leader;</span><br><span class="line">  write_group-&gt;size = <span class="number">1</span>;</span><br><span class="line">  Writer* last_writer = leader;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (allow_concurrent_memtable_write_ &amp;&amp; !leader-&gt;batch-&gt;<span class="built_in">HasMerge</span>()) &#123;</span><br><span class="line">    Writer* newest_writer = newest_memtable_writer_.<span class="built_in">load</span>();</span><br><span class="line">    <span class="built_in">CreateMissingNewerLinks</span>(newest_writer);</span><br><span class="line"></span><br><span class="line">    Writer* w = leader;</span><br><span class="line">    <span class="keyword">while</span> (w != newest_writer) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(w-&gt;link_newer);</span><br><span class="line">      w = w-&gt;link_newer;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w-&gt;batch == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w-&gt;batch-&gt;<span class="built_in">HasMerge</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      w-&gt;write_group = write_group;</span><br><span class="line">      last_writer = w;</span><br><span class="line">      write_group-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write_group-&gt;last_writer = last_writer;</span><br><span class="line">  write_group-&gt;last_sequence =</span><br><span class="line">      last_writer-&gt;sequence + WriteBatchInternal::<span class="built_in">Count</span>(last_writer-&gt;batch) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LaunchParallelMemTableWriters"><a href="#LaunchParallelMemTableWriters" class="headerlink" title="LaunchParallelMemTableWriters"></a>LaunchParallelMemTableWriters</h4><p><code>LaunchParallelMemTableWriters</code> 函数即遍历 <code>memtable_write_group</code> 中所有的 writers，将其 w-&gt;state 设置为 <code>STATE_PARALLEL_MEMTABLE_WRITER</code> 来解除阻塞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::LaunchParallelMemTableWriters</span><span class="params">(WriteGroup* memtable_write_group)</span> </span>&#123;</span><br><span class="line">  memtable_write_group-&gt;running.<span class="built_in">store</span>(memtable_write_group-&gt;size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> w : *memtable_write_group) &#123;</span><br><span class="line">    <span class="built_in">SetState</span>(w, STATE_PARALLEL_MEMTABLE_WRITER);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompleteParallelMemTableWriter"><a href="#CompleteParallelMemTableWriter" class="headerlink" title="CompleteParallelMemTableWriter"></a>CompleteParallelMemTableWriter</h4><p>所有的 <code>w-&gt;state</code> 都在 LaunchParallelMemTableWriters 函数中被更改 <code>STATE_PARALLEL_MEMTABLE_WRITER</code>，此时已经没有主从 writers 的概念。</p><p>每个 writer 都并发地调用 WriteBatchInternal::InsertInto 函数向 MemTable 写数据。每个 writer 写完 MemTable，都会调用一次 CompleteParallelMemTableWriter 来检测自己是不是 memtable_write_group 中最后一个完成写 MemTable 的 writer。最后一个 memtable-writers 在 <code>ExitAsMemTableWriter</code> 函数中做善后工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.state == WriteThread::STATE_PARALLEL_MEMTABLE_WRITER) &#123;</span><br><span class="line">  <span class="function">ColumnFamilyMemTablesImpl <span class="title">column_family_memtables</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      versions_-&gt;GetColumnFamilySet())</span></span>;</span><br><span class="line">  w.status = WriteBatchInternal::<span class="built_in">InsertInto</span>(</span><br><span class="line">      &amp;w, w.sequence, &amp;column_family_memtables, &amp;flush_scheduler_,</span><br><span class="line">      &amp;trim_history_scheduler_, write_options.ignore_missing_column_families,</span><br><span class="line">      <span class="number">0</span> <span class="comment">/*log_number*/</span>, <span class="keyword">this</span>, <span class="literal">true</span> <span class="comment">/*concurrent_memtable_writes*/</span>,</span><br><span class="line">      <span class="literal">false</span> <span class="comment">/*seq_per_batch*/</span>, <span class="number">0</span> <span class="comment">/*batch_cnt*/</span>, <span class="literal">true</span> <span class="comment">/*batch_per_txn*/</span>,</span><br><span class="line">      write_options.memtable_insert_hint_per_batch);</span><br><span class="line">  <span class="keyword">if</span> (write_thread_.<span class="built_in">CompleteParallelMemTableWriter</span>(&amp;w)) &#123;</span><br><span class="line">    <span class="built_in">MemTableInsertStatusCheck</span>(w.status);</span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(w.write_group-&gt;last_sequence);</span><br><span class="line">    write_thread_.<span class="built_in">ExitAsMemTableWriter</span>(&amp;w, *w.write_group);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次 memtable-writer 写完 MemTable，都会进入 <code>CompleteParallelMemTableWriter</code> 将 <code>memtable_write_group-&gt;running</code> 减 1: 如果不是最后一个 memtable-writer，则阻塞等待最后一个 memtable-writer 完成后在 <code>ExitAsMemTableWriter</code> 函数中将所有的 writers 状态更改为 STATE_COMPLETED，则本次并发写 MemTable 操作结束。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteThread::CompleteParallelMemTableWriter</span><span class="params">(Writer* w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* write_group = w-&gt;write_group;</span><br><span class="line">  <span class="keyword">if</span> (!w-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(write_group-&gt;leader-&gt;StateMutex())</span></span>;</span><br><span class="line">    write_group-&gt;status = w-&gt;status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_group-&gt;running-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// we&#x27;re not the last one</span></span><br><span class="line">    <span class="built_in">AwaitState</span>(w, STATE_COMPLETED, &amp;cpmtw_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// else we&#x27;re the last parallel worker and should perform exit duties.</span></span><br><span class="line">  w-&gt;status = write_group-&gt;status;</span><br><span class="line">  <span class="comment">// Callers of this function must ensure w-&gt;status is checked.</span></span><br><span class="line">  write_group-&gt;status.<span class="built_in">PermitUncheckedError</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ExitAsMemTableWriter"><a href="#ExitAsMemTableWriter" class="headerlink" title="ExitAsMemTableWriter"></a>ExitAsMemTableWriter</h4><p><code>ExitAsMemTableWriter</code> 函数和 <code>ExitAsBatchGroupLeader</code> 函数类似，主要有两个作用：</p><ul><li><p>选出下一轮 memtable_write_group1 的的 leader-memtable-writer，将其 state 设置为 <code>STATE_MEMTABLE_WRITER_LEADER</code>，使下一轮 memtable_write_group1 能尽快进入 T3 阶段；</p></li><li><p>将本轮 memtable_write_group0 的所有 memtable-writers 的状态更改为 <code>STATE_COMPLETED</code>，解除阻塞在 <code>CompleteParallelMemTableWriter</code> 函数处阻塞的 writers，让他们释放资源返回应用层。</p><p>这里需要让 leader-memtable-writer 最后一个退出，因为它拥有 memtable_write_group 所有权：如果它不是最后一个释放，会造成 <code>ExitAsMemTableWriter</code> 函数在执行过程中 coredump。</p></li></ul><p>这部分代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::ExitAsMemTableWriter</span><span class="params">(Writer* <span class="comment">/*self*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       WriteGroup&amp; write_group)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. </span></span><br><span class="line">  Writer* newest_writer = last_writer;</span><br><span class="line">  <span class="keyword">if</span> (!newest_memtable_writer_.<span class="built_in">compare_exchange_strong</span>(newest_writer,</span><br><span class="line">                                                       <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="built_in">CreateMissingNewerLinks</span>(newest_writer);</span><br><span class="line">    Writer* next_leader = last_writer-&gt;link_newer;</span><br><span class="line">    <span class="built_in">assert</span>(next_leader != <span class="literal">nullptr</span>);</span><br><span class="line">    next_leader-&gt;link_older = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">SetState</span>(next_leader, STATE_MEMTABLE_WRITER_LEADER);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.</span></span><br><span class="line">  Writer* w = leader;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!write_group.status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      w-&gt;status = write_group.status;</span><br><span class="line">    &#125;</span><br><span class="line">    Writer* next = w-&gt;link_newer;</span><br><span class="line">    <span class="keyword">if</span> (w != leader) &#123;</span><br><span class="line">      <span class="built_in">SetState</span>(w, STATE_COMPLETED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (w == last_writer) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(next);</span><br><span class="line">    w = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//! Note that leader has to exit last, since it owns the write group.</span></span><br><span class="line">  <span class="built_in">SetState</span>(leader, STATE_COMPLETED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前面几篇讲解了从 WriteBatch 的内部序列化流程 和 WriteThread 如何控制并发写入的基本流程，本文进一步讲解 WriteThread 如何使用 PipelinedWrite 来提升写吞吐，其中和前文相似的逻辑不再细说。&lt;/p&gt;
&lt;p&gt;通过设置选项 &lt;c</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WriteThread 如何自适应优化线程同步</title>
    <link href="https://szza.github.io/2022/02/02/rocksdb/WritePath/write_thread_3/"/>
    <id>https://szza.github.io/2022/02/02/rocksdb/WritePath/write_thread_3/</id>
    <published>2022-02-02T06:15:35.000Z</published>
    <updated>2023-08-03T04:17:54.341Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>ROCKSDB_NAMESPACE::WriteThread</code> 中，通过 <a href="https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d2b39/db/write_thread.cc#L64">WriteThread::AwaitState</a> 和 <a href="https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d2b39/db/write_thread.cc#L212">WriteThread::SetState</a> 两个函数来 writers 的控制并发写入行为。 这一期主要来分析 RocksDB 中 WriteThread::AwaitState 中的优化，是如何尽可能地缩短阻塞等待时间。</p><h2 id="WriteThread-AwaitState"><a href="#WriteThread-AwaitState" class="headerlink" title="WriteThread::AwaitState"></a>WriteThread::AwaitState</h2><p><code>AwaitState</code> 函数用于阻塞等待直到满足 <code>w-&gt;state &amp; goal_mask != 0</code> 这一条件。如 <a href="https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d2b39/db/write_thread.cc#L401">JoinBatchGroup</a> 函数中新插入的 w 需要阻塞等待 <code>w-&gt;state</code> 变成 <code>goal_mask</code> 中的一种才能继续执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::JoinBatchGroup</span><span class="params">(Writer* w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... above code</span></span><br><span class="line">    <span class="keyword">if</span> (!linked_as_leader) &#123; </span><br><span class="line">        <span class="built_in">AwaitState</span>(</span><br><span class="line">            w,</span><br><span class="line">            <span class="comment">// goal_mask</span></span><br><span class="line">            STATE_GROUP_LEADER | </span><br><span class="line">            STATE_MEMTABLE_WRITER_LEADER |</span><br><span class="line">            STATE_PARALLEL_MEMTABLE_WRITER | </span><br><span class="line">            STATE_COMPLETED,</span><br><span class="line">            &amp;jbg_ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RocksDB 为尽可能降低阻塞时间，将等待情况分为三种:</p><ul><li><em>short-uncontended</em>: 几乎无竞争，直接使用 <code>spin-wait loop</code> 就能解决；</li><li><em>short-contended</em>: 存在竞争，但是预测阻塞时间不会太久，使用 <code>loop + yield</code> 应对</li><li><em>long</em>: 竞争激烈，使用 <code>mutex + condition_variable</code> 应对。</li></ul><p>如果开启了上帝视角，即事先知道本次 <em>AwaitState</em> 要等待的时间，就可以直接使用 <code>spin-wait loop</code>  来应对 short-uncontended, <code>mutex</code> 来应对 long。显然没有这样的上帝视角，那么就只能通过一种自适应的方式来判断了。</p><h3 id="pause-based-spin-wait-loop"><a href="#pause-based-spin-wait-loop" class="headerlink" title="pause-based spin-wait loop"></a><a href="https://stackoverflow.com/questions/12894078/what-is-the-purpose-of-the-pause-instruction-in-x86">pause-based spin-wait loop</a></h3><p><code>spin-wait loop</code> 是应对阻塞时间很短 (short-periods) 场景的常用方式，即占据着 CPU 做空转阻塞等待 <code>w-&gt;state</code> 变成预期值，这样可以减少线程上下文切换（context switch）带来的开销。如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="type">uint8_t</span> state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquired);</span><br><span class="line">    <span class="keyword">if</span> (state &amp; goal_mask != <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这么简单的写法却有问题，一般都会在 spin-wait loop 中加上一条 “<em>Pause</em>“ 指令来提升性能。在 <a href="https://www.felixcloutier.com/x86/pause">Pause</a> 指令中有这么一段描述：</p><blockquote><p>When executing a ‘spin-wait loop’, processors will suffer a severe performance penalty when exiting the loop because it detects a <code>possible memory order violation</code></p></blockquote><p>意思就是说，如果 spin-wait loop 里如果不加上 <em>Pause</em> 指令，则很可能因为 memory order violation 问题导致退出 loop 时遭受严重的性能惩罚</p><h4 id="memory-order-violation"><a href="#memory-order-violation" class="headerlink" title="memory order violation"></a>memory order violation</h4><p>如下从 <a href="https://cdrdv2-public.intel.com/671488/248966-Software-Optimization-Manual-R047.pdf">Intel 64 and IA-32 Architectures Optimization Reference Manual</a> 中选取的示例代码，来解释为什么退出loop时会带来性能惩罚。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Spin_Lock:</span><br><span class="line">    CMP lockvar, <span class="number">0</span>;       <span class="comment">// (1) Check if lock is free.</span></span><br><span class="line">    JE Get_Lock;          <span class="comment">// (1.1) lockvar == 0</span></span><br><span class="line">    JMP Spin_Lock;        <span class="comment">// (1.2) lockvar != 0</span></span><br><span class="line">Get_Lock:</span><br><span class="line">    MOV EAX, <span class="number">1</span>;</span><br><span class="line">    XCHG EAX, lockvar;    <span class="comment">// (2) Try to get lock</span></span><br><span class="line">    CMP EAX, <span class="number">0</span>;           <span class="comment">// (3) Test if successful.</span></span><br><span class="line">    JNE Spin_Lock;</span><br><span class="line">Critical_Section:</span><br><span class="line">    <span class="comment">// critical section cod&gt;</span></span><br><span class="line">    MOV lockvar, <span class="number">0</span>;      <span class="comment">// (4) Release lock</span></span><br></pre></td></tr></table></figure><p>当线程 T1 spin-wait loop 几轮迭代后，条件分支(1)处一直都是 false，即 <code>lockvar</code> 一直不是 0。这种情况下，CPU 的分支预测器会认为条件(1) 永远不会为 true，就会将 JMP(1.2) 的指令填充整个 pipeline。</p><p>当线程 T2 将 <code>lockvar</code>  写为 0 时，由于此时 T1 的 <em>pipeline</em> 已经被错误的预测指令 (1.2) 填充满，即(1) 处的 <code>lockvar</code>  已经预测为0。这时 <em>memory order violation</em> 就会发生了：T1 线程看到 T2 线程对 <code>lockvar</code>  的修改后，就会在 T1 的 pipeline 中搜索访问了 <code>lockvar</code>  变量且还没执行的预测指令（1.2），如果发现了则会使得这部分预测指令失效，并且 flush pipeline 来删除这部分预测指令。获取锁后，就会退出 spin-wait loop。</p><p>在退出时 flush pipeline 的代价会很高。</p><p>因此，每次进入 spin-wait loop ，就会在满足条件退出 spin-wait loop 时带来严重的性能惩罚，比预期的同步时间要久。</p><p>加上 <em>PAUSE</em> 指令，是通过引入轻微的延迟来 <code>de-pipelined</code>，使得 pipeline 中不会填充错误的预测指令: 插入 PAUSE 指令后，会等待 PAUSE 之前的 pipeline 执行完变空，然后再执行下一轮 CMP，如果 T2 线程将 lockvar 的值为 0，则 T1 能立即检测到。因此现在 CMP 指令就是顺序执行，消除了预测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spin_Lock:</span><br><span class="line">    CMP lockvar, <span class="number">0</span>;       <span class="comment">// (1) Check if lock is free.</span></span><br><span class="line">    JE Get_Lock</span><br><span class="line">        PAUSE;            <span class="comment">// (2) short a delay, wait for memory pipeline to become empty</span></span><br><span class="line">    JMP Spin_Lock;</span><br><span class="line">Get_Lock:</span><br></pre></td></tr></table></figure><p>从使用角度来说，”PAUSE” 指令<em>甚至是专门</em>用于优化 spin-wait loop 的，需要搭配使用。</p><p>而 RocksDB 进入 <em>AwaitState</em> 后率先使用 <code>spin-wait loop</code> 迭代两百次(大约 1us)来尝试满足 short-uncontended 场景。原生代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">AwaitState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> goal_mask, AdaptationContext* ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> tries = <span class="number">0</span>; tries &lt; <span class="number">200</span>; ++tries) &#123;</span><br><span class="line">        state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span> ((state &amp; goal_mask) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line">        port::<span class="built_in">AsmVolatilePause</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">由于 <span class="string">&quot;PAUSE&quot;</span> 指令随着架构的变化，latency 也会更改，甚至差一个数量级，故而这里如果想要更准确的控制 wait 的时间可以使用 `__rdtsc()` 函数来控制:</span><br><span class="line">```cpp</span><br><span class="line">    <span class="comment">// __rdtsc intrinsic is used to read the time stamp counter</span></span><br><span class="line">    <span class="comment">// This allows the loop to run for a fixed number of cycles</span></span><br><span class="line">    <span class="type">uint64_t</span> prev = __rdtsc();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span> ((state &amp; goal_mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line">        port::<span class="built_in">AsmVolatilePause</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (__rdtsc() - prev &lt; max_spin_time);</span><br></pre></td></tr></table></figure><h3 id="std-this-thread-yield"><a href="#std-this-thread-yield" class="headerlink" title="std::this_thread::yield"></a>std::this_thread::yield</h3><p>如果第一阶段的 spin-wait loop 没能等到 <code>w-&gt;state</code> 的值变更为预期值，说明还是存在竞争，则进入第二阶段 <code>short-contended</code>。 这一阶段由 <code>DBOptions::enable_write_thread_adaptive_yield</code> 配置是否开启，默认值为 true。</p><p>这一段有两个问题:</p><ul><li>如何从 <code>short-contended</code> 阶段进入 <code>long</code> 阶段</li><li>如何判断下一次是否需要再进入 <code>short-contended</code> 阶段</li></ul><p>当进入 <code>short-contended</code> 阶段说明存在竞争，<em>但是假设竞争可能不大</em>。比如线程数可能不超过 CPU cores 数目，这种情况下使用 <code>std::thread::yield()</code> 并不会导致 cotext switch，效果比 pthread_mutex 要好。</p><blockquote><p>注意：从 RocksDB 开发者角度，没有上帝视角，只能先假设没有竞争（short-uncontended），不满足则再假设存在竞争但是不激烈（<code>short-contended</code>），如果还没不满足再考虑mutex阻塞。</p></blockquote><p>因此，需要对调用 <code>std::thread::yield()</code> 前后的 latency 进行统计，粗略判断竞争激烈程度：</p><ul><li><p><code>max_yield_usec_</code>: 默认 100us，控制 <code>short-contended</code> 阶段最大等待时间</p></li><li><p><code>slow_yield_usec_</code>: 默认 3us, 是 <code>yield</code> 的 latency 上限，用来反应是否有其他线程也想占据当前 cpu core</p><p>如果当前竞争比较激烈，那么调用 <code>std::thread::yield()</code> 前后的 latency 肯定会增加，(比如 threads &gt; cpu-cores 时，甚至会产生 context switch），最终导致 latency &gt; <code>slow_yield_usec_</code>。如果累计 <code>kMaxSlowYieldsWhileSpinning = 3</code> 次都超过该值，则可以跳出 <code>short-contended</code> 阶段，直接进入 <code>long</code> 阶段，阻塞等待。</p></li></ul><p>开启第二阶段的开关有3个，这一部分代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> would_spin_again = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> update_ctx = <span class="literal">false</span>;</span><br><span class="line"><span class="type">uint64_t</span> sampling_base = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">if</span> (max_yield_usec_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  update_ctx = Random::<span class="built_in">GetTLSInstance</span>()-&gt;<span class="built_in">OneIn</span>(sampling_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (update_ctx || yield_credit.<span class="built_in">load</span>(std::memory_order_relaxed) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// short-contended code...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>max_yield_usec_ &gt; 0</code>: 默认情况下总是开启</p></li><li><p><code>update_ctx</code>: 表示是否更新 <code>yield_credit</code> 的值。当且仅当基于均匀分布从 <em>[0, 255]</em> 区间获得 0 时值为 true，即 <code>Random::OneIn(sampling_base)</code> 返回 true 的概率为 <em>1&#x2F;256</em></p><p>  <em>would_spin_again</em> 表示 <code>w-&gt;state</code> 是否在第二阶段等到预期值，如果成功则 <code>yield_credit</code> 值增加，反之降低。<code>yield_credit</code> 的更新公式如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (update_ctx) &#123;</span><br><span class="line">   <span class="keyword">auto</span> v = yield_credit.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">   v = v - (v / <span class="number">1024</span>) + (would_spin_again ? <span class="number">1</span> : <span class="number">-1</span>) * <span class="number">131072</span>;</span><br><span class="line">   yield_credit.<span class="built_in">store</span>(v, std::memory_order_relaxed);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>yield_credit</code>: 默认值为 0，在是否开启第二阶段中起着决定性作用。基本上需要满足 <code>yield_credit &gt;= 0</code> 才能进入第二阶段</p><p>  <em>yield_credit</em> 值在两种情况下会更改，也是<strong>自适应</strong>原理：</p><p>  1）进入了第二阶段，但是因为竞争太激烈，没有在第二阶段实现 <code>w-&gt;state &amp; goal_mask != 0</code>，此时会将 update_ctx &#x3D; true，再由上述公式降低 <em>yield_credit</em> 的值，使其小于 0，这样 AwaitState 函数下次不会再进入第二阶段；</p><ol start="2"><li>如果长时间 <code>yield_credit &lt; 0</code> 会一直无法进入第二阶段。但是由均匀分布可知，存在 1&#x2F;256 的概率将 update_ctx &#x3D; true，进入第二阶段，来<em>试探</em>现在竞争是否没那么激烈了。如果此时在第二阶段等到了 <code>w-&gt;state &amp; goal_mask != 0</code> ，那么就会再根据上述公式将 <code>yield_credit</code> 调节为非负数，使得下一次 AwaitState 函数仍能进入第二阶段。</li></ol></li></ul><p>这里的 <code>yield_credit</code> 值记录在 <code>AdaptationContext::value</code> 中，<code>AdaptationContext</code> 的所有对象在 <code>WriteThread</code> 中都是 static 变量，因此会一直反应着进程生命周期中线程竞争状态，故而上述的 <code>update_ctx</code> 中的 <code>ctx</code> 即 <code>yield_credit</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AdaptationContext</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">  std::atomic&lt;<span class="type">int32_t</span>&gt; value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AdaptationContext</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name0)</span> : name(name0), value(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的介绍大致介绍了 <code>short-contended</code> 阶段的自适应原理，下面来看看核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; yield_credit = ctx-&gt;value;</span><br><span class="line"><span class="type">bool</span> update_ctx = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> would_spin_again = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (update_ctx || yield_credit.<span class="built_in">load</span>(std::memory_order_relaxed) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">auto</span> spin_begin = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超过 slow_yield_usec_ 的次数</span></span><br><span class="line">  <span class="type">size_t</span> slow_yield_count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> iter_begin = spin_begin;</span><br><span class="line">  <span class="comment">// 最多消耗的时间片: max_yield_usec_</span></span><br><span class="line">  <span class="keyword">while</span> (iter_begin - spin_begin) &lt;= </span><br><span class="line">            std::chrono::<span class="built_in">microseconds</span>(max_yield_usec_) &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line">    state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> ((state &amp; goal_mask) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 1. 成功，则退出第二阶段</span></span><br><span class="line">      would_spin_again = <span class="literal">true</span>; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 2. latency 超过 slow_yield_usec_</span></span><br><span class="line">    <span class="keyword">if</span> (now == iter_begin ||</span><br><span class="line">        now - iter_begin &gt;= std::chrono::<span class="built_in">microseconds</span>(slow_yield_usec_)) &#123;</span><br><span class="line">      ++slow_yield_count;</span><br><span class="line">      <span class="comment">// 2.1 累计超过 kMaxSlowYieldsWhileSpinning 次则退出第二阶段，</span></span><br><span class="line">      <span class="comment">//     并设置 update_ctx =true，后续更新 yield_credit</span></span><br><span class="line">      <span class="keyword">if</span> (slow_yield_count &gt;= kMaxSlowYieldsWhileSpinning) &#123;</span><br><span class="line">        update_ctx = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iter_begin = now;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BlockingAwaitState"><a href="#BlockingAwaitState" class="headerlink" title="BlockingAwaitState"></a>BlockingAwaitState</h3><p>如果不幸，<code>w-&gt;state</code> 的值仍然没有变更为预期值，则需要进入第三阶段：使用 Mutex + ConditionVarable 进行阻塞等待。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((state &amp; goal_mask) == <span class="number">0</span>) &#123;</span><br><span class="line">  state = <span class="built_in">BlockingAwaitState</span>(w, goal_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlockingAwaitState</code> 函数比较简单：先再次判断 <code>w-&gt;state</code> 是否变更为预期值 <code>goal_mask</code>； 没有，则将 w-&gt;state 设置为 <code>STATE_LOCKED_WAITING</code> 状态，等待唤醒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">WriteThread::BlockingAwaitState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> goal_mask)</span> </span>&#123;</span><br><span class="line">  w-&gt;<span class="built_in">CreateMutex</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="built_in">assert</span>(state != STATE_LOCKED_WAITING);</span><br><span class="line">  <span class="keyword">if</span> ((state &amp; goal_mask) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      w-&gt;state.<span class="built_in">compare_exchange_strong</span>(state, STATE_LOCKED_WAITING)) &#123;</span><br><span class="line">    <span class="comment">// we have permission (and an obligation) to use StateMutex</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(w-&gt;StateMutex())</span></span>;</span><br><span class="line">    w-&gt;<span class="built_in">StateCV</span>().<span class="built_in">wait</span>(guard, [w] &#123;</span><br><span class="line">      <span class="keyword">return</span> w-&gt;state.<span class="built_in">load</span>(std::memory_order_relaxed) != STATE_LOCKED_WAITING;</span><br><span class="line">    &#125;);</span><br><span class="line">    state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// else tricky.  Goal is met or CAS failed.  In the latter case the waker</span></span><br><span class="line">  <span class="comment">// must have changed the state, and compare_exchange_strong has updated</span></span><br><span class="line">  <span class="comment">// our local variable with the new one.  At the moment WriteThread never</span></span><br><span class="line">  <span class="comment">// waits for a transition across intermediate states, so we know that</span></span><br><span class="line">  <span class="comment">// since a state change has occurred the goal must have been met</span></span><br><span class="line">  <span class="built_in">assert</span>((state &amp; goal_mask) != <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WriteThread-SetState"><a href="#WriteThread-SetState" class="headerlink" title="WriteThread::SetState"></a>WriteThread::SetState</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::SetState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> new_state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(w);</span><br><span class="line">  <span class="keyword">auto</span> state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span> (state == STATE_LOCKED_WAITING ||</span><br><span class="line">      !w-&gt;state.<span class="built_in">compare_exchange_strong</span>(state, new_state)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(state == STATE_LOCKED_WAITING);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(w-&gt;StateMutex())</span></span>;</span><br><span class="line">    <span class="built_in">assert</span>(w-&gt;state.<span class="built_in">load</span>(std::memory_order_relaxed) != new_state);</span><br><span class="line">    w-&gt;state.<span class="built_in">store</span>(new_state, std::memory_order_relaxed);</span><br><span class="line">    w-&gt;<span class="built_in">StateCV</span>().<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;code&gt;ROCKSDB_NAMESPACE::WriteThread&lt;/code&gt; 中，通过 &lt;a href=&quot;https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WriteThread 如何控制并发写入流程</title>
    <link href="https://szza.github.io/2022/01/15/rocksdb/WritePath/write_thread_2/"/>
    <id>https://szza.github.io/2022/01/15/rocksdb/WritePath/write_thread_2/</id>
    <published>2022-01-15T06:15:35.000Z</published>
    <updated>2023-08-03T04:48:14.865Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>建议先阅读上一篇文章 <a href="https://szza.github.io/2022/01/10/rocksdb/WritePath/write_thread_1/">WriteBatch 写入前的准备工作</a> 了解一些基本概念</p></blockquote><p>本篇博客讲解批量写流程的控制流程，了解这个流程之后再来讲解 <em>PipelineWriteImpl</em> 中优化。</p><p>整个写入流程大致如下：<br><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_write_thread_2_1.png?raw=true" alt="write_path_2_1"></p><h3 id="WriteThread-JoinBatchGroup"><a href="#WriteThread-JoinBatchGroup" class="headerlink" title="WriteThread::JoinBatchGroup"></a>WriteThread::JoinBatchGroup</h3><p><code>JoinBatchGroup</code> 函数充当着锁的作用：能成为 leader 的 writer 才能真正执行 <code>WriteToWAL</code> 和 <code>MemTable::Add</code> 操作，其他 writers 只能阻塞等待 leader-writer 完成。</p><p>在 <code>WriteThread</code> 中有个 <code>newest_writer_</code> 字段总是指向最新插入的 <code>Writer</code> 对象：</p><ol><li>如果新插入一个 <code>Writer</code> 对象 w，则会尝试让 <code>newest_writer_</code> 指向该 w 。如果当前触发了 <em>WriteStall</em> 则会等待 <code>WriteStall</code> 被解除，才会再次尝试让 <code>newest_writer_</code> 指向该 w</li><li>如果 w 插入时，<code>newest_writer_ == NULL</code> ，则 w 能顺利通过 <code>JoinBatchGroup</code> 函数，进入后续写入流程</li><li>否则，说明当前已经存在 leader-writer，则只能阻塞等待 <code>w-&gt;state</code> 更改为下面其中一种才能解除阻塞:<ul><li><code>STATE_GROUP_LEADER</code>: 变成下一个 write_group 的 leader，执行写入</li><li><code>STATE_COMPLETED</code>: 说明已经存在一个 leader-writer 替自己完成了写入，解除阻塞后就可以直接返回应用层</li><li><code>STATE_MEMTABLE_WRITER_LEADER</code>: …</li><li><code>STATE_PARALLEL_MEMTABLE_WRITER</code>: …</li></ul></li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::JoinBatchGroup</span><span class="params">(Writer* w)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(w-&gt;batch != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 1. 让 nnewest_writer_ 指向 w</span></span><br><span class="line">  <span class="type">bool</span> linked_as_leader = <span class="built_in">LinkOne</span>(w, &amp;newest_writer_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (linked_as_leader) &#123;</span><br><span class="line">    <span class="built_in">SetState</span>(w, STATE_GROUP_LEADER);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!linked_as_leader) &#123;</span><br><span class="line">     <span class="comment">// 2. 阻塞等待 w-&gt;state &amp; mask != 0</span></span><br><span class="line">    <span class="built_in">AwaitState</span>(w,</span><br><span class="line">               STATE_GROUP_LEADER | STATE_MEMTABLE_WRITER_LEADER |</span><br><span class="line">                   STATE_PARALLEL_MEMTABLE_WRITER | STATE_COMPLETED,</span><br><span class="line">               &amp;jbg_ctx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteThread-LinkOne"><a href="#WriteThread-LinkOne" class="headerlink" title="WriteThread::LinkOne"></a>WriteThread::LinkOne</h3><p><code>LinkOne</code>的功能其实就是在链表头发插入一个节点，不过需要先检查一个前提 <em>WriteStall</em>。</p><h4 id="WriteStall"><a href="#WriteStall" class="headerlink" title="WriteStall"></a>WriteStall</h4><p>如果写操作触发了 <em>WriteStall</em> ，会向 WriterThread 中写入一个 <code>write_stall_dummy_</code> 标志。因此在尝试将 <code>newest_writer_</code> 指向新加入的 <code>w</code> 时都需要先检查下 <code>newest_writer_</code> 是否等于 <code>write_stall_dummy_</code>。如果等于，有以下两种情况：</p><ul><li><p><code>Writer::no_slowdown == false</code>，这是默认情况，即基于条件变量 <code>stall_cv_</code> 阻塞等待 <em>WriteStall</em> 解除。解除后则需要重新读取 <code>newest_writer_</code></p><p>条件变量一般配合 while 一起使用，防止虚假唤醒，因此 <code>stall_cv_</code> 被唤醒后会 <em>continue</em> 并进行下一轮 while 循环，确认 <code>newest_writer_</code> 不是 <code>write_stall_dummy_</code> 才能继续下一步。</p></li><li><p><code>Writer::no_slowdown == true</code>，此时将错误 <code>Status::Incomplete</code> 返回给上层应用，让其自行决定如何处理 <code>WriteStall</code>，这就类似网络编程的非阻塞行为。</p></li></ul><h4 id="compare-exchange-weak"><a href="#compare-exchange-weak" class="headerlink" title="compare_exchange_weak"></a>compare_exchange_weak</h4><p>当没有 <em>WriteStall</em> 或者有已经解除，则可以继续写入，将 <code>w-&gt;link_older = writers</code>。这里的 <code>link_older</code> 的语义其实就是 <code>next</code> 指针，效果即 <code>w-&gt;next = writers</code>。</p><p>完成这一步后 <font color="red"> 却并没有执行 writers-&gt;prev &#x3D; w 操作</font>，为什么呢？这是为了在 leader-writer 写流程结束时能通过 <code>link_newer/prev</code> 是否为 NULL 选出下一轮的 leader-writer，详见后文的 <code>ExitAsBatchGroupLeader</code> 函数。</p><p>再通过 <code>compare_exchange_weak</code> 操作将 <code>newest_writer_</code> 指向最新插入的 w，</p><ul><li><p>成功，则通过判断 <code>writers</code> 是否为 NULL，来判断 w 是不是下一轮 writer_group 的 leader-writer </p><p>这是因为上一个 write_group 完成后就会尝试将 <code>newest_writer_</code> 设置为 NULL，只需要通过判断 <code>writers ==  NULL</code> 就可以确定新插入的 w 是不是下一轮 write_group 的 leader。</p></li><li><p>失败，则说明有个并发 <code>w0</code> 在自己之前完成了 <code>compare_exchange_weak</code> 操作，则自己会在下一轮 while 循环中完成此操作，使得 <code>newest_writer_</code> 指向 w，并形成 <code>w-&gt;next = w0</code> 连接。</p></li></ul><p>每次有新的 w，都只是改变 <code>newest_writer_</code>，并通过 <code>link_older/next</code> 指针把所有插入的 writers 串联起来，<em>且不重不漏</em>。由于每次只有 leader-writer 具有写权限，再让 leader-writer 在将所有的 writers 打包成一个 writer_group 时，给缺失的 <code>link_newer/prev</code> 指针赋值，就完成了双链表创建。由于此时实际上已经是单线程操作，因此不需要借助任何同步措施也没有并发的风险。</p><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteThread::LinkOne</span><span class="params">(Writer* w, std::atomic&lt;Writer*&gt;* newest_writer)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(newest_writer != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(w-&gt;state == STATE_INIT);</span><br><span class="line">  Writer* writers = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(writers != w);</span><br><span class="line">    <span class="keyword">if</span> (writers == &amp;write_stall_dummy_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (w-&gt;no_slowdown) &#123;</span><br><span class="line">        w-&gt;status = Status::<span class="built_in">Incomplete</span>(<span class="string">&quot;Write stall&quot;</span>);</span><br><span class="line">        <span class="built_in">SetState</span>(w, STATE_COMPLETED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function">MutexLock <span class="title">lock</span><span class="params">(&amp;stall_mu_)</span></span>;</span><br><span class="line">        writers = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (writers == &amp;write_stall_dummy_) &#123;</span><br><span class="line">          stall_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">          <span class="comment">// Load newest_writers_ again since it may have changed</span></span><br><span class="line">          writers = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    w-&gt;link_older = writers;</span><br><span class="line">    <span class="keyword">if</span> (newest_writer-&gt;<span class="built_in">compare_exchange_weak</span>(writers, w)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (writers == <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteThread-AwaitState"><a href="#WriteThread-AwaitState" class="headerlink" title="WriteThread::AwaitState"></a>WriteThread::AwaitState</h4><p><code>WriteThread::AwaitState</code> 中的优化点较多，下一期单独开一篇讲解这里的优化。这个函数的作用是阻塞等待直到满足 <code>w-&gt;state &amp; goal_mask != 0</code>。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">AwaitState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> goal_mask, AdaptationContext* ctx)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="WriteThread-CreateMissingNewerLinks"><a href="#WriteThread-CreateMissingNewerLinks" class="headerlink" title="WriteThread::CreateMissingNewerLinks"></a>WriteThread::CreateMissingNewerLinks</h4><p>缺失的 <code>prev</code> 指针由 <code>CreateMissingNewerLinks</code> 函数补全。</p><p>传入的 <code>head</code> 即 <code>newest_writer_</code> 的值，目前所有待执行的 writers 已经通过 next 指针串联起来了，这里要做的就是将其 prev 指针补全。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::CreateMissingNewerLinks</span><span class="params">(Writer* head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Writer* next = head-&gt;link_older;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">nullptr</span> || next-&gt;link_newer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(next == <span class="literal">nullptr</span> || next-&gt;link_newer == head);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next-&gt;link_newer = head; <span class="comment">// next-&gt;prev = head;</span></span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteThread-EnterAsBatchGroupLeader"><a href="#WriteThread-EnterAsBatchGroupLeader" class="headerlink" title="WriteThread::EnterAsBatchGroupLeader"></a>WriteThread::EnterAsBatchGroupLeader</h3><p>writer 没有阻塞在 <code>WriteThread::JoinBatchGroup</code> 函数，则说明 <code>writer</code> 目前已经成为 leader-writer，则需要由 leader-writer 尝试将目前所有待执行的 writers 封装到一个 write_group 中，这个由 <code>EnterAsBatchGroupLeader</code> 函数完成。</p><p>执行到 <code>EnterAsBatchGroupLeader</code> 函数时，<code>newest_writer_</code> 可能一直在更改，即不断指向最新的 writer。但是没关系，因为此时 leader-writer 已经诞生了，更新的 writer 在执行 <code>WriteThread::JoinBatchGroup</code> 时候会被阻塞在 <code>AwaitState</code>，如果此时 leader-writer 刚好执行到 <code>EnterAsBatchGroupLeader</code> 函数，则会由 leader-writer 将 <em>[leader-writer, newest_writer]</em> 区间的所有 writers 封装到 writer_group 中，由 leader-writer 来统一执行批量写入。其中 <code>write_group-&gt;last_writer</code> 指向的就是当前最新的 newest_writer。</p><p>在上一篇文章，讲解了 <code>WriteGroup</code> 内部封装了迭代器，那么就可以使用如下方式并以 <code>leader_writer -&gt; newst_writer</code> 顺序遍历所有 writers。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> writer : *writer_group) &#123;</span><br><span class="line">  <span class="comment">// 批量写入 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如下4步：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">WriteThread::EnterAsBatchGroupLeader</span><span class="params">(Writer* leader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            WriteGroup* write_group)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;batch != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(write_group != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> size = WriteBatchInternal::<span class="built_in">ByteSize</span>(leader-&gt;batch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. write_group 大小限制</span></span><br><span class="line">  <span class="type">size_t</span> max_size = max_write_batch_group_size_bytes;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> min_batch_size_bytes = max_write_batch_group_size_bytes / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= min_batch_size_bytes) &#123;</span><br><span class="line">    max_size = size + min_batch_size_bytes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 初始化 write_group</span></span><br><span class="line">  leader-&gt;write_group = write_group;</span><br><span class="line">  write_group-&gt;leader = leader;</span><br><span class="line">  write_group-&gt;last_writer = leader;</span><br><span class="line">  write_group-&gt;size = <span class="number">1</span>;</span><br><span class="line">  Writer* newest_writer = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 补全 [leader-writer, newest_writer] 丢失的 prev 指针</span></span><br><span class="line">  <span class="built_in">CreateMissingNewerLinks</span>(newest_writer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 封装到 write_group</span></span><br><span class="line">  Writer* w = leader;</span><br><span class="line">  <span class="keyword">while</span> (w != newest_writer) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(w-&gt;link_newer);</span><br><span class="line">    w = w-&gt;link_newer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other break conditions</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size + WriteBatchInternal::<span class="built_in">ByteSize</span>(w-&gt;batch) &gt; max_size) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w-&gt;write_group = write_group; <span class="comment">// 设置 w 属于当前 write_group</span></span><br><span class="line">    size += batch_size;           <span class="comment">// 这个 write_group 的数据量大小</span></span><br><span class="line">    write_group-&gt;last_writer = w; <span class="comment">// 更新 last_writer</span></span><br><span class="line">    write_group-&gt;size++;          <span class="comment">// writer_group 中 writers 的个数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteThread-ExitAsBatchGroupLeader"><a href="#WriteThread-ExitAsBatchGroupLeader" class="headerlink" title="WriteThread::ExitAsBatchGroupLeader"></a>WriteThread::ExitAsBatchGroupLeader</h3><p>这里暂时不关注 <em>enable_pipelined_write_</em>, 这是开启 <em>PipelineWriteImpl</em> 的标志位。</p><p>当数据都已经写入 WAL 和 MemTable，则会调用 <code>ExitAsBatchGroupLeader</code>，此时需要判断在当前 write_group 写入过程中是否出现了新的 writers：</p><ul><li>是：则需要从等待的 writers 中挑选出<em>新的</em> leader-writer</li><li>否：则需要将 <code>newest_writer_</code> 赋值为 NULL</li></ul><p>需要先读取 <code>newest_writer_</code> 的最新值 <em>head</em>，来判断是否有新的 <code>writer</code> 插入: </p><ul><li><p>如果 <code>head != last_writer</code> 则说明在当前 write_group 写操作过程中有出现新的 writers ，并阻塞等待在 <code>JoinBatchGroup</code></p></li><li><p>如果 <code>head == last_writer</code> 但是 <code>newest_writer_.compare_exchange_strong(head, nullptr)</code> 为 false，则说明在 <code>newest_writer_</code> load <em>之后</em>并在 <code>compare_exchange_strong</code> <em>之前</em> 有新的 writers 出现</p><p>上述两种情况，都需要将 <em>[<code>last_writer</code>, <code>head</code>]</em> 区间所有 writers 缺失的 prev 指针补全，因为补全后 <code>last_writer-&gt;prev</code> 指向的就是新的 leader-writer。</p><p>这是因为 <code>last_writer-&gt;prev</code> 是在 last_writer 之后最早插入的 writer，为保持顺序性，这就是新的 leader-writer。</p></li></ul><p>完成上述操作，剩下的就是将当前 write_group 中的所有 writers 状态更改为 <em>STATE_COMPLETED</em> 解除他们在 <code>JoinBatchGroup</code> 处的阻塞，尽快返回应用层。这一步也有个小细节，见代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::ExitAsBatchGroupLeader</span><span class="params">(WriteGroup&amp; write_group,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Status&amp; status)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enable_pipelined_write_) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Writer* head = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (head != last_writer ||</span><br><span class="line">        !newest_writer_.<span class="built_in">compare_exchange_strong</span>(head, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      <span class="comment">// 存在新插入的 writer</span></span><br><span class="line">      <span class="built_in">assert</span>(head != last_writer);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1. 补全 [last_writer, head] 的 prev指针</span></span><br><span class="line">      <span class="built_in">CreateMissingNewerLinks</span>(head);</span><br><span class="line">      <span class="built_in">assert</span>(last_writer-&gt;link_newer != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="built_in">assert</span>(last_writer-&gt;link_newer-&gt;link_older == last_writer);</span><br><span class="line">      <span class="comment">// 2. 断开链表</span></span><br><span class="line">      last_writer-&gt;link_newer-&gt;link_older = <span class="literal">nullptr</span>; </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 设置新的 leader-writer</span></span><br><span class="line">      <span class="built_in">SetState</span>(last_writer-&gt;link_newer, STATE_GROUP_LEADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 将 [leader, last_writer] 区间的 writers 状态设置为 STATE_COMPLETED</span></span><br><span class="line">    <span class="comment">//    即解除阻塞，让 follower-writer 返回应用层</span></span><br><span class="line">    <span class="keyword">while</span> (last_writer != leader) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(last_writer);</span><br><span class="line">      last_writer-&gt;status = status;</span><br><span class="line">      <span class="comment">// 需要先获取 next指针，再更改状态为 STATE_COMPLETED</span></span><br><span class="line">      <span class="comment">// 因为先更改 STATE_COMPLETED 很可能导致 last_writer 就被正在阻塞的线程销毁了</span></span><br><span class="line">      <span class="comment">// 再获取 next 指针就会触发 coredump</span></span><br><span class="line">      <span class="keyword">auto</span> next = last_writer-&gt;link_older;</span><br><span class="line">      <span class="built_in">SetState</span>(last_writer, STATE_COMPLETED); <span class="comment">// 解除阻塞</span></span><br><span class="line"></span><br><span class="line">      last_writer = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="By-the-Way"><a href="#By-the-Way" class="headerlink" title="By the Way"></a>By the Way</h3><ul><li>这篇文章里面用了许多原子操作以及一些内存序，诸如 <code>compare_exchange_strong/compare_exchange_weak</code> 区别，<code>acquire/release</code>语义，等后面有空再单独讲解下这个问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;建议先阅读上一篇文章 &lt;a href=&quot;https://szza.github.io/2022/01/10/rocksdb/WritePath/write_thread_1/&quot;&gt;WriteBatch 写入前的准备工作&lt;/a&gt; 了解一些基本概念&lt;/p</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WriteBatch 写入前的准备工作</title>
    <link href="https://szza.github.io/2022/01/10/rocksdb/WritePath/write_thread_1/"/>
    <id>https://szza.github.io/2022/01/10/rocksdb/WritePath/write_thread_1/</id>
    <published>2022-01-10T06:15:35.000Z</published>
    <updated>2023-08-03T04:12:05.472Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WriteBatch"><a href="#WriteBatch" class="headerlink" title="WriteBatch"></a>WriteBatch</h2><blockquote><p>无论 <code>Put/Delete/DeleteRange</code> 都是向 RocksDB 插入一对 {key, value}，在不至于引起误解的前提下，下面不加以区分地统一表述为 <strong>写入</strong> 操作</p></blockquote><p>写入一条 <code>&#123;key, value&#125;</code> 数据需要先在 <em>WriteBatch</em> 内部序列化到 <code>WriteBatch::rep_</code>字段中。其整体格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时上是一行连续存储，为便于阅读多行显示</span></span><br><span class="line">  |sequence|count|</span><br><span class="line">  |serialized-kv-1|</span><br><span class="line">  |serialized-kv-2|</span><br></pre></td></tr></table></figure><p><code>WriteBatch::rep_</code> 在首部需要 <code>KHeader=12</code> 个字节存储本次 <code>writer_batch</code> 的元数据信息:</p><ul><li><code>sequence: uint64_t</code>: 8个字节，类似主键 id，记录的是当前 write_batch 是自从 RocksDB 创建以来第几个 write_batch。即便 RocksDB 挂了重启也不会更改，只会单增；</li><li><code>count: uint32_t</code>: 4个字节，记录本次 write_batch 写入了多少个 <code>&#123;key, value&#125;</code>，每次写入一条数据就会递增一次。下面的<code>Put</code> 案例操作可见。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  WriteBatch::<span class="built_in">WriteBatch</span>(<span class="type">size_t</span> reserved_bytes, <span class="type">size_t</span> max_bytes,</span><br><span class="line">                         <span class="type">size_t</span> protection_bytes_per_key, <span class="type">size_t</span> default_cf_ts_sz)</span><br><span class="line">    : <span class="built_in">content_flags_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">max_bytes_</span>(max_bytes),</span><br><span class="line">      <span class="built_in">default_cf_ts_sz_</span>(default_cf_ts_sz) &#123;</span><br><span class="line">    rep_.<span class="built_in">reserve</span>((reserved_bytes &gt; WriteBatchInternal::kHeader)</span><br><span class="line">                   ? reserved_bytes</span><br><span class="line">                   : WriteBatchInternal::kHeader);</span><br><span class="line">    rep_.<span class="built_in">resize</span>(WriteBatchInternal::kHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元信息 <code>sequence/count</code> 的 <em>setter</em>&#x2F;<em>getter</em> 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SequenceNumber <span class="title">WriteBatchInternal::Sequence</span><span class="params">(<span class="type">const</span> WriteBatch* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SequenceNumber</span>(<span class="built_in">DecodeFixed64</span>(b-&gt;rep_.<span class="built_in">data</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::SetSequence</span><span class="params">(WriteBatch* b, SequenceNumber seq)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(&amp;b-&gt;rep_[<span class="number">0</span>], seq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">WriteBatchInternal::Count</span><span class="params">(<span class="type">const</span> WriteBatch* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(b-&gt;rep_.<span class="built_in">data</span>() + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::SetCount</span><span class="params">(WriteBatch* b, <span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">EncodeFixed32</span>(&amp;b-&gt;rep_[<span class="number">8</span>], n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h3><p>RocksDB 中数据本身基本按照 <code>|xxx_length|xxx_bytes|</code> 格式编码。</p><p>下面将写入的 <code>&#123;key, value&#125;</code> 序列化成 <code>Record</code>，根据是否指定 ColumnFamily 有两种格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">default cf:</span><br><span class="line">  |KTypeValue|</span><br><span class="line">  |key_size|key_bytes|</span><br><span class="line">  |value_length|value_bytes|</span><br><span class="line"></span><br><span class="line">specify cf:    </span><br><span class="line">  |kTypeColumnFamilyValue|column_family_id|</span><br><span class="line">  |key_size|key_bytes|</span><br><span class="line">  |value_length|value_bytes|</span><br></pre></td></tr></table></figure><p>在 <code>Record</code> 前面有两个字段:</p><ul><li><code>ValueType: uint8_t</code>: 1个字节，表征本次是 <code>Put/Delete</code> 等具体操作类型，以及是否指定了 ColumnFamily</li><li><code>column_family_id: uint32_t</code>: 4个字节，只有指定了 ColumnFamily，才会有这个字段</li></ul><p>下面的 <code>WriteBatchInternal::Put</code> 实现就是按照上述格式封装 <code>&#123;key, value&#125;</code> 后续写入WAL 和 MemTable。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatchInternal::Put</span><span class="params">(WriteBatch* b, <span class="type">uint32_t</span> column_family_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="function">LocalSavePoint <span class="title">save</span><span class="params">(b)</span></span>;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(b, WriteBatchInternal::<span class="built_in">Count</span>(b) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (column_family_id == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeValue));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b-&gt;rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeColumnFamilyValue));</span><br><span class="line">    <span class="built_in">PutVarint32</span>(&amp;b-&gt;rep_, column_family_id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;b-&gt;rep_, key);</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;b-&gt;rep_, value);</span><br><span class="line">  b-&gt;content_flags_.<span class="built_in">store</span>(</span><br><span class="line">      b-&gt;content_flags_.<span class="built_in">load</span>(std::memory_order_relaxed) | ContentFlags::HAS_PUT,</span><br><span class="line">      std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> save.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LocalSavePoint"><a href="#LocalSavePoint" class="headerlink" title="LocalSavePoint"></a>LocalSavePoint</h3><p>LocalSavePoint 是基于 RAII 机制来判断 WriteBatch 写入的数据量累计是否已经超过限制: 是则回滚到生成 <em>save</em> 的位置，即调用本次 <code>WriteBatchInternel::Put</code> 之前的状态，然后返回 <code>Status::MemoryLimit</code> 错误，阻止本次写入流程。源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalSavePoint</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">LocalSavePoint</span><span class="params">(WriteBatch* batch)</span></span></span><br><span class="line"><span class="function">    : batch_(batch), </span></span><br><span class="line"><span class="function">      // savepoint 记录初始状态</span></span><br><span class="line"><span class="function">      savepoint_(batch-&gt;GetDataSize(), </span></span><br><span class="line"><span class="function">                 batch-&gt;Count(),</span></span><br><span class="line"><span class="function">                 batch-&gt;content_flags_.load(std::memory_order_relaxed))</span></span><br><span class="line"><span class="function">  &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 超过限制则 rollack 到初始状态</span></span><br><span class="line">    <span class="keyword">if</span> (batch_-&gt;max_bytes_ &amp;&amp; batch_-&gt;rep_.<span class="built_in">size</span>() &gt; batch_-&gt;max_bytes_) &#123;</span><br><span class="line">      batch_-&gt;rep_.<span class="built_in">resize</span>(savepoint_.size);</span><br><span class="line">      WriteBatchInternal::<span class="built_in">SetCount</span>(batch_, savepoint_.count);</span><br><span class="line">      batch_-&gt;content_flags_.<span class="built_in">store</span>(savepoint_.content_flags,</span><br><span class="line">                                   std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">MemoryLimit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  WriteBatch* batch_;</span><br><span class="line">  SavePoint savepoint_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 Savepoint 也是个简单的 <em>struct</em>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SavePoint</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> size;  <span class="comment">// size of rep_</span></span><br><span class="line">  <span class="type">int</span> count;    <span class="comment">// count of elements in rep_</span></span><br><span class="line">  <span class="type">uint32_t</span> content_flags;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SavePoint</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">count</span>(<span class="number">0</span>), <span class="built_in">content_flags</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SavePoint</span>(<span class="type">size_t</span> _size, <span class="type">int</span> _count, <span class="type">uint32_t</span> _flags)</span><br><span class="line">      : <span class="built_in">size</span>(_size), <span class="built_in">count</span>(_count), <span class="built_in">content_flags</span>(_flags) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    content_flags = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_cleared</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (size | count | content_flags) == <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Deserializtion"><a href="#Deserializtion" class="headerlink" title="Deserializtion"></a>Deserializtion</h3><p>WriteBatch 序列化时将数据连续存储，反序列化时则可以顺序读取，具有更好的局部性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ReadRecordFromWriteBatch</span><span class="params">(Slice* input, <span class="type">char</span>* tag,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint32_t</span>* column_family, Slice* key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Slice* value, Slice* blob, Slice* xid)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(key != <span class="literal">nullptr</span> &amp;&amp; value != <span class="literal">nullptr</span>);</span><br><span class="line">  *tag = (*input)[<span class="number">0</span>];</span><br><span class="line">  input-&gt;<span class="built_in">remove_prefix</span>(<span class="number">1</span>);</span><br><span class="line">  *column_family = <span class="number">0</span>;  <span class="comment">// default</span></span><br><span class="line">  <span class="keyword">switch</span> (*tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> kTypeColumnFamilyValue:</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">GetVarint32</span>(input, column_family)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad WriteBatch Put&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> kTypeValue:</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">GetLengthPrefixedSlice</span>(input, key) ||</span><br><span class="line">          !<span class="built_in">GetLengthPrefixedSlice</span>(input, value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad WriteBatch Put&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// other value   </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>数据写入 WriteBatch 后，下面就要写入 WAL 和 MemTable，先来看看写入操作之前的一些逻辑。</p><h2 id="WriteThread"><a href="#WriteThread" class="headerlink" title="WriteThread"></a>WriteThread</h2><p>基于 RocksDB 构建的上层应用向 RocksDB 多线程写入数据时，由 <code>RocksDB::WriteThread</code> 保障多线程写入的有序性，并通过内部优化尽可能提高写入效率，不阻塞后来的写入流程，具体优化下一期再来详解，下面先讲解一些基础逻辑。</p><p>上层应用向 RocksDB 写入的数据序列化到 <code>WriteBatch</code> 后，再把 WriteBatch 封装到 <code>WriteThread::Writer</code>，生成一个 writer 并向 <code>WriteThread</code> 申请写入许可。</p><h3 id="WriteThread-Writer"><a href="#WriteThread-Writer" class="headerlink" title="WriteThread::Writer"></a>WriteThread::Writer</h3><p><code>WriterThread::Writer</code> 是个链表:</p><ul><li><code>link_older</code> 指向 <code>this</code> 之前插入的 <code>Writer</code>，类似 <code>next</code></li><li><code>link_newer</code> 指向 <code>this</code> 后面插入的 <code>Writer</code>，类似 <code>prev</code></li></ul><p>每个 writer 节点内部存储着本次写入的数据 batch:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WriteThread</span>::Writer &#123;</span><br><span class="line">  WriteBatch* batch;</span><br><span class="line">  <span class="comment">//.. too many other fields ..</span></span><br><span class="line"></span><br><span class="line">  std::atomic&lt;<span class="type">uint8_t</span>&gt; state;</span><br><span class="line">  std::aligned_storage&lt;<span class="built_in">sizeof</span>(std::mutex)&gt;::type state_mutex_bytes;</span><br><span class="line">  std::aligned_storage&lt;<span class="built_in">sizeof</span>(std::condition_variable)&gt;::type state_cv_bytes;</span><br><span class="line">  Writer* link_older;  <span class="comment">// this 之前之前写入的 writers</span></span><br><span class="line">  Writer* link_newer;  <span class="comment">// this 之后写入的 writers</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//... methods</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用 <code>std::aligned_storage</code> 进行内存对齐的原理可以参考之前写的一篇文章 <a href="https://szza.github.io/2022/01/01/C++/align/">内存对齐之 alignof、alignas 、aligned_storage、align 剖析</a></p></blockquote><h3 id="WriteThread-WriteGroup"><a href="#WriteThread-WriteGroup" class="headerlink" title="WriteThread::WriteGroup"></a>WriteThread::WriteGroup</h3><p>如果每次只有一个 writer 能写入数据，其他 writers 只能阻塞等待，那 RocksDB 也就毫无写性能可言。于是乎，RocksDB 每次将一批 writers 组成一个 <code>WriteGroup</code> 统一写入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WriteThread</span>::WriteGroup &#123;</span><br><span class="line">  Writer* leader = <span class="literal">nullptr</span>;</span><br><span class="line">  Writer* last_writer = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//... other fields</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    Writer* writer;</span><br><span class="line">    Writer* last_writer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(Writer* w, Writer* last)</span></span></span><br><span class="line"><span class="function">        : writer(w), last_writer(last) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    Writer* <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> writer; &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">      <span class="built_in">assert</span>(writer != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">if</span> (writer == last_writer) &#123;</span><br><span class="line">        writer = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writer = writer-&gt;link_newer;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> writer != other.writer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Iterator</span>(leader, last_writer); &#125;</span><br><span class="line">  <span class="function">Iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>leader</code> 负责本次 write_group 的写入操作</p></li><li><p><code>last_writer</code> 负责将本次 writer_group 中待写入的所有 writers 对象串联起来。</p><p>last_writr 实际上是 <em>tail node</em>，而 leader 是 <em>head node</em>，通过 last_writer 向 leader 方向迭代，可以遍历整个 writer_group。</p><p>因此就可以通过 <code>leader</code> 和 <code>last_writer</code> 实现 <code>Iterator</code>，进一步可以轻松融入 for-loop 迭代体系，方便后续遍历 writer_group 中所有的 witers</p></li></ul><p>之所以从 last_writer 向 leader 节点遍历，也是为了满足写入的<em>顺序性</em>：tail 是更早写 RocksDB，head 是最晚写 RocksDB，因此需要迭代时使用 <code>link_newer</code>。</p><h3 id="WriteThread-State"><a href="#WriteThread-State" class="headerlink" title="WriteThread::State"></a>WriteThread::State</h3><p>而每个 writer 在写入过程中都有个状态， 由 <code>Writer::state</code> 字段表示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WriteThread</span>::State : <span class="type">uint8_t</span> &#123;</span><br><span class="line">  STATE_INIT = <span class="number">1</span>,</span><br><span class="line">  STATE_GROUP_LEADER = <span class="number">2</span>,</span><br><span class="line">  STATE_MEMTABLE_WRITER_LEADER = <span class="number">4</span>,</span><br><span class="line">  STATE_PARALLEL_MEMTABLE_WRITER = <span class="number">8</span>,</span><br><span class="line">  STATE_COMPLETED = <span class="number">16</span>,</span><br><span class="line">  STATE_LOCKED_WAITING = <span class="number">32</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>writer 创建后，初始化状态 <em>State::STATE_INIT</em> ，然后进入 <code>WriteThread::JoinBatchGroup</code> 函数中尝试更改自己的状态：</p><ol><li>要么成为本次写入流程的 leader，即 <em>State::STATE_GROUP_LEADER</em> 状态，然后组建自己的 writer_group，代替 writer_group 中所有 writers 完成写入，所有的 writers 状态都变成 <em>State::STATE_COMPLETED</em>；</li><li>要么加入一个已经选出 leader 但是尚未执行的 writer_group 成为 follower，让该 leader 代替自己执行完本次写入，完成后自己状态即 <em>State::STATE_COMPLETED</em></li><li>否则，只能阻塞等待前面正在执行写操作的 writer_group 完成</li></ol><h2 id="这一期主要讲解个-WriteBatch-在写入前的准备工作，下一期会开始讲解-WriteThread-内部的调度过程以及一些多线程中的原子操作。"><a href="#这一期主要讲解个-WriteBatch-在写入前的准备工作，下一期会开始讲解-WriteThread-内部的调度过程以及一些多线程中的原子操作。" class="headerlink" title="这一期主要讲解个 WriteBatch 在写入前的准备工作，下一期会开始讲解 WriteThread 内部的调度过程以及一些多线程中的原子操作。 "></a>这一期主要讲解个 WriteBatch 在写入前的准备工作，下一期会开始讲解 <code>WriteThread</code> 内部的调度过程以及一些多线程中的原子操作。 </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WriteBatch&quot;&gt;&lt;a href=&quot;#WriteBatch&quot; class=&quot;headerlink&quot; title=&quot;WriteBatch&quot;&gt;&lt;/a&gt;WriteBatch&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;无论 &lt;code&gt;Put/Delete/Delet</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>MemTable、WAL、ColumnFamily 简述</title>
    <link href="https://szza.github.io/2022/01/08/rocksdb/WritePath/overview/"/>
    <id>https://szza.github.io/2022/01/08/rocksdb/WritePath/overview/</id>
    <published>2022-01-08T06:15:35.000Z</published>
    <updated>2023-08-03T04:26:02.083Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>尽管 rocksdb wiki 中 <a href="https://github.com/facebook/rocksdb/wiki">rocksdb-overview</a> 已经描述了，本文以自己的理解作为一个补充。</p><p>如图 rocksdb 的总体架构图中主要由 <code>MemTable</code>, <code>WAL</code> 和 <code>sstfile</code> 三个基本组件组成，本文主要阐述下他们之间的协作关系。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb-overview.png" alt="rocksdb-overview"></p><h3 id="MemTable"><a href="#MemTable" class="headerlink" title="MemTable"></a>MemTable</h3><p>写入的kv数据会先写入 <code>WriteBatch</code>， 在经过 <code>WriteBatchInternal</code> 封装后写入 MemTable。</p><p>MemTable 是在读写路径中共享，这样可以减少读写路径中和磁盘交互的频次。但由于 MemTable 是个内存结构，为了防止各种故障导致 MemTable 中数据丢失，进而引入 WAL (<code>W</code>rite <code>A</code>head <code>L</code>og)，即每次写入的数据，会先写入 WAL，成功后再写入 MemTable，如果 MemTable 中的数据丢失则从 WAL 中恢复。</p><p>正常情况下，写入的数据会持续写入 MemTable，直到 MemTable 的大小超过阈值，则会变成只具有只读属性的 ImutableMemTable, 同时创建新的 MemTable 接受后续的写入。等待后台线程 <em>Pickup</em> 合适的 ImmutableMemTables，将其 Flush 到 $Level_0$ 中，那么选中的 ImmutableMemTables 对应的 WALs 也可以删除了。</p><p>这里为什么用了 <em>Pickup</em> 这个说法？在 RocksDB-3.0 引入 cf(<code>C</code>olumn<code>F</code>amily) 设计，每个 cf 都有一个自己的 MemTable，但是所有的 cfs 共享一个 WAL：当向其中一个 cf 写入大量数据会导致它的 MemTable full 并转为 ImmtableMemTable。此时能直接删除当前 WAL 吗，由于WAL 可能仍保存着其他 cfs 的 MemTable 数据，这就涉及到 WAL 生命周期的问题。因此在删除 WALs 时，需要挑选出 WALs 生命周期结束的才能删除。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>TiKV 原本的架构是一个 TiKV-Server 上的所有 regions 共享两个 RocksDB 实例: <code>raft-rocksdb</code> 用于存放 raft log，<code>kv-rocksdb</code> 用于存放状态机数据，kv-rocksdb 实例有三个 column family，</p><ol><li>事务 T1 在 prewrite 阶段写入 MemTable 的 lock 信息，在事务 T1 commit 阶段之前可能有其他热点 regions 写入大量数据导致 Flush MemTable，进而导致事务 T1 commit 阶段原本可以在 MemTable 中就可以查询到 lock 信息，现在需要去 sst 文件中查询，无疑增加了成本。</li><li>那么我们是否可以通过每个 region 一个 cf 来实现 region 的隔离？</li></ol><p>  显然也是不行，因为 cf 只是逻辑上的隔离，所有的 cf 仍共享一个 WAL：如果上万个 regions 对应上万个 cfs，如果会造成很多 WALs 生命周期无法结束、得不到释放，势必生成占用大量资源。<br>3. 每个 region 一个 RocksDB 实例</p><p>  在 Release-6.6 提出 Partitioned-TiKV 架构，即每个 region 分配一个 rocksdb 实例，从物理层上实现 region 隔离，这样原本一个 region 只能存储 64M 的存储，现在可以存储10G+的数据，减少了写入过程 region-leader 分裂的频次。</p><p>  <em>Question</em>: 但是也有其他问题，比如 每个 region 一个 rocksdb，是否会因为 MemTable 导致占用的内存增加？尤其本来 TiKV 对硬件要求就很高，如此硬件成本是否会更高，以及内部 region 合并时 两个不同 RocksDB 实例的 regions 数据如何合并。不过由于 tikv region 本身就是按照 kv-range 划分的，不存在重复，合并可能主要需要修改元数据信息。</p><p>  这个设计可以参考: <a href="https://cn.pingcap.com/blog/principle-analysis-of-partitioned-raft-kv">partitioned-raft-kv</a></p><h3 id="SST"><a href="#SST" class="headerlink" title="SST"></a>SST</h3><p>Rocksdb 引擎是个 LSM (<code>L</code>og <code>S</code>tructured <code>M</code>erge) Tree， 其中 $level_0$ ~ $level_N$ 都由 sst(<code>S</code>orted <code>S</code>tring <code>T</code>able) files 组成。</p><p>sstfile 是已经将 kv 数据有序存储在磁盘上，因此和 sstfile 有关的问题不再是数据有没有可能丢失，而是如何减少 LSM Tree 中不同 level 的 sstfiles 中存储的冗余数据。这种方式即 compaction。</p><ul><li>$Level_0$ 存储最新的数据， $Level_N$ 存储最旧的数据。</li><li>$Level_0$ 中的 sstfiles 可能会有重复，$Level_1$ ~ $Level_N$ 中的数据不重复</li></ul><p>当 Compaction 方式是 <code>Level Compaction</code> 时:</p><ul><li><p>$level_0$: 当 MemTable 中的数据 Flush 到 $Level_0$ 时，会导致 $Level_0$ 存在重复的 kv range。当 $Level_0$ 的文件数量达到阈值 <code>$Level_0$_file_num_compaction_trigger</code>，$Level_0$ 会被合并到会和 $Level_1$，并保持使得 $Level_1$ 层的 sstfiles 仍然有序且无重复。</p><p>如图是 $level_0$ 的 compaction 前后过程：</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_pre_l0_compaction.png" alt="pre_l0_compaction"></p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_post_l0_compaction.png" alt="post_l0_compaction"></p></li><li><p>当 $$Level_1$$ 的数据量越来越大，会触发 $Level_1$(inpit-level)层和 $level_2$ (output-level)层的 compaction。</p><p>如图是 $level_1$ 的 compaction 前后过程：</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_pre_l1_compaction.png" alt="rocksdb_pre_l1_compaction"></p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_post_l1_compaction.png" alt="rocksdb_post_l1_compaction"></p></li><li><p>以此类推到 LSM 最底层。</p></li></ul><p>这里面需要研究的细节:</p><ul><li>input&#x2F;output level 中的哪些 sstfiles 进行 compaction</li><li>如何选择合适的 compaction 方式，平衡读写放大</li><li>当 value 较大，进行 kv 分离来降低写方大问题</li></ul><p>由于现在新型的数据库的存储引擎基本都是以 LSM Tree 为蓝本， compaction 对内存和磁盘的影响就显得愈发重要，几乎都会借鉴 RocksDB 的设计。因此，在学习 RocksDB 时，compaction 是不可或缺的一点。 </p><h2 id="ColumnFamily"><a href="#ColumnFamily" class="headerlink" title="ColumnFamily"></a>ColumnFamily</h2><p>上面已经简述了 cf，它在逻辑上将 RocksDB 划分为多个 cf，每个 cf 类似一个关系数据库中的分区表的概念。</p><p>如图，cf 的实体是 <code>class ColumnFamilyData</code>，一个 RocksDB 实例可以有多个 cfs，都保存在 <code>ColumnFamilySet</code> 对象中。一个 cf 中要记录三大部分:</p><ul><li><code>version</code>: 表征的是 lsm tree 的 $Level_0$ - $Level_N$ 信息</li><li><code>imm</code>: 表征的是只读的 MemTable，不再接受写入的 MemTable；</li><li><code>mm</code>: 当前最新的 MemTable，接受读写</li></ul><p>同样这里也存在<code>version</code>、<code>imm</code> 生命周期的问题，因为每次 flush&#x2F;comapction，都会对 imm&#x2F;version 产生影响，为了追踪生命周期，</p><ul><li><code>MemTableList</code> 对象 imm 中有个 <code>MemTableListVersion</code> 对象，并有 <em>Ref()</em>&#x2F;<em>Unref()</em> 函数来追踪生命周期；</li><li><code>Version</code> 对象 version 也有 <em>Ref()</em>&#x2F;<em>Unref()</em> 函数来追踪生命周期；</li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_cf.png" alt="rocksdb-cf"></p><p>因此，关于 cf 也好理解，在分析这块的时候可以多关注下 WALs、Version 等生命周期的起始。</p><h2 id="Get-MultiGet"><a href="#Get-MultiGet" class="headerlink" title="Get&#x2F;MultiGet"></a>Get&#x2F;MultiGet</h2><p>读取路径会比较复杂，主要是将 mm&#x2F;imm、sstfile 数据有序合并起来再取最新的数据输出，相关的三个迭代器 <code>MergingIterator</code>，<code>CompactionIterator</code>、<code>RangeTomeStoneIterator</code> 放在后续慢慢再讲解。这一部分还有一点就是利用 C++20 的协程实现异步IO来提取读取性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;尽管 rocksdb wiki 中 &lt;a href=&quot;https://github.com/</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>内存分配器之 concurrent_arena</title>
    <link href="https://szza.github.io/2022/01/07/rocksdb/MemoryAllocator/2_concurrent_arena/"/>
    <id>https://szza.github.io/2022/01/07/rocksdb/MemoryAllocator/2_concurrent_arena/</id>
    <published>2022-01-07T06:15:35.000Z</published>
    <updated>2023-08-01T02:29:39.377Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrent-arena"><a href="#concurrent-arena" class="headerlink" title="concurrent_arena"></a>concurrent_arena</h1><p>在上一期的 <a href="./2_arena.md">存分配器之 arena</a> 中，讲解了 RocksDB 是如何混合new、mmap设计一个高效的内存分配器。这一期，我们继续深入探索 RocksDB 是如何设计出一个高效的多线程内存分配器 <code>concurrent_arena</code> 。</p><p>let’s go</p><p>多线程程序的性能关键，有两个关键因素：</p><ul><li><p>减少竞争</p><p>减少竞争，有诸多方式，比如使用原子变量、细粒度锁（fine-grained mutex），threadlocal。</p></li><li><p>False Sharing</p><p>降低false sharing，一般解决办法是将线程间共享的数据大小与cacheline大小对齐（align）。</p></li></ul><p>而 concurrent_arena 即在 arena 的基础上，增加了一些多线程间的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentArena</span> : <span class="keyword">public</span> Allocator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// @brief 参数 @c block_size 与 @c huge_page_size 含义同 Arena 中</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ConcurrentArena</span><span class="params">(<span class="type">size_t</span> block_size = Arena::kMinBlockSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">size_t</span> huge_page_size = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 分配无须对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 分配需要对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Logger* logger = <span class="literal">nullptr</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Shard</span> &#123;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">40</span>] ROCKSDB_FIELD_UNUSED; </span><br><span class="line">    <span class="keyword">mutable</span> SpinMutex mutex;</span><br><span class="line">    <span class="type">char</span>* free_begin_; </span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; allocated_and_unused_; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">Shard</span>() : <span class="built_in">free_begin_</span>(<span class="literal">nullptr</span>), <span class="built_in">allocated_and_unused_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">size_t</span> tls_cpuid; </span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> padding0[<span class="number">56</span>] ROCKSDB_FIELD_UNUSED;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> shard_block_size_;</span><br><span class="line"></span><br><span class="line">  CoreLocalArray&lt;Shard&gt; shards_; <span class="comment">// 存储数据</span></span><br><span class="line"></span><br><span class="line">  Arena arena_;                                     <span class="comment">// 内存分配器</span></span><br><span class="line">  <span class="keyword">mutable</span> SpinMutex arena_mutex_;                   <span class="comment">// 保证使用 arena 分配内存时线程安全</span></span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; arena_allocated_and_unused_;  <span class="comment">// arena_ 剩余可使用的内存 </span></span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; memory_allocated_bytes_;      <span class="comment">// arena 总的分配内存</span></span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; irregular_block_num_;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> padding1[<span class="number">56</span>] ROCKSDB_FIELD_UNUSED;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Shard"><a href="#ConcurrentArena-Shard" class="headerlink" title="ConcurrentArena::Shard"></a>ConcurrentArena::Shard</h3><p>为避免竞争，<code>concurrent_arena</code> 使用将每个线程所需的内存分配在线程所属的cpu核上，如此每个线程在分配内存时都会使用自己的内存，如此就避免了竞争。这也是一种空间换时间的策略，类似于threadlocal思想。</p><p>结构体 <code>Shard</code> 记录了每个核上的内存分配、使用情况。字段 <code>shards_</code> 记录了所有核上shard。</p><p>类<code>CoreLocalArray</code> 本质上是个数组，为了提高多线程的访问效率，要将<code>Shard</code>的大小对齐到cacheline大小，以阻止false sharing现象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shard</span> &#123;</span><br><span class="line">   <span class="comment">// 填充字节以对齐到 cacheline, 避免 false sharding</span></span><br><span class="line">   <span class="type">char</span> padding[<span class="number">40</span>] ROCKSDB_FIELD_UNUSED; </span><br><span class="line">   <span class="comment">// 用于保护 free_begin_ 指向的数据</span></span><br><span class="line">   <span class="keyword">mutable</span> SpinMutex mutex;</span><br><span class="line">   <span class="comment">// 每个core上分配内存地址</span></span><br><span class="line">   <span class="type">char</span>* free_begin_; </span><br><span class="line">   <span class="comment">// 每个core剩余可用内存</span></span><br><span class="line">   std::atomic&lt;<span class="type">size_t</span>&gt; allocated_and_unused_; </span><br><span class="line"></span><br><span class="line">   <span class="built_in">Shard</span>() : <span class="built_in">free_begin_</span>(<span class="literal">nullptr</span>), <span class="built_in">allocated_and_unused_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> CoreLocalArray&lt;Shard&gt; shards_;</span><br></pre></td></tr></table></figure><h4 id="CoreLocalArray"><a href="#CoreLocalArray" class="headerlink" title="CoreLocalArray"></a>CoreLocalArray</h4><p>类 <code>CoreLocalArray</code>  只用于存储数据，本身不是线程安全的，因此需要 <code>Shard::mutex</code> 字段保护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoreLocalArray</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CoreLocalArray</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 数组元素个数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @return 返回当前线程所在core上的数据地址 ptr</span></span><br><span class="line">  <span class="function">T* <span class="title">Access</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AccessElementAndIndex</span>().first;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// @return 不仅返回当前线程所在core上的数据地址 ptr，还返回该core的index</span></span><br><span class="line">  <span class="function">std::pair&lt;T*, <span class="type">size_t</span>&gt; <span class="title">AccessElementAndIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 通过 core_idx 来获取该 core 的数据</span></span><br><span class="line">  <span class="function">T* <span class="title">AccessAtCore</span><span class="params">(<span class="type">size_t</span> core_idx)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::unique_ptr&lt;T[]&gt; data_;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="type">int</span> size_shift_;             </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-CoreLocalArray"><a href="#CoreLocalArray-CoreLocalArray" class="headerlink" title="CoreLocalArray::CoreLocalArray"></a>CoreLocalArray::CoreLocalArray</h5><p>C++11中提供了<code>std::thread::hardware_concurrency</code> 函数，来获取CPU的核数<code>num_cpus</code>，将线程数设置为 <code>num_cpus</code>，如此就能避免在一个进程中线程频繁的在不同的core上来回切换，降低线程切换上下文的开销。</p><ul><li>如果<code>num_cpus &lt;= 8</code>，则启动8个线程；</li><li>否则，开启<code>num_cpus</code>个线程（num_cpus 一般也是2的幂）。</li></ul><p>代码简洁如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CoreLocalArray&lt;T&gt;::<span class="built_in">CoreLocalArray</span>() &#123;</span><br><span class="line">  <span class="type">int</span> num_cpus = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::thread::<span class="built_in">hardware_concurrency</span>());</span><br><span class="line">  size_shift_ = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span> &lt;&lt; size_shift_ &lt; num_cpus) &#123;</span><br><span class="line">    ++size_shift_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每个core上都有类型 T 的数据</span></span><br><span class="line">  data_.<span class="built_in">reset</span>(<span class="keyword">new</span> T[<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-AccessAtCore"><a href="#CoreLocalArray-AccessAtCore" class="headerlink" title="CoreLocalArray::AccessAtCore"></a>CoreLocalArray::AccessAtCore</h5><p><code>AccessAtCore</code> 函数，用于获取核<code>core_idx</code>上的数据，即获取数组<code>data_[core_idx]</code>中数据。</p><p>在这解释下为啥类型<code>T</code>大小需要对齐到 cacheline大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* CoreLocalArray&lt;T&gt;::<span class="built_in">AccessAtCore</span>(<span class="type">size_t</span> core_idx) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">assert</span>(core_idx &lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_);</span><br><span class="line">  <span class="keyword">return</span> &amp;data_[core_idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-AccessElementAndIndex"><a href="#CoreLocalArray-AccessElementAndIndex" class="headerlink" title="CoreLocalArray::AccessElementAndIndex"></a>CoreLocalArray::AccessElementAndIndex</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::pair&lt;T*, <span class="type">size_t</span>&gt; CoreLocalArray&lt;T&gt;::<span class="built_in">AccessElementAndIndex</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="type">int</span> cpuid = port::<span class="built_in">PhysicalCoreID</span>(); <span class="comment">// 获取cpu的物理id</span></span><br><span class="line">  <span class="type">size_t</span> core_idx;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(cpuid &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// cpu id unavailable, just pick randomly</span></span><br><span class="line">    core_idx = Random::<span class="built_in">GetTLSInstance</span>()-&gt;<span class="built_in">Uniform</span>(<span class="number">1</span> &lt;&lt; size_shift_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将 cpuid 映射到 1 &lt;&lt; size_shift_ 以内</span></span><br><span class="line">    core_idx = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(cpuid &amp; ((<span class="number">1</span> &lt;&lt; size_shift_) - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="built_in">AccessAtCore</span>(core_idx), core_idx&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-ShardAllocatedAndUnused"><a href="#ConcurrentArena-ShardAllocatedAndUnused" class="headerlink" title="ConcurrentArena::ShardAllocatedAndUnused"></a>ConcurrentArena::ShardAllocatedAndUnused</h3><p><code>ShardAllocatedAndUnused</code> 则用于记录，<code>shards</code>中各个<code>shard</code>中剩余可用内存大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有已分配但未使用的内存</span></span><br><span class="line"> <span class="function"><span class="type">size_t</span> <span class="title">ConcurrentArena::ShardAllocatedAndUnused</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">   <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; shards_.<span class="built_in">Size</span>(); ++i) &#123;</span><br><span class="line">     total += </span><br><span class="line">       shards_.<span class="built_in">AccessAtCore</span>(i)-&gt;allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> total;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-ConcurrentArena"><a href="#ConcurrentArena-ConcurrentArena" class="headerlink" title="ConcurrentArena::ConcurrentArena"></a>ConcurrentArena::ConcurrentArena</h3><p><code>ConcurrentArena</code> 的构造函数比较简单：</p><ol><li>初始化每个<code>shard</code> 需要分配的内存大小 <code>shard_block_size_</code>；</li><li>初始化 <code>shards_</code> 数组；</li><li>初始化<code>arena</code></li><li>调用<code>Fixup</code>函数，初始化内存使用情况；</li></ol><p>简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentArena::<span class="built_in">ConcurrentArena</span>(<span class="type">size_t</span> block_size,</span><br><span class="line">                                 AllocTracker* tracker,</span><br><span class="line">                                 <span class="type">size_t</span> huge_page_size)</span><br><span class="line">    : <span class="built_in">shard_block_size_</span>(std::<span class="built_in">min</span>(kMaxShardBlockSize, block_size / <span class="number">8</span>)),</span><br><span class="line">      <span class="built_in">shards_</span>(),</span><br><span class="line">      <span class="built_in">arena_</span>(block_size, tracker, huge_page_size) &#123;</span><br><span class="line">  <span class="built_in">Fixup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Fixup"><a href="#ConcurrentArena-Fixup" class="headerlink" title="ConcurrentArena::Fixup"></a>ConcurrentArena::Fixup</h3><p><code>FixUp</code> 函数用于记录当前内存情况。</p><p>下面三个原子变量写入新值时，使用<code>::std::memory_order_relaxed</code>即能满足。关于<code>memory order</code>，花了两个周末的时候重温了下，有时间会再出博客深度讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcurrentArena::Fixup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arena_ 所分配的内存中剩余可使用的内存</span></span><br><span class="line">    arena_allocated_and_unused_.<span class="built_in">store</span>(arena_.<span class="built_in">AllocatedAndUnused</span>(), std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// arena 分配的内存总量</span></span><br><span class="line">    memory_allocated_bytes_.<span class="built_in">store</span>(arena_.<span class="built_in">MemoryAllocatedBytes</span>(), std::memory_order_relaxed);</span><br><span class="line">    irregular_block_num_.<span class="built_in">store</span>(arena_.<span class="built_in">IrregularBlockNum</span>(), std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Repick"><a href="#ConcurrentArena-Repick" class="headerlink" title="ConcurrentArena::Repick"></a>ConcurrentArena::Repick</h3><p><code>Repick</code> 函数，用来初始化线程。把一个线程绑定到所属的核<code>tls_cpuid</code>。这样下次以后这个线程需要内存，直接去对应的<code>shard</code>获取内存。</p><p>注意，<code>tls_cpuid</code> 默认为0，因此对于<code>core_idx</code>为0的线程需要映射到<code>num_cpus</code>，这样就能通过<code>tls_cpuid != 0</code>来判断这个线程是否初始化过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ConcurrentArena::Shard* <span class="title">ConcurrentArena::Repick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> shard_and_index = shards_.<span class="built_in">AccessElementAndIndex</span>();</span><br><span class="line">  <span class="comment">// 用于将 cord_idx 为 0 时 映射为 num_cpus，来体现此线程已初始化 </span></span><br><span class="line">  tls_cpuid = shard_and_index.second | shards_.<span class="built_in">Size</span>();</span><br><span class="line">  <span class="keyword">return</span> shard_and_index.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-AllocateImpl"><a href="#ConcurrentArena-AllocateImpl" class="headerlink" title="ConcurrentArena::AllocateImpl"></a>ConcurrentArena::AllocateImpl</h3><p>整个流程如下：</p><ol><li><p>先判断此次分配内存，是否需要从arena直接分配即可</p><ul><li>超过一个shards内存大小的1&#x2F;4</li><li>上层强制使用 arena</li><li>该线程首次调用<code>AllocateImpl</code> 函数，此时<code>shards</code>中的各个<code>shard-&gt;free_begin</code>尚未指向有效内存地址；</li></ul><p>如果要使用 <code>arena_</code>，则需要使用<code>arena_mutex_</code>保护。</p></li><li><p>尝试从shard中获取内存</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">AllocateImpl</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">bool</span> force_arena, <span class="type">const</span> Func&amp; func)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> cpu;</span><br><span class="line">  <span class="comment">// 直接使用arena分配内存，有两种情况：</span></span><br><span class="line">  <span class="comment">// 1. 待分配的内存比较大。</span></span><br><span class="line">  <span class="comment">// 2. Repick 尚未调用过，并且当前 arena_mutex_ 能直接获得</span></span><br><span class="line">  <span class="function">std::unique_lock&lt;SpinMutex&gt; <span class="title">arena_lock</span><span class="params">(arena_mutex_, std::defer_lock)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; shard_block_size_ / <span class="number">4</span> </span><br><span class="line">      <span class="comment">// 使用 huge_page</span></span><br><span class="line">      || force_arena </span><br><span class="line">      <span class="comment">// 判断条件执行到此，说明 所需的内存 bytes 并不大，比较小</span></span><br><span class="line">      <span class="comment">// 原则上是不需要使用 arena，但是如果同时满足以下二个条件：</span></span><br><span class="line">      <span class="comment">//  1. 没有执行过 Repick 函数</span></span><br><span class="line">      <span class="comment">//  2. 成功获得锁</span></span><br><span class="line">      || ((cpu = tls_cpuid) == <span class="number">0</span>   <span class="comment">// 线程尚未初始化</span></span><br><span class="line">           &amp;&amp; !shards_.<span class="built_in">AccessAtCore</span>(<span class="number">0</span>)-&gt;allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed) </span><br><span class="line">           &amp;&amp; arena_lock.<span class="built_in">try_lock</span>())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arena_lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">      <span class="comment">// 阻塞等待</span></span><br><span class="line">      arena_lock.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="comment">// 获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> rv = <span class="built_in">func</span>(); <span class="comment">// 分配内存的回调函数</span></span><br><span class="line">    <span class="built_in">Fixup</span>();</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 选择一个 shard 来满足此次内存分配</span></span><br><span class="line">  Shard* s = shards_.<span class="built_in">AccessAtCore</span>(cpu &amp; (shards_.<span class="built_in">Size</span>() - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (!s-&gt;mutex.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">    s = <span class="built_in">Repick</span>();</span><br><span class="line">    s-&gt;mutex.<span class="built_in">lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::unique_lock&lt;SpinMutex&gt; <span class="title">lock</span><span class="params">(s-&gt;mutex, std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> avail = s-&gt;allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (avail &lt; bytes) &#123;</span><br><span class="line">    <span class="comment">// reload</span></span><br><span class="line">    <span class="comment">// 此时需要使用 arnea 来分配内存</span></span><br><span class="line">    <span class="comment">// 1. 该 core 所剩的内存不足</span></span><br><span class="line">    <span class="comment">// 2. 第一次执行（本质还是第一种情况）</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;SpinMutex&gt; <span class="title">reload_lock</span><span class="params">(arena_mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> exact = arena_allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">assert</span>(exact == arena_.<span class="built_in">AllocatedAndUnused</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exact &gt;= bytes &amp;&amp; arena_.<span class="built_in">IsInInlineBlock</span>()) &#123;</span><br><span class="line">      <span class="comment">// 如果还没有消耗完 arena 的inline block的内存，则直接使用该内存</span></span><br><span class="line">      <span class="comment">// 这样就可以避免分配新的block，</span></span><br><span class="line">      <span class="keyword">auto</span> rv = <span class="built_in">func</span>(); <span class="comment">// 执行回调函数分配</span></span><br><span class="line">      <span class="built_in">Fixup</span>();</span><br><span class="line">      <span class="keyword">return</span> rv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avail = exact &gt;= shard_block_size_ / <span class="number">2</span> &amp;&amp; exact &lt; shard_block_size_ * <span class="number">2</span></span><br><span class="line">                ? exact</span><br><span class="line">                : shard_block_size_;</span><br><span class="line">    <span class="comment">// 重新分配内存</span></span><br><span class="line">    <span class="comment">// 首次调用即在此分配内存</span></span><br><span class="line">    s-&gt;free_begin_ = arena_.<span class="built_in">AllocateAligned</span>(avail);</span><br><span class="line">    <span class="built_in">Fixup</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可用内存减少</span></span><br><span class="line">  s-&gt;allocated_and_unused_.<span class="built_in">store</span>(avail - bytes, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* rv;</span><br><span class="line">  <span class="keyword">if</span> ((bytes % <span class="built_in">sizeof</span>(<span class="type">void</span>*)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// aligned allocation from the beginning</span></span><br><span class="line">    rv = s-&gt;free_begin_;</span><br><span class="line">    s-&gt;free_begin_ += bytes;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// unaligned from the end</span></span><br><span class="line">    rv = s-&gt;free_begin_ + avail - bytes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concurrent-arena&quot;&gt;&lt;a href=&quot;#concurrent-arena&quot; class=&quot;headerlink&quot; title=&quot;concurrent_arena&quot;&gt;&lt;/a&gt;concurrent_arena&lt;/h1&gt;&lt;p&gt;在上一期的 &lt;a href=</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>内存分配器之 arena</title>
    <link href="https://szza.github.io/2022/01/06/rocksdb/MemoryAllocator/2_arena/"/>
    <id>https://szza.github.io/2022/01/06/rocksdb/MemoryAllocator/2_arena/</id>
    <published>2022-01-06T06:15:35.000Z</published>
    <updated>2023-08-01T02:29:53.781Z</updated>
    
    <content type="html"><![CDATA[<p>今天，就开始逐步更新剖析 RocksDB 源码的博客。思前想后，准备自下而上，因此还是从内存分配器开始叭。</p><p>在 RocksDB 中主要有两类内存分配器<code>MemoryAllocator</code>、<code>Allocator</code>。</p><h4 id="MemoryAllocator"><a href="#MemoryAllocator" class="headerlink" title="MemoryAllocator"></a>MemoryAllocator</h4><p><code>MemoryAllocator</code> 是个基类，RocksDB 提供了两个子类：<code>MemkindKmemAllocator</code>、<code>JemallocNodumpAllocator</code>，而这两个子类，实际上分别是 <a href="https://github.com/memkind/memkind">memkind</a>、<a href="https://github.com/jemalloc/jemalloc">jemalloc</a>两个开源库的 wrapper，即利用两个开源库的函数来实现<code>Allocate</code>、<code>Deallocate</code>操作。<code>jemalloc</code>后者有时间再开专题专门细解，这里就不展开说了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAllocator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">MemoryAllocator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///@note 需要保证线程安全</span></span><br><span class="line">  <span class="comment">///@param 至少分配的内存大小</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///@note 需要保证线程安全</span></span><br><span class="line">  <span class="comment">///@brief 释放之前由 Allocate 分配的内存</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Deallocate</span><span class="params">(<span class="type">void</span>* p)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///@brief 返回 ptr 指向的block的内存大小</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">UsableSize</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> allocation_size)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// default implementation just returns the allocation size</span></span><br><span class="line">    <span class="keyword">return</span> allocation_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h2><p>本节主要详细讲解<code>Allocator</code>及其子类<code>Arena</code>的实现。</p><p>类 <code>Allocator</code> 是个基类，主要有两个接口：</p><ul><li><code>Allocate</code>：分配无须对齐的内存；</li><li><code>AllocateAligned</code>：分配需要经过对齐的内存；</li></ul><p>关于内存对齐，可以参考之前写过的一期博客 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析]，在这一期，通过讲解<code>Allocator</code>，会更加深刻的理解内存对齐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Allocator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">char</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Logger* logger = <span class="literal">nullptr</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">BlockSize</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基类<code>Allocator</code> 有两个子类，<code>Arena</code> 和<code>concurrent_arena</code>，分别用于单线程和多线程内存分配，其中 <code>concurrent_arena</code> 也是个<code>Arena</code>的<code>wrapper</code>，外加了一些措施，保证<code>Arnea</code>在多线程下的安全。因此，本文先详细讲解下<code>Arena</code>，下一节再把注意力集中在concurrent_arena&#96;的多线程设计上。</p><img src="/Users/shuzhuangzhuang/self_study/graph/需求/rocksdb/images/Allocator.jpg" style="zoom:50%;"><h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><p>类<code>Arena</code> 在分配内存时，是以 <code>block</code> 为单位，即每次先分配一个<code>block</code>大小的内存，后续所需<code>bytes</code>大小的内存时，会先尝试从<code>block</code> 中获取，如果这个<code>block</code>中剩余的可用内存能满足<code>bytes</code>，则从<code>block</code>中划出一部分给上层使用，否则才从操作系统中获取。</p><p>一个<code>block</code>容纳的内存大小，由<code>kBlockSize</code>参数来指定。</p><p>现在<code>Arena</code>怎么实现基类中<code>Allocate</code>、<code>AllocateAligned</code>两个接口？</p><p><code>Arena</code> 中有两个指针：<code>aligned_alloc_ptr_</code>、<code>unaligned_alloc_ptr_</code>，当一个<code>block</code>的内存创建完毕时：</p><ul><li><code>aligned_alloc_ptr_</code>：指向该<code>block</code>的首地址（低地址），后续用于分配需要对齐的内存；</li><li><code>unaligned_alloc_ptr_</code>：指向该<code>block</code>的末地址（高地址），后续用于分配不需要对齐的内存。</li></ul><p>示意图如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block : [-------------------------]</span><br><span class="line">        ^                         ^</span><br><span class="line">        |                         | </span><br><span class="line">   aligned_alloc_ptr_    unaligned_alloc_ptr_</span><br></pre></td></tr></table></figure><p>为啥要这么做？</p><p>由于每次内存对齐操作可能存在一定的浪费，而同一个类中所需的内存对齐大小一般是固定的，因此从blokc的一端只分配需要对齐的内存，若内存对齐大小是固定的，那么每次分配的内存也都是连续的，如此就可以减少因为内存对齐带来的浪费。</p><p>从<code>block</code>的另一端分配无需对齐的内存，还能提高内存利用率。</p><blockquote><p>比如，block的大小为7个字节，分配一块需要4字节对齐的内存，还剩下3字节的内存，可以继续用于无须对齐的内存。</p></blockquote><p>下面先整体看看类<code>Arean</code>。</p><blockquote><p>在下面的源码分析中，做了一些简化，去除了一些统计内存大小部分的代码，读者可自行追溯RocksDB中该部分的源码。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Arena</span> : <span class="keyword">public</span> Allocator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  <span class="built_in">Arena</span>(<span class="type">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kInlineSize = <span class="number">2048</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kMinBlockSize;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kMaxBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Arena</span><span class="params">(<span class="type">size_t</span> block_size = kMinBlockSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                 AllocTracker* tracker = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">size_t</span> huge_page_size = <span class="number">0</span>)</span></span>;</span><br><span class="line">  ~<span class="built_in">Arena</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 分配无需对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 分配需要对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Logger* logger = <span class="literal">nullptr</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// 当前已使用内存大小</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">ApproximateMemoryUsage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blocks_memory_ + blocks_.<span class="built_in">capacity</span>() * <span class="built_in">sizeof</span>(<span class="type">char</span>*) - alloc_bytes_remaining_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 总的已分配内存</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">MemoryAllocatedBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> blocks_memory_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 剩余可用内存</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">AllocatedAndUnused</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> alloc_bytes_remaining_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 分配的不对齐block数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">IrregularBlockNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> irregular_block_num; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 一个 block 的内存大小</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">BlockSize</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> kBlockSize; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// blocks_ 是否用的栈上内存</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsInInlineBlock</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blocks_.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">alignas</span>(<span class="type">max_align_t</span>) <span class="type">char</span> inline_block_[kInlineSize];</span><br><span class="line">  <span class="comment">// 一个block分配的内存大小</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> kBlockSize;           </span><br><span class="line">  <span class="keyword">typedef</span> std::vector&lt;<span class="type">char</span>*&gt; Blocks; </span><br><span class="line">  <span class="comment">// 使用new分配的block集合</span></span><br><span class="line">  Blocks blocks_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">MmapInfo</span> &#123;</span><br><span class="line">    <span class="type">void</span>* addr_;</span><br><span class="line">    <span class="type">size_t</span> length_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MmapInfo</span>(<span class="type">void</span>* addr, <span class="type">size_t</span> length) : <span class="built_in">addr_</span>(addr), <span class="built_in">length_</span>(length) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 使用 mmap 分配内存的block集合</span></span><br><span class="line">  std::vector&lt;MmapInfo&gt; huge_blocks_; </span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> irregular_block_num = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span>* unaligned_alloc_ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">char</span>* aligned_alloc_ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 当前block剩余可用内存</span></span><br><span class="line">  <span class="type">size_t</span> alloc_bytes_remaining_ = <span class="number">0</span>; </span><br><span class="line">   <span class="comment">// 目前一共分配的内存</span></span><br><span class="line">  <span class="type">size_t</span> blocks_memory_ = <span class="number">0</span>;        </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="type">size_t</span> hugetlb_size_ = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MAP_HUGETLB</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateFromHugePage</span><span class="params">(<span class="type">size_t</span> bytes)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">bool</span> aligned)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Arena-Arena"><a href="#Arena-Arena" class="headerlink" title="Arena::Arena"></a>Arena::Arena</h3><p>先来看看构造函数 <code>Arena::Arena</code>。这里，主要初始化一些类成员变量：</p><ul><li><p><code>kBlockSize</code></p><p>字段<code>kBlockSize</code> ，表达的是以后每次分配一个block时的内存大小。在初始化之前，使用<code>OptimizeBlockSize</code>函数对传入的参数<code>block_size</code>进行限制，使其满足后续的<code>assert</code>判断。</p><p>通过 <code>OptimizeBlockSize</code> 函数限制<code>block_size</code>的值，减少后续分配需要对齐的内存浪费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> Arena::kMinBlockSize = <span class="number">4096</span>;           <span class="comment">// 最小为 4k</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> Arena::kMaxBlockSize = <span class="number">2u</span> &lt;&lt; <span class="number">30</span>;       <span class="comment">// 最大为 8k</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kAlignUnit = <span class="built_in">alignof</span>(<span class="type">max_align_t</span>); <span class="comment">// 按照 8 byte 对齐</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">OptimizeBlockSize</span><span class="params">(<span class="type">size_t</span> block_size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确保满足： Arena::kMinBlockSize &lt;= block_size &lt;= Arena::kMaxBlockSize</span></span><br><span class="line">  block_size = std::<span class="built_in">max</span>(Arena::kMinBlockSize, block_size);</span><br><span class="line">  block_size = std::<span class="built_in">min</span>(Arena::kMaxBlockSize, block_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保 block_size 是 8 的倍数</span></span><br><span class="line">  <span class="keyword">if</span> (block_size % kAlignUnit != <span class="number">0</span>) &#123;</span><br><span class="line">    block_size = (<span class="number">1</span> + block_size / kAlignUnit) * kAlignUnit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>inline_block_</code></p><p>字段<code>inline_block_</code> ，其中的<code>inline</code>语义是指这块内存分配在栈上，在地址上和<code>Arena</code>是连续的。这对于那些只需要分配小内存的操作具有优势，可以避免从堆上分配内存。当这块内存使用完毕，会再从堆上获取。</p></li><li><p><code>hugetlb_size_</code></p><p>字段<code>hugetlb_size_</code>，是默认情况下使用<code>mmap</code>给block分配的内存大小。如果 <code>hugetlb_size_ == 0</code>，则表示不使用<code>mmap</code>分配内存。</p><p>当然，<code>hugetlb_size_</code> 在构造函数中也是经过向上取整操作，变为 8 的倍数。</p></li></ul><p>现在，可以很好的阅读构造函数 <code>Arena::Arena</code> 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Arena::<span class="built_in">Arena</span>(<span class="type">size_t</span> block_size, </span><br><span class="line">             AllocTracker* tracker, </span><br><span class="line">             <span class="type">size_t</span> huge_page_size)</span><br><span class="line">    : <span class="built_in">kBlockSize</span>(<span class="built_in">OptimizeBlockSize</span>(block_size)) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(kBlockSize &gt;= kMinBlockSize &amp;&amp; kBlockSize &lt;= kMaxBlockSize &amp;&amp;</span><br><span class="line">         kBlockSize % kAlignUnit == <span class="number">0</span>);</span><br><span class="line">  alloc_bytes_remaining_ = <span class="built_in">sizeof</span>(inline_block_);</span><br><span class="line">  blocks_memory_ += alloc_bytes_remaining_;</span><br><span class="line">  <span class="comment">// 对齐侧指向了低地址</span></span><br><span class="line">  aligned_alloc_ptr_ = inline_block_;</span><br><span class="line">  <span class="comment">// 不对齐侧指向了高地址</span></span><br><span class="line">  unaligned_alloc_ptr_ = inline_block_ + alloc_bytes_remaining_;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  hugetlb_size_ = huge_page_size;</span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_ &amp;&amp; kBlockSize &gt; hugetlb_size_) &#123;</span><br><span class="line">    <span class="comment">// hugetlb_size_ 向上取整</span></span><br><span class="line">    hugetlb_size_ = ((kBlockSize - <span class="number">1U</span>) / hugetlb_size_ + <span class="number">1U</span>) * hugetlb_size_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)huge_page_size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateNewBlock"><a href="#Arena-AllocateNewBlock" class="headerlink" title="Arena::AllocateNewBlock"></a>Arena::AllocateNewBlock</h3><p><code>AllocateNewBlock</code> 函数比较普通，本质上就是使用 <code>new</code> 操作从操作系统获取内存。</p><p>这里面稍微有个<code>trick</code>的操作，是<code>blocks_.emplace_back(nullptr);</code> 这行，作用是在<code>blocks_</code>中预留一个指针大小的空间，即 <code>sizeof(Block*)</code>，出于内存泄露的考虑，使用了<code>emplace_back</code>，而不是<code>reserve</code>函数。</p><p>RocksDB 解释如下：</p><ul><li>如果<code>emplace_back</code> 函数抛出异常，不会发生内存泄露，因为此时还没使用<code>new</code>分配内存；</li><li>如果<code>new</code> 抛出异常（即<code>std::bad_alloc</code>异常），也不会发生内存泄露，因为在<code>blocks_</code>中预留的空间将会基于RAII语义被清除。</li></ul><p><code>AllocateNewBlock</code> 函数，直接使用<code>new</code>操作分配内存，不负责进行内存对齐操作。如果需要按照某个<code>alignment</code>大小进行对齐，得调用 <code>AllocateAligned</code>  函数，这个后面再说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///@return 返回指针，指向当前分配的 block</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Reserve space in `blocks_` before allocating memory via new.</span></span><br><span class="line">  <span class="comment">// Use `emplace_back()` instead of `reserve()` to let std::vector manage its</span></span><br><span class="line">  <span class="comment">// own memory and do fewer reallocations.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// - If `emplace_back` throws, no memory leaks because we haven&#x27;t called `new`</span></span><br><span class="line">  <span class="comment">//   yet.</span></span><br><span class="line">  <span class="comment">// - If `new` throws, no memory leaks because the vector will be cleaned up</span></span><br><span class="line">  <span class="comment">//   via RAII.</span></span><br><span class="line">  blocks_.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 分配内存</span></span><br><span class="line">  <span class="type">char</span>* block = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">  <span class="type">size_t</span> allocated_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ROCKSDB_MALLOC_USABLE_SIZE</span></span><br><span class="line">  allocated_size = <span class="built_in">malloc_usable_size</span>(block);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  allocated_size = block_bytes;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 增加已分配内存</span></span><br><span class="line">  blocks_memory_ += allocated_size;</span><br><span class="line">  <span class="comment">// 赋值</span></span><br><span class="line">  blocks_.<span class="built_in">back</span>() = block;</span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来解释下为何使用<code>reserve</code>可能会导致内存泄露，写法如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  blocks_.<span class="built_in">reserve</span>(<span class="number">1</span>);        <span class="comment">// 预留空间</span></span><br><span class="line">  <span class="type">char</span>* block = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">  <span class="type">size_t</span> allocated_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ROCKSDB_MALLOC_USABLE_SIZE</span></span><br><span class="line">  allocated_size = <span class="built_in">malloc_usable_size</span>(block);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  allocated_size = block_bytes;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  blocks_memory_ += allocated_size;</span><br><span class="line">  blocks_.<span class="built_in">emplace_back</span>(block); <span class="comment">// 抛出异常???</span></span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理由很简单：上面这个写法，如果在<code>emplace_back</code>的过程中抛出异常，那么 <code>block</code> 指向的内存将会泄露。</p><p>尽管<code>emplace_back</code>抛异常这种bad case极少出现，但也应该为RocksDB的细致点赞。</p><h3 id="Arena-AllocateFromHugePage"><a href="#Arena-AllocateFromHugePage" class="headerlink" title="Arena::AllocateFromHugePage"></a>Arena::AllocateFromHugePage</h3><p><code>Arena</code> 中有两种方式从操作系统获取内存：</p><ul><li><code>new</code>：即如<code>Arena::AllocateNewBlock</code> 函中数的实现；</li><li><code>mmap</code>：即如 <code>Arena::AllocateFromHugePage</code> 函数中的实现。</li></ul><p><code>mmap</code>、<code>munmap</code>函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>; </span><br><span class="line"><span class="comment">// 释放 mmap 分配的内存</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;   </span><br></pre></td></tr></table></figure><p>使用<code>mmap</code>分配内存，需要<code>linux</code>内核支持  <a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/maz/arm-platforms/+/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2/Documentation/vm/hugetlbpage.txt">HUGE_PAGE</a>，即当前linux内核具有 <code>MAP_HUGETLB</code> 标志位， 即可以如下操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///@return 返回指针，指向当前分配的 block</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateFromHugePage</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先使用 emplace_back 理由同上</span></span><br><span class="line">  huge_blocks_.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span> <span class="comment">/* addr */</span>, <span class="number">0</span> <span class="comment">/* length */</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 mmap 从 hugepage 中分配 bytes 个字节</span></span><br><span class="line">  <span class="type">void</span>* addr = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, </span><br><span class="line">                    bytes, </span><br><span class="line">                    (PROT_READ | PROT_WRITE),</span><br><span class="line">                    (MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB), <span class="comment">// 需要 MAP_HUGETLB 支持</span></span><br><span class="line">                    <span class="number">-1</span>, </span><br><span class="line">                    <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  huge_blocks_.<span class="built_in">back</span>() = <span class="built_in">MmapInfo</span>(addr, bytes);</span><br><span class="line">  blocks_memory_ += bytes;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(addr);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)bytes;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateFallback"><a href="#Arena-AllocateFallback" class="headerlink" title="Arena::AllocateFallback"></a>Arena::AllocateFallback</h3><p>好嘞，介绍完上面两种分配内存的措施，现在来看看统一上述两个操作的<code>AllocateFallback</code>函数。</p><p>当调用<code>AllocateFallback</code>函数时，是上层发现当前<code>block</code>中剩余的内存无法满足<code>bytes</code>个字节的需求，需要重新从操作系统获取内存。运行到<code>AllocateFallback</code>函数时，逻辑如下：</p><ul><li><p>如果所需的内存大小 <code>bytes</code> 超过了<code>kBlockSize / 4</code>，就直接从操作系统中获取<code>bytes</code>大小的内存，返回给<code>AllocateFallback</code>函数的调用方。那么就能避免浪费当前 block 中剩余的内存，这部分可以继续保留，供给下一次内存分配时使用。</p></li><li><p>否则，当前block中剩余的内存就将会被抛弃，重新从操作系统获中分配一个block的内存，供给上层使用。</p><p>此时，由 <code>bytes &lt;= kBlockSize / 4</code>，因此也降低了浪费，</p></li></ul><p>现在，顺着代码注释往下看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">bool</span> aligned)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    ++irregular_block_num;</span><br><span class="line">    <span class="comment">// 如果所需的内存大小 bytes 超过了 block 的1/4，那么就直接分配内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span>* block_head = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_) &#123;</span><br><span class="line">    <span class="comment">// mmap 分配的的一个block内存大小为 hugetlb_size_</span></span><br><span class="line">    size = hugetlb_size_;</span><br><span class="line">    block_head = <span class="built_in">AllocateFromHugePage</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (!block_head) &#123;</span><br><span class="line">    <span class="comment">// block_head == nullptr, 即当前linux内核不支 hugetlb</span></span><br><span class="line">    <span class="comment">// 那么使用 new 来分配内存</span></span><br><span class="line">    size = kBlockSize;</span><br><span class="line">    block_head = <span class="built_in">AllocateNewBlock</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//! 之前block未使用的内存就忽略了，</span></span><br><span class="line">  <span class="comment">//! 但不会内存泄露，因为会在析构函数 ~Arena 中释放</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前block划掉 bytes 个字节后，剩余的可用内存大小</span></span><br><span class="line">  alloc_bytes_remaining_ = size - bytes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (aligned) &#123;</span><br><span class="line">    aligned_alloc_ptr_ = block_head + bytes; <span class="comment">// 从低地址端增加 bytes 字节</span></span><br><span class="line">    unaligned_alloc_ptr_ = block_head + size;</span><br><span class="line">    <span class="comment">// 表示 [block_head, block_head + bytes) 可用</span></span><br><span class="line">    <span class="keyword">return</span> block_head;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    aligned_alloc_ptr_ = block_head; </span><br><span class="line">    unaligned_alloc_ptr_ = block_head + size - bytes; <span class="comment">// 尾部向前推动 bytes</span></span><br><span class="line">    <span class="comment">// 表示 [unaligned_alloc_ptr_, unaligned_alloc_ptr_ + bytes) 可用</span></span><br><span class="line">    <span class="keyword">return</span> unaligned_alloc_ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateAligned"><a href="#Arena-AllocateAligned" class="headerlink" title="Arena::AllocateAligned"></a>Arena::AllocateAligned</h3><p>最后，就是对外提供分配对齐内存的函数 <code>AllocateAligned</code>。</p><p>其输入参数<code>huge_page_size</code>，语义是在使用mmap分配内存时的自定义 <code>alignment</code>，如果 <code>huge_page_size</code>  为 0，只是表示此时不需要自定义的<code>alignment</code>，使用默认的<code>kAlignUnit</code>即可。</p><p>换句话说，当需要自定义<code>alignment</code>时，RcoskDb 是准备使用<code>mmap</code>来分配内存。</p><p>当使用默认的<code>kAlignUnit</code>，如果当前block中剩余的可用内存能满足need个字节（need个字节，是bytes字节按照<code>kAlignUnit</code>对齐的后的大小），则继续从当前block中划分出去need个字节，否则就使用上述的<code>AllocateFallback</code>函数，重新从操作系统分配内存。</p><p>现在，顺着代码注释向下看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">size_t</span> huge_page_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Logger* logger)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Pointer size should be a power of 2</span></span><br><span class="line">  <span class="built_in">assert</span>((kAlignUnit &amp; (kAlignUnit - <span class="number">1</span>)) == <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义的内存对齐值 huge_page_size，只使用mmap来分配</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (huge_page_size &gt; <span class="number">0</span> &amp;&amp; bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(logger != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 将 bytes 向上调整到 huge_page_size 的整倍数</span></span><br><span class="line">    <span class="type">size_t</span> reserved_size = ((bytes - <span class="number">1U</span>) / huge_page_size + <span class="number">1U</span>) * huge_page_size;</span><br><span class="line">    <span class="built_in">assert</span>(reserved_size &gt;= bytes);</span><br><span class="line">    <span class="type">char</span>* addr = <span class="built_in">AllocateFromHugePage</span>(reserved_size);</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">ROCKS_LOG_WARN</span>(logger,</span><br><span class="line">                     <span class="string">&quot;AllocateAligned fail to allocate huge TLB pages: %s&quot;</span>,</span><br><span class="line">                     <span class="built_in">errnoStr</span>(errno).<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)huge_page_size;</span><br><span class="line">  (<span class="type">void</span>)logger;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面则使用默认的 kAlignUnit 对齐大小</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> current_mod =</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(aligned_alloc_ptr_) &amp; (kAlignUnit - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 计算距离对齐还差几个字节</span></span><br><span class="line">  <span class="type">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : kAlignUnit - current_mod);</span><br><span class="line">  <span class="comment">// 对齐后需分配的字节数</span></span><br><span class="line">  <span class="type">size_t</span> needed = bytes + slop;  </span><br><span class="line">  <span class="type">char</span>* result;</span><br><span class="line">  <span class="comment">// 当前block中的剩余内存是否能满足此次 needed 个字节需求</span></span><br><span class="line">  <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="comment">// result 调整到对齐后的位置</span></span><br><span class="line">    result = aligned_alloc_ptr_ + slop; </span><br><span class="line">    <span class="comment">// 调整到对齐后的位置</span></span><br><span class="line">    aligned_alloc_ptr_ += needed;  </span><br><span class="line">    <span class="comment">// block中剩余的字节数</span></span><br><span class="line">    alloc_bytes_remaining_ -= needed;   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前 block 剩余的内存不足，则从操作系统获取</span></span><br><span class="line">    result = <span class="built_in">AllocateFallback</span>(bytes, <span class="literal">true</span> <span class="comment">/* aligned */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>((<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(result) &amp; (kAlignUnit - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>by the way</strong></p><p>这里稍微总结下，如何向上调整、计算对齐后的地址。</p><p>实际上计算的方法有很多种，但是都符合上一期 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析] 最后提到了一点：本质上就是以「<code>alignment</code>进制」向上（下）取为<code>alignment</code>的整倍数。</p><p>比如，在十进制下，12向上取整为10的倍数，即20。</p><p>理解了这一层之后，再来看看下面几个计算方式：</p><ul><li><p>case 1：<code>size_t aligned = ((bytes - 1U) / alignment + 1U) * alignment</code></p><p>单纯地将<code>bytes</code>向上调整为<code>alignment</code>的整倍数，可以实现为  <code>(bytes / alignment + 1U) * alignment</code>，那为啥要 <code>- 1</code> 呢？</p><p>如果<code>bytes</code>本身就已是<code>alignment</code>的整数，按照这 native 实现，会无端将<code>bytes</code>增加了<code>alignment</code>。为了应对这种情况，需要先减少1。</p><p>此外，在 <code>Arena::Arena</code> 中调整<code>hugetlb_size_</code> 时，也是如此计算。而在<code>OptimizeBlockSize</code>函数中，调整<code>block_size</code>时，可以确定<code>block_size</code> 不是 <code>kAlignUnit</code>的整数时，就可将<code>-1</code>去掉，简化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block_size % kAlignUnit != <span class="number">0</span>) &#123;</span><br><span class="line">  block_size = (<span class="number">1</span> + block_size / kAlignUnit) * kAlignUnit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>case 2：<code>size_t aligned = (bytes - 1u + alignment) &amp; -alignment</code></p><p>这种实现，利用位位运算将余数清除，效率较高，这也是<code>std::align</code> 函数的实现方式，这在 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析] 分析过，这里顺带再解释下。</p><p>其中 <code>alignment</code> 是无符号数，<code>-alignment</code> 的值实际上是 <code>::pow(2, n) - alignment</code>。那么<code>bytes - 1u + alignment</code> 对 <code>-alignment</code> 取 <code>&amp;</code>操作，就能保证 <code>bytes - 1u + alignment</code> 的高位不变，而小于<code>alignment</code> 的余数全部清除。</p></li></ul><p>万变不离其宗，理解了这个逻辑，无论是向上调整、亦或是向下调整，都能很好理解了。</p><h3 id="Arena-Allocate"><a href="#Arena-Allocate" class="headerlink" title="Arena::Allocate"></a>Arena::Allocate</h3><p>讲完了上面<code>AllocateAligned</code>函数之后，再看<code>Allocate</code>函数，就非常好理解了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 如果当前block剩余足够的内存，则直接分配</span></span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    unaligned_alloc_ptr_ -= bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> unaligned_alloc_ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不用对齐</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes, <span class="literal">false</span> <span class="comment">/* unaligned */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-Arena-1"><a href="#Arena-Arena-1" class="headerlink" title="Arena::~Arena"></a>Arena::~Arena</h3><p>释放所有已分配的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Arena::~<span class="built_in">Arena</span>() &#123;</span><br><span class="line">  <span class="comment">// 释放所有使用 new 分配的内存</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; block : blocks_) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] block;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; mmap_info : huge_blocks_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mmap_info.addr_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放所有使用 mmap 分配的内存</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">munmap</span>(mmap_info.addr_, mmap_info.length_);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO(sdong): Better handling</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Say-Something"><a href="#Say-Something" class="headerlink" title="Say Something"></a>Say Something</h2><p>一个优秀的开源项目，其单元测试（unitest）也是很好的学习资料。尤其对于RocksDB这类比较大的项目，无法下手的话，可以先从单元测试着手。</p><p>下一期，讲解下多线程内存分配器的设计，会更加硬核，敬请期待。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天，就开始逐步更新剖析 RocksDB 源码的博客。思前想后，准备自下而上，因此还是从内存分配器开始叭。&lt;/p&gt;
&lt;p&gt;在 RocksDB 中主要有两类内存分配器&lt;code&gt;MemoryAllocator&lt;/code&gt;、&lt;code&gt;Allocator&lt;/code&gt;。&lt;/p</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>内存对齐之 alignof、alignas 、aligned_storage、align 剖析</title>
    <link href="https://szza.github.io/2022/01/01/C++/align/"/>
    <id>https://szza.github.io/2022/01/01/C++/align/</id>
    <published>2022-01-01T06:09:54.000Z</published>
    <updated>2023-08-03T04:03:48.215Z</updated>
    
    <content type="html"><![CDATA[<p>关于内存对齐，有诸多好处，因此常常在分配内存时也会将内存对齐这一因素纳入考量。</p><p>这一节，来讲下内存对齐以及C++11中关于内存对齐引入的<code>alignof</code>、<code>alignas</code>、<code>std::aligned_storage</code>、<code>std::align</code> ，其中前两个为关键字，后两个分别为类和函数。</p><h2 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h2><p>我们知道，C++中的内置的基础类型，比如<code>char</code>、<code>int</code>、<code>float</code>、<code>double</code>，在内存布局上都是按照其 <code>sizeof</code> 大小进行对齐（alignment）。</p><p>什么叫对齐？</p><p>比如，<code>sizoef(int)</code> 值为 4，如果满足内存对齐要求，那么int类型变量<code>a</code>的地址<code>&amp;a</code>对4取余的结果应该是0。</p><p>下面提供一个编译期就能检测内存对齐的宏 <code>CHECK_ALIGN</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_ALIGN(ptr, alignment)                       \</span></span><br><span class="line"><span class="meta">  do&#123;                                                     \</span></span><br><span class="line"><span class="meta">    constexpr size_t status                               \</span></span><br><span class="line"><span class="meta">       = reinterpret_cast<span class="string">&lt;uintptr_t&gt;</span>(ptr) % alignment;    \</span></span><br><span class="line"><span class="meta">    static_assert(status == 0, <span class="string">&quot;ptr must be aligned&quot;</span>);    \</span></span><br><span class="line"><span class="meta">  &#125;while(0)                                               \</span></span><br></pre></td></tr></table></figure><p>下面我们来校验内置类型的内存对齐大小确实等于其<code>sizoef(T)</code>值，demo如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">long</span> l ;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;c, <span class="built_in">sizeof</span>(c));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;i, <span class="built_in">sizeof</span>(i));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;l, <span class="built_in">sizeof</span>(l));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;f, <span class="built_in">sizeof</span>(f));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;i, <span class="built_in">sizeof</span>(l)); <span class="comment">// 编译错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述demo中的 <code>CHECK_ALIGN(&amp;i, sizeof(l));</code> 会导致编译错误，因为<code>int</code>类型变量的内存对齐大小要求是4，而<code>long</code>在gcc下是8个字节，即<code>sizoef(l)</code>为8，故而编译失败。</p><p>到此，我相信你应该明白何为「内存对齐」了。</p><h2 id="alignof"><a href="#alignof" class="headerlink" title="alignof"></a>alignof</h2><p>C++11引入的关键字<code>alignof</code>，可直接获取类型<code>T</code>的内存对齐要求。<code>alignof</code>的返回值类型是<code>size_t</code>，用法类似于<code>sizeof</code>。</p><p>下面先来看看<code>alignof</code>的用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW_SIZEOF_AND_ALIGNOF(T)                                   \</span></span><br><span class="line"><span class="meta">  do &#123;                                                               \</span></span><br><span class="line"><span class="meta">    std::cout &lt;&lt; <span class="string">&quot;sizeof(&quot;</span> &lt;&lt; #T &lt;&lt; <span class="string">&quot;):\t&quot;</span> &lt;&lt; sizeof(T) &lt;&lt; <span class="string">&quot;,\t&quot;</span>     \</span></span><br><span class="line"><span class="meta">              &lt;&lt; <span class="string">&quot;alignof(&quot;</span> &lt;&lt; #T &lt;&lt; <span class="string">&quot;):\t&quot;</span> &lt;&lt; alignof(T)            \</span></span><br><span class="line"><span class="meta">              &lt;&lt; std::endl;                                          \</span></span><br><span class="line"><span class="meta">  &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">char</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">int</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">long</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">float</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">double</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，这也是符合前文关于基础类型内存对齐的论述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(char):   1,      alignof(char):  1</span><br><span class="line">sizeof(int):    4,      alignof(int):   4</span><br><span class="line">sizeof(long):   8,      alignof(long):  8</span><br><span class="line">sizeof(<span class="built_in">float</span>):  4,      alignof(<span class="built_in">float</span>): 4</span><br><span class="line">sizeof(double): 8,      alignof(double):8</span><br></pre></td></tr></table></figure><p>好，到此我相信你已经对内存对齐和<code>alignof</code>有了基本了解。下面我们来看看类的内存对齐。</p><p>现在有类<code>Foo</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1; </span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>考虑下<code>alignof(Foo)</code>和<code>sizeof(Foo)</code>分别会是多少，即下面的demo会输出？？？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(Foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Think Again~~~~</p><p>3</p><p>2</p><p>1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(Foo):    24,     alignof(Foo):   8</span><br></pre></td></tr></table></figure><p>嗯？怎么会是这个结果？</p><p>为了更好地解释这个结果，我准备借助<code>offsetof</code>函数，来获取成员变量距离类起始地址的偏移量，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Offset of member MEMBER in a struct of type TYPE. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(OBJECT_TYPE, MEMBER) __builtin_offsetof (OBJECT_TYPE, MEMBER)</span></span><br></pre></td></tr></table></figure><p>好，现在看下如下代码，并猜测下输出？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">offsetof</span>(Foo, c)  &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">offsetof</span>(Foo, i1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span> </span><br><span class="line">            &lt;&lt; <span class="built_in">offsetof</span>(Foo, i2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">offsetof</span>(Foo, l)  &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">0   <span class="comment"># c 的偏移量为 0 </span></span><br><span class="line">4   <span class="comment"># i1 的偏移量为 4， c  -&gt; i1 中间填充了 3个字节，才满足 4 字节的内存对齐要求</span></span><br><span class="line">8   <span class="comment"># i2 的偏移量为 8,  i1 -&gt; i2 无填充</span></span><br><span class="line">16  <span class="comment"># l 的偏移量为 16， i2 -&gt; l  中间填充了4个字节，才满足8字节的内存对齐要求</span></span><br></pre></td></tr></table></figure><p>好，到此，我准备基于这个输出来解释<code>alignof</code>了。</p><p>对于<code>Foo</code>而言，所谓内存对齐，即<code>Foo</code>中每个字段都要满足内存对齐。而内存对齐最严格（即对齐字节数最大）的字段满足了，其他的字段也就满足了。</p><p>假设现在有三个起始地址，分别是 0、1、4，我们来看看是否都能满足<code>Foo</code>中所有字段的内存对齐要求。</p><p>起始地址分别0、1、4，各个字段的地址如下三列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;   </span><br><span class="line">  <span class="type">char</span> c;     <span class="comment">// 0  |  1  |  4</span></span><br><span class="line">  <span class="type">int</span> i1;     <span class="comment">// 4  |  5  |  8</span></span><br><span class="line">  <span class="type">int</span> i2;     <span class="comment">// 8  |  9  |  12 </span></span><br><span class="line">  <span class="type">long</span> l;     <span class="comment">// 16 |  17 |  20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的右侧三列结果可以看出，只有起始地址为0（8的整倍数）的恰好能满足所有字段内存对齐的要求。因此，<code>alignof(Foo)</code>输出为8。</p><h2 id="alignas"><a href="#alignas" class="headerlink" title="alignas"></a>alignas</h2><p>上面讲述的内存对齐要求都是默认情况下的，有时候考虑到cacheline、以及向量化操作，可能会需要改变一个类的<code>alignof</code>值。</p><p>怎么办？</p><p>在C++11之前，需要依赖靠编译器的扩展指令，C++11之后可以借助<code>alignas</code>关键字。</p><blockquote><p>比如，在C++11之前，gcc实现 <code>alignas(alignment)</code> 效果的方式为  <code>__attribute__((__aligned__((alignment)))</code></p></blockquote><p>仍然以上述的<code>Foo</code>为例子，不过此时你希望<code>Foo</code>对象的起始地址总是32的倍数，C++11之后借助<code>alignas</code>关键字，可以如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>) Foo &#123; </span><br><span class="line">  <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1; </span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  Foo foo;</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;foo, <span class="built_in">alignof</span>(foo));</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(Foo);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">0x16d6f34e0</span><br><span class="line">sizeof(Foo):    32,     alignof(Foo):   32</span><br></pre></td></tr></table></figure><p>说完<code>alignas</code>的基础用法，下面说下使用<code>alignas</code>时的注意事项，即<code>alignas(alignment)</code>中的<code>alignment</code>也不是随意写的，对于类型<code>T</code>，需要满足如下两个条件。</p><h3 id="1-alignment-alignof-T"><a href="#1-alignment-alignof-T" class="headerlink" title="1. alignment &gt;&#x3D; alignof(T)"></a>1. alignment &gt;&#x3D; alignof(T)</h3><p>仍然以<code>Foo</code>为例，在没有<code>alignas</code>修饰时，默认的Foo的内存对齐要求<code>alignof(Foo)</code>为8，现在尝试使用<code>alignas</code>让<code>Foo</code>的对齐要求为4，操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">4</span>) Foo &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1;</span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时 <code>SHOW_SIZEOF_AND_ALIGNOF(Foo);</code>的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(Foo):    24,     alignof(Foo):   8</span><br></pre></td></tr></table></figure><p>可以看出，此时的<code>alignas</code>是失效的，在其他编译器下也许直接编译失败。</p><h3 id="2-alignment-pow-2-N"><a href="#2-alignment-pow-2-N" class="headerlink" title="2. alignment &#x3D;&#x3D; pow(2, N)"></a>2. alignment &#x3D;&#x3D; pow(2, N)</h3><p>即<code>alignas</code> 指定的大小<code>alignment</code>必须是2的正数幂（<code>N&gt;0</code>），否则也是失效，在有些编译器下也许直接编译失败。</p><p>仍然以<code>Foo</code>为例子，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">9</span>) Foo &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1;</span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">main.cc:<span class="number">20</span>:<span class="number">19</span>: error: requested alignment <span class="string">&#x27;9&#x27;</span> is <span class="keyword">not</span> a positive power of <span class="number">2</span></span><br><span class="line">   <span class="number">20</span> | <span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">9</span>) Foo &#123;</span><br><span class="line">      |                   ^~~</span><br></pre></td></tr></table></figure><p>好，到此，我想你应该大致理解了<code>alignof</code>和<code>alignas</code>两个关键字，更多用法可以参&#96;<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a>。</p><h2 id="std-aligned-storage"><a href="#std-aligned-storage" class="headerlink" title="std::aligned_storage"></a>std::aligned_storage</h2><p>在C++11中，也引入了一个满足内存对齐要求的静态内存分配类<code>std::aligned_storage</code>，其类模板原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &lt;type_traits&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; std::<span class="type">size_t</span> Len, </span><br><span class="line">          std::<span class="type">size_t</span> Align = <span class="comment">/*default-alignment*/</span> &gt;</span><br><span class="line"><span class="keyword">struct</span> aligned_storage;</span><br></pre></td></tr></table></figure><p>类<code> std::aligned_storage</code>对象构造完成时，即分配了长度为<code>Len</code>个字节的内存，且该内存满足大小为 <code>Align</code> 的对齐要求。</p><p>下面，我们先来看看 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a> 给的一个demo，来熟悉下怎么使用<code>std::aligned_storage</code>。</p><p>类 <code>StaticVector</code> ，是一个满足内存对齐要求的静态数组，模板参数<code>T</code>是元素类型，<code>N</code>是数组元素个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticVector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StaticVector</span>() &#123; </span><br><span class="line">      std::cout &lt;&lt; <span class="built_in">alignof</span>(T) &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(T)&lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; N; ++idx) &#123; </span><br><span class="line">        std::cout &lt;&lt; &amp;data[idx] &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">StaticVector</span>() &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> pos = <span class="number">0</span>; pos &lt; m_size; ++pos) &#123;</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(data+pos)-&gt;~<span class="built_in">T</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; </span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(m_size &gt;= N) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::bad_alloc&#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">new</span>(data+m_size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">      ++m_size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> T*&gt;(data+pos);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type data[N]; // C++11</span></span><br><span class="line">  std::<span class="type">aligned_storage_t</span>&lt;<span class="built_in">sizeof</span>(T), <span class="built_in">alignof</span>(T)&gt; data[N];        <span class="comment">// c++14</span></span><br><span class="line">  <span class="type">size_t</span> m_size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类<code>StaticVector</code>的使用如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>) Foo &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1; </span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    StaticVector&lt;std::string, <span class="number">2</span>&gt; v1;</span><br><span class="line">    v1.<span class="built_in">emplace_back</span>(<span class="number">5</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    std::cout &lt;&lt; v1[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    StaticVector&lt;Foo, <span class="number">2</span>&gt;v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在输出前，我们预测下：</p><ul><li><code>std:::string</code> 的<code>alignof</code>值是8，那么<code>StaticVector</code>分配的两个<code>std::string</code>对象地址，都应该是8的倍数</li><li><code>Foo</code>的<code>alignof</code>值是32，那么<code>StaticVector</code>为<code>Foo</code> 分配的两个<code>Foo</code>对象地址，都是32的倍数，</li></ul><p>好，现在我们来看下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align_stroe.cc -o as &amp;&amp; ./as</span><br><span class="line">8/32</span><br><span class="line">0x16b5734c0</span><br><span class="line">0x16b5734e0</span><br><span class="line">*****</span><br><span class="line">32/32</span><br><span class="line">0x16b573470</span><br><span class="line">0x16b573490</span><br></pre></td></tr></table></figure><p>所以，到此，你也许理解了<code>std::aligned_storage</code> 中<code>aligned</code>的含义，即每个对象都是经过内存对齐的。</p><p>熟悉了<code>std::aligned_storage</code> 的用法，现在来看看他的实现叭，毕竟没人愿意只做个调包侠（滑稽脸）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in std namespace;</span></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> _Len&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__aligned_storage_msa</span> &#123;</span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">__type</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> __data[_Len];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__attribute__</span>((__aligned__)) &#123; &#125; __align;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> _Len, </span><br><span class="line">      std::<span class="type">size_t</span> _Align = <span class="built_in">alignof</span>(<span class="keyword">typename</span> __aligned_storage_msa&lt;_Len&gt;::__type)&gt;</span><br><span class="line"><span class="keyword">struct</span> aligned_storage &#123;</span><br><span class="line">  <span class="keyword">union</span> type &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> __data[_Len];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">alignas</span>(_Align) &#123; &#125; __align;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>std::aligned_storage</code> 内部，是通过一个<code>union</code>来实现的：</p><ul><li><code>unsigned char __data[_Len];</code>：这一行保证了分配的内存大小是<code>_Len</code>个字节</li><li><code>struct alignas(_Align) &#123; &#125; __align;</code> ：这一行保证了分配的内存是按照<code>Align</code> 大小进行对齐的。</li></ul><p>其中，第二点很好理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">char</span> aligned_data[<span class="number">16</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unaligned: &quot;</span>&lt;&lt; <span class="built_in">alignof</span>(data) &lt;&lt; <span class="string">&quot;, aligned: &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(aligned_data) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unaligned: <span class="number">1</span>, aligned: <span class="number">16</span></span><br></pre></td></tr></table></figure><p>因此，如果只有<code>unsigned char __data[_Len]；</code>，无法保证内存对齐，需要<code>struct alignas(_Align) &#123; &#125; __align</code>的辅助。</p><p>最后再提下 <code>std::__aligned_storage_msa</code>的必要性：在构造类<code>std::aligned_storage</code>对象时，如果没有指定类的第二个模板参数<code>_Align</code>，即内存对齐大小，由<code>std::__aligned_storage_msa</code>为你设置默认的内存对齐大小。</p><p>可以看出，在 <code>std::__aligned_storage_msa</code> 的实现中，<code>__attribute__((__aligned__))</code> 后面是没有参数的，此时gcc即会根据平台生成默认内存对齐大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">1</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">4</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">16</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">32</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align_stroe.cc -o as &amp;&amp; ./as</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>这个大小就是gcc编译器默认的内存大小。</p><h2 id="std-align"><a href="#std-align" class="headerlink" title="std::align"></a>std::align</h2><p>类<code>std::aligned_storage</code> 是一个静态的内存对齐分配器，即在类<code>std::aligned_storage</code>对象构造完时，就已满足设定内存大小、内存对齐要求，但是如果现在有一块内存，想从中取出一块符合某对齐要求的内存，咋办？</p><p>此时就可以使用<code>std::align</code>函数，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param  alignment 是想要分配的内存符合的内存对齐大小</span></span><br><span class="line"><span class="comment">/// @param  size 想要分配内存的大小</span></span><br><span class="line"><span class="comment">/// @param  ptr 是个输入输出参数，输入时指向待使用的内存，输出时调整为符合alignment对齐要求的内存地址</span></span><br><span class="line"><span class="comment">/// @param  space 是ptr指向的内存剩余的空间</span></span><br><span class="line"><span class="comment">/// @return 如果 ptr 经过调整后能满足大小为 alignment 的对齐要求，则返回ptr的值，否则返回 nullptr</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">align</span><span class="params">( std::<span class="type">size_t</span> alignment,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::<span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">void</span>*&amp; ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::<span class="type">size_t</span>&amp; space)</span></span>;</span><br></pre></td></tr></table></figure><p>下面，我们继续先来看看 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a> 中提供的一个demo，熟悉下怎么使用<code>std::align</code>这个函数。</p><p>类<code>Arena</code>内已有一块缓冲区<code>buffer</code>，每次调用<code>AlignedAllocate&lt;T&gt;(size_t alignment)</code>函数时，即需要从<code>buffer</code>中取出大小为<code>sizeof(T)</code>的一块内存<code>ptr</code>，<code>AlignedAllocate</code>函数的输入参数<code>alignment</code>指定了获得的内存<code>ptr</code>满足的内存对齐要求。</p><p>现在来看看实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Arena</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[N];</span><br><span class="line">  <span class="type">void</span>* ptr;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Arena</span>() : <span class="built_in">ptr</span>(buffer), <span class="built_in">size</span>(N) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @return 返回的指针满足大小为 alignment 的内存对齐要求</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T* <span class="title">AlignedAllocate</span><span class="params">(<span class="type">size_t</span> alignment = <span class="keyword">alignof</span>(T))</span> </span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;ptr: &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(ptr) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (std::<span class="built_in">align</span>(alignment, <span class="built_in">sizeof</span>(T), ptr, size)) &#123;</span><br><span class="line">          T* result = <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">          ptr = (<span class="type">char</span>*)ptr + <span class="built_in">sizeof</span>(T);</span><br><span class="line">          size -= <span class="built_in">sizeof</span>(T);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若无，则返回 nullptr</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Arena&lt;<span class="number">64</span>&gt; arena;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* p1 = arena.<span class="built_in">AlignedAllocate</span>&lt;<span class="type">char</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p1) *p1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocated a char at &quot;</span> &lt;&lt; (<span class="type">void</span>*)p1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span>* p2 = arena.<span class="built_in">AlignedAllocate</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p2) *p2 = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocated an int at &quot;</span> &lt;&lt; (<span class="type">void</span>*)p2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span>* p3 = arena.<span class="built_in">AlignedAllocate</span>&lt;<span class="type">int</span>&gt;(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> (p3) *p3 = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocated an int at &quot;</span> &lt;&lt; (<span class="type">void</span>*)p3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下面的输出可以看出，<code>AlignedAllocate</code> 函数返回的内存地址都是符合设定的内存对齐要求的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align.cc -o align &amp;&amp; ./align </span><br><span class="line">ptr: 0x16fc2b4b8, allocated a char at 0x16fc2b4b8     <span class="comment"># 1 byte 内存对齐，指针无须调整</span></span><br><span class="line">ptr: 0x16fc2b4b9, allocated an int at 0x16fc2b4bc     <span class="comment"># 4 byte 内存对齐，指针调整了 3 个字节</span></span><br><span class="line">ptr: 0x16fc2b4c0, allocated an int at 0x16fc2b4c0     <span class="comment"># 32 byte 内存对齐，指针无须调整</span></span><br></pre></td></tr></table></figure><p>最后，我们再来看看<code>std::align</code>函数的实现，稍微简化后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &lt;memory&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="title">align</span><span class="params">(<span class="type">size_t</span> __align, <span class="type">size_t</span> __size, <span class="type">void</span> *&amp;__ptr, <span class="type">size_t</span> &amp;__space)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> __intptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(__ptr);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> __aligned = (__intptr - <span class="number">1u</span> + __align) &amp; -__align;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> __diff = __aligned - __intptr;</span><br><span class="line">  <span class="comment">// 如果没有剩余的空间，直接返回 nullptr</span></span><br><span class="line">  <span class="keyword">if</span> ((__size + __diff) &gt; __space)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">   __space -= __diff;</span><br><span class="line">   <span class="keyword">return</span> __ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(__aligned);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::align</code>的实现里，最为关键的一步，即计算对齐后的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> __aligned = (__intptr - <span class="number">1u</span> + __align) &amp; -__align;</span><br></pre></td></tr></table></figure><p>对于这一步，本来想写个证明啥的，还是举个例子来解释比较通俗。</p><p>按照<code>__align</code>大小进行内存对齐，即可视为按<code>__align</code>进制向上取整。</p><p>什么意思呢？</p><p>比如说，现在按照10进制对齐，有地址12，想让12向上调整到10的倍数，怎么做？</p><ol><li>先加上一个步长：<code>12 + 10 - 1 = 21</code></li><li>将余数1清掉：<code>21 &amp;  (-10) = 20</code>。这一步中，<code>-10</code> 的本质就是保证高位不变，将低位全部变为0，取<code>&amp;</code>之后，取余就全部清理了。</li></ol><p>现在的内存对齐，本质上也是向上取整：<code>__intptr - 1u + __align</code>是为了向前一个步长，再对  <code>-__align</code>取<code>&amp;</code>，来清除余数。</p><p>关于内存对齐，很多项目里都有涉及，最近在阅读RocksDB也再次遇到，于是乎就找了个契机写下了这篇博客，后续会尝试更新RocksDB。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于内存对齐，有诸多好处，因此常常在分配内存时也会将内存对齐这一因素纳入考量。&lt;/p&gt;
&lt;p&gt;这一节，来讲下内存对齐以及C++11中关于内存对齐引入的&lt;code&gt;alignof&lt;/code&gt;、&lt;code&gt;alignas&lt;/code&gt;、&lt;code&gt;std::aligned_s</summary>
      
    
    
    
    <category term="Modern C++" scheme="https://szza.github.io/categories/Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>从 std::auto_ptr 到 std::unique_ptr</title>
    <link href="https://szza.github.io/2021/12/21/C++/unique_ptr/"/>
    <id>https://szza.github.io/2021/12/21/C++/unique_ptr/</id>
    <published>2021-12-21T04:47:23.000Z</published>
    <updated>2023-08-03T04:10:02.758Z</updated>
    
    <content type="html"><![CDATA[<p>从本期，就开始智能指针源码分析之路，从源码中了解他们的设计。</p><p>智能指针，可以分为两类：</p><ul><li>独占型：如<code>std::unique_ptr</code>，一份资源，仅能由一个<code>std::unique_ptr</code>对象管理；</li><li>共享型：如<code>std::shared_ptr</code>，一份资源，可以由多个<code>std::shared_ptr</code>对象共同管理，当没有<code>std::shared_ptr</code>对象指向这份的资源，资源才会被释放，即基于引用技术原理。</li></ul><p>本期，先来讲解<code>std::unique_ptr</code>，之后会分几期来讲解<code>std::shared_ptr</code>的设计。</p><p>不过，在讲解<code>std::unique_ptr</code>之前，先讲解下C++03中的失败品：<code>std::auto_ptr</code>。</p><h2 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h2><p>原本也是想要将 <code>std::auto_ptr</code> 设计成资源独占型的指针，即像现在的<code>std::unique_ptr</code>，但由于移动语义直到C++11中才出现，使得<code>std::auto_ptr</code>终究成了失败品。</p><p>不明白，没关系，go on。</p><p>在C++03标准下，有如下demo中的一个场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">iptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">    std::vector&lt;std::auto_ptr&lt;<span class="type">int</span>&gt; &gt; integer_vec;</span><br><span class="line"></span><br><span class="line">    integer_vec.<span class="built_in">push_back</span>(iptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在C++03标准中还没有引入移动语义，只能以<code>push_back</code>函数向<code>vector</code>中添加元素。</p><p>如果你没接触过<code>std::auto_ptr</code>，应该会认为上面的demo是能编译通过的，但实际上是无法编译通过的。</p><p>编译指令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std=c++<span class="number">03</span>  main.cc -o main &amp;&amp; ./main</span><br></pre></td></tr></table></figure><p>下面只贴出最初的错误信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc<span class="number">-8.2</span>/include/c++/<span class="number">8.2</span><span class="number">.0</span>/ext/new_allocator.h:<span class="number">146</span>:<span class="number">9</span>: error: no matching function <span class="keyword">for</span> call to ‘std::auto_ptr&lt;<span class="type">int</span>&gt;::<span class="built_in">auto_ptr</span>(<span class="type">const</span> std::auto_ptr&lt;<span class="type">int</span>&gt;&amp;)’</span><br><span class="line">       &#123; ::<span class="keyword">new</span>((<span class="type">void</span> *)__p) _Tp(__val); &#125;</span><br><span class="line">         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><p>先给出导致错误的结论：是由于类<code>std::auto_ptr</code> 没有提供<code>const std::auto_ptr&lt;T&gt;&amp;</code>类型的复制构造函数。</p><p>那为啥会没有呢？</p><p>因为<code>std::auto_ptr</code>的设计者，想使<code>std::auto_ptr</code>的复制构造函数具备移动构造函数的属性（如果不懂右值、移动等内容，可以看看 <a href="https://szza.github.io/2021/03/04/C++/reference_1">右值引用的正确用法</a>），这就使得<code>std::auto_ptr</code>复制构造函数的输入参数<code>__a</code>不能由 const 修饰，否则<code>__a</code>指向的资源就无法移动到新创建的对象中了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>(auto_ptr&amp; __a) <span class="keyword">throw</span>() : _M_ptr(__a.<span class="built_in">release</span>()) &#123;&#125; </span><br></pre></td></tr></table></figure><p>这就导致<code>std::auto_ptr</code>中，所有和赋值有关的操作，都不能有<code>const</code>修饰。</p><p><code>std::auto_ptr</code>的核心代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  _Tp *_M_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(element_type *__p = <span class="number">0</span>)</span> <span class="title">throw</span><span class="params">()</span> : _M_ptr(__p) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">auto_ptr</span>(auto_ptr&amp; __a) <span class="keyword">throw</span>() : _M_ptr(__a.<span class="built_in">release</span>()) &#123;&#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">  <span class="built_in">auto_ptr</span>(auto_ptr&lt;_Tp1&gt;&amp; __a) <span class="built_in">throw</span>() : _M_ptr(__a.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  auto_ptr &amp;<span class="keyword">operator</span>=(auto_ptr&amp; __a) <span class="built_in">throw</span>() &#123;</span><br><span class="line">    <span class="built_in">reset</span>(__a.<span class="built_in">release</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> _M_ptr; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">element_type* <span class="title">release</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    element_type *__tmp = _M_ptr;</span><br><span class="line">    _M_ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(element_type *__p = <span class="number">0</span>)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__p != _M_ptr) &#123;</span><br><span class="line">      <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">      _M_ptr = __p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="by-the-way"><a href="#by-the-way" class="headerlink" title="by the way"></a>by the way</h3><p>对于最上面的demo，我们再啰嗦几点：为什么会在 <code>construct</code>函数中报错？</p><ol><li><p>因为<code>push_back</code>函数中，输入参数<code>__x</code>是<code>const std::auto_ptr&amp;</code>类型，能接受<code>iptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt; </span><br><span class="line"><span class="type">void</span> std::vector&lt;_Tp, _Alloc&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> value_type&amp; __x);</span><br></pre></td></tr></table></figure></li><li><p>在<code>push_back</code>函数内部会调用 <code>_Alloc_traits::construct</code> 函数来构造一个新的<code>std::auto_ptr</code>对象<code>obj</code>，然后将这个<code>obj</code>放到<code>integer_vec</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish, __x);</span><br></pre></td></tr></table></figure></li><li><p>因为要构造<code>obj</code>，那么必要会调用<code>std::auto_ptr</code>的复制构造函数，且输入参数是<code>__x</code>；</p></li><li><p>但由于<code>__x</code> 是 <code>const std::auto_ptr&amp;</code> 类型，二<code>std::auto_ptr</code>的复制构造函数输入类型是<code>std::auto_ptr&amp;</code>，接受不了<code>__x</code>作为输入，因此会导致<code>construct</code>函数执行失败。出现上述的错误。</p></li></ol><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>C++11引入移动语义，提出了<code>std::unique_ptr</code>，才真正地完成了<code>std::auto_ptr</code>的设计意图，而原本的<code>std::auto_ptr</code>也被标记为<code>deprecated</code>。</p><p>由于 <code>std::unique_ptr</code> 对象管理的资源，不可共享，只能在 <code>std::unique_ptr</code> 对象之间转移，因此类<code>std::unique_ptr</code> 就禁止了复制构造函数、赋值表达式，仅实现了移动构造函数等。</p><p>此外，<code>std::unique_ptr</code> 有两个版本：</p><ol><li>管理单个对象（例如以 <code>new</code> 分配）</li><li>管理动态分配的对象数组（例如以 <code>new[]</code> 分配）</li></ol><p>因此， <code>std::unique_ptr</code> 的类模板有如下两个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 适合 new 分配的内存</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr &#123; <span class="comment">/****/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 针对 new[] 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span>&lt;_Tp[], _Dp&gt; &#123; <span class="comment">/****/</span> &#125;;</span><br></pre></td></tr></table></figure><p>在下面的情况中，<code>std::unique_ptr</code>对象管理的资源，会调用传入的析构器<code>_Dp</code>来释放放资源：</p><ul><li>当前<code>std::unique_ptr</code> 对象被销毁，生命周期结束；</li><li>重新给当前<code>std::unique_ptr</code>对象赋值，比如调用 <code>operator=</code>、<code>reset()</code> 等操作。</li></ul><p>下面就先讲解下默认的析构器<code>std::default_delete</code>。</p><h3 id="std-default-delete"><a href="#std-default-delete" class="headerlink" title="std::default_delete"></a>std::default_delete</h3><p>由于<code>std::unique_ptr</code> 有两个版本，因此默认的析构器也存在两个版本，即对<code>new[]</code> 进行特化。</p><p>此外，这就导致后文的<code>make_unique</code> 函数也需要对<code>new[]</code>进行特化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span> &#123; <span class="comment">/****/</span> &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span>&lt;_Tp[]&gt; &#123; <span class="comment">/****/</span> &#125;;</span><br></pre></td></tr></table></figure><p>由于默认采用<code>new</code>、<code>new[]</code>来分配内存的，而<code>sd::default_delete</code> 实际上是个仿函数，内部也是基于<code>delete</code>、<code>delete[]</code>来释放内存资源的。</p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>类<code>std::default_delete</code>  实际上是个仿函数，并且是个空类，因此他的默认构造函数直接设置为<code>default</code>了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/// @brief 默认构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 复制构造函数</span></span><br><span class="line">  <span class="comment">///        _Up* 必须能转为 _Tp*，否则无法编译通过</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, </span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value&gt;::type&gt;</span><br><span class="line">  <span class="built_in">default_delete</span>(<span class="type">const</span> default_delete&lt;_Up&gt;&amp; ) <span class="keyword">noexcept</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 释放内存</span></span><br><span class="line">  <span class="type">void</span> <span class="built_in">operator</span>()(_Tp *__ptr) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，<code>std::default_delete</code> 还有个复制构造函数，这里传入<code>_Up*</code>参数 必须能转换为 <code>_Tp*</code> 类型，否则在编译期会报错。所谓<code>_Up*</code> 能转换为 <code>_Tp*</code>，即<code>is_convertible&lt;_Up*, _Tp*&gt;::value</code> 为 true，这个值在编译期就能确定，如果为false，就相当于不存在这个复制构造函数。</p><p>不信，可以把下面的代码复制到IDE中，会有红线提示，编译会出错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::is_convertible&lt;<span class="type">float</span>*, <span class="type">double</span>*&gt;::value;                  <span class="comment">// false: float* 不能直接转换为 double*</span></span><br><span class="line"><span class="function">std::default_delete&lt;<span class="type">double</span>&gt; <span class="title">de</span><span class="params">(std::default_delete&lt;<span class="type">float</span>&gt;&#123;&#125;)</span></span>; <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><p>在<code>std::default_delete</code>的内部，实现的<code>operator()</code> 函数会调用<code>delete</code>来 析构传入的指针<code>__ptr</code>，对于<code>__ptr</code>需要满足两点：</p><ul><li><code>__ptr</code>不能是个<code>void</code>类型；</li><li>大小也不能是0。</li></ul><p>否则无法提供完整的信息去析构<code>__ptr</code>指向的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp *__ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(!is_void&lt;_Tp&gt;::value, <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(_Tp) &gt; <span class="number">0</span>, <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">  <span class="keyword">delete</span> __ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，你就可以这样来使用<code>std::default_delete</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* iptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">std::<span class="built_in">default_delete</span>&lt;<span class="type">int</span>&gt;()(iptr); <span class="comment">// delete iptr;</span></span><br></pre></td></tr></table></figure><p>使用<code>valgrind</code>检测也不存在内存泄露。</p><h4 id="delete-1"><a href="#delete-1" class="headerlink" title="delete[]"></a>delete[]</h4><p>当输入类型是<code>_Tp[]</code>时，会进入此版本。实现和上面的版本差不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span>&lt;_Tp[]&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// @brief 默认构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 复制构造函数</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, </span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up (*)[], _Tp (*)[]&gt;::value&gt;::type&gt;</span><br><span class="line">  <span class="built_in">default_delete</span>(<span class="type">const</span> default_delete&lt;_Up[]&gt; &amp;) <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 释放内存</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up (*)[], _Tp (*)[]&gt;::value&gt;::type</span><br><span class="line">  <span class="built_in">operator</span>()(_Up *__ptr) <span class="type">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(_Tp) &gt; <span class="number">0</span>, <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] __ptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，这样就可以使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* iptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">std::<span class="built_in">default_delete</span>&lt;<span class="type">int</span>[]&gt;()(iptr); </span><br></pre></td></tr></table></figure><p>使用<code>valgrind</code>检查也没有任何内存泄露。</p><p>因此，<code>std::default_delete</code> 对两种常用的内存释放方式进行重载，提供了同一个统一接口。</p><h3 id="std-uniq-ptr-impl"><a href="#std-uniq-ptr-impl" class="headerlink" title="std::__uniq_ptr_impl"></a>std::__uniq_ptr_impl</h3><p>类<code>std::unique_ptr</code> 内部只有一个成员变量，其类型是 <code>std::__uniq_ptr_impl</code>。</p><p>类<code>std::__uniq_ptr_impl</code>实际上就一个<code>&lt;pointer, Deleter&gt;</code>的一个wrapper，即简单封装了指向资源的指针，以及对应的析构器 <code>Deleter</code>。</p><p>先大致看下<code>std::__uniq_ptr_impl</code>的部分实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__uniq_ptr_impl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> _DeleterConstraint = enable_if&lt;__and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;, </span><br><span class="line">                                              is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;</span><br><span class="line">  </span><br><span class="line">  __uniq_ptr_impl() = <span class="keyword">default</span>;</span><br><span class="line">  __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del&gt;</span><br><span class="line">  __uniq_ptr_impl(pointer __p, _Del&amp;&amp; __d)</span><br><span class="line">  : _M_t(__p, std::forward&lt;_Del&gt;(__d)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  pointer&amp;   _M_ptr()           &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">  pointer    _M_ptr()     <span class="type">const</span> &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">  _Dp&amp;       _M_deleter()       &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line">  <span class="type">const</span> _Dp&amp; _M_deleter() <span class="type">const</span> &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(__uniq_ptr_impl&amp; __rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;_M_ptr(), __rhs._M_ptr());</span><br><span class="line">    std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;_M_deleter(), __rhs._M_deleter());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  tuple&lt;pointer, _Dp&gt; _M_t; <span class="comment">// pointer 的定义后文讲解</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类<code>std::__uniq_ptr_impl</code> 的成员变量<code>_M_t</code>是由<code>tuple</code>类型：</p><ul><li>第一个成员：是指针，指向资源；</li><li>第二个成员：是析构器，用于释放指针指向的资源。</li></ul><p>由于在X86-84位系统上指针大小是8，而<code>_Dp</code>在默认情况下（即<code>std::default_delete</code>）是个空类，得益于<a href="https://mp.weixin.qq.com/s?__biz=MzkyMjIxMzIxNA==&mid=2247485249&idx=1&sn=f395397f1621cf8a4d897d0213ca1788&chksm=c1f68970f68100666cbb65313780797bc65490703dac02a9603e0b9733fa01db270ca445f0e6&token=1599630750&lang=zh_CN#rd">空基类优化</a>，因此<code>_M_t</code> 的大小是8。</p><blockquote><p><strong>NOTICE</strong>：如果自定义了一个<code>Deleter</code>，且不是空类，则<code>std::unique_ptr</code>的大小会增加。</p></blockquote><p>下面，来分析下<code>std::__uniq_ptr_impl</code> 中的 <code>pointer</code>类型，他的完整实现及注释如下。</p><p>因此，当<code>_Dp</code>是默认的析构器<code>std::default_delete</code>时，<code>pointer</code> 即 <code>_Tp*</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">__uniq_ptr_impl</span></span><br><span class="line"> &#123;    </span><br><span class="line">   <span class="comment">/// 原型</span></span><br><span class="line">   <span class="comment">/// @brief 特化版本决议失败，则会进入此版本</span></span><br><span class="line">   <span class="comment">/// @type  此时 type 就是 _up*</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line">   <span class="keyword">struct</span> _Ptr</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">using</span> type = _Up*;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/// 特化版本</span></span><br><span class="line">   <span class="comment">/// @brief 如果 类 _Ep 中有 pointer 的定义，则会进入此特化版本</span></span><br><span class="line">   <span class="comment">/// @type  此时 type 是 _Ep 中的 pointer </span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">_Ptr</span>&lt;_Up, _Ep, <span class="type">__void_t</span>&lt;<span class="keyword">typename</span> remove_reference&lt;_Ep&gt;::type::pointer&gt;&gt;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">using</span> type = <span class="keyword">typename</span> remove_reference&lt;_Ep&gt;::type::pointer;</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">using</span> pointer = <span class="keyword">typename</span> _Ptr&lt;_Tp, _Dp&gt;::type;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"> &#125;；</span><br></pre></td></tr></table></figure><h3 id="std-unique-ptr-1"><a href="#std-unique-ptr-1" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p>分析的进度终于到了类<code>std::unique_ptr</code>，它的设计主要如下四点：</p><ol><li>禁止复制构造函数、复制赋值的重载，即设置为<code>=delete</code>；</li><li>实现各种移动构造函数；</li><li>实现移动赋值重载，即<code>operator=</code>，需要先释放本身的资源，再将对方的资源移动过来；</li><li>如果资源没有释放过，则会在析构函数中释放。</li></ol><p>为便于理解，先看下<code>std::unique_ptr</code>的部分源码及其注释，另一个特化版本差不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">  <span class="keyword">using</span> _DeleterConstraint = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint::type;</span><br><span class="line"></span><br><span class="line">  __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</span><br><span class="line">  <span class="keyword">using</span> element_type = _Tp;</span><br><span class="line">  <span class="keyword">using</span> deleter_type = _Dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// 用于检测从另一个 std::unique_ptr 对象转换过来是否安全</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line">  <span class="keyword">using</span> __safe_conversion_up = __and_&lt;is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Up, _Ep&gt;::pointer, pointer&gt;,</span><br><span class="line">                                      __not_&lt;is_array&lt;_Up&gt;&gt;&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/*** Move constructors. ***/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 移动构造函数</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">  : _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>())) &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 移动赋值</span></span><br><span class="line">  unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">reset</span>(__u.<span class="built_in">release</span>()); </span><br><span class="line">    <span class="built_in">get_deleter</span>() = std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 设置 unique_ptr 对象为初始化状态</span></span><br><span class="line">  unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 禁止复制</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  unique_ptr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  ~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(__is_invocable&lt;deleter_type&amp;, pointer&gt;::value,</span><br><span class="line">                  <span class="string">&quot;unique_ptr&#x27;s deleter must be invocable with a pointer&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span>&amp; __ptr = _M_t._M_ptr();</span><br><span class="line">    <span class="keyword">if</span> (__ptr != <span class="literal">nullptr</span>)</span><br><span class="line">       <span class="built_in">get_deleter</span>()(std::<span class="built_in">move</span>(__ptr)); <span class="comment">// 析构</span></span><br><span class="line">    __ptr = <span class="built_in">pointer</span>();                  <span class="comment">// 设置为初始化状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 返回指针</span></span><br><span class="line">  <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> _M_t._M_ptr(); &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/// @brief 返回一个指向内部的deleter的引用</span></span><br><span class="line">  <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_t._M_deleter();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Return @c true if the stored pointer is not null.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>() == <span class="built_in">pointer</span>() ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Release ownership of any stored pointer.</span></span><br><span class="line">  <span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pointer __p = <span class="built_in">get</span>();</span><br><span class="line">    _M_t._M_ptr() = <span class="built_in">pointer</span>();</span><br><span class="line">    <span class="keyword">return</span> __p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(__is_invocable&lt;deleter_type &amp;, pointer&gt;::value,</span><br><span class="line">                  <span class="string">&quot;unique_ptr&#x27;s deleter must be invocable with a pointer&quot;</span>);</span><br><span class="line">    std::<span class="built_in">swap</span>(_M_t._M_ptr(), __p);</span><br><span class="line">    <span class="keyword">if</span> (__p != <span class="built_in">pointer</span>())</span><br><span class="line">      <span class="built_in">get_deleter</span>()(std::<span class="built_in">move</span>(__p));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr &amp;__u)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(__is_swappable&lt;_Dp&gt;::value, <span class="string">&quot;deleter must be swappable&quot;</span>);</span><br><span class="line">    _M_t.<span class="built_in">swap</span>(__u._M_t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::unique_ptr</code> 的设计总体比较清晰。</p><p>到此，<code>std::unique_ptr</code>的设计分析差不多就结束了，下面对源码中（上面未列出）几个模板稍微分析下。</p><h4 id="DeleterConstraint"><a href="#DeleterConstraint" class="headerlink" title="_DeleterConstraint"></a>_DeleterConstraint</h4><p><code>_DeleterConstraint</code> 定义于<code>std::__uniq_ptr_impl</code>之中，用于限制传入的析构器<code>Deleter</code>必须满足以下两点：</p><ol><li>传入的<code>Deleter</code> 不能是指针；</li><li>必须具备默认构造函数。</li></ol><p>否则，<code>std::unique_ptr</code> 的构造函数会失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> _DeleterConstraint = enable_if&lt;__and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;, </span><br><span class="line">                                        is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Del&gt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">: _M_t()</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Del&gt;&gt;</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="Require"><a href="#Require" class="headerlink" title="_Require"></a>_Require</h4><p>其原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Cond&gt;</span><br><span class="line"><span class="keyword">using</span> _Require = <span class="type">__enable_if_t</span>&lt;__and_&lt;_Cond...&gt;::value&gt;;</span><br></pre></td></tr></table></figure><p><code>_Require</code>模板是要求所有传入的条件<code>Cond</code>都为true，则<code>_Require</code>修饰的函数才会存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 如果传入的 _Del 没有复制构造函数，则unique_ptr此版本构造函数就不存在</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = deleter_type,</span><br><span class="line">          <span class="keyword">typename</span> = _Require&lt;is_copy_constructible&lt;_Del&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p, <span class="type">const</span> deleter_type&amp; __d) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p, __d) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 如果传入的 _Del 没有移动构造函数，则 unique_ptr此版本构造函数就不存在</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = deleter_type,</span><br><span class="line">          <span class="keyword">typename</span> = _Require&lt;is_move_constructible&lt;_Del&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p, <span class="type">__enable_if_t</span>&lt;!is_lvalue_reference&lt;_Del&gt;::value, _Del&amp;&amp;&gt; __d) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p, std::<span class="built_in">move</span>(__d))</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="safe-conversion-up"><a href="#safe-conversion-up" class="headerlink" title="__safe_conversion_up"></a>__safe_conversion_up</h4><p>在构造函数中，有时候需要通过其他<code>std::unique_ptr</code>对象来构造当前<code>std::unique_ptr</code>对象，但是<code>pointer</code>类型可能不同，模板<code>__safe_conversion_up</code>可以在编译期确定是否可以转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line"><span class="keyword">using</span> __safe_conversion_up = __and_&lt;is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Up, _Ep&gt;::pointer, pointer&gt;,</span><br><span class="line">                                    __not_&lt;is_array&lt;_Up&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure><p>此外还有个条件模板<code>conditional</code>，实现编译期的条件表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Cond ? _Iftrue ： _Iffalse;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> _Cond, <span class="keyword">typename</span> _Iftrue, <span class="keyword">typename</span> _Iffalse&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> _Iftrue type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iftrue, <span class="keyword">typename</span> _Iffalse&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span>&lt;<span class="literal">false</span>, _Iftrue, _Iffalse&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> _Iffalse type; &#125;;</span><br></pre></td></tr></table></figure><p>最终，可以用于构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 由其他std::unique_ptr对象 __u 构造this</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, </span><br><span class="line">          <span class="keyword">typename</span> _Ep, </span><br><span class="line">          <span class="keyword">typename</span> = _Require&lt;__safe_conversion_up&lt;_Up, _Ep&gt;,   <span class="comment">// 先判断指针，必须可转换</span></span><br><span class="line">          <span class="keyword">typename</span> conditional&lt;is_reference&lt;_Dp&gt;::value,        <span class="comment">// 再判断析构器</span></span><br><span class="line">                               is_same&lt;_Ep, _Dp&gt;,               </span><br><span class="line">                               is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt;</span><br><span class="line"> <span class="built_in">unique_ptr</span>(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line"> : _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>()))</span><br><span class="line"> &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="std-make-unique"><a href="#std-make-unique" class="headerlink" title="std::make_unique"></a>std::make_unique</h3><p>最后，再来看下<code>std::make_unique</code> 函数，它在C++14中引入，这在之前的’编译器优化之copy elision’一期中也讲解过怎么设计它。</p><p>现在，我们再来看看C++14中 <code>std::make_unique()</code> 的实现，如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 返回类型 ***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MakeUniq</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> unique_ptr&lt;_Tp&gt; __single_object; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 为数组类型特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MakeUniq</span>&lt;_Tp[]&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> unique_ptr&lt;_Tp[]&gt; __array; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 无效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="type">size_t</span> _Bound&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MakeUniq</span>&lt;_Tp[_Bound]&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__invalid_type</span> &#123; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 函数实现 ***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// std::make_unique for single objects</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> _MakeUniq&lt;_Tp&gt;::<span class="function">__single_object <span class="title">make_unique</span><span class="params">(_Args&amp;&amp; ...__args)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> _Tp(std::forward&lt;_Args&gt;(__args)...)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// std::make_unique for arrays of unknown bound</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> _MakeUniq&lt;_Tp&gt;::<span class="function">__array <span class="title">make_unique</span><span class="params">(<span class="type">size_t</span> __num)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> <span class="type">remove_extent_t</span>&lt;_Tp&gt;[__num]()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Disable std::make_unique for arrays of known bound</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> _MakeUniq&lt;_Tp&gt;::<span class="function">__invalid_type <span class="title">make_unique</span><span class="params">(_Args&amp;&amp; ...)</span> </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>结束，再回顾下<code>std::unique_ptr</code> 和 <code>std::auto_ptr</code>。</p><p>可以发现<code>std::auto_ptr</code>的失败在于CXX03中并不支持移动语义，而<code>std::auto_ptr</code> 却试图用复制构造函数来实现移动构造函数的功能，结果导致其无法与<code>vector</code> 等容器兼容，论为失败品。</p><p><code>std::unique_ptr</code> 的分析为止。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从本期，就开始智能指针源码分析之路，从源码中了解他们的设计。&lt;/p&gt;
&lt;p&gt;智能指针，可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独占型：如&lt;code&gt;std::unique_ptr&lt;/code&gt;，一份资源，仅能由一个&lt;code&gt;std::unique_ptr&lt;/code&gt;对</summary>
      
    
    
    
    <category term="Modern C++" scheme="https://szza.github.io/categories/Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>异步通信</title>
    <link href="https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"/>
    <id>https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/</id>
    <published>2021-12-09T03:40:15.000Z</published>
    <updated>2022-02-14T14:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h1><p>之前有两期讲解了服务端框的架构，这一期来讲下服务器是如何与客户端进行异步通信的，下一期再讲述客户端是如何异步非阻塞connect服务器的。</p><ul><li>通信，无外乎两点：1）服务器读取对端发送过来的数据；2）向对端发送数据。</li><li>异步，目前常用的是<code>epoll</code> + 回调函数。</li></ul><p>下面从非阻塞IO开始，逐步构建异步通信框架。</p><h2 id="Non-Blocking-IO"><a href="#Non-Blocking-IO" class="headerlink" title="Non-Blocking IO"></a>Non-Blocking IO</h2><p>在服务端常用的IO读写操作，主要是<code>read</code>、<code>write</code>及其衍生函数。</p><p>所谓阻塞模式，也是<code>read</code>、<code>write</code>等操作的默认行为，比如<code>read</code>函数从<code>stdin</code>读取输入，如果用户没有从终端输入，则会一直阻塞在<code>read</code>函数处。</p><p>在非阻塞模式下，<code>read</code>继续从终端读取数据，如果用户没有在终端输入数据，<code>read</code>函数并不会阻塞等待，而是立即返回-1，并将错误码<code>errno</code> 设置为<code>EAGAIN</code> 或者 <code>EWOULDBLOCK</code>。此时<code>read</code>函数返回值<code>n</code>有三种可能：</p><ul><li><code>n &gt; 0</code>：读取到<code>n</code>个字节；</li><li><code>n == 0</code>：对端关闭、文件末尾；</li><li><code>n == -1</code>：表示遇到问题，<ul><li><code>errno == EAGAIN/EWOULDBLOCK </code>：在非阻塞IO模式下，表示没有数据可读，可忽略本次<code>read</code>操作；</li><li><code>errno == EINTR</code>：表示被信号中断，重新读取一次即可。</li><li>其他错误类型。</li></ul></li></ul><p>写操作<code>write</code>函数也基本类似，更加详细可以<code>man 2 read/write</code> 查看。</p><p>因此，非阻塞IO非常适合服务器设计，不会在<code>read/write</code>处发生堵塞。</p><p>将文件描述符fd设置为非阻塞模式，有如下两种方式（来自muduo）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNonBlockAndCloseOnExec</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> flags = ::<span class="built_in">fcntl</span>(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">  flags |= O_NONBLOCK;</span><br><span class="line">  <span class="type">int</span> ret = ::<span class="built_in">fcntl</span>(sockfd, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// close-on-exec</span></span><br><span class="line">  flags = ::<span class="built_in">fcntl</span>(sockfd, F_GETFD, <span class="number">0</span>);</span><br><span class="line">  flags |= FD_CLOEXEC;</span><br><span class="line">  ret = ::<span class="built_in">fcntl</span>(sockfd, F_SETFD, flags);</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sockets::createNonblockingOrDie</span><span class="params">(<span class="type">sa_family_t</span> family)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VALGRIND</span></span><br><span class="line">  <span class="comment">// 方式1 </span></span><br><span class="line">  <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(family, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;sockets::createNonblockingOrDie&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setNonBlockAndCloseOnExec</span>(sockfd);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">// 方式2：系统内核支持 SOCK_NONBLOCK 标志，更加安全。</span></span><br><span class="line">  <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(family, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;sockets::createNonblockingOrDie&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ET-LT"><a href="#ET-LT" class="headerlink" title="ET &amp; LT"></a>ET &amp; LT</h2><p>众所周知，<code>epoll</code>有两种工作模式：<code>ET </code>&amp; <code>LT</code>。但是在讲解 ET &amp; LT 之前，先讲解下「高电平」和「低电平」的概念。</p><h3 id="高低电平"><a href="#高低电平" class="headerlink" title="高低电平"></a>高低电平</h3><p>对于可读事件：</p><ul><li>内核中<code>socket</code>的<code>recv_buff </code> 为空，此时为「低电平」状态，即无数据可读</li><li>内核中<code>socket</code>的<code>recv_buff </code> 不空，此时为「高电平」状态，此时有数据可读</li></ul><p>对于可写事件：</p><ul><li>内核中<code>socket</code>的<code>send_buff</code>为满 ，此时为「低电平」状态，不可发送数据</li><li>内核中<code>socket</code>的<code>send_buff</code>不满，此时为「高电平」状态，可发送数据</li></ul><p>简而言之，「低电平」状态下不能进行读、写操作，「高电平」则可以读、写。</p><p>为便于描述，<code>socket</code>的接受缓冲区定义为<code>recv_buff</code>，<code>socket</code>的发送缓冲区定义为<code>send_buff</code>，<code>connfd</code>是服务端与对端建立连接的文件描述符。</p><h3 id="LT（Level-Triggered）"><a href="#LT（Level-Triggered）" class="headerlink" title="LT（Level Triggered）"></a>LT（Level Triggered）</h3><p>LT，电平触发，即socket缓冲区处于高电平时触发事件。此外，<code>epoll_wait</code>的默认工作模式也是LT。</p><h4 id="可读事件"><a href="#可读事件" class="headerlink" title="可读事件"></a>可读事件</h4><p>为接受对端<code>connfd</code>发送的数据，服务器首先要为<code>connfd</code>注册可读事件<code>EPOLLIN</code>。</p><p>如此，当对端发送数据过来，服务器<code>connfd</code>的<code>recv_buff </code> 不为空，则<code>epoll_wait</code>上的可读事件触发，在读回调函数<code>HandleRead</code>中从<code>socket</code>的<code>recv_buff </code> 中读取数据。</p><p>然而，即使服务端本次没有将scoket<code>recv_buff </code> 中的数据全部读取，下次调用<code>epoll_wait</code>时也依然会触发可读事件。</p><p>为啥？</p><p>因为，只要<code>recv_buff </code> 中的数据没有读取完，即为「高电平」状态，那么就会一直触发<code>epoll_wait</code>的<code>EPOLLIN</code> 事件，直到<code>recv_buff </code> 变空，即为「低电平」状态。</p><p>因此<code>LT</code>模式下，不用担心数据漏读的问题。</p><h4 id="可写事件"><a href="#可写事件" class="headerlink" title="可写事件"></a>可写事件</h4><p>然而，可写事件与可读事件不同：可读事件是被动触发的，即服务端不知道对端何时发送数据。因此服务端与对端建立连接之后，要立即为<code>connfd</code>注册可读事件，然后在<code>epoll_wait</code>上阻塞等待客户端发送数据过来。</p><p>那么，可写事件呢？是服务端主动触发的。</p><p>服务端与对端建立连接后，<code>connfd</code>的<code>send_buff</code>是空的，即处于高电平，是可以直接发送数据的。</p><p>如果此时为<code>connfd</code>注册可写事件，这就会导致<code>epoll_wait</code>一直检测到<code>connfd</code>上的可写事件触发，但实际上服务端又没有数据可以发送给对端，造成服务端的CPU资源无端被消耗。</p><p>因此，在<code>LT</code>模式下，当服务端要向对端发送数据时，不需要先通过<code>epoll_ctl</code>注册可写事件，然后阻塞在<code>epoll_wait</code>上等待可写事件的发生。<font color="red"> 正确的做法如下</font>：</p><ul><li>直接发送数据 <code>n = write(connfd, outbuffer, sizeof(outbuffer))</code>；</li><li>如果此次数据没有发送完毕，即<code>n != sizeof(outbuffer)</code>，则为<code>connfd</code>注册可写事件；</li><li>在<code>epoll_wait</code>上等待可写事件触发；</li><li>可写事件触发，则将剩余的数据发送完毕；</li><li>如果没有发送完毕，则等待下次的可写事件；发送完毕，则取消关注可写事件。</li></ul><p><strong>注意</strong>：当数据发送完毕，一定要取消可写事件，否则当<code>connfd</code>的<code>send_buff</code>变空，后面又没有可发的数据，则又会导致<code>epoll_wait</code>一直触发可写事件。</p><h3 id="ET（Edge-Triggered）"><a href="#ET（Edge-Triggered）" class="headerlink" title="ET（Edge Triggered）"></a>ET（Edge Triggered）</h3><p>ET，所谓边缘触发，即只有在电平状态发生变化时才会触发。开启ET模式，需要设置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET; <span class="comment">// ET 模式</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br></pre></td></tr></table></figure><h4 id="可读事件-1"><a href="#可读事件-1" class="headerlink" title="可读事件"></a>可读事件</h4><p>注册了可读事件后，阻塞于<code>epoll_wait</code>等待对端发送数据，再触发可读事件。</p><p><strong>注意</strong>：如果服务端没有将<code>recv_buff </code> 中的数据全部读取，那么进入下一轮循环并阻塞在<code>epoll_wait</code>后，可读事件就再也不会触发。</p><p>为啥？</p><p>在<code>ET</code>模式下，只有<code>connfd</code>的<code>recv_buffer</code>电平状态发生变化才会触发可读事件，但只要<code>recv_buff </code> 中还有数据，则一直为高电平状态，那么即便下次对端又发送数据过来，并不会改<code>recv_buff </code> 的电平状态，这就导致<code>epoll_wait</code>就无法再检测到<code>connfd</code>上的可读事件。</p><p>那么对端发送了数据，服务端迟迟无法给出回应。如果是<code>listenfd</code>，那么这个服务器就不再能处理新的连接请求了。</p><p>因此，如果不熟悉<code>ET</code>模式的正确使用方法，很可能导致整个服务器无法使用。</p><p>那<code>ET</code>模式下，怎么处理可读事件？</p><p>一旦检测到<code>connfd</code>上的可读事件，需要不停地从<code>recv_buff </code> 中读取数据，直到<code>read</code>函数返回<code>-1</code>，且错误码<code>errno</code>是<code>EAGAIN</code>标志。</p><p>这标志着<code>recv_buff </code> 中的数据已经读取完（已处于低电平），下次对端再发送数据过来（变为高电平），就能再次触发可读事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(; ; ;) &#123; </span><br><span class="line">  ret = <span class="built_in">read</span>(connfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EAGAIN) &#123; </span><br><span class="line">     <span class="built_in">LOG</span>(NOTICE) &lt;&lt; <span class="string">&quot;READ DONE&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>但是又有一个问题：</p><ul><li><code>read</code>函数，什么情况下才会返回<code>EAGAIN</code>？</li><li>要是<code>read</code> 函数不返回<code>EAGAIN</code>，那么岂不是一直在<code>while/for</code>循环？</li></ul><p>仅在<code>connfd</code>设置为非阻塞模式时，<code>read</code>函数无法从空的<code>recv_buff</code>继续读取到数据，此时错误码<code>errno</code>就会被设置为<code>EAGAIN</code>。</p><h4 id="可写事件-1"><a href="#可写事件-1" class="headerlink" title="可写事件"></a>可写事件</h4><p>ET模式下，在与客户端建立连接后，<strong>可以为<code>connfd</code>注册可写事件</strong>，因为此时<code>connfd</code>的<code>send_buff</code>是空的，处于高电平，不会触发可写事件。</p><p>当服务端要通过<code>connfd</code>向客户端发送数据时，直接发送即可：</p><ul><li><p>如果应用层缓冲区<code>outbuffer</code>的数据大小小于<code>send_buff</code>大小，则无须任何操作；</p><p>换言之，<code>connfd</code>的<code>send_buff</code>能容纳<code>outbuffer</code>中的全部数据，那么<code>send_buff</code>依然未满，即处于高电平状态。下次应用层有待发送的数据，直接发送即可；</p></li><li><p>如果<code>outbuffer</code>中的数据大小大于<code>send_buff</code>大小，那么<code>write(connfd, outbuffer, size)</code>返回-1 且 <code>errno</code>是<code>EAGAIN</code>。</p><p>由于<code>send_buff</code>满了，即处于「低电平」状态，表示不可再接受来自应用层的数据。为了将<code>outbuffer</code>中剩余的数据也发送到对端，此时需要为<code>connfd</code>注册可写事件。</p><p>当<code>send_buff</code>的数据发送出去，则会变为「高电平」状态，此时就会触发<code>connfd</code>上的可写事件，进而就能继续发送<code>outbuffer</code>中剩下的数据了。</p></li></ul><p>总结下，写操作要一直写到应用层<code>outBuffer</code>为空，或者<code>write</code>函数返回<code>EAGAIN</code>。</p><p>上面的 <code>epoll LT</code> 模式注：如果数据未发送完毕，需要注册可写事件；可写事件触发后，尝试发送<code>outBuffer</code>中的剩余数据，如果数据此时还不能全部发送完，<strong>不用再次注册可写事件，若全部发送完毕，需要取消注册可写事件</strong>。</p><p>如果是 <code>epoll ET</code> 模：如果数据未发送完毕，注册可写事件；可写事件触发后，尝试发送剩余数据，如果数据此时还不能全部发送完，<strong>需要再次注册可写事件，以便让可写事件下次再次触发，数据全部发送完毕，不用取消注册可写事件</strong>。</p><h3 id="LT-or-ET"><a href="#LT-or-ET" class="headerlink" title="LT  or ET ?"></a>LT  or ET ?</h3><p>说了这么多，那自己设计一个服务器，到底是选 <code>ET</code> 还是 <code>LT</code> ?</p><p>从个人的目前经验来说，看到的大多数都是<code>LT</code>。</p><p>对于可读事件，<code>ET</code>模式只会触发一次<code>epoll_wait</code>，而<code>LT</code>模式下，如果不能一次性读取完<code>recv_buff </code> 中的数据，则会多次触发<code>epoll_wait</code>，增加系统调用开销。</p><p>如果我使用<code>LT</code>模式，且一次就将<code>recv_buff </code> 中的数据全部读取出来，那不也就只调用一次<code>epoll_wait</code>，不就和<code>ET</code>模式一样了？</p><p>此外，LT模式下的<code>read</code>函数可以少一次系统调用，因为<code>ET</code>模式下的<code>read</code>操作必须读取到返回<code>EAGAIN</code>，就多了一次系统调用开销。</p><p>这就是<code>muduo</code>设计了一个<code>InputBuffer</code>的原因，而在<code>redis</code>中也有个输入缓冲区。</p><blockquote><p>muduo、libuv、redis等都是采用LT模式，其他库不太清楚。</p></blockquote><p>更为重要的是，<code>ET</code>模式操作不当，容易造成数据漏读、甚至服务器阻塞等问题，而良好的设计的<code>LT</code>模式效率也依然很高。</p><p>下面我们从muduo源码角度还原上述过程。</p><h2 id="muduo源码展示"><a href="#muduo源码展示" class="headerlink" title="muduo源码展示"></a>muduo源码展示</h2><p>确定好大的方向是「LT模式的<code>epoll</code> + 非阻塞IO」来设计异步通信之后。下面，我们就根据「网络编程」的前三期大致梳理下muduo服务端的源码。</p><h3 id="监听客户端连接请求"><a href="#监听客户端连接请求" class="headerlink" title="监听客户端连接请求"></a>监听客户端连接请求</h3><p>当muduo的服务器<code>TcpServer</code>运行时，会先在<code>Acceptor</code>中创建一个非阻塞的<code>listenfd</code>，用于监听客户端的连接请求，即muduo中的<code>acceptSocket_</code>字段， 并为<code>acceptSocket_</code>注册可读事件、设置可读回调函数 <code>Acceptor::handleRead</code>。</p><p>这样，服务端就能监听客户端<code>cli</code>的连接请求：</p><ul><li>当监听到客户端的连接请求后，在读取回调函数<code>Acceptor::handleRead</code>中为请求连接的客户端<code>cli</code>创建<code>TcpConnection</code>对象<code>conn</code>；</li><li>在众多<code>sub-eventloops</code>线程中，选择一个<code>sub-loop</code>线程，将<code>conn</code>分发到该<code>sub-loop</code>线程；</li><li>以后服务端与该<code>cli</code>的通信，都在<code>sub-loop</code>线程中完成，而<code>Acceptor</code>所在的<code>main-eventloop</code>线程，只是负责监听客户端的连接请求。</li></ul><p>如此，<code>Accptor</code>的作用即任务分发器<code>dispatcher</code>：</p><p>整个框架逻辑如图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop* loop, <span class="type">const</span> InetAddress&amp; listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">  : <span class="built_in">loop_</span>(loop),</span><br><span class="line">    <span class="built_in">acceptSocket_</span>(sockets::<span class="built_in">createNonblockingOrDie</span>(listenAddr.<span class="built_in">family</span>())),</span><br><span class="line">    <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()),</span><br><span class="line">    <span class="built_in">listening_</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">idleFd_</span>(::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">assert</span>(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line">  acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">  acceptSocket_.<span class="built_in">setReusePort</span>(reuseport); <span class="comment">// 设置端口复用</span></span><br><span class="line">  acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// 绑定地址</span></span><br><span class="line">  acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>)); <span class="comment">// 可读事件回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自然，分发任务的操作就是在可读事件的回调函数<code>Acceptor::handleRead</code>中完成的，其核心就是<code>newConnectionCallback_</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  InetAddress peerAddr;</span><br><span class="line">  <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr); <span class="comment">// 获取客户端的 ip:port</span></span><br><span class="line">  <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">      <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      sockets::<span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">&quot;in Acceptor::handleRead&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">      ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">      idleFd_ = ::<span class="built_in">accept</span>(acceptSocket_.<span class="built_in">fd</span>(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">      idleFd_ = ::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而回调函数<code>newConnectionCallback_</code>最终初始化为<code>TcpServer</code>类中的<code>TcpServer::newConnection</code>函数：</p><ul><li>创建<code>TcpConnection</code>对象 <code>conn</code>；</li><li><code>TcpServer</code>中的<code>connections_</code>记录着每个客户端，因此要把新创建的客户端记录在<code>connections_</code>中；</li><li>为<code>conn</code>设置一些回调函数；</li><li>将<code>conn</code>放到<code>sub-eventloop</code>中运行，以后服务器与该客户端的通讯就在<code>ioLoop</code>中进行了。</li></ul><p>整个逻辑如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress&amp; peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  EventLoop* ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>(); <span class="comment">// 从子线程中选择一个</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">  LOG_INFO &lt;&lt; <span class="string">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_</span><br><span class="line">           &lt;&lt; <span class="string">&quot;] - new connection [&quot;</span> &lt;&lt; connName</span><br><span class="line">           &lt;&lt; <span class="string">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class="built_in">toIpPort</span>();</span><br><span class="line">  <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">  <span class="comment">// 创建TcpConnection对象</span></span><br><span class="line">  <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          peerAddr))</span></span>;</span><br><span class="line">  connections_[connName] = conn;</span><br><span class="line">  <span class="comment">// 设置相关的回调函数</span></span><br><span class="line">  conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">  conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">  conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">  <span class="comment">// 放到 sub-eventloop 中运行</span></span><br><span class="line">  ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>TcpConnection::connectEstablished</code>回调函数中，为每个刚建立连接的<code>TcpConnection</code>对象注册可读事件，这是为了监听等待客户端的发送数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="built_in">assert</span>(state_ == kConnecting);</span><br><span class="line">  <span class="built_in">setState</span>(kConnected);</span><br><span class="line">  channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">  channel_-&gt;<span class="built_in">enableReading</span>(); <span class="comment">// 注册可读事件</span></span><br><span class="line">  <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个<code>conn</code>的可读、可写等事件的回调函数在<code>TcpConnection</code>构造函数中就完成了初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop* loop,</span><br><span class="line">                             <span class="type">const</span> string&amp; nameArg,</span><br><span class="line">                             <span class="type">int</span> sockfd,</span><br><span class="line">                             <span class="type">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                             <span class="type">const</span> InetAddress&amp; peerAddr)</span><br><span class="line">  : <span class="built_in">loop_</span>(<span class="built_in">CHECK_NOTNULL</span>(loop)),</span><br><span class="line">    <span class="built_in">name_</span>(nameArg),</span><br><span class="line">    <span class="built_in">state_</span>(kConnecting),</span><br><span class="line">    <span class="built_in">reading_</span>(<span class="literal">true</span>),</span><br><span class="line">    <span class="built_in">socket_</span>(<span class="keyword">new</span> <span class="built_in">Socket</span>(sockfd)),</span><br><span class="line">    <span class="built_in">channel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop, sockfd)),</span><br><span class="line">    <span class="built_in">localAddr_</span>(localAddr),</span><br><span class="line">    <span class="built_in">peerAddr_</span>(peerAddr),</span><br><span class="line">    <span class="built_in">highWaterMark_</span>(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">  channel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1)); <span class="comment">// 读回调</span></span><br><span class="line">  channel_-&gt;<span class="built_in">setWriteCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));   <span class="comment">// 写回调</span></span><br><span class="line">  channel_-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));   <span class="comment">// 关闭回调</span></span><br><span class="line">  channel_-&gt;<span class="built_in">setErrorCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>));   <span class="comment">// 错误处理回调</span></span><br><span class="line">  LOG_DEBUG &lt;&lt; <span class="string">&quot;TcpConnection::ctor[&quot;</span> &lt;&lt;  name_ &lt;&lt; <span class="string">&quot;] at &quot;</span> &lt;&lt; <span class="keyword">this</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; sockfd;</span><br><span class="line">  socket_-&gt;<span class="built_in">setKeepAlive</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，当<code>conn</code>对应的客户端发送过来数据时，触发可读事件后，会调用<code>TcpConnection::handleRead</code>来进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">  <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">handleClose</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleRead&quot;</span>;</span><br><span class="line">    <span class="built_in">handleError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，启动服务器到和客户端建立连接请求的过程、接受数据的流程大致结束了。</p><h3 id="可写事件-2"><a href="#可写事件-2" class="headerlink" title="可写事件"></a>可写事件</h3><p>在前面说过<code>LT</code>模式下的可写事件需要注意的点，下面顺着代码注释去看就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="type">ssize_t</span> nwrote   = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> remaining = len;</span><br><span class="line">  <span class="type">bool</span> faultError  = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (state_ == kDisconnected)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;disconnected, give up writing&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 如果没有关注可写事件 且 outbuffer_ 中无待发送数据，说明之前的数据都已经写完</span></span><br><span class="line">  <span class="comment">/// 对于 用户来说是向 outbuffer_ 中写，</span></span><br><span class="line">  <span class="comment">/// 对于 socket 来说是从 outbuffer_ 中读取</span></span><br><span class="line">  <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outbuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    nwrote = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(), data, len);</span><br><span class="line">    <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      remaining = len - nwrote;</span><br><span class="line">      <span class="comment">// 全部写完了，那么就执行写完成回调</span></span><br><span class="line">      <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)</span><br><span class="line">      &#123;</span><br><span class="line">        loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">    &#123;</span><br><span class="line">      nwrote = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/// socket 的发送缓冲已经满，无法将 outbuffer_ 的数据都复制到 socket 的 send_buff</span></span><br><span class="line">      <span class="comment">/// 非阻塞模式下，函数返回 -1 &amp;&amp; errno == EWOULDBLOCK</span></span><br><span class="line">      <span class="comment">/// 如果错误码不是EWOULDBLOCK，那么是真的产生错误了，需要关闭连接</span></span><br><span class="line">      <span class="keyword">if</span> (errno != EWOULDBLOCK) </span><br><span class="line">      &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::sendInLoop&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></span><br><span class="line">        &#123;</span><br><span class="line">          faultError = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(remaining &lt;= len);</span><br><span class="line">  <span class="comment">/// @brief: 运行到这有两种可能：</span></span><br><span class="line">  <span class="comment">/// 1 之前没有注册可写事件，且 outbuffer_ 中没有可读取数据，</span></span><br><span class="line">  <span class="comment">/// 运行到此是因为此次数据 data 没有发送完</span></span><br><span class="line">  <span class="comment">/// 2 之前的数据没有发送完，又来了新的数据</span></span><br><span class="line">  <span class="comment">/// 无论哪种情况，处理方式：</span></span><br><span class="line">  <span class="comment">///  将数据复制到 outbuffer_ 中，关注 EPOLLOUT 事件，等待可写事件触发，发送数据</span></span><br><span class="line">  <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> oldLen = outbuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">    <span class="comment">// 待发送的内容已经超过标志位了，就调用高水位这个函数</span></span><br><span class="line">    <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_  &amp;&amp;</span><br><span class="line">        oldLen &lt; highWaterMark_  &amp;&amp;</span><br><span class="line">        highWaterMarkCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(highWaterMarkCallback_, </span><br><span class="line">                                   <span class="built_in">shared_from_this</span>(), </span><br><span class="line">                                   oldLen + remaining));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 将剩余的内容加如 outbuffer_</span></span><br><span class="line">    outbuffer_.<span class="built_in">append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data)+nwrote, remaining);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在LT 模式下不需要重复关注可写事件，即使运行到此的第二种情况不需要再关注可写事件</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      channel_-&gt;<span class="built_in">enableWriting</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief: 写回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="comment">/// 触发写回调函数</span></span><br><span class="line">  <span class="comment">/// 将 @b outbuffer_ 中的数据复制到 @b socket 的`send_buff`</span></span><br><span class="line">  <span class="keyword">if</span> (channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),</span><br><span class="line">                               outbuffer_.<span class="built_in">peek</span>(),</span><br><span class="line">                               outbuffer_.<span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      outbuffer_.<span class="built_in">retrieve</span>(n);</span><br><span class="line">      <span class="comment">/// 如果 @b outbuffer_ 中的数据全部写完，</span></span><br><span class="line">      <span class="comment">/// 那么就可以取消关注 @b EPOLLOUT ，防止出现 busy loop</span></span><br><span class="line">      <span class="comment">/// 并且调用写完成回调函数</span></span><br><span class="line">      <span class="comment">/// 如果全部写完，此时就需要取消关注可写事件</span></span><br><span class="line">      <span class="comment">/// 如果 @b outbuffer_ 中还有数据，就继续等待下次可写事件的触发</span></span><br><span class="line">      <span class="keyword">if</span> (outbuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">        <span class="keyword">if</span> (writeCompleteCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">          loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (state_ == kDisconnecting)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleWrite&quot;</span>;</span><br><span class="line">      <span class="comment">// if (state_ == kDisconnecting)</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   shutdownInLoop();</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;Connection fd = &quot;</span> &lt;&lt; channel_-&gt;<span class="built_in">fd</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot; is down, no more writing&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>到此，就差不多了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异步通信&quot;&gt;&lt;a href=&quot;#异步通信&quot; class=&quot;headerlink&quot; title=&quot;异步通信&quot;&gt;&lt;/a&gt;异步通信&lt;/h1&gt;&lt;p&gt;之前有两期讲解了服务端框的架构，这一期来讲下服务器是如何与客户端进行异步通信的，下一期再讲述客户端是如何异步非阻塞conne</summary>
      
    
    
    
    <category term="nio" scheme="https://szza.github.io/categories/nio/"/>
    
    
    <category term="nio" scheme="https://szza.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>persistent cache 设计</title>
    <link href="https://szza.github.io/2021/12/02/rocksdb/utility/persistent_cache/"/>
    <id>https://szza.github.io/2021/12/02/rocksdb/utility/persistent_cache/</id>
    <published>2021-12-02T06:15:35.000Z</published>
    <updated>2023-08-01T02:43:41.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="persistent-cache"><a href="#persistent-cache" class="headerlink" title="persistent cache"></a>persistent cache</h2><p>RocksDB  利用分层概念，设计了persistent cache：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// PersistentTieredCache architecture:</span><br><span class="line">// +--------------------------+ PersistentCacheTier that handles multiple tiers</span><br><span class="line">// | +----------------+       |</span><br><span class="line">// | | RAM            | PersistentCacheTier that handles RAM (VolatileCacheImpl)</span><br><span class="line">// | +----------------+       |</span><br><span class="line">// |   | next                 |</span><br><span class="line">// |   v                      |</span><br><span class="line">// | +----------------+       |</span><br><span class="line">// | | NVM            | PersistentCacheTier implementation that handles NVM</span><br><span class="line">// | +----------------+ (BlockCacheImpl)</span><br><span class="line">// |   | next                 |</span><br><span class="line">// |   V                      |</span><br><span class="line">// | +----------------+       |</span><br><span class="line">// | | LE-SSD         | PersistentCacheTier implementation that handles LE-SSD</span><br><span class="line">// | +----------------+ (BlockCacheImpl)</span><br><span class="line">// |   |                      |</span><br><span class="line">// |   V                      |</span><br><span class="line">// |  null                    |</span><br><span class="line">// +--------------------------+</span><br><span class="line">//               |</span><br><span class="line">//               V</span><br><span class="line">//              null</span><br></pre></td></tr></table></figure><ul><li>在最上层，数据全都是在内存中，这一部分属于易失性数据由 <code>VolatileCacheImpl</code> 实现</li><li>其他层，在内存和文件中的数据进行交互，由 <code>BlockCacheImpl</code> 实现。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;persistent-cache&quot;&gt;&lt;a href=&quot;#persistent-cache&quot; class=&quot;headerlink&quot; title=&quot;persistent cache&quot;&gt;&lt;/a&gt;persistent cache&lt;/h2&gt;&lt;p&gt;RocksDB  利用分层概</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>多线程 HashTable 设计</title>
    <link href="https://szza.github.io/2021/12/01/rocksdb/utility/HashTablel/"/>
    <id>https://szza.github.io/2021/12/01/rocksdb/utility/HashTablel/</id>
    <published>2021-12-01T06:15:35.000Z</published>
    <updated>2023-08-01T02:43:34.123Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable&lt;T, Hash, Equal&gt;"></a>HashTable&lt;T, Hash, Equal&gt;</h2><p>RocksDB 为了优化多核下的HashTable性能，放弃了全局锁设计，取而代之是如下分段锁设计：在并发下，将全局锁上的竞争分散到各个bucket上。</p><p>对每个桶（bucket）分配一个锁（mutex），当获取某个bucket中的元素时，只使用对应bucket的mutex即可，这样对其他bucket的元素就没有额外的负担。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                         |&lt;-------- alpha -------------&gt;|</span></span><br><span class="line"><span class="comment">//               Buckets   Collision list</span></span><br><span class="line"><span class="comment">//          ---- +----+    +---+---+--- ...... ---+---+---+</span></span><br><span class="line"><span class="comment">//         /     |    |---&gt;|   |   |              |   |   |</span></span><br><span class="line"><span class="comment">//        /      +----+    +---+---+--- ...... ---+---+---+</span></span><br><span class="line"><span class="comment">//       /       |    |</span></span><br><span class="line"><span class="comment">// Locks/        +----+</span></span><br><span class="line"><span class="comment">// +--+/         .    .</span></span><br><span class="line"><span class="comment">// |  |          .    .</span></span><br><span class="line"><span class="comment">// +--+          .    .</span></span><br><span class="line"><span class="comment">// |  |          .    .</span></span><br><span class="line"><span class="comment">// +--+          .    .</span></span><br><span class="line"><span class="comment">// |  |          .    .</span></span><br><span class="line"><span class="comment">// +--+          .    .</span></span><br><span class="line"><span class="comment">//     \         +----+</span></span><br><span class="line"><span class="comment">//      \        |    |</span></span><br><span class="line"><span class="comment">//       \       +----+</span></span><br><span class="line"><span class="comment">//        \      |    |</span></span><br><span class="line"><span class="comment">//         \---- +----+</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="HashTable-1"><a href="#HashTable-1" class="headerlink" title="HashTable"></a>HashTable</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Hash</span>, <span class="keyword">class</span> <span class="title class_">Equal</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">HashTable</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> capacity = <span class="number">1024</span> * <span class="number">1024</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">float</span> load_factor = <span class="number">2.0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint32_t</span> nlocks = <span class="number">256</span>)</span></span></span><br><span class="line"><span class="function">      : nbuckets_(static_cast&lt;uint32_t&gt;(load_factor ? capacity / load_factor : <span class="number">0</span>)),</span></span><br><span class="line"><span class="function">        nlocks_(nlocks) &#123;</span></span><br><span class="line">    <span class="built_in">assert</span>(capacity);</span><br><span class="line">    <span class="built_in">assert</span>(load_factor);</span><br><span class="line">    <span class="built_in">assert</span>(nbuckets_);</span><br><span class="line">    <span class="built_in">assert</span>(nlocks_);</span><br><span class="line"></span><br><span class="line">    buckets_.<span class="built_in">reset</span>(<span class="keyword">new</span> Bucket[nbuckets_]);</span><br><span class="line">  <span class="comment">// initialize</span></span><br><span class="line">    <span class="built_in">mlock</span>(buckets_.<span class="built_in">get</span>(), nbuckets_ * <span class="built_in">sizeof</span>(Bucket));</span><br><span class="line">    <span class="built_in">mlock</span>(locks_.<span class="built_in">get</span>(), nlocks_ * <span class="built_in">sizeof</span>(port::RWMutex));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(buckets_);</span><br><span class="line">    <span class="built_in">assert</span>(locks_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">HashTable</span>() &#123; <span class="built_in">AssertEmptyBuckets</span>(); &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Bucket</span> &#123;</span><br><span class="line">    std::list&lt;T&gt; list_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">AssertEmptyBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nbuckets_; ++i) &#123;</span><br><span class="line">      WriteLock _(&amp;locks_[i % nlocks_]);</span><br><span class="line">      <span class="built_in">assert</span>(buckets_[i].list_.<span class="built_in">empty</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> nbuckets_;                 <span class="comment">// 桶的总数</span></span><br><span class="line">  std::unique_ptr&lt;Bucket[]&gt; buckets_;       <span class="comment">// 桶</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> nlocks_;                   <span class="comment">// 锁的总数</span></span><br><span class="line">  std::unique_ptr&lt;port::RWMutex[]&gt; locks_;  <span class="comment">// 锁 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h4><p>每个bucket都指向一个链表，用于解决hash冲突，因此当查找一个key时，需要在链表中顺序查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 顺序查找，时间复杂度O(N)</span></span><br><span class="line"><span class="keyword">typename</span> std::list&lt;T&gt;::<span class="function">iterator <span class="title">Find</span><span class="params">(std::list&lt;T&gt;* list, <span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = list-&gt;<span class="built_in">begin</span>(); it != list-&gt;<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Equal</span>()(*it, t)) &#123;</span><br><span class="line">      <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list-&gt;<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///@brief 在 bucket 中查找 t</span></span><br><span class="line"><span class="comment">///@param ret 就是传出参数，返回true时有效</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(Bucket* bucket, <span class="type">const</span> T&amp; t, T* ret)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = <span class="built_in">Find</span>(&amp;bucket-&gt;list_, t);</span><br><span class="line">  <span class="keyword">if</span> (it != bucket-&gt;list_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      *ret = *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将 t 添加到 bucket 中，不会重复添加</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(Bucket* bucket, <span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = <span class="built_in">Find</span>(&amp;bucket-&gt;list_, t);</span><br><span class="line">  <span class="keyword">if</span> (it != bucket-&gt;list_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 不存在，则添加</span></span><br><span class="line">  bucket-&gt;list_.<span class="built_in">push_back</span>(t);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Erase"><a href="#Erase" class="headerlink" title="Erase"></a>Erase</h4><p><code>Erase</code> 和 <code>Insert</code>类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(Bucket* bucket, <span class="type">const</span> T&amp; t, T* ret)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = <span class="built_in">Find</span>(&amp;bucket-&gt;list_, t);</span><br><span class="line">  <span class="keyword">if</span> (it != bucket-&gt;list_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      *ret = *it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bucket-&gt;list_.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GetMutex"><a href="#GetMutex" class="headerlink" title="GetMutex"></a>GetMutex</h4><p><code>GetMutex</code>函数，用于获得一个key对应的mutex。</p><ul><li>获得 key 对应的 hash_code</li><li>获得 hash_code 映射到 buckets_ 中的索引 bucket_idx</li><li>通过 bucket_idx 映射到 locks_ 中的索引 lock_idx</li></ul><p>最终，对 key 进行同步操作的锁就是 <code>locks_[lock_idx]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">port::RWMutex* <span class="title">GetMutex</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> h = <span class="built_in">Hash</span>()(t);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> bucket_idx = h % nbuckets_;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> lock_idx = bucket_idx % nlocks_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;locks_[lock_idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>下面来看看，将一个 key 插入到 HashTable 中的过程。</p><ul><li>获得 <code>bucket_idx</code>、<code>lock_idx</code></li><li>使用 <code>locks_[lock_idx]</code> 对要修改的 <code>buckets_[bucket_idx]</code> 进行保护，再调用bucket级别的insert方法，将key插入到 <code>buckets_[bucket_idx]</code> 中。</li></ul><p>整体表现如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">uint64_t</span> h = <span class="built_in">Hash</span>()(t);</span><br><span class="line">   <span class="type">const</span> <span class="type">uint32_t</span> bucket_idx = h % nbuckets_;</span><br><span class="line">   <span class="type">const</span> <span class="type">uint32_t</span> lock_idx = bucket_idx % nlocks_;</span><br><span class="line"></span><br><span class="line">   WriteLock _(&amp;locks_[lock_idx]);</span><br><span class="line">   <span class="keyword">auto</span>&amp; bucket = buckets_[bucket_idx];</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Insert</span>(&amp;bucket, t);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其余方法，和 <code>Insert</code> 类似。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HashTable&quot;&gt;&lt;a href=&quot;#HashTable&quot; class=&quot;headerlink&quot; title=&quot;HashTable&amp;lt;T, Hash, Equal&amp;gt;&quot;&gt;&lt;/a&gt;HashTable&amp;lt;T, Hash, Equal&amp;gt;&lt;/h2&gt;&lt;</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>BlockBasedTableBuilder 源码分析</title>
    <link href="https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/"/>
    <id>https://szza.github.io/2021/11/28/rocksdb/Table/builder/4_BlockBaseTableBuilder/</id>
    <published>2021-11-28T06:15:35.000Z</published>
    <updated>2023-08-01T02:43:06.664Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BlockBasedTableBuilder-ParallelCompressionRep"><a href="#BlockBasedTableBuilder-ParallelCompressionRep" class="headerlink" title="BlockBasedTableBuilder::ParallelCompressionRep"></a>BlockBasedTableBuilder::ParallelCompressionRep</h2><p>先来看看<code>BlockBasedTableBuilder</code>中的多线程压缩部分 <code> BlockBasedTableBuilder::ParallelCompressionRep</code>。</p><p>以下代码不加说明，都是在类 <code>BlockBasedTableBuilder::ParallelCompressionRep</code> 里面。</p><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p>在 <code>class ParallelCompressionRep</code> 中，有个<code>class Keys</code>，这是一个为了提高内存利用率的类。涉及点：</p><ul><li>预分配 <code>kKeysInitSize</code>个元素的内存：若向<code>Keys</code>中添加的元素个数小于 <code>kKeysInitSize</code>，则使用可以使用预分配的内存，避免了动态内存分配；</li><li>每次<code>Keys::Clear()</code>的时候，并不是真的释放了之前的内存，仅仅是调整了计数器<code>size_</code>，即常见的『惰性删除』。</li></ul><p>这是常见而有效的设计，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Keys</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Keys</span>() : <span class="built_in">keys_</span>(kKeysInitSize), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">PushBack</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (size_ == keys_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">       <span class="comment">// 说明 keys_的元素个数超过预分配</span></span><br><span class="line">       keys_.<span class="built_in">emplace_back</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 使用预分配内存</span></span><br><span class="line">       keys_[size_].<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">     &#125;</span><br><span class="line">     size_++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">SwapAssign</span><span class="params">(std::vector&lt;std::string&gt;&amp; keys)</span> </span>&#123;</span><br><span class="line">     size_ = keys.<span class="built_in">size</span>();</span><br><span class="line">     std::<span class="built_in">swap</span>(keys_, keys);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 惰性删除</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123; size_ = <span class="number">0</span>; &#125;</span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">   <span class="function">std::string&amp; <span class="title">Back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> keys_[size_ - <span class="number">1</span>]; &#125;</span><br><span class="line">   std::string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> idx) &#123;</span><br><span class="line">     <span class="built_in">assert</span>(idx &lt; size_);</span><br><span class="line">     <span class="keyword">return</span> keys_[idx];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   <span class="type">const</span> <span class="type">size_t</span> kKeysInitSize = <span class="number">32</span>;</span><br><span class="line">   std::vector&lt;std::string&gt; keys_;</span><br><span class="line">   <span class="type">size_t</span> size_;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Keys&gt; curr_block_keys;</span><br></pre></td></tr></table></figure><h3 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h3><p>在继续讲解之前，先讲解下Rocksdb保证多线程安全的队列。</p><p>在rocksdb中，是怎么保证多线程压缩的顺序性呢，依赖<code>WorkQueue</code>，<code>WorkQueue</code>其实就是个很简单的『生产-消费』多线程模型：写线程和多线程之间共享一个任务队列 <code>queue_</code>，以及保护这个共享队列<code>queue_</code>的互斥锁<code>mutex_</code>。</p><p><code>WorkQueue</code>在<code>::Finish</code>函数之后，就不可用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkQueue</span> &#123;</span><br><span class="line">  std::mutex mutex_;</span><br><span class="line">  std::condition_variable readerCv_;</span><br><span class="line">  std::condition_variable writerCv_;</span><br><span class="line">  std::condition_variable finishCv_;</span><br><span class="line"></span><br><span class="line">  std::queue&lt;T&gt; queue_;</span><br><span class="line">  <span class="type">bool</span> done_;</span><br><span class="line">  std::<span class="type">size_t</span> maxSize_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 必须在锁中调用这个函数</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue_.<span class="built_in">size</span>() &gt;= maxSize_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">WorkQueue</span>(std::<span class="type">size_t</span> maxSize = <span class="number">0</span>) : <span class="built_in">done_</span>(<span class="literal">false</span>), <span class="built_in">maxSize_</span>(maxSize) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(U&amp;&amp; item)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">waitUntilFinished</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 更改 queue_ 大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setMaxSize</span><span class="params">(std::<span class="type">size_t</span> maxSize)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">      maxSize_ = maxSize;</span><br><span class="line">     &#125;</span><br><span class="line">    writerCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p><code>push</code> 函数，向共享队列<code>queue_</code> 中添加一个任务，成功则返回true。如果已经调用了<code>::Finish</code> 函数，则返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorkQueue::push</span><span class="params">(U&amp;&amp; item)</span> </span>&#123;</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// 等待 queue_ 队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">full</span>() &amp;&amp; !done_) &#123;</span><br><span class="line">      writerCv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果调用了 Finish 函数</span></span><br><span class="line">    <span class="comment">// 则不再接受新的元素</span></span><br><span class="line">    <span class="keyword">if</span> (done_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加新的元素</span></span><br><span class="line">    queue_.<span class="built_in">push</span>(std::forward&lt;U&gt;(item));</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 通知读线程</span></span><br><span class="line">  readerCv_.<span class="built_in">notify_one</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p><code>pop</code>函数，按照FIFO规则从共享任务队列 <code>queue_</code> 中弹出一个待处理任务，并返回true。</p><p>如果已经调用了<code>::Finish</code> 函数，则返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"> <span class="type">bool</span> <span class="title">WorkQueue::pop</span><span class="params">(T&amp; item)</span> </span>&#123;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">// 等写线程添加元素</span></span><br><span class="line">     <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">     <span class="keyword">while</span> (queue_.<span class="built_in">empty</span>() &amp;&amp; !done_) &#123;</span><br><span class="line">       readerCv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 如果已经调用了 ::Finish 函数</span></span><br><span class="line">     <span class="comment">// 则不再处理</span></span><br><span class="line">     <span class="keyword">if</span> (queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">       <span class="built_in">assert</span>(done_);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 弹出</span></span><br><span class="line">     item = queue_.<span class="built_in">front</span>();</span><br><span class="line">     queue_.<span class="built_in">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 通知写线程</span></span><br><span class="line">   writerCv_.<span class="built_in">notify_one</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="waitUntilFinished"><a href="#waitUntilFinished" class="headerlink" title="waitUntilFinished"></a>waitUntilFinished</h4><p><code>waitUntilFinished</code> 函数，用于阻塞等待 <code>WorkQueue::Finish</code> 函数调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitUntilFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (!done_) &#123;</span><br><span class="line">    finishCv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h4><p><code>::Finish</code> 函数调用后，<code>WorkQueue</code> 不再处理接受新的元素，也不再弹出旧的元素，<code>waitUntilFinished</code> 函数就能返回了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkQueue::finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="built_in">assert</span>(!done_);</span><br><span class="line">    done_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  readerCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  writerCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  finishCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BlockRepSlot"><a href="#BlockRepSlot" class="headerlink" title="BlockRepSlot"></a>BlockRepSlot</h3><p><code>BlockRepSlot</code> 是基于<code>WorkQueue</code>实现的线程安全队列。</p><p>每个节点<code>BlockRep*</code>记录一个block的相关数据及其状态，那么就可以由写线程将<code>BlockRep</code>节点加入到<code>BlockRepSlot</code>中，压缩等工作线程从<code>BlockRepSlot</code>中通过<code>take</code>函数取出<code>BlockRep</code>节点，对其进行压缩等操作。</p><p>如此，就能完成多线程操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// BlockRep 记录一个 block 的数据及其相关信息</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">BlockRep</span> &#123;</span><br><span class="line">   Slice contents;                      <span class="comment">// 原始内容</span></span><br><span class="line">   Slice compressed_contents;                     <span class="comment">// 压缩内容</span></span><br><span class="line">   std::unique_ptr&lt;std::string&gt; data;             <span class="comment">// 原始内容， 与 contents 区别</span></span><br><span class="line">   std::unique_ptr&lt;std::string&gt; compressed_data;  <span class="comment">// 压缩之后的数据</span></span><br><span class="line">   CompressionType compression_type;              <span class="comment">// 压缩类型</span></span><br><span class="line">   std::unique_ptr&lt;std::string&gt; first_key_in_next_block;</span><br><span class="line">   std::unique_ptr&lt;Keys&gt; keys;                    <span class="comment">// 此block的所有keys</span></span><br><span class="line">   std::unique_ptr&lt;BlockRepSlot&gt; slot;            <span class="comment">// 所属的 BlockRepSlot  ???          </span></span><br><span class="line">   Status status;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockRepSlot</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">BlockRepSlot</span>() : <span class="built_in">slot_</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 向 slot_ 中添加一</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Fill</span><span class="params">(T&amp;&amp; rep)</span> </span>&#123;</span><br><span class="line">     slot_.<span class="built_in">push</span>(std::forward&lt;T&gt;(rep));</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Take</span><span class="params">(BlockRep*&amp; rep)</span> </span>&#123; slot_.<span class="built_in">pop</span>(rep); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   WorkQueue&lt;BlockRep*&gt; slot_;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="FileSizeEstimator"><a href="#FileSizeEstimator" class="headerlink" title="FileSizeEstimator"></a>FileSizeEstimator</h3><p>当并行压缩开启时，类 <code>FileSizeEstimator</code> 用于计算输出文件大小。主要是有两个回调函数 <code>EmitBlock</code>  、<code>ReapBlock</code>：</p><ul><li><code>EmitBlock</code>：在添加到压缩线程之前调用</li><li><code>ReapBlock</code>：在压缩完成之后调用</li></ul><p><code>FileSizeEstimator</code> 的源码简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSizeEstimator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FileSizeEstimator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      : raw_bytes_compressed(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        raw_bytes_curr_block(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        raw_bytes_curr_block_set(false),</span></span><br><span class="line"><span class="function">        raw_bytes_inflight(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        blocks_inflight(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        curr_compression_ratio(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        estimated_file_size(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 当一个 block 要 emit to 压缩线程时，则计算一个文件大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(<span class="type">uint64_t</span> raw_block_size, <span class="type">uint64_t</span> curr_file_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 当一个 block 从压缩线程压缩完毕时</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(<span class="type">uint64_t</span> compressed_block_size, <span class="type">uint64_t</span> curr_file_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 设置文件近似大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetEstimatedFileSize</span><span class="params">(<span class="type">uint64_t</span> size)</span> </span>&#123;</span><br><span class="line">    estimated_file_size.<span class="built_in">store</span>(size, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 获得文件近似大小</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">GetEstimatedFileSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> estimated_file_size.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/// 设置block大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetCurrBlockRawSize</span><span class="params">(<span class="type">uint64_t</span> size)</span> </span>&#123;</span><br><span class="line">    raw_bytes_curr_block = size;</span><br><span class="line">    raw_bytes_curr_block_set = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint64_t</span> raw_bytes_compressed;  <span class="comment">// 到目前为止压缩的字节，即这么多的字节是要要压缩的</span></span><br><span class="line">  <span class="type">uint64_t</span> raw_bytes_curr_block;  <span class="comment">// Size of current block being appended.</span></span><br><span class="line">  <span class="type">bool</span> raw_bytes_curr_block_set;  <span class="comment">// </span></span><br><span class="line">  std::atomic&lt;<span class="type">uint64_t</span>&gt; raw_bytes_inflight; <span class="comment">// 正在压缩，但尚未添加到sst文件的字节大小</span></span><br><span class="line">  std::atomic&lt;<span class="type">uint64_t</span>&gt; blocks_inflight;    <span class="comment">// Number of blocks under compression and not appended yet.</span></span><br><span class="line">  std::atomic&lt;<span class="type">double</span>&gt; curr_compression_ratio; <span class="comment">// 压缩率</span></span><br><span class="line">  std::atomic&lt;<span class="type">uint64_t</span>&gt; estimated_file_size;  <span class="comment">// SST 文件的近似大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="EmitBlock"><a href="#EmitBlock" class="headerlink" title="EmitBlock"></a>EmitBlock</h4><p><code>EmitBlock</code>函数，在将一个待压缩的block发送给压缩线程之前调用，用于计算当所有block压缩完成后sst文件的近似大小。主要有三部分组成：</p><ol><li><code>curr_file_size</code>：已写入到sst的部分</li><li><code>new_raw_bytes_inflight</code>：当前正在压缩，还没写入sst的部分。这部分按照压缩率<code>curr_compression_ratio</code> 大致折算成最终写入sst的大小。</li><li><code>kBlockTrailerSize</code>：每个block都有<code>footer</code>，这部分不压缩，按照正在压缩的block数<code>new_blocks_inflight</code> 乘以每个<code>footer</code>的大小<code>kBlockTrailerSize</code>，即这部分写入sst的大小。</li></ol><p>源码简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param raw_block_size 待压缩的 block 大小</span></span><br><span class="line"><span class="comment">/// @param curr_file_size </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(<span class="type">uint64_t</span> raw_block_size, <span class="type">uint64_t</span> curr_file_size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前正在压缩的字节数</span></span><br><span class="line">    <span class="type">uint64_t</span> new_raw_bytes_inflight =</span><br><span class="line">        raw_bytes_inflight.<span class="built_in">fetch_add</span>(raw_block_size,</span><br><span class="line">                                     std::memory_order_relaxed) +</span><br><span class="line">        raw_block_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在压缩的block数据</span></span><br><span class="line">    <span class="type">uint64_t</span> new_blocks_inflight =</span><br><span class="line">        blocks_inflight.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    estimated_file_size.<span class="built_in">store</span>(</span><br><span class="line">        curr_file_size +  <span class="comment">// 1. 已经写入 sst 的大小</span></span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(new_raw_bytes_inflight) * <span class="comment">// 2. 压缩完成的大小 = 当前正在压缩 * 压缩率</span></span><br><span class="line">                curr_compression_ratio.<span class="built_in">load</span>(std::memory_order_relaxed)) +</span><br><span class="line">            new_blocks_inflight * kBlockTrailerSize, <span class="comment">// 3. new_blocks_inflight * 脚注大小</span></span><br><span class="line">        std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="ReapBlock"><a href="#ReapBlock" class="headerlink" title="ReapBlock"></a>ReapBlock</h4><p><code>ReapBlock</code>，也是个回调函数 ，当一个block压缩完毕时调用，来更新当前压缩的状态：</p><ul><li><code>raw_bytes_compressed</code>：到目前为止，有多少字节的数据被压缩了；</li><li><code>curr_compression_ratio</code>：已压缩的字节数 &#x2F; 当前对应的原始字节数</li><li>重新估算最终写入sst文件的大小</li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(<span class="type">uint64_t</span> compressed_block_size, <span class="type">uint64_t</span> curr_file_size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(raw_bytes_curr_block_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前一共被压缩的字节数</span></span><br><span class="line">    <span class="type">uint64_t</span> new_raw_bytes_compressed =</span><br><span class="line">        raw_bytes_compressed + raw_bytes_curr_block;</span><br><span class="line">    <span class="built_in">assert</span>(new_raw_bytes_compressed &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新压缩率</span></span><br><span class="line">    <span class="comment">// 分子：压缩的字节，分母：原始字节</span></span><br><span class="line">    curr_compression_ratio.<span class="built_in">store</span>(</span><br><span class="line">        (curr_compression_ratio.<span class="built_in">load</span>(std::memory_order_relaxed) *</span><br><span class="line">             raw_bytes_compressed +</span><br><span class="line">         compressed_block_size) /</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(new_raw_bytes_compressed),</span><br><span class="line">        std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    raw_bytes_compressed = new_raw_bytes_compressed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复</span></span><br><span class="line">    <span class="type">uint64_t</span> new_raw_bytes_inflight =</span><br><span class="line">        raw_bytes_inflight.<span class="built_in">fetch_sub</span>(raw_bytes_curr_block,</span><br><span class="line">                                     std::memory_order_relaxed) -</span><br><span class="line">        raw_bytes_curr_block;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> new_blocks_inflight =</span><br><span class="line">        blocks_inflight.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算下文件大小</span></span><br><span class="line">    estimated_file_size.<span class="built_in">store</span>(</span><br><span class="line">        curr_file_size +</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(new_raw_bytes_inflight) * </span><br><span class="line">                curr_compression_ratio.<span class="built_in">load</span>(std::memory_order_relaxed)) +</span><br><span class="line">            new_blocks_inflight * kBlockTrailerSize,</span><br><span class="line">        std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    raw_bytes_curr_block_set = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ParallelCompressionRep"><a href="#ParallelCompressionRep" class="headerlink" title="ParallelCompressionRep"></a>ParallelCompressionRep</h3><p>为了更好地理解 <code>class ParallelCompressionRep</code>，下面在讲解源码时，会调整下不同字段的顺序。</p><p><code>ParallelCompressionRep</code>，使用顺序如下：</p><ul><li>在<code>ParallelCompressionRep</code>内部，会调用<code>ParallelCompressionRep::PrepareBlock</code>接口，准备此block的数据；</li><li>调用 <code>EmitBlock</code>函数发送给压缩线程；</li><li>当压缩完成，会调用<code>ParallelCompressionRep::ReapBlock</code>接口。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BlockBasedTableBuilder</span>::ParallelCompressionRep &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Keys</span>              &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">BlockRepSlot</span>      &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">BlockRep</span>         &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">FileSizeEstimator</span> &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typedef</span> std::vector&lt;BlockRep&gt;    BlockRepBuffer;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRep*&gt;     BlockRepPool;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRep*&gt;     CompressQueue;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRepSlot*&gt; WriteQueue;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 字段</span></span><br><span class="line">  std::unique_ptr&lt;Keys&gt;         curr_block_keys;      <span class="comment">// 当前block的key</span></span><br><span class="line">  BlockRepBuffer                block_rep_buf;        <span class="comment">// 记录各个block的数据状态</span></span><br><span class="line">  BlockRepPool                  block_rep_pool;       <span class="comment">// block_rep_pool 中记录的是 block_rep_buf</span></span><br><span class="line">  CompressQueue                 compress_queue;       <span class="comment">// 待压缩的任务队列</span></span><br><span class="line">  std::vector&lt;port::Thread&gt;     compress_thread_pool; <span class="comment">// 压缩线程</span></span><br><span class="line">  WriteQueue                    write_queue;          <span class="comment">// 写入文件的队列</span></span><br><span class="line">  std::unique_ptr&lt;port::Thread&gt; write_thread;    <span class="comment">// 写线程</span></span><br><span class="line">  FileSizeEstimator             file_size_estimator;  <span class="comment">// 评估文件大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待第一个 block 压缩完成</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt;             first_block_processed;</span><br><span class="line">  std::condition_variable       first_block_cond;</span><br><span class="line">  std::mutex                    first_block_mutex;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ParallelCompressionRep</span><span class="params">(<span class="type">uint32_t</span> parallel_threads)</span></span></span><br><span class="line"><span class="function">      : curr_block_keys(new Keys()),</span></span><br><span class="line"><span class="function">        block_rep_buf(parallel_threads),</span></span><br><span class="line"><span class="function">        block_rep_pool(parallel_threads),</span></span><br><span class="line"><span class="function">        compress_queue(parallel_threads),</span></span><br><span class="line"><span class="function">        write_queue(parallel_threads),</span></span><br><span class="line"><span class="function">        first_block_processed(false) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; parallel_threads; i++) &#123;</span><br><span class="line">      block_rep_buf[i].contents = <span class="built_in">Slice</span>();</span><br><span class="line">      block_rep_buf[i].compressed_contents = <span class="built_in">Slice</span>();</span><br><span class="line">      block_rep_buf[i].data.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].compressed_data.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].compression_type = <span class="built_in">CompressionType</span>();</span><br><span class="line">      block_rep_buf[i].first_key_in_next_block.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].keys.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Keys</span>());</span><br><span class="line">      block_rep_buf[i].slot.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">BlockRepSlot</span>());</span><br><span class="line">      block_rep_buf[i].status = Status::<span class="built_in">OK</span>();</span><br><span class="line">      <span class="comment">// 放到线程池</span></span><br><span class="line">      <span class="comment">// 因此，block_rep_pool 中每个元素的生命周期是由 block_rep_buf 中的每个元素负责</span></span><br><span class="line">      <span class="comment">// block_rep_buf 中存储着原始数据</span></span><br><span class="line">      block_rep_pool.<span class="built_in">push</span>(&amp;block_rep_buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/// 等待完成</span></span><br><span class="line">  ~<span class="built_in">ParallelCompressionRep</span>() &#123; block_rep_pool.<span class="built_in">finish</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 使用在 non-buffered 模式</span></span><br><span class="line">  <span class="comment">/// 准备好一个 block，并准备发送给 压缩线程</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                         BlockBuilder* data_block)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Used in EnterUnbuffered</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::string* data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::vector&lt;std::string&gt;* keys)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将 block 发送给 压缩线程</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 接受从压缩线程的结果</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(BlockRep* block_rep)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// 生成 block</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlockInternal</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> Slice* first_key_in_next_block)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="PrepareBlockInternal"><a href="#PrepareBlockInternal" class="headerlink" title="PrepareBlockInternal"></a>PrepareBlockInternal</h4><p>下面，先来讲讲怎么创建一个 <code>BlockRep</code>对象。</p><h5 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h5><p><code>block_rep_pool</code> 的意义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 block</span></span><br><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlockInternal</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Slice* first_key_in_next_block)</span> </span>&#123;</span><br><span class="line">  BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 从 block_rep_pool 头部出来</span></span><br><span class="line">  block_rep_pool.<span class="built_in">pop</span>(block_rep);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(block_rep-&gt;data);</span><br><span class="line"></span><br><span class="line">  block_rep-&gt;compression_type = compression_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_key_in_next_block == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 表示最后一个block</span></span><br><span class="line">    block_rep-&gt;first_key_in_next_block.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非最后一个block</span></span><br><span class="line">    block_rep-&gt;first_key_in_next_block-&gt;<span class="built_in">assign</span>(</span><br><span class="line">        first_key_in_next_block-&gt;<span class="built_in">data</span>(), first_key_in_next_block-&gt;<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PrepareBlock"><a href="#PrepareBlock" class="headerlink" title="PrepareBlock"></a>PrepareBlock</h4><p>在将待压缩的block发送给压缩线程之前，要先准备好这个block。</p><p><code>PrepareBlock</code> 函数，即用于完成这个过程。</p><ul><li><code>compression_type</code>：压缩类型</li><li><code>first_key_in_next_block</code>：下一个block的第一个<code>key</code></li><li><code>data_block</code>：待压缩的block的数据部分</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                       BlockBuilder* data_block)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 block_req</span></span><br><span class="line">  BlockRep* block_rep =</span><br><span class="line">      <span class="built_in">PrepareBlockInternal</span>(compression_type, first_key_in_next_block);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 将 data_block 中数据给 block_rep-&gt;data</span></span><br><span class="line">  data_block-&gt;<span class="built_in">SwapAndReset</span>(*(block_rep-&gt;data));</span><br><span class="line">  <span class="comment">// 数据复制给 block_rep-&gt;contents</span></span><br><span class="line">  block_rep-&gt;contents = *(block_rep-&gt;data);</span><br><span class="line">  <span class="comment">// 再将当前block的数据给 block_rep-&gt;keys</span></span><br><span class="line">  std::<span class="built_in">swap</span>(block_rep-&gt;keys, curr_block_keys);</span><br><span class="line">  curr_block_keys-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PrepareBlock-1"><a href="#PrepareBlock-1" class="headerlink" title="PrepareBlock"></a>PrepareBlock</h4><p><code>PrepareBlock</code> 只是上述函数的重载。上述函数传入的是一个<code>BlockBuilder*</code>，这里只是把原本一个<code>BlockBuilder</code> 记录的数据分别传入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::string* data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::vector&lt;std::string&gt;* keys)</span> </span>&#123;</span><br><span class="line">  BlockRep* block_rep =</span><br><span class="line">      <span class="built_in">PrepareBlockInternal</span>(compression_type, first_key_in_next_block);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  std::<span class="built_in">swap</span>(*(block_rep-&gt;data), *data_block);</span><br><span class="line">  block_rep-&gt;contents = *(block_rep-&gt;data);</span><br><span class="line">  block_rep-&gt;keys-&gt;<span class="built_in">SwapAssign</span>(*keys);</span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EmitBlock-1"><a href="#EmitBlock-1" class="headerlink" title="EmitBlock"></a>EmitBlock</h4><p>将上述准备好的block发送给压缩线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 block 发送给 压缩线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep-&gt;status.<span class="built_in">ok</span>());</span><br><span class="line">  <span class="comment">// 将准备好的block加入工作队列</span></span><br><span class="line">  <span class="keyword">if</span> (!write_queue.<span class="built_in">push</span>(block_rep-&gt;slot.<span class="built_in">get</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!compress_queue.<span class="built_in">push</span>(block_rep)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等待压缩完成 </span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到 first_block_processed 为 true</span></span><br><span class="line">    first_block_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">return</span> first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReapBlock-1"><a href="#ReapBlock-1" class="headerlink" title="ReapBlock"></a>ReapBlock</h4><h5 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h5><p><code>ReapBlock</code>，当压缩完成时的回调函数。??? 应该是写入文件???</p><p>用于清除压缩数据，通知emit线程，可以继续压缩</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reap a block from compression thread</span></span><br><span class="line"><span class="comment">// 接受从压缩线程的结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 清除压缩数据</span></span><br><span class="line">  block_rep-&gt;compressed_data-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="comment">// ??? </span></span><br><span class="line">  block_rep_pool.<span class="built_in">push</span>(block_rep);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知 emit Block，可以继续压缩</span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    first_block_processed.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">    first_block_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BlockBasedTableBuilder"><a href="#BlockBasedTableBuilder" class="headerlink" title="BlockBasedTableBuilder"></a>BlockBasedTableBuilder</h2><p>初始化操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">BlockBasedTableBuilder::<span class="built_in">BlockBasedTableBuilder</span>(</span><br><span class="line">    <span class="type">const</span> BlockBasedTableOptions&amp; table_options, <span class="type">const</span> TableBuilderOptions&amp; tbo,</span><br><span class="line">    WritableFileWriter* file) &#123;</span><br><span class="line">  <span class="function">BlockBasedTableOptions <span class="title">sanitized_table_options</span><span class="params">(table_options)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 压缩格式</span></span><br><span class="line">  <span class="keyword">if</span> (sanitized_table_options.format_version == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      sanitized_table_options.checksum != kCRC32c) &#123;</span><br><span class="line">    <span class="built_in">ROCKS_LOG_WARN</span>(</span><br><span class="line">        tbo.ioptions.logger,</span><br><span class="line">        <span class="string">&quot;Silently converting format_version to 1 because checksum is &quot;</span></span><br><span class="line">        <span class="string">&quot;non-default&quot;</span>);</span><br><span class="line">    <span class="comment">// silently convert format_version to 1 to keep consistent with current</span></span><br><span class="line">    <span class="comment">// behavior</span></span><br><span class="line">    sanitized_table_options.format_version = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 rep_</span></span><br><span class="line">  rep_ = <span class="keyword">new</span> <span class="built_in">Rep</span>(sanitized_table_options, tbo, file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// filter block 此时还没创建，初始化</span></span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    rep_-&gt;filter_builder-&gt;<span class="built_in">StartBlock</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成前缀</span></span><br><span class="line">  <span class="keyword">if</span> (table_options.block_cache_compressed.<span class="built_in">get</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    BlockBasedTable::<span class="built_in">GenerateCachePrefix</span>&lt;Cache, FSWritableFile&gt;(</span><br><span class="line">        table_options.block_cache_compressed.<span class="built_in">get</span>(), </span><br><span class="line">        file-&gt;<span class="built_in">writable_file</span>(),</span><br><span class="line">        &amp;rep_-&gt;compressed_cache_key_prefix[<span class="number">0</span>],    <span class="comment">// 输出参数</span></span><br><span class="line">        &amp;rep_-&gt;compressed_cache_key_prefix_size,  <span class="comment">// 输出参数</span></span><br><span class="line">        tbo.db_session_id,</span><br><span class="line">        tbo.cur_file_num);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开启多线程压缩</span></span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">StartParallelCompression</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ParallelCompression"><a href="#ParallelCompression" class="headerlink" title="ParallelCompression"></a>ParallelCompression</h3><p>下面从压缩开始。</p><p>每个data_block在写入sst之前，如果设置了压缩，则都会经过一个压缩的过程。</p><h4 id="IsParallelCompressionEnabled"><a href="#IsParallelCompressionEnabled" class="headerlink" title="IsParallelCompressionEnabled"></a>IsParallelCompressionEnabled</h4><p>是否开启多线程压缩，则由 <code>CompressionOptions::parallel_threads</code> 字段的值指示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> BlockBasedTableBuilder::Rep::<span class="built_in">IsParallelCompressionEnabled</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> compression_opts.parallel_threads &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StartParallelCompression"><a href="#StartParallelCompression" class="headerlink" title="StartParallelCompression"></a>StartParallelCompression</h4><p>如果开启了多线程压缩，压缩流程如下：</p><ul><li>在每次压缩前，主线程，使用<code>ParallelCompressionRep::PrepareBlock</code>函数，准备好待压缩的block；</li><li>主线程调用<code>ParallelCompressionRep::EmitBlock</code>函数，将block送入压缩线程；</li><li>压缩线程再进行压缩</li><li>将压缩完毕的data_block，写入到sst文件中</li></ul><p>下面是开启多个压缩线程的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::StartParallelCompression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化 ParallelCompressionRep 对象</span></span><br><span class="line">  rep_-&gt;pc_rep.<span class="built_in">reset</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">ParallelCompressionRep</span>(rep_-&gt;compression_opts.parallel_threads));</span><br><span class="line">  rep_-&gt;pc_rep-&gt;compress_thread_pool.<span class="built_in">reserve</span>(</span><br><span class="line">      rep_-&gt;compression_opts.parallel_threads);</span><br><span class="line">  <span class="comment">// 开启 parallel_threads 个压缩线程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; rep_-&gt;compression_opts.parallel_threads; i++) &#123;</span><br><span class="line">    rep_-&gt;pc_rep-&gt;compress_thread_pool.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i] &#123;</span><br><span class="line">      <span class="built_in">BGWorkCompression</span>(*(rep_-&gt;compression_ctxs[i]),  <span class="comment">// 压缩上下文</span></span><br><span class="line">                          rep_-&gt;verify_ctxs[i].<span class="built_in">get</span>()); <span class="comment">// 解压上下文</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开启 1 个写线程</span></span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_thread.<span class="built_in">reset</span>(</span><br><span class="line">      <span class="keyword">new</span> port::<span class="built_in">Thread</span>([<span class="keyword">this</span>] &#123; <span class="built_in">BGWorkWriteRawBlock</span>(); &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BGWorkCompression"><a href="#BGWorkCompression" class="headerlink" title="BGWorkCompression"></a>BGWorkCompression</h5><p>压缩线程的入口函数，<code>BGWorkCompression</code> ，仅用于压缩<code>data_block</code>，他一直在等待主线程发送待压缩的block，然后取出来，进行压缩。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::BGWorkCompression</span><span class="params">(<span class="type">const</span> CompressionContext&amp; compression_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               UncompressionContext* verify_ctx)</span> </span>&#123;</span><br><span class="line">  ParallelCompressionRep::BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (rep_-&gt;pc_rep-&gt;compress_queue.<span class="built_in">pop</span>(block_rep)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">CompressAndVerifyBlock</span>(block_rep-&gt;contents, </span><br><span class="line">                           <span class="literal">true</span>, <span class="comment">/* is_data_block*/</span></span><br><span class="line">                           compression_ctx, </span><br><span class="line">                           verify_ctx,</span><br><span class="line">                           block_rep-&gt;compressed_data.<span class="built_in">get</span>(), <span class="comment">// 输出参数，unused ?</span></span><br><span class="line">                           &amp;block_rep-&gt;compressed_contents,  <span class="comment">// 保存压缩结果</span></span><br><span class="line">                           &amp;(block_rep-&gt;compression_type),   <span class="comment">// 压缩结果的字节数</span></span><br><span class="line">                           &amp;block_rep-&gt;status);              <span class="comment">// 压缩是否成功</span></span><br><span class="line">    <span class="comment">// 将压缩完毕的 block 加入到 block_rep-&gt;slot 中</span></span><br><span class="line">    <span class="comment">// 为后面写入sst准备</span></span><br><span class="line">    block_rep-&gt;slot-&gt;<span class="built_in">Fill</span>(block_rep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CompressAndVerifyBlock"><a href="#CompressAndVerifyBlock" class="headerlink" title="CompressAndVerifyBlock"></a>CompressAndVerifyBlock</h5><p>CompressAndVerifyBlock&#96; 函数，不仅尝试去压缩，而且会统计压缩过程中的一些信息。为便于下面的代码简洁，易于理解，把这部分去掉了，专注于功能。</p><p>sst是由一系列的<code>block</code>组成，每个<code>block</code>的格式都是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block_data: uint8[n] <span class="comment"># block 存储的数据</span></span><br><span class="line"><span class="built_in">type</span>: uint8          <span class="comment"># 压缩类型</span></span><br><span class="line">crc: uint32          <span class="comment"># 校验和</span></span><br></pre></td></tr></table></figure><p>顺序的压缩过程如下：</p><ol><li>当前待压缩的数据是<code>raw_block_contents</code>，其大小不能超过 <code>kCompressionSizeLimit</code> 限制；</li><li>先尝试调用 <code>CompressBlock</code> 函数压缩，结果保存至<code>block_contents</code>；</li><li>如果设置了校验压缩结果，即设置了 <code>table_options.verify_compression</code> 标志位，则会对<code>block_contents</code>进行解压，保存至<code>contents</code>，顺利的压缩，需要保证 <code>block_contents</code> 和 <code>contents</code> 相同；</li></ol><p>如果一切顺利，则：</p><ul><li><code>block_contents</code> 中保存了<code>raw_block_contents</code>的压缩结果，</li><li><code>type</code> 保存了压缩类型；</li></ul><p>代码简洁后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::CompressAndVerifyBlock</span><span class="params">(<span class="type">const</span> Slice&amp; raw_block_contents, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">bool</span> is_data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">const</span> CompressionContext&amp; compression_ctx, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    UncompressionContext* verify_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    std::string* compressed_output,  <span class="comment">// unused</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Slice* block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    CompressionType* type, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Status* out_status)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="type">bool</span> is_status_ok = <span class="built_in">ok</span>();</span><br><span class="line">  <span class="keyword">if</span> (!r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(is_status_ok);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *type = r-&gt;compression_type;</span><br><span class="line">  <span class="comment">// 采样多少个字节用于压缩</span></span><br><span class="line">  <span class="type">uint64_t</span> sample_for_compression = r-&gt;sample_for_compression;</span><br><span class="line">  <span class="comment">// 中止压缩</span></span><br><span class="line">  <span class="type">bool</span> abort_compression = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">StopWatchNano <span class="title">timer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      r-&gt;ioptions.clock,</span></span></span><br><span class="line"><span class="params"><span class="function">      ShouldReportDetailedTime(r-&gt;ioptions.env, r-&gt;ioptions.stats))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次压缩字节大小有限制</span></span><br><span class="line">  <span class="keyword">if</span> (is_status_ok &amp;&amp; raw_block_contents.<span class="built_in">size</span>() &lt; kCompressionSizeLimit) &#123;</span><br><span class="line">    <span class="comment">// 1. 获取 compression_dict</span></span><br><span class="line">    <span class="type">const</span> CompressionDict* compression_dict;</span><br><span class="line">    <span class="keyword">if</span> (!is_data_block || r-&gt;compression_dict == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      compression_dict = &amp;CompressionDict::<span class="built_in">GetEmptyDict</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      compression_dict = r-&gt;compression_dict.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(compression_dict != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="function">CompressionInfo <span class="title">compression_info</span><span class="params">(r-&gt;compression_opts, </span></span></span><br><span class="line"><span class="params"><span class="function">                                     compression_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     *compression_dict, </span></span></span><br><span class="line"><span class="params"><span class="function">                                     *type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sample_for_compression)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::string sampled_output_fast;</span><br><span class="line">    std::string sampled_output_slow;</span><br><span class="line">    <span class="comment">/// 尝试将 @c raw_block_contents 进行压缩，并返回至 @c compressed_output</span></span><br><span class="line">    *block_contents = <span class="built_in">CompressBlock</span>(raw_block_contents, </span><br><span class="line">                                    compression_info, </span><br><span class="line">                                    type,</span><br><span class="line">                                    r-&gt;table_options.format_version, </span><br><span class="line">                                    is_data_block <span class="comment">/* do_sample */</span>,</span><br><span class="line">                                    compressed_output, </span><br><span class="line">                                    &amp;sampled_output_fast, </span><br><span class="line">                                    &amp;sampled_output_slow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于一些压缩算法不太可靠，因此如果设置了 verify_compression</span></span><br><span class="line">    <span class="comment">// 则需要校验</span></span><br><span class="line">    <span class="keyword">if</span> (*type != kNoCompression &amp;&amp; r-&gt;table_options.verify_compression) &#123;</span><br><span class="line">      <span class="comment">// Retrieve the uncompressed contents into a new buffer</span></span><br><span class="line">      <span class="type">const</span> UncompressionDict* verify_dict;</span><br><span class="line">      <span class="keyword">if</span> (!is_data_block || r-&gt;verify_dict == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        verify_dict = &amp;UncompressionDict::<span class="built_in">GetEmptyDict</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        verify_dict = r-&gt;verify_dict.<span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">assert</span>(verify_dict != <span class="literal">nullptr</span>);</span><br><span class="line">      BlockContents contents;</span><br><span class="line">      <span class="function">UncompressionInfo <span class="title">uncompression_info</span><span class="params">(*verify_ctx, </span></span></span><br><span class="line"><span class="params"><span class="function">                                           *verify_dict,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           r-&gt;compression_type)</span></span>;</span><br><span class="line">      Status stat = <span class="built_in">UncompressBlockContentsForCompressionType</span>(</span><br><span class="line">          uncompression_info, block_contents-&gt;<span class="built_in">data</span>(), block_contents-&gt;<span class="built_in">size</span>(),</span><br><span class="line">          &amp;contents, r-&gt;table_options.format_version, r-&gt;ioptions);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stat.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// 将解压的内容与压缩之前的源内容比较</span></span><br><span class="line">        <span class="type">bool</span> compressed_ok = contents.data.<span class="built_in">compare</span>(raw_block_contents) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!compressed_ok) &#123;</span><br><span class="line">          <span class="comment">// 解压内容与原来的待压缩的内容，不匹配，终止压缩</span></span><br><span class="line">          abort_compression = <span class="literal">true</span>;</span><br><span class="line">          <span class="built_in">ROCKS_LOG_ERROR</span>(r-&gt;ioptions.logger,</span><br><span class="line">                          <span class="string">&quot;Decompressed block did not match raw block&quot;</span>);</span><br><span class="line">          *out_status =</span><br><span class="line">              Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Decompressed block did not match raw block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解压失败，终止压缩</span></span><br><span class="line">        *out_status = Status::<span class="built_in">Corruption</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Could not decompress: &quot;</span>) +</span><br><span class="line">                                         stat.<span class="built_in">getState</span>());</span><br><span class="line">        abort_compression = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// block 内容太多，无法一次性压缩，也要终止压缩</span></span><br><span class="line">    <span class="keyword">if</span> (is_data_block) &#123;</span><br><span class="line">      r-&gt;uncompressible_input_data_bytes.<span class="built_in">fetch_add</span>(raw_block_contents.<span class="built_in">size</span>(),</span><br><span class="line">                                                   std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    abort_compression = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 校验压缩结果</span></span><br><span class="line">  <span class="keyword">if</span> (abort_compression) &#123;</span><br><span class="line">    *type = kNoCompression;</span><br><span class="line">    *block_contents = raw_block_contents;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BGWorkWriteRawBlock"><a href="#BGWorkWriteRawBlock" class="headerlink" title="BGWorkWriteRawBlock"></a>BGWorkWriteRawBlock</h5><p>在<code>BGWorkCompression</code> 函数，我们可以看到，压缩线程主要有两个动作：</p><ul><li>先压缩 <code>data block</code>，并将相关信息记录在<code>block_rep</code>中</li><li>再将 <code>block_rep</code> 保存在 <code>block_rep-&gt;slot</code> 中</li></ul><p>此时呢，可以回顾下 <code>ParallelCompressionRep::EmitBlock</code> 函数，<code>block_rep-&gt;slot</code> 一开始就就加入到 <code>write_queue</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!write_queue.<span class="built_in">push</span>(block_rep-&gt;slot.<span class="built_in">get</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!compress_queue.<span class="built_in">push</span>(block_rep)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待压缩完成 </span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到 ReapBlock 函数调用</span></span><br><span class="line">    first_block_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">return</span> first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这说明什么？</p><p>如果前面的压缩部分没有完成，则当执行到<code>BGWorkWriteRawBlock</code> 函数时，会一直阻塞在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot-&gt;<span class="built_in">Take</span>(block_rep);</span><br></pre></td></tr></table></figure><p>无论前面的 <code>CompressAndVerifyBlock</code>函数是否压缩成功，都需要调用<code>ReapBlock</code> 函数，以防止<code>EmitBlock</code>处产生死锁。</p><p>Of Course，若前面压缩成功，则还大致需要执行以下流程：</p><ul><li>先将当前<code>block</code>中的每个key添加到 <code>filter_builder</code>、<code>index_builder</code>；</li><li>再生成 <code>filter_block</code>、<code>idnex_block</code>；</li><li>将block压缩后的数据写入sst</li></ul><p>下面来看看细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::BGWorkWriteRawBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  ParallelCompressionRep::BlockRepSlot* slot = <span class="literal">nullptr</span>;</span><br><span class="line">  ParallelCompressionRep::BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (r-&gt;pc_rep-&gt;write_queue.<span class="built_in">pop</span>(slot)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(slot != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 阻塞于此，直到压缩完成，Take 函数才能返回</span></span><br><span class="line">    slot-&gt;<span class="built_in">Take</span>(block_rep);</span><br><span class="line">    <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!block_rep-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      r-&gt;<span class="built_in">SetStatus</span>(block_rep-&gt;status);</span><br><span class="line">      <span class="comment">// Flush() 中存在 Emit(), 需要 ReapBlock</span></span><br><span class="line">      block_rep-&gt;status = Status::<span class="built_in">OK</span>();</span><br><span class="line">      r-&gt;pc_rep-&gt;<span class="built_in">ReapBlock</span>(block_rep);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; block_rep-&gt;keys-&gt;<span class="built_in">Size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; key = (*block_rep-&gt;keys)[i];</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">size_t</span> ts_sz =</span><br><span class="line">            r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">         <span class="comment">// 为后面创建 filter block 准备</span></span><br><span class="line">        r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为后面创建 index block 准备</span></span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为后续重新估算 sst 文件大小准备</span></span><br><span class="line">    r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">SetCurrBlockRawSize</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将压缩后的数据写入sst</span></span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(block_rep-&gt;compressed_contents, <span class="comment">// 压缩的数据</span></span><br><span class="line">                 block_rep-&gt;compression_type,     <span class="comment">// 压缩类型</span></span><br><span class="line">                 &amp;r-&gt;pending_handle, </span><br><span class="line">                 <span class="literal">true</span> <span class="comment">/* is_data_block*/</span>,</span><br><span class="line">                 &amp;block_rep-&gt;contents);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于前面添加的key，生成 filter block</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      r-&gt;filter_builder-&gt;<span class="built_in">StartBlock</span>(r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;props.data_size = r-&gt;<span class="built_in">get_offset</span>();</span><br><span class="line">    ++r-&gt;props.num_data_blocks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于前面添加的key， 生成 index block</span></span><br><span class="line">    <span class="keyword">if</span> (block_rep-&gt;first_key_in_next_block == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 最后一个data block</span></span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;(block_rep-&gt;keys-&gt;<span class="built_in">Back</span>()), <span class="literal">nullptr</span>,</span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非最后一个data block</span></span><br><span class="line">      Slice first_key_in_next_block =</span><br><span class="line">          <span class="built_in">Slice</span>(*block_rep-&gt;first_key_in_next_block);</span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;(block_rep-&gt;keys-&gt;<span class="built_in">Back</span>()),</span><br><span class="line">                                      &amp;first_key_in_next_block,</span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 ParallelCompressionRep::EmitBlock</span></span><br><span class="line">    r-&gt;pc_rep-&gt;<span class="built_in">ReapBlock</span>(block_rep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WriteRawBlock"><a href="#WriteRawBlock" class="headerlink" title="WriteRawBlock"></a>WriteRawBlock</h5><p>最后一步，就是要将压缩完的数据按照如下格式写入到sst文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block_data: uint8[n] <span class="comment"># block 存储的数据</span></span><br><span class="line"><span class="built_in">type</span>: uint8          <span class="comment"># 压缩类型</span></span><br><span class="line">crc: uint32          <span class="comment"># 校验和</span></span><br><span class="line">padding              <span class="comment"># 填充</span></span><br></pre></td></tr></table></figure><p>注意，<code>WriteRawBlock</code> 函数的传入的参数<code>handle</code> ，在函数返回时记录了关于block的两个元信息：</p><ul><li>此block在sst文件中存储的起始位置</li><li>此block压缩后的大小。</li></ul><p>这个参数，实际上由<code>Add（key, value）</code>函数中的<code>r-&gt;pending_handle</code>传入，后续写入<code>index builder</code>，建立<code>index block</code>，这个在后面会讲解。</p><p>下面，简洁了部分代码后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteRawBlock</span><span class="params">(<span class="type">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           CompressionType type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           BlockHandle* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">bool</span> is_data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">const</span> Slice* raw_block_contents)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Status s = Status::<span class="built_in">OK</span>();</span><br><span class="line">  IOStatus io_s = IOStatus::<span class="built_in">OK</span>();</span><br><span class="line">  <span class="function">StopWatch <span class="title">sw</span><span class="params">(r-&gt;ioptions.clock, r-&gt;ioptions.stats, WRITE_RAW_BLOCK_MICROS)</span></span>;</span><br><span class="line">  <span class="comment">// 1. 初始化 handle</span></span><br><span class="line">  handle-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>());     <span class="comment">// block 在sst文件中的offset</span></span><br><span class="line">  handle-&gt;<span class="built_in">set_size</span>(block_contents.<span class="built_in">size</span>()); <span class="comment">// 这个block 压缩后的大小</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">io_status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="comment">// 2. 向sst文件中追加内容 block_contents</span></span><br><span class="line">  io_s = r-&gt;file-&gt;<span class="built_in">Append</span>(block_contents); </span><br><span class="line">  <span class="comment">// 3. 下面写入footer</span></span><br><span class="line">  <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="type">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;     <span class="comment">// 压缩类型</span></span><br><span class="line">    <span class="type">uint32_t</span> checksum = <span class="number">0</span>; <span class="comment">// 校验和</span></span><br><span class="line">    <span class="keyword">switch</span> (r-&gt;table_options.checksum) &#123;</span><br><span class="line">      <span class="comment">// 计算校验和</span></span><br><span class="line">      <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储校验和</span></span><br><span class="line">    <span class="built_in">EncodeFixed32</span>(trailer + <span class="number">1</span>, checksum);</span><br><span class="line">    <span class="built_in">assert</span>(io_s.<span class="built_in">ok</span>());</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(</span><br><span class="line">        <span class="string">&quot;BlockBasedTableBuilder::WriteRawBlock:TamperWithChecksum&quot;</span>,</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(trailer));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入 footer</span></span><br><span class="line">    io_s = r-&gt;file-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="comment">// 设置文件偏移量 : 当前偏移量 + block 数据大小 + footer </span></span><br><span class="line">      r-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>() + block_contents.<span class="built_in">size</span>() +</span><br><span class="line">                    kBlockTrailerSize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 填充</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;table_options.block_align &amp;&amp; is_data_block) &#123;</span><br><span class="line">        <span class="type">size_t</span> pad_bytes =</span><br><span class="line">            (r-&gt;alignment - ((block_contents.<span class="built_in">size</span>() + kBlockTrailerSize) &amp; (r-&gt;alignment - <span class="number">1</span>))) &amp;</span><br><span class="line">            (r-&gt;alignment - <span class="number">1</span>);</span><br><span class="line">        io_s = r-&gt;file-&gt;<span class="built_in">Pad</span>(pad_bytes);</span><br><span class="line">        <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="comment">// 填充后，重新更新文件偏移量</span></span><br><span class="line">          r-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>() + pad_bytes);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;<span class="built_in">SetIOStatus</span>(io_s);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5. 这个时候再重新计算文件大小</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_data_block) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">ReapBlock</span>(block_contents.<span class="built_in">size</span>(),</span><br><span class="line">                                                   r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">SetEstimatedFileSize</span>(r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r-&gt;<span class="built_in">SetIOStatus</span>(io_s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>() &amp;&amp; s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    r-&gt;<span class="built_in">SetStatus</span>(io_s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StopParallelCompression"><a href="#StopParallelCompression" class="headerlink" title="StopParallelCompression"></a>StopParallelCompression</h4><p>和启动多线程部分相应，停止压缩线程、写线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::StopParallelCompression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  rep_-&gt;pc_rep-&gt;compress_queue.<span class="built_in">finish</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : rep_-&gt;pc_rep-&gt;compress_thread_pool) &#123;</span><br><span class="line">    thread.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_queue.<span class="built_in">finish</span>();</span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_thread-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>好嘞，终于到了这里。</p><p>经过前面压缩部分的铺垫，相信这里会让你更加易懂。</p><p>每个key的编码信息中，都包含着一个<code>value_type</code>信息，关于<code>value_type</code>，详细地后续再说，这里一点，<code>IsValueType</code> 返回值为true，表示这对<code>&#123;k, v&#125;</code>可以写入到sst文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsValueType</span><span class="params">(ValueType t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt;= kTypeMerge || t == kTypeSingleDeletion || t == kTypeBlobIndex</span><br><span class="line">         || kTypeDeletionWithTimestamp == t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsExtendedValueType</span><span class="params">(ValueType t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">IsValueType</span>(t) || t == kTypeRangeDeletion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlockBasedTableBuilder</code> 在添加<code>&#123;k, v&#125;</code>并写入到sst文件的过程，会经历三个阶段<code>State</code>。</p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  kBuffered,</span><br><span class="line">  kUnbuffered,</span><br><span class="line">  kClosed,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>kBuffered</code>模式下，将待压缩、待写入sst文件的<code>data_block</code> 暂时缓存在<code>r-&gt;data_block_buffer</code>中。当缓存中的数据长度<code>r-&gt;data_begin_offset</code>超过限制<code>buffer_limit</code> 时，就会进入到<code>kUnbuffered</code>模式。</p><p>一旦进入到<code>kUnbuffered</code>，就不可逆转到<code>kBuffered</code>。最终只能在调用 <code>BlockBasedTableBuilder::Finish</code> 时进入<code>kClosed</code>模式。</p><h4 id="should-flush"><a href="#should-flush" class="headerlink" title="should_flush"></a>should_flush</h4><p>每个<code>BlockBasedTableBuilder</code>  中都有个刷新策略<code>r-&gt;flush_block_policy</code>：将当前<code>&#123;k, v&#125;</code>添加到 <code>r-&gt;data_block</code>，若会触发更新，则会先将当前 <code>r-&gt;data_block</code> 的数据进行<code>flush</code>：</p><ul><li>若 <code>r-&gt;data_begin_offset &lt; r-&gt;buffer_limit</code>：暂时缓存到  <code>r-&gt;data_block_buffer</code>中；</li><li>否则，会先压缩，再写入sst文件。</li></ul><p>此外，由于多线程的压缩、写入sst的过程在相应的子线程中完成，当没有开启多线程时，一些细节需要在主线程中单独进行处理，因此在下面的代码中会经常看到下面的代码结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (r-&gt;IsParallelCompressionEnabled()) &#123; </span><br><span class="line">&#125; else &#123; </span><br><span class="line">  // 对单线程进行处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要理解了之前讲解的多线程逻辑，下面的<code>Add</code>函数会很好理解。</p><p>代码简略后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 向 cur_block 中添加 &#123;key, value&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  ValueType value_type = <span class="built_in">ExtractValueType</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsValueType</span>(value_type)) &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要 flush</span></span><br><span class="line">    <span class="keyword">auto</span> should_flush = r-&gt;flush_block_policy-&gt;<span class="built_in">Update</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (should_flush) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(!r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">      r-&gt;first_key_in_next_block = &amp;key;</span><br><span class="line">      <span class="built_in">Flush</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从 kBuffer 模式进入 kUnbuffered 模式</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered </span><br><span class="line">          &amp;&amp; r-&gt;buffer_limit != <span class="number">0</span> </span><br><span class="line">          &amp;&amp;r-&gt;data_begin_offset &gt; r-&gt;buffer_limit) &#123;</span><br><span class="line">        <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 单线程：在 index builder 中添加一个 &#123;k, pending_handle&#125; </span></span><br><span class="line">          <span class="comment">// 其中 pending_handle 记录了写入sst的位置及大小</span></span><br><span class="line">          r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;r-&gt;last_key, </span><br><span class="line">                                          &amp;key,</span><br><span class="line">                                          r-&gt;pending_handle);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> PartitionedFilterBlockBuilder 需要在 key先添加到 index builder 之后，</span></span><br><span class="line">    <span class="comment">//       再添加到 PartitionedFilterBlockBuilder 中</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">PushBack</span>(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 单线程：在 filter builder 中添加一个记录</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="type">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">          r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前data_block的last_key</span></span><br><span class="line">    r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 添加 &#123;k, v&#125; 到当前 data_block</span></span><br><span class="line">    r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">      <span class="comment">// Buffered keys will be replayed from data_block_buffers during</span></span><br><span class="line">      <span class="comment">// `Finish()` once compression dictionary has been finalized.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        <span class="comment">// 单线程</span></span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NotifyCollectTableCollectorsOnAdd</span>(key, value, r-&gt;<span class="built_in">get_offset</span>(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_type == kTypeRangeDeletion) &#123;</span><br><span class="line">    r-&gt;range_del_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="built_in">NotifyCollectTableCollectorsOnAdd</span>(key, value, r-&gt;<span class="built_in">get_offset</span>(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 统计</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h4><p>在<code>Flush</code> 函数中，针对多线程和单线程两种模式：</p><ul><li>如果开启了多线程 &amp;&amp; 已经处于 <code>kUnbuffered</code> 模式，则调用多线程压缩、写入sst文件。</li><li>否则，直接调用单线程的压缩写入。</li></ul><p>下面来看看源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">    <span class="comment">// 序列化 r-&gt;data_block 中的数据</span></span><br><span class="line">    r-&gt;data_block.<span class="built_in">Finish</span>();</span><br><span class="line">    <span class="comment">// 利用 r-&gt;data_block 中的数据生成 block_rep</span></span><br><span class="line">    ParallelCompressionRep::BlockRep* block_rep = r-&gt;pc_rep-&gt;<span class="built_in">PrepareBlock</span>(</span><br><span class="line">        r-&gt;compression_type, r-&gt;first_key_in_next_block, &amp;(r-&gt;data_block));</span><br><span class="line">    <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 此时，r-&gt;data_block 中是空的了</span></span><br><span class="line">    <span class="built_in">assert</span>(r-&gt;data_block.<span class="built_in">emoty</span>());</span><br><span class="line">    <span class="comment">// 在压缩前，估计下 sst 文件大小</span></span><br><span class="line">    r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">EmitBlock</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                             r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">    <span class="comment">// 将 data_block 送入压缩线程，后台线程会压缩、写入sst文件</span></span><br><span class="line">    r-&gt;pc_rep-&gt;<span class="built_in">EmitBlock</span>(block_rep);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 单线程压缩</span></span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle, <span class="literal">true</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WriteBlock"><a href="#WriteBlock" class="headerlink" title="WriteBlock"></a>WriteBlock</h5><p>调用 <code>WriteBlock</code> 函数，不仅会来自于上面的 <code>Flush</code> 函数，还有会后面的<code>WriteIndexBlock</code>、<code>EnterUnbuffered</code>函数等。因此，<code>WriteBlock</code> 函数做了统一接口，来应对 <code>State::kBuffered</code> 和 <code>State::kUnBuffered</code>两种状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteBlock</span><span class="params">(BlockBuilder* block,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        BlockHandle* handle,  <span class="comment">// 正在pending的</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">bool</span> is_data_block)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 序列化 block 中的数据</span></span><br><span class="line">  block-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">  std::string raw_block_contents;</span><br><span class="line">  <span class="comment">// 将block序列化后的内容swap到 raw_block_contents 中</span></span><br><span class="line">  block-&gt;<span class="built_in">SwapAndReset</span>(raw_block_contents);</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">    <span class="comment">// 只有 data_block 存在 kbuffered 模式</span></span><br><span class="line">    <span class="built_in">assert</span>(is_data_block);</span><br><span class="line">    <span class="comment">// 将数据先写入 data_block_buffers</span></span><br><span class="line">    rep_-&gt;data_block_buffers.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(raw_block_contents));</span><br><span class="line">    rep_-&gt;data_begin_offset += rep_-&gt;data_block_buffers.<span class="built_in">back</span>().<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="comment">// else 就是 KUnBuffer 模式 </span></span><br><span class="line">  <span class="built_in">WriteBlock</span>(raw_block_contents, handle, is_data_block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="WriteBlock-1"><a href="#WriteBlock-1" class="headerlink" title="WriteBlock"></a>WriteBlock</h5><p>重载形式的<code>WriteBlock</code> ，只用于单线程压缩（没有写入sst文件的操作），且<code>BlockBasedTableBuilder</code>当前处于<code>kUnbuffered</code>模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 用于 kUnbuffered 模式：单线程压缩</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteBlock</span><span class="params">(<span class="type">const</span> Slice&amp; raw_block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        BlockHandle* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">bool</span> is_data_block)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state == Rep::State::kUnbuffered);</span><br><span class="line">  Slice block_contents;</span><br><span class="line">  CompressionType type;</span><br><span class="line">  Status compress_status;</span><br><span class="line">  <span class="comment">// 进行压缩</span></span><br><span class="line">  <span class="built_in">CompressAndVerifyBlock</span>(raw_block_contents, </span><br><span class="line">                         is_data_block,</span><br><span class="line">                         *(r-&gt;compression_ctxs[<span class="number">0</span>]), </span><br><span class="line">                         r-&gt;verify_ctxs[<span class="number">0</span>].<span class="built_in">get</span>(),</span><br><span class="line">                         &amp;(r-&gt;compressed_output), </span><br><span class="line">                         &amp;(block_contents), </span><br><span class="line">                         &amp;type,</span><br><span class="line">                         &amp;compress_status);</span><br><span class="line">  r-&gt;<span class="built_in">SetStatus</span>(compress_status);</span><br><span class="line">  <span class="comment">// 如果压缩不成功</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="EnterUnbuffered"><a href="#EnterUnbuffered" class="headerlink" title="EnterUnbuffered"></a>EnterUnbuffered</h4><p><code>EnterUnbuffered</code>函数，将<code>BlockBasedTableBuilder</code>的状态，从<code>kBuffered</code>推向<code>kUnBuffered</code>，仅会执行一次。</p><p>那么这个函数的使命？</p><p>我们知道在 <code>kBuffered</code> 模式下，每次调用<code>Flush</code>函数时，都是将<code>r-&gt;data_block</code>的数据缓存到<code>r-&gt;data_block_buffers</code>。</p><p>当从<code>kBuffered</code>专向<code>kUnBuffered</code>时，很自然，就需要让<code>r-&gt;data_block_buffers</code> 中的数据也经历两个过程：</p><ul><li>压缩</li><li>写入sst</li></ul><p>带着这个思路，下面的代码就很好理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::EnterUnbuffered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state == Rep::State::kBuffered);</span><br><span class="line">  r-&gt;state = Rep::State::kUnbuffered;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 获得 r-&gt;data_block_buffers[i] 的读迭代器</span></span><br><span class="line">  <span class="keyword">auto</span> get_iterator_for_block = [&amp;r](<span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; data_block = r-&gt;data_block_buffers[i];</span><br><span class="line">    <span class="built_in">assert</span>(!data_block.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">    Block reader&#123;BlockContents&#123;data_block&#125;&#125;;</span><br><span class="line">    DataBlockIter* iter = reader.<span class="built_in">NewDataIterator</span>(r-&gt;internal_comparator.<span class="built_in">user_comparator</span>(), </span><br><span class="line">                                                 kDisableGlobalSequenceNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到这个 data_block 的起始处</span></span><br><span class="line">    iter-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">    <span class="built_in">assert</span>(iter-&gt;<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;DataBlockIter&gt;(iter);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;DataBlockIter&gt; iter = <span class="literal">nullptr</span>, next_block_iter = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; <span class="built_in">ok</span>() &amp;&amp; i &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 初始化迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter = <span class="built_in">get_iterator_for_block</span>(i);</span><br><span class="line">      <span class="built_in">assert</span>(iter != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个 data_block 的迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      next_block_iter = <span class="built_in">get_iterator_for_block</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 data_block</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; data_block = r-&gt;data_block_buffers[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 下面对data_block进行压缩、写入***/</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">      <span class="comment">/*** 开启了多线程压缩 ***/</span></span><br><span class="line">      </span><br><span class="line">      Slice first_key_in_next_block;</span><br><span class="line">      <span class="type">const</span> Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">// 下一个 data_block 的第一个key</span></span><br><span class="line">        first_key_in_next_block = next_block_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// r-&gt;first_key_in_next_block </span></span><br><span class="line">        <span class="comment">// 即处于 kUnBuffered 状态的 data_block 第一个key</span></span><br><span class="line">        first_key_in_next_block_ptr = r-&gt;first_key_in_next_block;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 迭代当前 data_block, 将所有的key，全部添加到 keys</span></span><br><span class="line">      std::vector&lt;std::string&gt; keys;</span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">        keys.<span class="built_in">emplace_back</span>(iter-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 生成 block_req </span></span><br><span class="line">      ParallelCompressionRep::BlockRep* block_rep = r-&gt;pc_rep-&gt;<span class="built_in">PrepareBlock</span>(</span><br><span class="line">          r-&gt;compression_type, first_key_in_next_block_ptr, &amp;data_block, &amp;keys);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="comment">// 在发送前，估计下sst文件大小</span></span><br><span class="line">      r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">EmitBlock</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">      <span class="comment">// 发送至压缩线程</span></span><br><span class="line">      r-&gt;pc_rep-&gt;<span class="built_in">EmitBlock</span>(block_rep);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*** 没有开启多线程压缩 ***/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// fileter block，index block</span></span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">        Slice key = iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="type">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">          r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(<span class="built_in">Slice</span>(data_block),</span><br><span class="line">                 &amp;r-&gt;pending_handle,  <span class="comment">// 记录了 data_block 在文件中的位置及其大小</span></span><br><span class="line">                 <span class="literal">true</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//! 此for循环，不包含最后一个data block</span></span><br><span class="line">      <span class="comment">//! 因此，在 ::Finish 函数中，需要为最后一个 data block 单独调用一次 AddIndexEntry</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        Slice first_key_in_next_block = next_block_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line"></span><br><span class="line">        Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line"></span><br><span class="line">        iter-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">        std::string last_key = iter-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>();</span><br><span class="line">        <span class="comment">// 添加一个 &#123;key, handle&#125;</span></span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;last_key, first_key_in_next_block_ptr,</span><br><span class="line">                                        r-&gt;pending_handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** 遍历完当前 data_block ***/</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">swap</span>(iter, next_block_iter);</span><br><span class="line">  &#125; <span class="comment">// 遍历完所有的 data_block</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 清除数据</span></span><br><span class="line">  r-&gt;data_block_buffers.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p>在前文说过，一个table序列化到sst文件的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beginning_of_file&gt;</span><br><span class="line">[data block 1]</span><br><span class="line">[data block 2]</span><br><span class="line">...</span><br><span class="line">[data block N]</span><br><span class="line">[meta block 1: filter block]                 </span><br><span class="line">[meta block 2: index block]</span><br><span class="line">[meta block 3: compression dictionary block]</span><br><span class="line">[meta block 4: range deletion block]        </span><br><span class="line">[meta block 5: stats block]</span><br><span class="line">...</span><br><span class="line">[meta block K: future extended block]</span><br><span class="line">[metaindex block]</span><br><span class="line">[Footer]</span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure><p>当调用<code>::Finish</code>函数时，<code>data block</code>部分已经构建完毕，下面就需要开始构建<code>meta block</code> 。</p><h4 id="MetaIndexBuilder"><a href="#MetaIndexBuilder" class="headerlink" title="MetaIndexBuilder"></a>MetaIndexBuilder</h4><p>前面的<code>filter block</code>、<code>index block</code>、<code>compression dictionary block</code>、<code>range deletion block</code>、<code>prop block</code>等记录着<code>data block</code>各种信息，我们把这些记录<code>data block</code>信息的<code>block</code>统一叫做<code>meta block</code>。所谓<code>meta</code>，即信息的信息。</p><p><code>MetaIndexBuilder</code>，则用于存储前面这些<code>meta block</code>在sst中的存储位置及其大小，最终用于构建整个<code>Table</code>的<code>footer</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaIndexBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MetaIndexBuilder</span>()</span><br><span class="line">  : <span class="built_in">meta_index_block_</span>(<span class="keyword">new</span> <span class="built_in">BlockBuilder</span>(<span class="number">1</span> <span class="comment">/* restart interval */</span>)) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">MetaIndexBuilder</span>(<span class="type">const</span> MetaIndexBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MetaIndexBuilder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MetaIndexBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 添加 &#123;k, v&#125;</span></span><br><span class="line">  <span class="comment">/// handle 中记录了指向的 meta block 在sst中的位置及其大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> BlockHandle&amp; handle)</span> </span>&#123; </span><br><span class="line">     std::string handle_encoding;</span><br><span class="line">     handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding); <span class="comment">// 编码为字符串</span></span><br><span class="line">     meta_block_handles_.<span class="built_in">emplace</span>(key, std::<span class="built_in">move</span>(handle_encoding));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将所有添加到 meta_block_handles_ 中的&#123;k, v&#125; 序列化后返回</span></span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span> </span>&#123; </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; metablock : meta_block_handles_) &#123;</span><br><span class="line">       meta_index_block_-&gt;<span class="built_in">Add</span>(metablock.first, metablock.second);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> meta_index_block_-&gt;<span class="built_in">Finish</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  stl_wrappers::KVMap meta_block_handles_;          <span class="comment">// 存着所有meta block的信息</span></span><br><span class="line">  std::unique_ptr&lt;BlockBuilder&gt; meta_index_block_;  <span class="comment">// 由这些meta block的元信息构建的block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了这个思路，下面，就可以先来看看整体代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BlockBasedTableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="type">bool</span> empty_data_block = r-&gt;data_block.<span class="built_in">empty</span>();</span><br><span class="line">  <span class="comment">// 在flush时，暗示最后一个data block</span></span><br><span class="line">  r-&gt;first_key_in_next_block = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// flush最后一个data block</span></span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">  <span class="comment">// 如果状态不是 kUnBuffered，则直接进入</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">    <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">StopParallelCompression</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对于单线程，EnterUnbuffered 函数没发为最后一个 data block 建立 index </span></span><br><span class="line">    <span class="comment">// 因此，需要手动添加</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_data_block) &#123;</span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;r-&gt;last_key, </span><br><span class="line">                                     <span class="literal">nullptr</span> <span class="comment">/* no next data block */</span>, </span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 开始构建 meta-block</span></span><br><span class="line">  BlockHandle metaindex_block_handle, index_block_handle;</span><br><span class="line">  MetaIndexBuilder meta_index_builder;</span><br><span class="line">  <span class="built_in">WriteFilterBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WriteIndexBlock</span>(&amp;meta_index_builder, &amp;index_block_handle);</span><br><span class="line">  <span class="built_in">WriteCompressionDictBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WriteRangeDelBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WritePropertiesBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 将meta-block写入sst文件</span></span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(meta_index_builder.<span class="built_in">Finish</span>(), kNoCompression,</span><br><span class="line">                  &amp;metaindex_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// metaindex_block_handle 记录着 meta-block的信息</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">WriteFooter</span>(metaindex_block_handle, index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;state = Rep::State::kClosed;</span><br><span class="line">  r-&gt;<span class="built_in">SetStatus</span>(r-&gt;<span class="built_in">CopyIOStatus</span>());</span><br><span class="line">  Status ret_status = r-&gt;<span class="built_in">CopyStatus</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!ret_status.<span class="built_in">ok</span>() || <span class="built_in">io_status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="keyword">return</span> ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteFilterBlock"><a href="#WriteFilterBlock" class="headerlink" title="WriteFilterBlock"></a>WriteFilterBlock</h4><p><code>WriteFilterBlock</code>函数的逻辑如下：</p><ul><li>如果不是 <code>PartitionFilterBuilder</code>，则直接将整个<code>FilterBuiler</code>构建的数据，在直接序列化后写入sst文件。</li><li>如果是<code>PartitionFilterBuilder</code>，则以<code>partition</code>为单位，逐个写入到sst文件；</li><li>等上述过程完毕，再将将此 <code>FilterBuilder</code> 的属性作为<code>&#123;k, v&#125;</code>添加到 <code>meta_index_builder</code>中：<ul><li><code>k</code>：是<code>FilterBuilderType.FilterPolicyName</code>；</li><li><code>v</code>：是写入sst文件的<code>filter block</code>的元信息。</li></ul></li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteFilterBlock</span><span class="params">(MetaIndexBuilder* meta_index_builder)</span> </span>&#123;</span><br><span class="line">  BlockHandle filter_block_handle;</span><br><span class="line">  <span class="type">bool</span> empty_filter_block =</span><br><span class="line">      (rep_-&gt;filter_builder == <span class="literal">nullptr</span> || rep_-&gt;filter_builder-&gt;<span class="built_in">IsEmpty</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_filter_block) &#123;</span><br><span class="line">    <span class="comment">// 添加的key数</span></span><br><span class="line">    rep_-&gt;props.num_filter_entries +=</span><br><span class="line">        rep_-&gt;filter_builder-&gt;<span class="built_in">EstimateEntriesAdded</span>();</span><br><span class="line">    Status s = Status::<span class="built_in">Incomplete</span>();</span><br><span class="line">    <span class="comment">// 如果是 PartitionFilterBuilder</span></span><br><span class="line">    <span class="comment">// 返回值是 IsIncomplete</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ok</span>() &amp;&amp; s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">      <span class="comment">// 此处的 filter_block_handle 表示上一个partition的handle</span></span><br><span class="line">      Slice filter_content =</span><br><span class="line">          rep_-&gt;filter_builder-&gt;<span class="built_in">Finish</span>(filter_block_handle, &amp;s);</span><br><span class="line">      <span class="built_in">assert</span>(s.<span class="built_in">ok</span>() || s.<span class="built_in">IsIncomplete</span>());</span><br><span class="line">      rep_-&gt;props.filter_size += filter_content.<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">// filter_content : 当前 filter partition 的内容</span></span><br><span class="line">      <span class="comment">// filter_block_handle : 记录该 partition 在sst中大小及偏移量</span></span><br><span class="line">      <span class="built_in">WriteRawBlock</span>(filter_content, kNoCompression, &amp;filter_block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*** 全部写入sst ***/</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_filter_block) &#123;</span><br><span class="line">    <span class="comment">// 获取 FilterBuilder 的名字</span></span><br><span class="line">    std::string key;</span><br><span class="line">    <span class="keyword">if</span> (rep_-&gt;filter_builder-&gt;<span class="built_in">IsBlockBased</span>()) &#123;</span><br><span class="line">      key = BlockBasedTable::kFilterBlockPrefix;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      key = rep_-&gt;table_options.partition_filters</span><br><span class="line">                ? BlockBasedTable::kPartitionedFilterBlockPrefix</span><br><span class="line">                : BlockBasedTable::kFullFilterBlockPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 FilterPolicy 的名字</span></span><br><span class="line">    key.<span class="built_in">append</span>(rep_-&gt;table_options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">    <span class="comment">// 添加元信息</span></span><br><span class="line">    meta_index_builder-&gt;<span class="built_in">Add</span>(key, filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteIndexBlock"><a href="#WriteIndexBlock" class="headerlink" title="WriteIndexBlock"></a>WriteIndexBlock</h4><p>由前文可知，<code>IndexBuiler</code>对外提供了两种：</p><ul><li>HashIndexBuilder</li><li>PartitionIndexBuiler</li></ul><p>无论是哪种，最后的<code>index block</code>结果都是由 <code>IndexBuilder::IndexBlocks::index_block_contents</code> 保存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexBuilder</span>::IndexBlocks &#123;</span><br><span class="line">  Slice index_block_contents;</span><br><span class="line">  std::unordered_map&lt;std::string, Slice&gt; meta_blocks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>区别在于：</p><ul><li><code>PartitionIndexBuiler</code> 有很多个partition，而且这个partition的数量和 PartitionFilterBuilder 中的 partition 的数量一致。而<code>HashIndexBuilder</code>可等效的看做只有一个partition；</li><li><code>IndexBuilder::IndexBlocks::meta_blocks</code> 字段仅有<code>HashIndexBuilder</code>使用。</li></ul><p>因此，<code>WriteIndexBlock</code> 函数的最终目的也是将所有<code>partitions</code>的内容写入sst。写入sst的所有信息都记录在<code>index_block_handle</code>中，这用于后续的<code>footer</code>。</p><p>下面，带着上述理解，并顺着代码注释来阅读源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param index_block_handle 用于记录 partition 的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteIndexBlock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MetaIndexBuilder* meta_index_builder, BlockHandle* index_block_handle)</span> </span>&#123;</span><br><span class="line">  IndexBuilder::IndexBlocks index_blocks;</span><br><span class="line">  <span class="comment">// 可等效看做获取 first partition 的内容</span></span><br><span class="line">  <span class="keyword">auto</span> index_builder_status = rep_-&gt;index_builder-&gt;<span class="built_in">Finish</span>(&amp;index_blocks);</span><br><span class="line">  <span class="keyword">if</span> (index_builder_status.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">    <span class="comment">// meta_blocks 仅用于 HashIndexBuilder，在 PartitionIndexBuilder 下不支持</span></span><br><span class="line">    <span class="built_in">assert</span>(index_blocks.meta_blocks.<span class="built_in">empty</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !index_builder_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    rep_-&gt;<span class="built_in">SetStatus</span>(index_builder_status);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 这一部分是针对 HashIndexBuilder</span></span><br><span class="line">    <span class="comment">// item: &#123;name, content&#125;</span></span><br><span class="line">    <span class="comment">//  + &#123;hashindex.prefixes, prefix_block_&#125;</span></span><br><span class="line">    <span class="comment">//  + &#123;&quot;rocksdb.hashindex.metadata&quot;, prefix_meta_block_&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : index_blocks.meta_blocks) &#123;</span><br><span class="line">      BlockHandle block_handle;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(item.second, &amp;block_handle, <span class="literal">false</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      meta_index_builder-&gt;<span class="built_in">Add</span>(item.first, block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这一部分是通用的</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// first patition </span></span><br><span class="line">    <span class="keyword">if</span> (rep_-&gt;table_options.enable_index_compression) &#123;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(index_blocks.index_block_contents, index_block_handle, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">WriteRawBlock</span>(index_blocks.index_block_contents, kNoCompression,</span><br><span class="line">                    index_block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面是针对 PartitionIndexBuiler </span></span><br><span class="line">  <span class="keyword">if</span> (index_builder_status.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">    Status s = Status::<span class="built_in">Incomplete</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ok</span>() &amp;&amp; s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">      <span class="comment">// index_block_handle 表示上一个 partition</span></span><br><span class="line">      s = rep_-&gt;index_builder-&gt;<span class="built_in">Finish</span>(&amp;index_blocks, *index_block_handle);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>() &amp;&amp; !s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">        rep_-&gt;<span class="built_in">SetStatus</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将每个partition写入sst文件</span></span><br><span class="line">      <span class="keyword">if</span> (rep_-&gt;table_options.enable_index_compression) &#123;</span><br><span class="line">        <span class="built_in">WriteBlock</span>(index_blocks.index_block_contents, index_block_handle,</span><br><span class="line">                   <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">WriteRawBlock</span>(index_blocks.index_block_contents, kNoCompression,</span><br><span class="line">                      index_block_handle);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The last index_block_handle will be for the partition index block</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteFooter"><a href="#WriteFooter" class="headerlink" title="WriteFooter"></a>WriteFooter</h4><p>最后就是写入footer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteFooter</span><span class="params">(BlockHandle&amp; metaindex_block_handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         BlockHandle&amp; index_block_handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="type">bool</span> legacy = (r-&gt;table_options.format_version == <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;table_options.checksum == kCRC32c ||</span><br><span class="line">         r-&gt;table_options.format_version != <span class="number">0</span>);</span><br><span class="line">  <span class="function">Footer <span class="title">footer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      legacy ? kLegacyBlockBasedTableMagicNumber : kBlockBasedTableMagicNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">      r-&gt;table_options.format_version)</span></span>;</span><br><span class="line">  footer.<span class="built_in">set_metaindex_handle</span>(metaindex_block_handle);</span><br><span class="line">  footer.<span class="built_in">set_index_handle</span>(index_block_handle);</span><br><span class="line">  footer.<span class="built_in">set_checksum</span>(r-&gt;table_options.checksum);</span><br><span class="line">  std::string footer_encoding;</span><br><span class="line">  footer.<span class="built_in">EncodeTo</span>(&amp;footer_encoding);</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">ok</span>());</span><br><span class="line">  <span class="comment">// 最后在此写入</span></span><br><span class="line">  IOStatus ios = r-&gt;file-&gt;<span class="built_in">Append</span>(footer_encoding);</span><br><span class="line">  <span class="keyword">if</span> (ios.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    r-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>() + footer_encoding.<span class="built_in">size</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r-&gt;<span class="built_in">SetIOStatus</span>(ios);</span><br><span class="line">    r-&gt;<span class="built_in">SetStatus</span>(ios);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BlockBasedTableBuilder-ParallelCompressionRep&quot;&gt;&lt;a href=&quot;#BlockBasedTableBuilder-ParallelCompressionRep&quot; class=&quot;headerlink&quot; title=&quot;Bl</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>FilterBlock 源码分析</title>
    <link href="https://szza.github.io/2021/11/27/rocksdb/Table/builder/3_FilterBlock/"/>
    <id>https://szza.github.io/2021/11/27/rocksdb/Table/builder/3_FilterBlock/</id>
    <published>2021-11-27T06:15:35.000Z</published>
    <updated>2023-08-01T02:43:02.627Z</updated>
    
    <content type="html"><![CDATA[<p>Rocksdb,为了加速查询，基于bloom filter 设计了Filter。</p><h2 id="FilterBlockBuilder"><a href="#FilterBlockBuilder" class="headerlink" title="FilterBlockBuilder"></a>FilterBlockBuilder</h2><p><code>FilterBlockBuilder</code> 是个基类，用于为特定的<code>table</code>构建filter，调用<code>::Finish</code>函数后会以字符串形式返回生成filter。它也有三个子类：</p><ul><li><code>BlockBasedFilterBlockBuilder</code></li><li><code>FullFilterBlockBuilder</code></li><li><code>PartitionedFilterBlockBuilder</code></li></ul><p><code>FilterBlockBuilder</code> 的成员函数的调用顺序，要符合正则表达式： <code>(StartBlock Add*)* Finish</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FilterBlockBuilder</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FilterBlockBuilder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">FilterBlockBuilder</span>() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">FilterBlockBuilder</span>(<span class="type">const</span> FilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> FilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsBlockBased</span><span class="params">()</span> </span>= <span class="number">0</span>;                     <span class="comment">// If is blockbased filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartBlock</span><span class="params">(<span class="type">uint64_t</span> block_offset)</span> </span>= <span class="number">0</span>;  <span class="comment">// Start new block filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice&amp; key_without_ts)</span> </span>= <span class="number">0</span>;   <span class="comment">// Add a key to current filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;                    <span class="comment">// Empty == none added</span></span><br><span class="line">  <span class="comment">/// For reporting stats on how many entries the builder considered unique</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/// Generate Filter</span></span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> BlockHandle empty_handle;</span><br><span class="line">    Status dont_care_status;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">Finish</span>(empty_handle, &amp;dont_care_status);</span><br><span class="line">    <span class="built_in">assert</span>(dont_care_status.<span class="built_in">ok</span>());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; tmp, Status* status)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="BlockBasedFilterBlockBuilder"><a href="#BlockBasedFilterBlockBuilder" class="headerlink" title="BlockBasedFilterBlockBuilder"></a>BlockBasedFilterBlockBuilder</h2><p><code>BlockBasedFilterBlockBuilder</code> 调用<code>::Finish</code>函数最后生成的字符串数据格式，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filter_1</span><br><span class="line">filter_2</span><br><span class="line">...</span><br><span class="line">filter_N</span><br><span class="line">...</span><br><span class="line">filter_1_offset</span><br><span class="line">filter_2_offset</span><br><span class="line">...</span><br><span class="line">filter_N_offset</span><br></pre></td></tr></table></figure><p>下面先大致看下结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockBasedFilterBlockBuilder</span> : <span class="keyword">public</span> FilterBlockBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BlockBasedFilterBlockBuilder</span>(<span class="type">const</span> SliceTransform* prefix_extractor,</span><br><span class="line">                               <span class="type">const</span> BlockBasedTableOptions&amp; table_opt);</span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  <span class="built_in">BlockBasedFilterBlockBuilder</span>(<span class="type">const</span> BlockBasedFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> BlockBasedFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsBlockBased</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartBlock</span><span class="params">(<span class="type">uint64_t</span> block_offset)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice&amp; key_without_ts)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start_.<span class="built_in">empty</span>() &amp;&amp; filter_offsets_.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> filter_bits_builder_-&gt;<span class="built_in">EstimateEntriesAdded</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; tmp, Status* status)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="keyword">using</span> FilterBlockBuilder::Finish;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddPrefix</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">GenerateFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> FilterPolicy* policy_;</span><br><span class="line">  <span class="type">const</span> SliceTransform* prefix_extractor_;</span><br><span class="line">  <span class="type">bool</span> whole_key_filtering_;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> prev_prefix_start_;      <span class="comment">// 上次添加到 entries_ 中的 key_prefix 的起始地址</span></span><br><span class="line">  <span class="type">size_t</span> prev_prefix_size_;       <span class="comment">// 该 key_prefix 的大小</span></span><br><span class="line"></span><br><span class="line">  std::string entries_;        <span class="comment">// 将所有的key打平后存储在 entries 中</span></span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; start_;  <span class="comment">// 每个entry的的索引存储在 start_</span></span><br><span class="line"></span><br><span class="line">  std::string result_;              <span class="comment">// Filter data computed so far</span></span><br><span class="line">  std::vector&lt;Slice&gt; tmp_entries_;  <span class="comment">// policy_-&gt;CreateFilter() argument</span></span><br><span class="line">  std::vector&lt;<span class="type">uint32_t</span>&gt; filter_offsets_;</span><br><span class="line">  <span class="type">uint64_t</span> total_added_in_built_;  <span class="comment">// Total keys added to filters built so far</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p><code>BlockBasedFilterBlockBuilder</code> 在添加<code>key</code>时：</p><ul><li>如果能提取出待添加<code>key</code>的前缀，则会添加前缀</li><li>如果 <code>whole_key_filtering_  == true</code> ，则也会添加整个<code>key</code></li></ul><p>源码简单如斯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedFilterBlockBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key_without_ts)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是能提取出 key_without_ts 的前缀，则添加前缀</span></span><br><span class="line">  <span class="keyword">if</span> (prefix_extractor_ &amp;&amp; prefix_extractor_-&gt;<span class="built_in">InDomain</span>(key_without_ts)) &#123;</span><br><span class="line">    <span class="built_in">AddPrefix</span>(key_without_ts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否添加添加整个 key</span></span><br><span class="line">  <span class="keyword">if</span> (whole_key_filtering_) &#123;</span><br><span class="line">    <span class="built_in">AddKey</span>(key_without_ts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddKey"><a href="#AddKey" class="headerlink" title="AddKey"></a>AddKey</h4><p>在 <code>BlockBasedFilterBlockBuilder</code> 中，<code>entries_</code> 用于存储每次添加的<code>key</code>，<code>start_</code> 存储这个<code>key</code>在<code>entries_</code>中偏移量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BlockBasedFilterBlockBuilder::AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  start_.<span class="built_in">push_back</span>(entries_.<span class="built_in">size</span>()); <span class="comment">// entries_.size() 即下一个 key 在 entries_ 中的起始偏移量</span></span><br><span class="line">  entries_.<span class="built_in">append</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddPrefix"><a href="#AddPrefix" class="headerlink" title="AddPrefix"></a>AddPrefix</h4><p>非首次添加前缀时，都会先获得上一次添加key的前缀如果本次与上次不同，才添加本次key的前缀。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BlockBasedFilterBlockBuilder::AddPrefix</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  Slice prev;</span><br><span class="line">  <span class="keyword">if</span> (prev_prefix_size_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 上一个添加的 key 的前缀</span></span><br><span class="line">    prev = <span class="built_in">Slice</span>(entries_.<span class="built_in">data</span>() + prev_prefix_start_, prev_prefix_size_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本次添加的key的前缀</span></span><br><span class="line">  Slice prefix = prefix_extractor_-&gt;<span class="built_in">Transform</span>(key);</span><br><span class="line">  <span class="comment">// 如果当前前缀 prefix 和之前的 prev 不同，则插入</span></span><br><span class="line">  <span class="keyword">if</span> (prev.<span class="built_in">size</span>() == <span class="number">0</span> || prefix != prev) &#123;</span><br><span class="line">    prev_prefix_start_ = entries_.<span class="built_in">size</span>();<span class="comment">// 待插入的 key 在entries_中的起始地址</span></span><br><span class="line">    prev_prefix_size_ = prefix.<span class="built_in">size</span>();    <span class="comment">// 待插入的key的前缀</span></span><br><span class="line">    <span class="built_in">AddKey</span>(prefix);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StartBlock"><a href="#StartBlock" class="headerlink" title="StartBlock"></a>StartBlock</h3><p><code>StartBlock</code> 函数用于构建<code>filter block</code>。</p><p><code>BlockBasedFilterBlockBuilder</code> 是每 2kb的数据创建一个<code>filter block</code>，传入的参数<code>block_offset</code>是表示最终生成的<code>filter block</code> 在<code>result_</code>中的偏移量。</p><p>而 <code>filter_offsets_</code>中记录的是已有<code>filter block</code> 在<code>result_</code> 中的偏移量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kFilterBaseLg = <span class="number">11</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kFilterBase = <span class="number">1</span> &lt;&lt; kFilterBaseLg; <span class="comment">// 2kb</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedFilterBlockBuilder::StartBlock</span><span class="params">(<span class="type">uint64_t</span> block_offset)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> filter_index = (block_offset / kFilterBase);</span><br><span class="line">  <span class="built_in">assert</span>(filter_index &gt;= filter_offsets_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="built_in">GenerateFilter</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GenerateFilter"><a href="#GenerateFilter" class="headerlink" title="GenerateFilter"></a>GenerateFilter</h3><p>每个<code>filter block</code>的数据都记录在<code>entries_</code> 和 <code>start_</code>，当调用 <code>GenerateFilter</code> 函数时就会将<code>entries_</code> 、 <code>start_</code>中的数据添加到<code>result_</code>中，而这个<code>filter block</code> 的起始地址记录在<code>filter_offsets_</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedFilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> num_entries = start_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_entries == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果这个 filter block 没有key，直接存储上次生成的滤波器的起始地址</span></span><br><span class="line">    filter_offsets_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(result_.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  total_added_in_built_ += num_entries;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为便于下面使用 start_[i + 1] - start_[i] 计算每个entry的长度</span></span><br><span class="line">  start_.<span class="built_in">push_back</span>(entries_.<span class="built_in">size</span>());     </span><br><span class="line">  tmp_entries_.<span class="built_in">resize</span>(num_entries);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_entries; i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* base = entries_.<span class="built_in">data</span>() + start_[i]; <span class="comment">// 每个entry的起始地址</span></span><br><span class="line">    <span class="type">size_t</span> length = start_[i + <span class="number">1</span>] - start_[i];      <span class="comment">// 这个entry的长度</span></span><br><span class="line">    tmp_entries_[i] = <span class="built_in">Slice</span>(base, length);          <span class="comment">// slice</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// filter_offsets_  中保存着每个 filter block 的起始地址，即 result.size()</span></span><br><span class="line">  filter_offsets_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(result_.<span class="built_in">size</span>()));</span><br><span class="line">  <span class="comment">// 基于 tmp_entries 的内容创建 filter，结果存储至 result_</span></span><br><span class="line">  policy_-&gt;<span class="built_in">CreateFilter</span>(&amp;tmp_entries_[<span class="number">0</span>], </span><br><span class="line">                        <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num_entries),</span><br><span class="line">                        &amp;result_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清零，为下个 filter block 准备</span></span><br><span class="line">  tmp_entries_.<span class="built_in">clear</span>();</span><br><span class="line">  entries_.<span class="built_in">clear</span>();</span><br><span class="line">  start_.<span class="built_in">clear</span>();</span><br><span class="line">  prev_prefix_start_ = <span class="number">0</span>;</span><br><span class="line">  prev_prefix_size_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p>在调用<code>::Finish</code>函数时，需要<code>result_</code>向<code>result_</code>中写入三部分：</p><ul><li>每个<code>key</code>的偏移量<code>KEY_OFFSET</code></li><li><code>key</code>的数量<code>FILTER_BLOCK_NUM</code></li><li>结束标志 <code>kFilterBaseLg</code></li></ul><p>代码简单如此。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">BlockBasedFilterBlockBuilder::Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; <span class="comment">/*tmp*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Status* status)</span> </span>&#123;</span><br><span class="line">  *status = Status::<span class="built_in">OK</span>();</span><br><span class="line">  <span class="keyword">if</span> (!start_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">GenerateFilter</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> array_offset = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(result_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 把每个 filter block 的偏移量添加到result</span></span><br><span class="line">    <span class="built_in">PutFixed32</span>(&amp;result_, filter_offsets_[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 filter block 的数量</span></span><br><span class="line">  <span class="built_in">PutFixed32</span>(&amp;result_, array_offset);</span><br><span class="line">  <span class="comment">// 结束标志位</span></span><br><span class="line">  result_.<span class="built_in">push_back</span>(kFilterBaseLg);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Slice</span>(result_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FullFilterBlockBuilder"><a href="#FullFilterBlockBuilder" class="headerlink" title="FullFilterBlockBuilder"></a>FullFilterBlockBuilder</h2><p>他就是将全部的的key都放在了一起、。</p><blockquote><p>TODO：设计点</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FullFilterBlockBuilder</span> : <span class="keyword">public</span> FilterBlockBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FullFilterBlockBuilder</span><span class="params">(<span class="type">const</span> SliceTransform* prefix_extractor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span> whole_key_filtering,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  FilterBitsBuilder* filter_bits_builder)</span></span>;</span><br><span class="line">  <span class="built_in">FullFilterBlockBuilder</span>(<span class="type">const</span> FullFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> FullFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">FullFilterBlockBuilder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsBlockBased</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; <span class="comment">// 区分 BlockBasedFilterBlockBuilder</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartBlock</span><span class="params">(<span class="type">uint64_t</span>)</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> !any_added_; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice&amp; key_without_ts)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span> FilterBlockBuilder::Finish;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; tmp, Status* status)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddPrefix</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">const</span> SliceTransform* <span class="title">prefix_extractor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prefix_extractor_; &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">last_prefix_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> last_prefix_str_; &#125;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;FilterBitsBuilder&gt; filter_bits_builder_;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> SliceTransform* prefix_extractor_;<span class="comment">// 前缀提取器</span></span><br><span class="line">  <span class="type">bool</span> whole_key_filtering_;</span><br><span class="line">  <span class="type">bool</span> last_whole_key_recorded_;</span><br><span class="line">  std::string last_whole_key_str_;</span><br><span class="line">  <span class="type">bool</span> last_prefix_recorded_;</span><br><span class="line">  std::string last_prefix_str_;</span><br><span class="line">  <span class="type">bool</span> last_key_in_domain_;</span><br><span class="line">  <span class="type">bool</span> any_added_;</span><br><span class="line">  std::unique_ptr&lt;<span class="type">const</span> <span class="type">char</span>[]&gt; filter_data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Add-1"><a href="#Add-1" class="headerlink" title="Add"></a>Add</h3><ol><li>根据<code>whole_key_filtering_</code> 来确定是否添加整个<code>key_without_ts</code> </li><li>根据<code>add_prefix</code>，来看是否添加<code>key_without_ts</code>的前缀</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FullFilterBlockBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key_without_ts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> add_prefix =</span><br><span class="line">      prefix_extractor_ &amp;&amp; prefix_extractor_-&gt;<span class="built_in">InDomain</span>(key_without_ts);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!last_prefix_recorded_ &amp;&amp; last_key_in_domain_) &#123;</span><br><span class="line">    <span class="built_in">AddKey</span>(last_prefix_str_);</span><br><span class="line">    last_prefix_recorded_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (whole_key_filtering_) &#123;</span><br><span class="line">    <span class="comment">// 如果没前缀，则直接添加key</span></span><br><span class="line">    <span class="keyword">if</span> (!add_prefix) &#123;</span><br><span class="line">      <span class="built_in">AddKey</span>(key_without_ts);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 第一个 key or 遇到新的 key</span></span><br><span class="line">      Slice last_whole_key = <span class="built_in">Slice</span>(last_whole_key_str_);</span><br><span class="line">      <span class="keyword">if</span> (!last_whole_key_recorded_ ||</span><br><span class="line">          last_whole_key.<span class="built_in">compare</span>(key_without_ts) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">AddKey</span>(key_without_ts);</span><br><span class="line">        last_whole_key_recorded_ = <span class="literal">true</span>;</span><br><span class="line">        last_whole_key_str_.<span class="built_in">assign</span>(key_without_ts.<span class="built_in">data</span>(),</span><br><span class="line">                                   key_without_ts.<span class="built_in">size</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (add_prefix) &#123;</span><br><span class="line">    last_key_in_domain_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">AddPrefix</span>(key_without_ts);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    last_key_in_domain_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddKey-1"><a href="#AddKey-1" class="headerlink" title="AddKey"></a>AddKey</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FullFilterBlockBuilder::AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  filter_bits_builder_-&gt;<span class="built_in">AddKey</span>(key);</span><br><span class="line">  any_added_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddPrefix-1"><a href="#AddPrefix-1" class="headerlink" title="AddPrefix"></a>AddPrefix</h4><ul><li><p><code>last_prefix_str_</code>：记录上一次添加的前缀</p></li><li><p>如果<code>whole_key_filtering_ == true</code>，那么，从<code>FullFilterBlockBuilder::Add</code>函数运行至<code>FullFilterBlockBuilder::AddPrefix</code> 函数结束，添加的数据是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key_without_ts</span><br><span class="line">prefix</span><br></pre></td></tr></table></figure><p>但是如果<code>prefix</code>和上一个添加的前缀相同，则忽略本次的前缀，最终添加的内容只有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_without_ts</span><br></pre></td></tr></table></figure></li><li><p>如果<code>whole_key_filtering_ == false</code>，添加的数据只有<code>prefix</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FullFilterBlockBuilder::AddPrefix</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(prefix_extractor_ &amp;&amp; prefix_extractor_-&gt;<span class="built_in">InDomain</span>(key));</span><br><span class="line">  Slice prefix = prefix_extractor_-&gt;<span class="built_in">Transform</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (whole_key_filtering_) &#123;</span><br><span class="line"> <span class="comment">// 前一个添加的前缀</span></span><br><span class="line">    Slice last_prefix = <span class="built_in">Slice</span>(last_prefix_str_);  <span class="comment">// 前缀</span></span><br><span class="line">    <span class="comment">// 遇到新的前缀</span></span><br><span class="line">    <span class="keyword">if</span> (!last_prefix_recorded_ || last_prefix.<span class="built_in">compare</span>(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录前缀</span></span><br><span class="line">      <span class="built_in">AddKey</span>(prefix);</span><br><span class="line">      last_prefix_recorded_ = <span class="literal">true</span>; </span><br><span class="line">      last_prefix_str_.<span class="built_in">assign</span>(prefix.<span class="built_in">data</span>(), prefix.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 直接添加 prefix</span></span><br><span class="line">    <span class="built_in">AddKey</span>(prefix);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Finish-1"><a href="#Finish-1" class="headerlink" title="Finish"></a>Finish</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FullFilterBlockBuilder::Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  last_whole_key_recorded_ = <span class="literal">false</span>;</span><br><span class="line">  last_prefix_recorded_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice <span class="title">FullFilterBlockBuilder::Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; <span class="comment">/*tmp*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     Status* status)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Reset</span>();</span><br><span class="line">  <span class="comment">// In this impl we ignore BlockHandle</span></span><br><span class="line">  *status = Status::<span class="built_in">OK</span>();</span><br><span class="line">  <span class="keyword">if</span> (any_added_) &#123;</span><br><span class="line">    any_added_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> filter_bits_builder_-&gt;<span class="built_in">Finish</span>(&amp;filter_data_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Slice</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PartitionedFilterBlockBuilder"><a href="#PartitionedFilterBlockBuilder" class="headerlink" title="PartitionedFilterBlockBuilder"></a>PartitionedFilterBlockBuilder</h2><p>对应于 <code>PartitionedIndexBuilder</code>，rocksdb 现在是一个<code>partition filter block</code>  对应一个<code>partition index block</code>。</p><p>因此，每生成一个 <code>partition filter block</code> 也会请求  <code>PartitionedIndexBuilder</code> 生成一个 <code>partition index block</code>，来保证一一对应。</p><p>两种原理都差不多。</p><p>在<code>PartitionedFilterBlockBuilder</code>内部，也有个<code>FilterEntry</code>结构体，类似于<code>PartitionedIndexBuilder::Entry</code>，每个<code>value</code>都是一个<code>filter</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PartitionedFilterBlockBuilder</span> : <span class="keyword">public</span> FullFilterBlockBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PartitionedFilterBlockBuilder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> SliceTransform* prefix_extractor, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> whole_key_filtering,</span></span></span><br><span class="line"><span class="params"><span class="function">      FilterBitsBuilder* filter_bits_builder, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">int</span> index_block_restart_interval,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="params"><span class="function">      PartitionedIndexBuilder* <span class="type">const</span> p_index_builder,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">uint32_t</span> partition_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">PartitionedFilterBlockBuilder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; last_partition_block_handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Status* status)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  BlockBuilder index_on_filter_block_builder_;  <span class="comment">// top-level index builder</span></span><br><span class="line">  BlockBuilder index_on_filter_block_builder_without_seq_;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">FilterEntry</span> &#123;</span><br><span class="line">    std::string key;</span><br><span class="line">    Slice filter;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::list&lt;FilterEntry&gt; filters;      <span class="comment">// list of partitioned indexes and their keys</span></span><br><span class="line">  std::unique_ptr&lt;IndexBuilder&gt; value; <span class="comment">// 可以存储 PartitionedIndexBuilder</span></span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;<span class="type">const</span> <span class="type">char</span>[]&gt;&gt; filter_gc;</span><br><span class="line">  <span class="type">bool</span> finishing_filters = <span class="literal">false</span>;      <span class="comment">// 为true，表示正调用 Finish 函数，尚未返回 Status::OK()</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">MaybeCutAFilterBlock</span><span class="params">(<span class="type">const</span> Slice* next_key)</span></span>;</span><br><span class="line">  </span><br><span class="line">  PartitionedIndexBuilder* <span class="type">const</span> p_index_builder_;</span><br><span class="line">  <span class="type">uint32_t</span> keys_per_partition_;<span class="comment">// 每个 partition 中 key 的数量</span></span><br><span class="line">  <span class="type">uint32_t</span> keys_added_to_partition_;<span class="comment">// 最近一个partion添加的key的数量</span></span><br><span class="line">  <span class="type">uint64_t</span> total_added_in_built_;  <span class="comment">// 总共添加的key的数量</span></span><br><span class="line">  BlockHandle last_encoded_handle_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="MaybeCutAFilterBlock"><a href="#MaybeCutAFilterBlock" class="headerlink" title="MaybeCutAFilterBlock"></a>MaybeCutAFilterBlock</h3><p><code>MaybeCutAFilterBlock</code> 函数，用于判断当前是否需要生成一个<code>filter block</code>： <strong>当前 <code>partition</code>添加的key的数量 <code>keys_added_to_partition_</code> 已经到达阈值 <code>keys_per_partition_</code></strong> 。</p><p>由于<code>partition filter block</code> 和 <code>partition index block</code> 的数目是一一对应的。因此，需要请求 <code>PartitionedIndexBuilder</code> 对象 <code>p_index_builder_</code>  也生成一个<code>partition index block</code>。此外，生成的<code>partition idnex block</code>  和 <code>partition filter block</code> 对应的key是相同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PartitionedIndexBuilder</span>::Entry &#123;</span><br><span class="line">  std::string key;  <span class="comment">// sub_index_last_key_;</span></span><br><span class="line">  std::unique_ptr&lt;ShortenedIndexBuilder&gt; value; <span class="comment">// partition index block</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PartitionedFilterBlockBuilderFilterEntry</span> &#123;</span><br><span class="line">  std::string key;<span class="comment">// sub_index_last_key_</span></span><br><span class="line">  Slice filter;    <span class="comment">// partition filter block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>MaybeCutAFilterBlock</code> 的函数分为三步：</p><ol><li>如果当前 <code>partition filter block</code>的<code>keys_added_to_partition_</code>已达到阈值，则请求对应的<code>partiiton index block</code>也创建完毕，否则就阻塞等待；</li><li>将待添加的<code>next_key</code>的前缀<code>next_key_prefix</code>添加到<code>partition filer block</code>；</li><li>生成<code>partition filter block</code>，并添加到<code>filters</code> 中。</li></ol><p>顺着源码更加详细地去理解这个过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PartitionedFilterBlockBuilder::MaybeCutAFilterBlock</span><span class="params">(<span class="type">const</span> Slice* next_key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 parition 的 key 达到阈值</span></span><br><span class="line">  <span class="keyword">if</span> (keys_added_to_partition_ == keys_per_partition_) &#123;</span><br><span class="line">    <span class="comment">// 请求 p_index_builder_ 生成一个 partition</span></span><br><span class="line">    p_index_builder_-&gt;<span class="built_in">RequestPartitionCut</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!p_index_builder_-&gt;<span class="built_in">ShouldCutFilterBlock</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// p_index_builder_ 已生成一个 partition</span></span><br><span class="line"> </span><br><span class="line">  filter_gc.<span class="built_in">push_back</span>(std::<span class="built_in">unique_ptr</span>&lt;<span class="type">const</span> <span class="type">char</span>[]&gt;(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否需要添加 next_key 的前缀</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> maybe_add_prefix =</span><br><span class="line">      next_key &amp;&amp; <span class="built_in">prefix_extractor</span>() &amp;&amp; <span class="built_in">prefix_extractor</span>()-&gt;<span class="built_in">InDomain</span>(*next_key);</span><br><span class="line">  <span class="keyword">if</span> (maybe_add_prefix) &#123;</span><br><span class="line">    <span class="type">const</span> Slice next_key_prefix = <span class="built_in">prefix_extractor</span>()-&gt;<span class="built_in">Transform</span>(*next_key);</span><br><span class="line">    <span class="comment">// 与之前的前缀不同，则添加</span></span><br><span class="line">    <span class="keyword">if</span> (next_key_prefix.<span class="built_in">compare</span>(<span class="built_in">last_prefix_str</span>()) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">AddKey</span>(next_key_prefix);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  total_added_in_built_ += filter_bits_builder_-&gt;<span class="built_in">EstimateEntriesAdded</span>();</span><br><span class="line">  <span class="comment">// 生成一个 filter block</span></span><br><span class="line">  Slice filter = filter_bits_builder_-&gt;<span class="built_in">Finish</span>(&amp;filter_gc.<span class="built_in">back</span>());</span><br><span class="line">  <span class="comment">// index_key 是 partition index block 存储的时的 key</span></span><br><span class="line">  std::string&amp; index_key = p_index_builder_-&gt;<span class="built_in">GetPartitionKey</span>();</span><br><span class="line">  <span class="comment">// &#123;index_key, PartitionFilter&#125;</span></span><br><span class="line">  filters.<span class="built_in">push_back</span>(&#123;index_key, filter&#125;);</span><br><span class="line">  <span class="comment">// 当前 partition 已添加的key数清零</span></span><br><span class="line">  keys_added_to_partition_ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">Reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddKey-2"><a href="#AddKey-2" class="headerlink" title="AddKey"></a>AddKey</h4><p>添加 <code>key</code> 至当前<code>partition filter block</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PartitionedFilterBlockBuilder::AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  FullFilterBlockBuilder::<span class="built_in">AddKey</span>(key);</span><br><span class="line">  keys_added_to_partition_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Add-2"><a href="#Add-2" class="headerlink" title="Add"></a>Add</h3><p>由于<code>PartitionedFilterBlockBuilder</code> 继承自<code>FullFilterBlockBuilder</code>，唯一的区别就在于将一整个<code>Filter Block</code>，划分为多个<code>partitions</code>。</p><p>因此，在每次<code>Add</code>新的<code>key</code>，都先判断下是是否要需要生成新的<code>partition filter block</code>，然后将<code>key</code>添加到当前<code>partiton filter block</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PartitionedFilterBlockBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">MaybeCutAFilterBlock</span>(&amp;key);</span><br><span class="line">  FullFilterBlockBuilder::<span class="built_in">Add</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish-2"><a href="#Finish-2" class="headerlink" title="Finish"></a>Finish</h3><p>类似于<code>PartitionIndexBuiler</code>, 这里要将<code>fiters</code> 中记录的<code>partitions</code> 都写入到SST中，并记录下每个<code>partition</code> 在SST中的偏移量offset，根据<code>partiton</code>的大小size和offset生成 <code>TopLevelIndex</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">PartitionedFilterBlockBuilder::Finish</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> BlockHandle&amp; last_partition_block_handle, </span></span></span><br><span class="line"><span class="params"><span class="function">    Status* status)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (finishing_filters == <span class="literal">true</span>) &#123;</span><br><span class="line">    FilterEntry&amp; last_entry = filters.<span class="built_in">front</span>();</span><br><span class="line">    std::string handle_encoding;</span><br><span class="line">    last_partition_block_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">    std::string handle_delta_encoding;</span><br><span class="line">    <span class="built_in">PutVarsignedint64</span>(</span><br><span class="line">        &amp;handle_delta_encoding,</span><br><span class="line">        last_partition_block_handle.<span class="built_in">size</span>() - last_encoded_handle_.<span class="built_in">size</span>());</span><br><span class="line">    last_encoded_handle_ = last_partition_block_handle;</span><br><span class="line">    <span class="function"><span class="type">const</span> Slice <span class="title">handle_delta_encoding_slice</span><span class="params">(handle_delta_encoding)</span></span>;</span><br><span class="line">    index_on_filter_block_builder_.<span class="built_in">Add</span>(last_entry.key,  <span class="comment">// key 相同</span></span><br><span class="line">                                       handle_encoding,   <span class="comment">// block_handle</span></span><br><span class="line">                                       &amp;handle_delta_encoding_slice);</span><br><span class="line">    <span class="keyword">if</span> (!p_index_builder_-&gt;<span class="built_in">seperator_is_key_plus_seq</span>()) &#123;</span><br><span class="line">      index_on_filter_block_builder_without_seq_.<span class="built_in">Add</span>(</span><br><span class="line">          <span class="built_in">ExtractUserKey</span>(last_entry.key), handle_encoding,</span><br><span class="line">          &amp;handle_delta_encoding_slice);</span><br><span class="line">    &#125;</span><br><span class="line">    filters.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次调用 ::Finish 函数，此时没有 next_key，</span></span><br><span class="line">    <span class="comment">// 仅仅是为了生成最后一个 partition fiter block</span></span><br><span class="line">    <span class="built_in">MaybeCutAFilterBlock</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(filters.<span class="built_in">empty</span>())) &#123;</span><br><span class="line">    *status = Status::<span class="built_in">OK</span>();</span><br><span class="line">    <span class="keyword">if</span> (finishing_filters) &#123;</span><br><span class="line">       <span class="comment">/// 最后一次调用 ::Finish</span></span><br><span class="line">      total_added_in_built_ = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 返回partitions的元信息</span></span><br><span class="line">      <span class="keyword">if</span> (p_index_builder_-&gt;<span class="built_in">seperator_is_key_plus_seq</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> index_on_filter_block_builder_.<span class="built_in">Finish</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index_on_filter_block_builder_without_seq_.<span class="built_in">Finish</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This is the rare case where no key was added to the filter</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Slice</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回当前 partition 的信息</span></span><br><span class="line">    *status = Status::<span class="built_in">Incomplete</span>();</span><br><span class="line">    finishing_filters = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> filters.<span class="built_in">front</span>().filter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Rocksdb,为了加速查询，基于bloom filter 设计了Filter。&lt;/p&gt;
&lt;h2 id=&quot;FilterBlockBuilder&quot;&gt;&lt;a href=&quot;#FilterBlockBuilder&quot; class=&quot;headerlink&quot; title=&quot;FilterBl</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
</feed>
