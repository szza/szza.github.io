<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>szza</title>
  
  <subtitle>look code art</subtitle>
  <link href="https://szza.github.io/atom.xml" rel="self"/>
  
  <link href="https://szza.github.io/"/>
  <updated>2023-08-13T13:11:45.474Z</updated>
  <id>https://szza.github.io/</id>
  
  <author>
    <name>fibonaccii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Morsel 和 OlapScanOperator (3)</title>
    <link href="https://szza.github.io/2023/07/07/Pipeline/MorselQueue_3/"/>
    <id>https://szza.github.io/2023/07/07/Pipeline/MorselQueue_3/</id>
    <published>2023-07-07T02:30:02.000Z</published>
    <updated>2023-08-13T13:11:45.474Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ScanOperator-pull-chunk"><a href="#ScanOperator-pull-chunk" class="headerlink" title="ScanOperator::pull_chunk"></a>ScanOperator::pull_chunk</h2><p>就直接来看如何从 ScanOperator 中获取数据了。</p><ol><li>_try_to_trigger_next_scan: 是根据 morsel 信息从存储层中获取数据</li><li>get_chunk_from_buffer: 根据获得的数据创建 chunk_source</li></ol><p>主要这两部分。代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;vectorized::ChunkPtr&gt; <span class="title">ScanOperator::pull_chunk</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_get_scan_status());</span><br><span class="line"></span><br><span class="line">    _peak_buffer_size_counter-&gt;<span class="built_in">set</span>(<span class="built_in">buffer_size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_try_to_trigger_next_scan(state));</span><br><span class="line"></span><br><span class="line">    vectorized::ChunkPtr res = <span class="built_in">get_chunk_from_buffer</span>();</span><br><span class="line">    <span class="keyword">if</span> (res != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">begin_pull_chunk</span>(res);</span><br><span class="line">        <span class="comment">// for query cache mechanism, we should emit EOS chunk when we receive the last chunk.</span></span><br><span class="line">        <span class="keyword">auto</span> [tablet_id, is_eos] = _should_emit_eos(res);</span><br><span class="line">        <span class="built_in">eval_runtime_bloom_filters</span>(res.<span class="built_in">get</span>());</span><br><span class="line">        res-&gt;<span class="built_in">owner_info</span>().<span class="built_in">set_owner_id</span>(tablet_id, is_eos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="try-to-trigger-next-scan"><a href="#try-to-trigger-next-scan" class="headerlink" title="_try_to_trigger_next_scan"></a>_try_to_trigger_next_scan</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Status ScanOperator::_try_to_trigger_next_scan(RuntimeState* state) &#123;</span><br><span class="line">    <span class="comment">// to sure to put it here for updating state.</span></span><br><span class="line">    <span class="comment">// because we want to update state based on raw data.</span></span><br><span class="line">    <span class="type">int</span> total_cnt = <span class="built_in">available_pickup_morsel_count</span>();</span><br><span class="line">    <span class="keyword">if</span> (_num_running_io_tasks &gt;= _io_tasks_per_scan_operator) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Avoid uneven distribution when io tasks execute very fast, so we start</span></span><br><span class="line">    <span class="comment">// traverse the chunk_source array from last visit idx</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = _io_tasks_per_scan_operator;</span><br><span class="line">    <span class="type">int</span> to_sched[_io_tasks_per_scan_operator];</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pick up already started chunk source.</span></span><br><span class="line">    <span class="keyword">while</span> (--cnt &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        _chunk_source_idx = (_chunk_source_idx + <span class="number">1</span>) % _io_tasks_per_scan_operator;</span><br><span class="line">        <span class="type">int</span> i = _chunk_source_idx;</span><br><span class="line">        <span class="keyword">if</span> (_is_io_task_running[i]) &#123;</span><br><span class="line">            total_cnt -= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_chunk_sources[i] != <span class="literal">nullptr</span> &amp;&amp; _chunk_sources[i]-&gt;<span class="built_in">has_next_chunk</span>()) &#123;</span><br><span class="line">            <span class="built_in">RETURN_IF_ERROR</span>(_trigger_next_scan(state, i));</span><br><span class="line">            total_cnt -= <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            to_sched[size++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size = std::<span class="built_in">min</span>(size, total_cnt);</span><br><span class="line">    <span class="comment">// pick up new chunk source.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="type">int</span> idx = to_sched[i];</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_pickup_morsel(state, idx));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ScanOperator-pull-chunk&quot;&gt;&lt;a href=&quot;#ScanOperator-pull-chunk&quot; class=&quot;headerlink&quot; title=&quot;ScanOperator::pull_chunk&quot;&gt;&lt;/a&gt;ScanOperator::pu</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="Pipeline" scheme="https://szza.github.io/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>Morsel 和 OlapScanOperator (2)</title>
    <link href="https://szza.github.io/2023/07/05/Pipeline/MorselQueue_2/"/>
    <id>https://szza.github.io/2023/07/05/Pipeline/MorselQueue_2/</id>
    <published>2023-07-05T08:10:02.000Z</published>
    <updated>2023-08-13T13:04:34.034Z</updated>
    
    <content type="html"><![CDATA[<p>和 Morsel 有关的 SourceOperator 的类继承关系如下：<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-OlapScanOperator-2.svg?raw=true" alt="Pipeline-OlapScanOperator-2"></p><p>从 Morsel 到 OlapScanOperator 的执行流程如下:<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-OlapScanOperator-1.svg?raw=true" alt="Pipeline-OlapScanOperator-1"></p><p>OlapPrepareOperator 和 OlapScanOperator 共享一个 MorselQueue，<u>也是通过这个 MorselQueue 建立依赖关系</u>: 当 <em>OlapPrepareOperator::pull_chunk</em> 执行完毕，OlapScanOperator::pull_chunk 就可以从该 MorselQueue 中取出 morsel，进而才从存储层中读取数据。</p><p>构建 Pipeline 的过程为这两个 Pipelines 的输入设置了同一个 MorselQueue，具体过程在 <a href="https://github.com/StarRocks/starrocks/blob/a22ef531281e56a84f9b620c8730a184bc8f0019/be/src/exec/pipeline/fragment_executor.cpp#L552C1-L552C1">FragmentExecutor::_prepare_pipeline_driver</a> 函数处。</p><h2 id="OlapScanNode-decompose-to-pipeline"><a href="#OlapScanNode-decompose-to-pipeline" class="headerlink" title="OlapScanNode::decompose_to_pipeline"></a>OlapScanNode::decompose_to_pipeline</h2><p>通过 decompose_to_pipeline 函数将 ExecNode 分解为上图中 Operators，生成两个 Piplines。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pipeline::OpFactories <span class="title">OlapScanNode::decompose_to_pipeline</span><span class="params">(pipeline::PipelineBuilderContext* context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Set the dop according to requested parallelism and number of morsels</span></span><br><span class="line">    <span class="keyword">auto</span>* morsel_queue_factory = context-&gt;<span class="built_in">morsel_queue_factory_of_source_operator</span>(<span class="built_in">id</span>());</span><br><span class="line">    <span class="type">size_t</span> dop = morsel_queue_factory-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">bool</span> shared_morsel_queue = morsel_queue_factory-&gt;<span class="built_in">is_shared</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> max_buffer_capacity = pipeline::ScanOperator::<span class="built_in">max_buffer_capacity</span>() * dop;</span><br><span class="line">    <span class="type">size_t</span> default_buffer_capacity = std::<span class="built_in">min</span>&lt;<span class="type">size_t</span>&gt;(max_buffer_capacity, <span class="built_in">estimated_max_concurrent_chunks</span>());</span><br><span class="line">    pipeline::ChunkBufferLimiterPtr buffer_limiter = std::<span class="built_in">make_unique</span>&lt;pipeline::DynamicChunkBufferLimiter&gt;(</span><br><span class="line">            max_buffer_capacity, default_buffer_capacity, _mem_limit, <span class="built_in">runtime_state</span>()-&gt;<span class="built_in">chunk_size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scan_ctx_factory = std::<span class="built_in">make_shared</span>&lt;pipeline::OlapScanContextFactory&gt;(</span><br><span class="line">            <span class="keyword">this</span>, dop, shared_morsel_queue, _enable_shared_scan, std::<span class="built_in">move</span>(buffer_limiter));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; rc_rf_probe_collector = std::<span class="built_in">make_shared</span>&lt;RcRfProbeCollector&gt;(<span class="number">2</span>, std::<span class="built_in">move</span>(<span class="keyword">this</span>-&gt;<span class="built_in">runtime_filter_collector</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scan_prepare_op.</span></span><br><span class="line">    <span class="keyword">auto</span> scan_prepare_op = std::<span class="built_in">make_shared</span>&lt;pipeline::OlapScanPrepareOperatorFactory&gt;(context-&gt;<span class="built_in">next_operator_id</span>(), <span class="built_in">id</span>(),</span><br><span class="line">                                                                                      <span class="keyword">this</span>, scan_ctx_factory);</span><br><span class="line">    scan_prepare_op-&gt;<span class="built_in">set_degree_of_parallelism</span>(shared_morsel_queue ? <span class="number">1</span> : dop);</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">init_runtime_filter_for_operator</span>(scan_prepare_op.<span class="built_in">get</span>(), context, rc_rf_probe_collector);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> scan_prepare_pipeline = pipeline::OpFactories&#123;</span><br><span class="line">            std::<span class="built_in">move</span>(scan_prepare_op),</span><br><span class="line">            std::<span class="built_in">make_shared</span>&lt;pipeline::NoopSinkOperatorFactory&gt;(context-&gt;<span class="built_in">next_operator_id</span>(), <span class="built_in">id</span>()),</span><br><span class="line">    &#125;;</span><br><span class="line">    context-&gt;<span class="built_in">add_pipeline</span>(scan_prepare_pipeline);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// scan_op.</span></span><br><span class="line">    <span class="keyword">auto</span> scan_op = std::<span class="built_in">make_shared</span>&lt;pipeline::OlapScanOperatorFactory&gt;(context-&gt;<span class="built_in">next_operator_id</span>(), <span class="keyword">this</span>,</span><br><span class="line">                                                                       std::<span class="built_in">move</span>(scan_ctx_factory));</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">init_runtime_filter_for_operator</span>(scan_op.<span class="built_in">get</span>(), context, rc_rf_probe_collector);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pipeline::<span class="built_in">decompose_scan_node_to_pipeline</span>(scan_op, <span class="keyword">this</span>, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行此函数前，已经使用 <a href="https://szza.github.io/2023/07/02/Pipeline/MorselQueue_1/#convert-scan-range-to-morsel-queue-factory">convert-scan-range-to-morsel-queue-factory</a> 函数为每个输入分配了一个 MorselQueueFactory。</p><p>下面需要将每个 OlapScanNode 分解为 Operators，后续再根据 pipeline_dop，生成 pipeline_dop 个 PipelineDrivers，而这 pipeline_dop 个 PipelineDrivers 要么共享一个 MorselQueue，要么每个 PipelineDriver 都分配一个 MorselQueue，具体情况由 MorselQueueFactory::is_shared()d函数来确定：</p><ul><li>SharedMorselQueueFactory::is_shared() 为 true</li><li>IndividualMorselQueueFactory::is_shared() 为 false</li></ul><p>在 <em>shared_morsel_queue</em> 为 true 时，共享同一个 MorselQueue 的 OlapScanOperators，也需要共享同一个 OlapScanContext。此时，会忽略 <em>OlapScanContextFactory::get_or_create</em> 的传入参数 driver_sequence，只创建一个 OlapScanContext 对象。 反之，则创建 pipeline_dop 个 OlapScanContext。逻辑和 <em>MorselQueueFactory::create</em> 函数类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">OlapScanContextPtr <span class="title">OlapScanContextFactory::get_or_create</span><span class="params">(<span class="type">int32_t</span> driver_sequence)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK_LT</span>(driver_sequence, _dop);</span><br><span class="line">    <span class="comment">// ScanOperators sharing one morsel use the same context.</span></span><br><span class="line">    <span class="type">int32_t</span> idx = _shared_morsel_queue ? <span class="number">0</span> : driver_sequence;</span><br><span class="line">    <span class="built_in">DCHECK_LT</span>(idx, _contexts.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_contexts[idx] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        _contexts[idx] = std::<span class="built_in">make_shared</span>&lt;OlapScanContext&gt;(_scan_node, _dop, _shared_scan, _chunk_buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _contexts[idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OlapScanContext"><a href="#OlapScanContext" class="headerlink" title="OlapScanContext"></a>OlapScanContext</h2><p>OlapScanContextFactory 的构造函数中会根据是否 <em>shared_morsel_queue</em> 的值为 <strong>_contexts</strong> 数组初始化合理大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">OlapScanContextFactory</span>(vectorized::OlapScanNode* <span class="type">const</span> scan_node, <span class="type">int32_t</span> dop,</span><br><span class="line">                       <span class="type">bool</span> shared_morsel_queue, <span class="type">bool</span> shared_scan,</span><br><span class="line">                       ChunkBufferLimiterPtr chunk_buffer_limiter)</span><br><span class="line">        : _scan_node(scan_node),</span><br><span class="line">          _dop(dop),</span><br><span class="line">          _shared_morsel_queue(shared_morsel_queue),</span><br><span class="line">          _shared_scan(shared_scan),</span><br><span class="line">          _chunk_buffer(shared_scan ? BalanceStrategy::kRoundRobin : BalanceStrategy::kDirect,</span><br><span class="line">                        dop, std::<span class="built_in">move</span>(chunk_buffer_limiter)),</span><br><span class="line">          _contexts(shared_morsel_queue ? <span class="number">1</span> : dop) &#123;&#125;</span><br></pre></td></tr></table></figure><p>OlapScanContext 字段大致分为以下三部分。</p><ul><li><p>part1: 待读取的数据元信息</p><p>_conjunct_ctxs: 是本次的 SQL 查询中 <strong>where</strong> 后的 AND predicates，以及某些查询条件改写后<br>_not_push_down_conjuncts: 是无法下推到存储层的判断条件<br>_key_ranges: 是本次查询范围<br>_dict_optimize_parser: 用于低基数优化，rewrite 谓词</p></li><li><p>part2: 用于 shared_scan 机制</p></li><li><p>part3: 用于防止本次查询的数据在 SQL 执行过程中被删除了，事先增加一次引用计数</p></li></ul><p>OlapScanContext 字段如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OlapScanContext</span> <span class="keyword">final</span> : <span class="keyword">public</span> ContextWithDependency &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// part1: meta data</span></span><br><span class="line">    vectorized::OlapScanNode* _scan_node;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;ExprContext*&gt; _conjunct_ctxs;</span><br><span class="line">    vectorized::OlapScanConjunctsManager _conjuncts_manager;</span><br><span class="line">    <span class="comment">// The conjuncts couldn&#x27;t push down to storage engine</span></span><br><span class="line">    std::vector&lt;ExprContext*&gt; _not_push_down_conjuncts;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;OlapScanRange&gt;&gt; _key_ranges;</span><br><span class="line">    vectorized::DictOptimizeParser _dict_optimize_parser;</span><br><span class="line">    ObjectPool _obj_pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// part2: For shared_scan mechanism</span></span><br><span class="line">    <span class="keyword">using</span> ActiveInputKey = std::pair&lt;<span class="type">int32_t</span>, <span class="type">int32_t</span>&gt;;</span><br><span class="line">    <span class="keyword">using</span> ActiveInputSet = phmap::parallel_flat_hash_set&lt;</span><br><span class="line">            ActiveInputKey, <span class="keyword">typename</span> phmap::Hash&lt;ActiveInputKey&gt;, <span class="keyword">typename</span> phmap::EqualTo&lt;ActiveInputKey&gt;,</span><br><span class="line">            <span class="keyword">typename</span> std::allocator&lt;ActiveInputKey&gt;, NUM_LOCK_SHARD_LOG, std::mutex, <span class="literal">true</span>&gt;;</span><br><span class="line">    BalancedChunkBuffer&amp; _chunk_buffer;</span><br><span class="line">    ActiveInputSet _active_inputs;</span><br><span class="line">    <span class="type">bool</span> _shared_scan;</span><br><span class="line"></span><br><span class="line">    std::atomic&lt;<span class="type">bool</span>&gt; _is_prepare_finished&#123;<span class="literal">false</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parrt3: avoid to be deleted beacuse of compactions, </span></span><br><span class="line">    <span class="comment">//         increase reference in perpare stage</span></span><br><span class="line">    std::vector&lt;TabletSharedPtr&gt; _tablets;</span><br><span class="line">    std::vector&lt;std::vector&lt;RowsetSharedPtr&gt;&gt; _tablet_rowsets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="capture-tablet-rowsets"><a href="#capture-tablet-rowsets" class="headerlink" title="capture_tablet_rowsets"></a>capture_tablet_rowsets</h3><p>StarRocks 中 Operators&#x2F;ExecNode 的执行流程基本都是 <code>prepare -&gt; open -&gt; get_next -&gt; close</code>。<br>而 <em>OlapScanContext::capture_tablet_rowsets</em> 会在 OlapScanPrepareOperator::prepare 中执行，<u>防止在 SQL 执行过程中（即 get_next 函数读取数据过程中）tablet&#x2F;rowset 被删除</u>。函数本身是比较简单:</p><ol><li>基于 <em>scan_range-&gt;tablet_id</em> 从 TabletManger 中获得 tablet</li><li>再基于 <em>scan_range-&gt;version</em> 从 tablet 中获得本次需要查询的 rowsets</li></ol><p>代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">OlapScanContext::capture_tablet_rowsets</span><span class="params">(<span class="type">const</span> std::vector&lt;TInternalScanRange*&gt;&amp; olap_scan_ranges)</span> </span>&#123;</span><br><span class="line">    _tablet_rowsets.<span class="built_in">resize</span>(olap_scan_ranges.<span class="built_in">size</span>());</span><br><span class="line">    _tablets.<span class="built_in">resize</span>(olap_scan_ranges.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; olap_scan_ranges.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span>* scan_range = olap_scan_ranges[i];</span><br><span class="line">        <span class="type">int64_t</span> version = <span class="built_in">strtoul</span>(scan_range-&gt;version.<span class="built_in">c_str</span>(), <span class="literal">nullptr</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="comment">//1. 获得 tablet</span></span><br><span class="line">        <span class="built_in">ASSIGN_OR_RETURN</span>(TabletSharedPtr tablet, vectorized::OlapScanNode::<span class="built_in">get_tablet</span>(scan_range));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Capture row sets of this version tablet.</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 2. 获得 rowset</span></span><br><span class="line">            <span class="function">std::shared_lock <span class="title">l</span><span class="params">(tablet-&gt;get_header_lock())</span></span>;</span><br><span class="line">            <span class="built_in">RETURN_IF_ERROR</span>(tablet-&gt;<span class="built_in">capture_consistent_rowsets</span>(<span class="built_in">Version</span>(<span class="number">0</span>, version), &amp;_tablet_rowsets[i]));</span><br><span class="line">            Rowset::<span class="built_in">acquire_readers</span>(_tablet_rowsets[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _tablets[i] = std::<span class="built_in">move</span>(tablet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OlapScanPrepareOperator"><a href="#OlapScanPrepareOperator" class="headerlink" title="OlapScanPrepareOperator"></a>OlapScanPrepareOperator</h2><p>OlapScanPrepareOperator 内就一个 OlapScanContext 字段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OlapScanPrepareOperator</span> <span class="keyword">final</span> : <span class="keyword">public</span> SourceOperator &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">OlapScanPrepareOperator</span>(OperatorFactory* factory, <span class="type">int32_t</span> id,</span><br><span class="line">                            <span class="type">const</span> string&amp; name, <span class="type">int32_t</span> plan_node_id,</span><br><span class="line">                            <span class="type">int32_t</span> driver_sequence, OlapScanContextPtr ctx)</span><br><span class="line">        : <span class="built_in">SourceOperator</span>(factory, id, name, plan_node_id, driver_sequence), </span><br><span class="line">          _ctx(std::<span class="built_in">move</span>(ctx)) &#123;</span><br><span class="line">        _ctx-&gt;<span class="built_in">ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~OlapScanPrepareOperator::~<span class="built_in">OlapScanPrepareOperator</span>() &#123;</span><br><span class="line">       <span class="keyword">auto</span>* state = <span class="built_in">runtime_state</span>();</span><br><span class="line">       <span class="keyword">if</span> (state == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       _ctx-&gt;<span class="built_in">unref</span>(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Status <span class="title">prepare</span><span class="params">(RuntimeState* state)</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">(RuntimeState* state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">has_output</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">is_finished</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">StatusOr&lt;vectorized::ChunkPtr&gt; <span class="title">pull_chunk</span><span class="params">(RuntimeState* state)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    OlapScanContextPtr _ctx;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="pull-chunk"><a href="#pull-chunk" class="headerlink" title="pull_chunk"></a>pull_chunk</h3><p>顾名思义，在 OlapScanPrepareOperator 中需要完成的是准备工作，在这里完成的给每个 SourceOperator::_morsel_queue 检测本次所需读取的 tablets&#x2F;rowsets 是否存在，存在则将其赋值给 _morsel_queue。</p><p>pull_chunk 执行完，OlapScanPrepareOperator 的生命周期就结束了，会进入下一个算子 NoopSinkOperator：<strong>PipelineDriver 检测到 OlapScanPrepareOperator 算子完成后就会将其结果 push 到 NoopSinkOperator 中</strong>。</p><p>由 OlapScanPrepareOperator 和 OpenSacnOperator 共享一个 OlapScanContext，因此 OlapScanPrepareOperator 的下一个算子 NoopSinkOperator::push_chunk 没有任何操作，因为只要 OlapScanPrepareOperator::pull_chunk 执行完毕，则 OpenSacnOperator 的前置依赖就完成了，就可以开始执行：即从存储层中读数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">OlapScanPrepareOperator::prepare</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(SourceOperator::<span class="built_in">prepare</span>(state));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_ctx-&gt;<span class="built_in">prepare</span>(state));</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_ctx-&gt;<span class="built_in">capture_tablet_rowsets</span>(_morsel_queue-&gt;<span class="built_in">olap_scan_ranges</span>()));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">StatusOr&lt;vectorized::ChunkPtr&gt; <span class="title">OlapScanPrepareOperator::pull_chunk</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    Status status = _ctx-&gt;<span class="built_in">parse_conjuncts</span>(state, <span class="built_in">runtime_in_filters</span>(), <span class="built_in">runtime_bloom_filters</span>());</span><br><span class="line"></span><br><span class="line">    _morsel_queue-&gt;<span class="built_in">set_key_ranges</span>(_ctx-&gt;<span class="built_in">key_ranges</span>());</span><br><span class="line">    _morsel_queue-&gt;<span class="built_in">set_tablets</span>(_ctx-&gt;<span class="built_in">tablets</span>());</span><br><span class="line">    _morsel_queue-&gt;<span class="built_in">set_tablet_rowsets</span>(_ctx-&gt;<span class="built_in">tablet_rowsets</span>());</span><br><span class="line"></span><br><span class="line">    _ctx-&gt;<span class="built_in">set_prepare_finished</span>();</span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        _ctx-&gt;<span class="built_in">set_finished</span>();</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Status <span class="title">NoopSinkOperator::push_chunk</span><span class="params">(RuntimeState* state, <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;和 Morsel 有关的 SourceOperator 的类继承关系如下：&lt;br&gt;&lt;img src=&quot;https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-OlapScanO</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="Pipeline" scheme="https://szza.github.io/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>Morsel 和 OlapScanOperator (1)</title>
    <link href="https://szza.github.io/2023/07/02/Pipeline/MorselQueue_1/"/>
    <id>https://szza.github.io/2023/07/02/Pipeline/MorselQueue_1/</id>
    <published>2023-07-02T08:00:02.000Z</published>
    <updated>2023-08-13T07:23:23.103Z</updated>
    
    <content type="html"><![CDATA[<p>MorselQueue 用于存放本次待读取的数据源 Morsels 集合，继承派生体系如下：</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-morsel-3.svg?raw=true" alt="Morsel-Queue"></p><h3 id="convert-scan-range-to-morsel-queue"><a href="#convert-scan-range-to-morsel-queue" class="headerlink" title="convert_scan_range_to_morsel_queue"></a>convert_scan_range_to_morsel_queue</h3><p><code>convert_scan_range_to_morsel_queue</code> 函数将本次带查询的数据源 <code>scan_ranges</code> 转换成 <code>std::vector&lt;pipeline::Morsel&gt;</code> 对象 <code>morsels</code>，并根据是否能开启 <code>Tablet</code> 选择具体的 MorselQueue 子类。</p><p>因此，区别在于 <code>morsels</code> 在 MorselQueue 内部怎么划分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;pipeline::MorselQueuePtr&gt; <span class="title">OlapScanNode::convert_scan_range_to_morsel_queue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;TScanRangeParams&gt;&amp; scan_ranges, <span class="type">int</span> node_id, <span class="type">int32_t</span> pipeline_dop,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> enable_tablet_internal_parallel, TTabletInternalParallelMode::type tablet_internal_parallel_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> num_total_scan_ranges)</span> </span>&#123;</span><br><span class="line">    pipeline::Morsels morsels;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; scan_range : scan_ranges) &#123;</span><br><span class="line">        morsels.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;pipeline::ScanMorsel&gt;(node_id, scan_range));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// None tablet to read shouldn&#x27;t use tablet internal parallel.</span></span><br><span class="line">    <span class="keyword">if</span> (morsels.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::FixedMorselQueue&gt;(std::<span class="built_in">move</span>(morsels));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable by the session variable shouldn&#x27;t use tablet internal parallel.</span></span><br><span class="line">    <span class="keyword">if</span> (!enable_tablet_internal_parallel) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::FixedMorselQueue&gt;(std::<span class="built_in">move</span>(morsels));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> scan_dop;</span><br><span class="line">    <span class="type">int64_t</span> splitted_scan_rows;</span><br><span class="line">    <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> could,</span><br><span class="line">                     _could_tablet_internal_parallel(scan_ranges, pipeline_dop, num_total_scan_ranges,</span><br><span class="line">                                                     tablet_internal_parallel_mode, &amp;scan_dop, &amp;splitted_scan_rows));</span><br><span class="line">    <span class="keyword">if</span> (!could) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::FixedMorselQueue&gt;(std::<span class="built_in">move</span>(morsels));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split tablet physically.</span></span><br><span class="line">    <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="type">bool</span> ok, _could_split_tablet_physically(scan_ranges));</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::PhysicalSplitMorselQueue&gt;(std::<span class="built_in">move</span>(morsels), scan_dop, splitted_scan_rows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::LogicalSplitMorselQueue&gt;(std::<span class="built_in">move</span>(morsels), scan_dop, splitted_scan_rows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="could-tablet-internal-parallel"><a href="#could-tablet-internal-parallel" class="headerlink" title="_could_tablet_internal_parallel"></a>_could_tablet_internal_parallel</h3><p>变量 <code>enable_tablet_internal_parallel</code> 为 true 时，只是建议开启 tablet 并行，能不能真开启还要使用 <em>_could_tablet_internal_parallel</em> 函数根据实际多个因素判断。</p><ul><li><p>主键模型开启了持久化索引 use_pk_index 为 false</p></li><li><p>tablet_internal_parallel_mode 默认值是 TTabletInternalParallelMode::AUTO，如果不是主动设置为 FORCE_SPLIT，并且实际的读取的 num_total_scan_ranges  &gt;&#x3D; 本次 Pipeline 的并行度 pipeline_dop， 也返回 false</p><p>  如果 num_total_scan_ranges &gt;&#x3D; pipeline_dop，则说明当前有非常多的 tablet 待读取，不应该再把划分，否则会导致很多竞争。</p></li><li><p>统计本次需要读取的行数 num_table_rows</p><p>  config::tablet_internal_parallel_max_splitted_scan_bytes，默认是 512M，是单次从一个 segment 文件中读取的最大字节数，_estimated_scan_row_bytes 本次要读取的所有字段类型的大小（即一行数据的大小），二者相除的结果 splitted_scan_rows 即单次从 segment 文件中读取的最大行数。</p><p>  再将 <strong>splitted_scan_rows</strong> 限制在 <em>[min_splitted_scan_rows, max_splitted_scan_rows]</em> 区间，</p><p>  先估计本次的 <strong>scan_dop</strong> &#x3D; num_table_rows &#x2F; splitted_scan_rows，再将 scan_dop 限制到 [1, pipeline_dop] 区间。</p><p>  只要 scan_dop &gt; pipeline_dop 或者 config::tablet_internal_parallel_min_scan_dop 本函数就返回 true。</p></li></ul><p>因此，如果函数返回 false 上层就直接启用 FixedMorselQueue 来粗存储本次数据源 Morsels，返回 true 则会使用 SplitMorseQueue。</p><p><em>scan_dop</em>, <em>splitted_scan_rows</em> 两个参数输出后再作为 SplitMorselQueue 的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">StatusOr&lt;<span class="type">bool</span>&gt; OlapScanNode::_could_tablet_internal_parallel(</span><br><span class="line">        <span class="type">const</span> std::vector&lt;TScanRangeParams&gt;&amp; scan_ranges, <span class="type">int32_t</span> pipeline_dop, <span class="type">size_t</span> num_total_scan_ranges,</span><br><span class="line">        TTabletInternalParallelMode::type tablet_internal_parallel_mode, <span class="type">int64_t</span>* scan_dop,</span><br><span class="line">        <span class="type">int64_t</span>* splitted_scan_rows) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (_olap_scan_node.use_pk_index) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> force_split = tablet_internal_parallel_mode == TTabletInternalParallelMode::type::FORCE_SPLIT;</span><br><span class="line">    <span class="comment">// The enough number of tablets shouldn&#x27;t use tablet internal parallel.</span></span><br><span class="line">    <span class="keyword">if</span> (!force_split &amp;&amp; num_total_scan_ranges &gt;= pipeline_dop) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> num_table_rows = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; tablet_scan_range : scan_ranges) &#123;</span><br><span class="line">        <span class="built_in">ASSIGN_OR_RETURN</span>(TabletSharedPtr tablet, <span class="built_in">get_tablet</span>(&amp;(tablet_scan_range.scan_range.internal_scan_range)));</span><br><span class="line">        num_table_rows += <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(tablet-&gt;<span class="built_in">num_rows</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// splitted_scan_rows is restricted in the range [min_splitted_scan_rows, max_splitted_scan_rows].</span></span><br><span class="line">    *splitted_scan_rows = config::tablet_internal_parallel_max_splitted_scan_bytes / _estimated_scan_row_bytes;</span><br><span class="line">    *splitted_scan_rows =</span><br><span class="line">            std::<span class="built_in">max</span>(config::tablet_internal_parallel_min_splitted_scan_rows,</span><br><span class="line">                     std::<span class="built_in">min</span>(*splitted_scan_rows, config::tablet_internal_parallel_max_splitted_scan_rows));</span><br><span class="line">    <span class="comment">// scan_dop is restricted in the range [1, dop].</span></span><br><span class="line">    *scan_dop = num_table_rows / *splitted_scan_rows;</span><br><span class="line">    *scan_dop = std::<span class="built_in">max</span>&lt;<span class="type">int64_t</span>&gt;(<span class="number">1</span>, std::<span class="built_in">min</span>&lt;<span class="type">int64_t</span>&gt;(*scan_dop, pipeline_dop));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (force_split) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> could = *scan_dop &gt;= pipeline_dop || *scan_dop &gt;= config::tablet_internal_parallel_min_scan_dop;</span><br><span class="line">    <span class="keyword">return</span> could;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FixedMorselQueue"><a href="#FixedMorselQueue" class="headerlink" title="FixedMorselQueue"></a>FixedMorselQueue</h2><p>顾名思义，<code>FixedMorselQueue</code> 存储是固定数据量的 Morsels，<code>FixedMorselQueue::_morsels</code> 都是 ScanMorsel 对象（不是 ScanMorsel 的子类），即是以 tablet 为级别，后续 TabletReader 要从存储层查询该 _morsels[i] 指向的数据时，是需要 FullScan。</p><p>当从 OlapScanOperator 从存储层获得数据后，才会调用 <code>FixedMorselQueue::set_tablet_rowsets</code> 函数将数据赋值给 <code>_tablet_rowsets</code>，进而 ScanOperator::pull 就可以从 <code>FixedMorselQueue::try_get</code> 函数从 _tablet_rowsets 中获得数据，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FixedMorselQueue</span> <span class="keyword">final</span> : <span class="keyword">public</span> MorselQueue &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">FixedMorselQueue</span><span class="params">(Morsels&amp;&amp; morsels)</span></span></span><br><span class="line"><span class="function">            : _morsels(std::move(morsels)), _num_morsels(_morsels.size()), _pop_index(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">    ~<span class="built_in">FixedMorselQueue</span>() <span class="keyword">override</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;TInternalScanRange*&gt; <span class="title">olap_scan_ranges</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_tablet_rowsets</span><span class="params">(<span class="type">const</span> std::vector&lt;std::vector&lt;RowsetSharedPtr&gt;&gt;&amp; tablet_rowsets)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        _tablet_rowsets = tablet_rowsets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">num_original_morsels</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> _num_morsels; &#125;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">max_degree_of_parallelism</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> _num_morsels; &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> _unget_morsel == <span class="literal">nullptr</span> &amp;&amp; _pop_index &gt;= _num_morsels; &#125;</span><br><span class="line">    <span class="function">StatusOr&lt;MorselPtr&gt; <span class="title">try_get</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">name</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="string">&quot;fixed_morsel_queue&quot;</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Morsels _morsels;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> _num_morsels;</span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; _pop_index;</span><br><span class="line">    std::vector&lt;std::vector&lt;RowsetSharedPtr&gt;&gt; _tablet_rowsets;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="FixedMorselQueue-try-get"><a href="#FixedMorselQueue-try-get" class="headerlink" title="FixedMorselQueue::try_get"></a>FixedMorselQueue::try_get</h3><p>FixedMorselQueue 是有可能在多个 Pipeline 线程之间共享，即共享数据源，多个 Pipelines 同时从 FixedMorselQueue 获取数据源信息。而 FixedMorselQueue::_morsels 大小在构造函数已经确定，且 FixedMorselQueue 内部不会再细分每个 morsel（和 SplitMorselQueue 的对比），因此可以将 FixedMorselQueue 设计成 LookFree 的数据结构，因此使用 _pop_index 来指向当前已经分配的 morsel 就能满足要求。</p><p>在 FixedMorselQueue::try_get 中，通 <strong>std::move</strong> 将 _morsels[idx]、_tablet_rowsets[idx] 中的数据转移给上层，这样不会破坏 _morsels、_tablet_rowsets 结构，在多线程只读场景下就不用 mutex 保护。当 _pop_index &#x3D;&#x3D; _num_morsels, _tablet_rowsets 和 _morsels 就是大小为 _num_morsels 的空壳。如此，也就实现了 LookFree。</p><p>源码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;MorselPtr&gt; <span class="title">FixedMorselQueue::try_get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 和 QueryCache 有关</span></span><br><span class="line">    <span class="keyword">if</span> (_unget_morsel != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(_unget_morsel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> idx = _pop_index.<span class="built_in">load</span>();</span><br><span class="line">    <span class="comment">// prevent _num_morsels from superfluous addition</span></span><br><span class="line">    <span class="keyword">if</span> (idx &gt;= _num_morsels) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    idx = _pop_index.<span class="built_in">fetch_add</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (idx &lt; _num_morsels) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_tablet_rowsets.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _morsels[idx]-&gt;<span class="built_in">set_rowsets</span>(std::<span class="built_in">move</span>(_tablet_rowsets[idx]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">move</span>(_morsels[idx]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SplitMorselQueue"><a href="#SplitMorselQueue" class="headerlink" title="SplitMorselQueue"></a>SplitMorselQueue</h2><p>scan_dop 传递给 SplitMorselQueue::_degree_of_parallelism，后续用于生成 MorselQueueFactory。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SplitMorselQueue::<span class="built_in">SplitMorselQueue</span>(Morsels&amp;&amp; morsels, <span class="type">int64_t</span> degree_of_parallelism, <span class="type">int64_t</span> splitted_scan_rows)</span><br><span class="line">  : _morsels(std::<span class="built_in">move</span>(morsels)),</span><br><span class="line">    _num_original_morsels(_morsels.<span class="built_in">size</span>()),</span><br><span class="line">    _degree_of_parallelism(degree_of_parallelism),</span><br><span class="line">    _splitted_scan_rows(splitted_scan_rows) &#123;&#125;</span><br></pre></td></tr></table></figure><p>SplitMorselQueue 有两个子类，根据 _could_split_tablet_physically 函数来选择。只有在表类型是聚合模型（即 AGG_KEYS 或者 UNIQUE_KEYS）且数据尚未聚合完成（skip_aggr 为 false）时，该函数才会返回 false。</p><p>返回 true 时，选择 PhysicalSplitMorselQueue，否则选择 LogicalSplitMorselQueue 对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">StatusOr&lt;<span class="type">bool</span>&gt; OlapScanNode::_could_split_tablet_physically(<span class="type">const</span> std::vector&lt;TScanRangeParams&gt;&amp; scan_ranges) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="comment">// Keys type needn&#x27;t merge or aggregate.</span></span><br><span class="line">    <span class="built_in">ASSIGN_OR_RETURN</span>(TabletSharedPtr first_tablet, <span class="built_in">get_tablet</span>(&amp;(scan_ranges[<span class="number">0</span>].scan_range.internal_scan_range)));</span><br><span class="line">    KeysType keys_type = first_tablet-&gt;<span class="built_in">tablet_schema</span>().<span class="built_in">keys_type</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> skip_aggr = <span class="built_in">thrift_olap_scan_node</span>().is_preaggregation;</span><br><span class="line">    <span class="keyword">return</span> keys_type == PRIMARY_KEYS || keys_type == DUP_KEYS ||</span><br><span class="line">           ((keys_type == UNIQUE_KEYS || keys_type == AGG_KEYS) &amp;&amp; skip_aggr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PhysicalSplitMorselQueue-try-get"><a href="#PhysicalSplitMorselQueue-try-get" class="headerlink" title="PhysicalSplitMorselQueue::try_get"></a>PhysicalSplitMorselQueue::try_get</h3><p>StarRocks 中数据持久化后文件的基本单位是 Segment，一个 Tablet 数据组织结构是 Tablet&#x2F;Rowset&#x2F;Segment，每次从 Segment 中读取的行数是 _splitted_scan_rows，因此可以将 PhysicalSplitMorselQueue::try_get 分为两个部分:</p><ol><li><p>检测 _cur_segment 是否为空，以及 _cur_segment 是还有剩余可读数据</p><p> 如果没有，则需要从磁盘中能读取下一个 Segment 文件，将其加载到内存中，生成 SegemntIterator 对象 <strong>_segment_range_iter</strong>，再进行下一步</p>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;MorselPtr&gt; <span class="title">PhysicalSplitMorselQueue::try_get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (_tablet_idx &gt;= _tablets.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When it hasn&#x27;t initialized any segment,</span></span><br><span class="line">    <span class="comment">// or _segment_idx exceeds the segments of the current rowset,</span></span><br><span class="line">    <span class="comment">// or current segment is empty or finished,</span></span><br><span class="line">    <span class="comment">// we should pick up the next segment and init it.</span></span><br><span class="line">    <span class="keyword">while</span> (!_has_init_any_segment || _cur_segment() == <span class="literal">nullptr</span> || _cur_segment()-&gt;<span class="built_in">num_rows</span>() == <span class="number">0</span> ||</span><br><span class="line">           !_segment_range_iter.<span class="built_in">has_more</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_next_segment()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> status = _init_segment(); !status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">            <span class="comment">// Morsel_queue cannot generate morsels after errors occurring.</span></span><br><span class="line">            _tablet_idx = _tablets.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">return</span> status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当仍有待读取的数据，则通过 <em>_segment_range_iter</em> 获取下一个批次数据（即 _splitted_scan_rows 行），如果剩余的数据不足 _splitted_scan_rows 行，则将剩余的数据合并到当前批次，（合并）生成一个 PhysicalSplitScanMorsel 对象，其中本次读取的元信息 <strong>{rowset, segment_id, token_range}</strong> 精确指示了本次要读取的数据位置，最终在读取数据时，用于初始化 <em>OlapChunkSource::_params</em> 参数的 <strong>rowid_range_option</strong> 字段。</p><p> 这里的 _tablet_rowsets[_tablet_idx] 就不能用 std::move 赋值给 Morsel 了，因为其他线程也要使用。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">StatusOr&lt;MorselPtr&gt; <span class="title">PhysicalSplitMorselQueue::try_get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_mutex)</span></span>;</span><br><span class="line">     <span class="comment">//... above code</span></span><br><span class="line"></span><br><span class="line">    vectorized::SparseRange taken_range;</span><br><span class="line">    _segment_range_iter.<span class="built_in">next_range</span>(_splitted_scan_rows, &amp;taken_range);</span><br><span class="line">    _num_segment_rest_rows -= taken_range.<span class="built_in">span_size</span>();</span><br><span class="line">    <span class="keyword">if</span> (_num_segment_rest_rows &lt; _splitted_scan_rows) &#123;</span><br><span class="line">        <span class="comment">// If there are too few rows left in the segment, take them all this time.</span></span><br><span class="line">        _segment_range_iter.<span class="built_in">next_range</span>(_splitted_scan_rows, &amp;taken_range);</span><br><span class="line">        _num_segment_rest_rows = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>* scan_morsel = _cur_scan_morsel();</span><br><span class="line">    <span class="keyword">auto</span>* rowset = _cur_rowset();</span><br><span class="line">    <span class="keyword">auto</span> rowid_range = std::<span class="built_in">make_shared</span>&lt;vectorized::RowidRangeOption&gt;(</span><br><span class="line">            rowset-&gt;<span class="built_in">rowset_id</span>(), rowset-&gt;<span class="built_in">segments</span>()[_segment_idx]-&gt;<span class="built_in">id</span>(), std::<span class="built_in">move</span>(taken_range));</span><br><span class="line"></span><br><span class="line">    MorselPtr morsel = std::<span class="built_in">make_unique</span>&lt;PhysicalSplitScanMorsel&gt;(</span><br><span class="line">            scan_morsel-&gt;<span class="built_in">get_plan_node_id</span>(), *(scan_morsel-&gt;<span class="built_in">get_scan_range</span>()), std::<span class="built_in">move</span>(rowid_range));</span><br><span class="line">    morsel-&gt;<span class="built_in">set_rowsets</span>(_tablet_rowsets[_tablet_idx]);</span><br><span class="line">    _inc_num_splits(_is_last_split_of_current_morsel());</span><br><span class="line">    <span class="keyword">return</span> morsel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="next-segment"><a href="#next-segment" class="headerlink" title="_next_segment"></a>_next_segment</h4><p>寻找下个 <em>segment</em> 是比较简单的，依次按照 segment_id&#x2F;rowset_id&#x2F;tablet_id 递增的顺序。比如，如果当前 rowset 的 segments 读取完，则 ++rowset_id，切换到当前 tablet 的下一个 rowset，如果当前 tablet 的所有 rowsets 都读取完毕，则 ++tablet_id，切换到下一个 tablet。</p><p>当 tablet_id &gt;&#x3D; _tablets.size()，_next_segment 函数返回 false，表示所有数据都已经读取完毕。</p><p>这部分代码比较简单。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Rowset* PhysicalSplitMorselQueue::_cur_rowset() &#123;</span><br><span class="line">    <span class="keyword">return</span> _tablet_rowsets[_tablet_idx][_rowset_idx].<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Segment* PhysicalSplitMorselQueue::_cur_segment() &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; segments = _cur_rowset()-&gt;<span class="built_in">segments</span>();</span><br><span class="line">    <span class="keyword">return</span> _segment_idx &gt;= segments.<span class="built_in">size</span>() ? <span class="literal">nullptr</span> : segments[_segment_idx].<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> PhysicalSplitMorselQueue::_next_segment() &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(_num_segment_rest_rows == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!_has_init_any_segment) &#123;</span><br><span class="line">        _has_init_any_segment = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Read the next segment of the current rowset.</span></span><br><span class="line">        <span class="keyword">if</span> (++_segment_idx &gt;= _cur_rowset()-&gt;<span class="built_in">segments</span>().<span class="built_in">size</span>()) &#123;</span><br><span class="line">            _segment_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// Read the next rowset of the current tablet.</span></span><br><span class="line">            <span class="keyword">if</span> (++_rowset_idx &gt;= _tablet_rowsets[_tablet_idx].<span class="built_in">size</span>()) &#123;</span><br><span class="line">                _rowset_idx = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// Read the next tablet.</span></span><br><span class="line">                ++_tablet_idx;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _tablet_idx &lt; _tablets.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="inti-segment"><a href="#inti-segment" class="headerlink" title="_inti_segment"></a>_inti_segment</h4><p>初始化 segment 要复杂点。但是也可以大致分为两个步骤：</p><ol><li><p>加载元数据</p><p> 针对每个 Tablet 都有一个查询范围 **{_range_start_key, _Range_end_key}**，两边是开闭还是闭区间由 <strong>{_range_start_op, _range_end_op}</strong> 表示。比如，如果 _range_xxx_op 中包含等于操作即闭区间，否则是开区间，这两个符号定义如下:</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">RangeStartOperation</span> &#123; GT = <span class="number">0</span>, GE, EQ &#125;;</span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">RangeEndOperation</span> &#123; LT = <span class="number">0</span>, LE, EQ &#125;;</span><br></pre></td></tr></table></figure><p> 第一步主要是将 OlapScanRange 类型的 {_range_start_key, _range_end_key} 转化为 SeekRange 类型的 _tablet_seek_ranges，这样方便后续遍历。</p><p> 注意：这里的 <em>_range_start_key</em> 和 <em>_range_end_key</em> 都是 std::vector 类型，可能包含多个查询范围，比如 1 &lt; x &lt;&#x3D; 2, 10 &lt; y &lt; 20，而起始条件都在 _range_start_key 中，终止条件都在 _Range_end_key 中。</p><p> <strong>顺带提下</strong>，在读过程中，数据的内存分配方式基本都是基于内存池 MemPool。这个 MemPool 只是缓存作用，实际内部分配内存的操作是由 ChunkAllocator 完成，其分配内存特点是先在线程所在 core 上分配，如果线程所在 core 上分配的内存超过了限制（默认2G）则会 cross-core 分配，这样可以减少线程跨 core 通信。</p><p>因为数据读取的单位是 Segment，当 segment &#x3D;&#x3D; 0 即表示需要从一个新的 Rowset 中读取数据，因此需要先调用 Rowset::load 函数初始化 Rowset::_segments，来获悉所有 semgnet 信息。</p><p>如果，当前 rowset 没有可读的数据，则 return。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Status PhysicalSplitMorselQueue::_init_segment() &#123;</span><br><span class="line">   <span class="comment">// Load the meta of the new rowset and the index of the new segment。</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="number">0</span> == _segment_idx) &#123;</span><br><span class="line">       <span class="comment">// Read a new tablet.</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="number">0</span> == _rowset_idx) &#123;</span><br><span class="line">           _tablet_seek_ranges.<span class="built_in">clear</span>();</span><br><span class="line">           _mempool.<span class="built_in">clear</span>();</span><br><span class="line">           <span class="built_in">RETURN_IF_ERROR</span>(vectorized::TabletReader::<span class="built_in">parse_seek_range</span>(</span><br><span class="line">               _tablets[_tablet_idx], _range_start_op, _range_end_op,</span><br><span class="line">               _range_start_key, _range_end_key, </span><br><span class="line">               &amp;_tablet_seek_ranges, &amp;_mempool));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// Read a new rowset.</span></span><br><span class="line">       <span class="built_in">RETURN_IF_ERROR</span>(_cur_rowset()-&gt;<span class="built_in">load</span>());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   _num_segment_rest_rows = <span class="number">0</span>;</span><br><span class="line">   _segment_scan_range.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">auto</span>* segment = _cur_segment();</span><br><span class="line">   <span class="comment">// The new rowset doesn&#x27;t contain any segment.</span></span><br><span class="line">   <span class="keyword">if</span> (segment == <span class="literal">nullptr</span> || segment-&gt;<span class="built_in">num_rows</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br></pre></td></tr></table></figure></li><li><p>step(1) 过后，得到可迭代的 <strong>_tablet_seek_ranges</strong>，下面就需要将其转化为在 Segment 中的所有读取范围，并合并到 <strong>_segment_scan_range</strong> 中。</p><p>而且 _segment_scan_range 中每一个 range 的起始位置 {lower_rowid, upper_rowid} 都待读取数据的行号，因此后续读取效率会非常高。 </p><p>比如找某个 key 在 segment 的上限位置，这是由于 _upper_bound_ordinal 函数：尝试将该 key 根据表的 short_keys 编码成 index_key，再在该 segment 中利用二分搜索定位到 key 在 segment 文件中的上限位置 <em>end</em>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">rowid_t</span> PhysicalSplitMorselQueue::_upper_bound_ordinal(Segment* segment, <span class="type">const</span> vectorized::SeekTuple&amp; key, <span class="type">bool</span> lower,</span><br><span class="line">                                                       <span class="type">rowid_t</span> end) <span class="type">const</span> &#123;</span><br><span class="line">    std::string index_key =</span><br><span class="line">            key.<span class="built_in">short_key_encode</span>(segment-&gt;<span class="built_in">num_short_keys</span>(), lower ? KEY_MINIMAL_MARKER : KEY_MAXIMAL_MARKER);</span><br><span class="line">    <span class="comment">// 定位到 key 在 segment 中的上限</span></span><br><span class="line">    <span class="keyword">auto</span> end_iter = segment-&gt;<span class="built_in">upper_bound</span>(index_key);</span><br><span class="line">    <span class="keyword">if</span> (end_iter.<span class="built_in">valid</span>()) &#123;</span><br><span class="line">        end = end_iter.<span class="built_in">ordinal</span>() * segment-&gt;<span class="built_in">num_rows_per_block</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以， <em>_upper_bound_ordinal</em> 函数也说明了step(1) 中将 OlapScanRange 转为 SeekTuple 类型的原因，因为 SeekTuple 包含每一行的 Schema，可以对查找的 key 基于 short_keys 进行编码。最后得到的 <code>_segment_scan_range</code> 即表征了 curr_segment 要读取的数据范围。</p><p>第二部分完整的代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"> Status PhysicalSplitMorselQueue::_init_segment() &#123;</span><br><span class="line">    <span class="comment">//...above code</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the rowid range of each key range in this segment.</span></span><br><span class="line">    <span class="keyword">if</span> (_tablet_seek_ranges.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _segment_scan_range.<span class="built_in">add</span>(vectorized::<span class="built_in">Range</span>(<span class="number">0</span>, segment-&gt;<span class="built_in">num_rows</span>()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(segment-&gt;<span class="built_in">load_index</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; range : _tablet_seek_ranges) &#123;</span><br><span class="line">            <span class="type">rowid_t</span> lower_rowid = <span class="number">0</span>;</span><br><span class="line">            <span class="type">rowid_t</span> upper_rowid = segment-&gt;<span class="built_in">num_rows</span>();</span><br><span class="line"></span><br><span class="line">             <span class="comment">// 上限</span></span><br><span class="line">            <span class="keyword">if</span> (!range.<span class="built_in">upper</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                upper_rowid = _upper_bound_ordinal(segment,</span><br><span class="line">                                                   range.<span class="built_in">upper</span>(),</span><br><span class="line">                                                   !range.<span class="built_in">inclusive_upper</span>(),</span><br><span class="line">                                                   segment-&gt;<span class="built_in">num_rows</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 下限</span></span><br><span class="line">            <span class="keyword">if</span> (!range.<span class="built_in">lower</span>().<span class="built_in">empty</span>() &amp;&amp; upper_rowid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                lower_rowid = _lower_bound_ordinal(segment,</span><br><span class="line">                                                   range.<span class="built_in">lower</span>(),</span><br><span class="line">                                                   range.<span class="built_in">inclusive_lower</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在 segment 中， 一个可读取的 range 就产生了</span></span><br><span class="line">            <span class="keyword">if</span> (lower_rowid &lt;= upper_rowid) &#123;</span><br><span class="line">                _segment_scan_range.<span class="built_in">add</span>(vectorized::Range&#123;lower_rowid, upper_rowid&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _segment_range_iter = _segment_scan_range.<span class="built_in">new_iterator</span>();</span><br><span class="line">    _num_segment_rest_rows = _segment_scan_range.<span class="built_in">span_size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="MorselQueueFactory"><a href="#MorselQueueFactory" class="headerlink" title="MorselQueueFactory"></a>MorselQueueFactory</h2><p>MorselQueue 创建完后，就要准备创建 MorselQueueFactory。因为后续由 MorselQueueFactory 将 MorselQueue 分配给 PipelineDriver。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-morsel-2.svg?raw=true" alt="pipeline-morsel-2"></p><p>顾名思义，<strong>SharedMorselQueueFactory</strong> 即所有的 PipelineDrivers 共享一个 MorselQueue，此时就要求该 MorselQueue 具有较好的并发性能，比如FixedMorselQueue，而 IndividualMorselQueueFactory 则为每个 PipelineDriver 都分配一个 MorselQueue。</p><p>通过 Factory 创建 MorselQueue 的函数如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MorselQueue* <span class="title">SharedMorselQueueFactory::create</span><span class="params">(<span class="type">int</span> driver_sequence)</span> <span class="keyword">override</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> _queue.<span class="built_in">get</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个 PipelineDrvier 都有一个 driver_sequence</span></span><br><span class="line"><span class="function">MorselQueue* <span class="title">IndividualMorselQueueFactory::create</span><span class="params">(<span class="type">int</span> driver_sequence)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK_LT</span>(driver_sequence, _queue_per_driver_seq.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">return</span> _queue_per_driver_seq[driver_sequence].<span class="built_in">get</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="convert-scan-range-to-morsel-queue-factory"><a href="#convert-scan-range-to-morsel-queue-factory" class="headerlink" title="convert_scan_range_to_morsel_queue_factory"></a>convert_scan_range_to_morsel_queue_factory</h3><p>在创建 Factory 前，需要先由 <em>convert_scan_range_to_morsel_queue</em> 函数获得 MorselQueue，再根据 frontend 优化器是否设置了 <code>scan_ranges_per_driver_seq</code> 来做一些决策。</p><ul><li><p>大多数情况下，<code>scan_ranges_per_driver_seq</code> 都不为空，即每个 PipelineDriver 已经分配好了自己要读取的 scan_range，则直接使用 convert_scan_range_to_morsel_queue 函数每个 PipelineDriver 生成 MorselQueue，并添加到 pipeline::IndividualMorselQueueFactory 对象中暂存。</p></li><li><p>如果 <code>scan_ranges_per_driver_seq</code> 为空，则为全局要读取的数据范围 global_scan_ranges 创建对应的 MorselQueue。</p><p>MorselQueue::max_degree_of_parallelism() 表征同时支持的读取并行度，比如 FixedMorseQueue 的 max_degree_of_parallelism 即 _morsel_size，最多只允许 _morsel_size 一起读取。而 SplitMorselQueue 的 max_degree_of_parallelism 则是在 _could_tablet_internal_parallel 函数中计算出来的 scan_dop。</p><blockquote><p>到底是什么规模想要用 FixedMorselQueue</p></blockquote></li></ul><p>这部分代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;pipeline::MorselQueueFactoryPtr&gt; <span class="title">ScanNode::convert_scan_range_to_morsel_queue_factory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;TScanRangeParams&gt;&amp; global_scan_ranges,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::map&lt;<span class="type">int32_t</span>, std::vector&lt;TScanRangeParams&gt;&gt;&amp; scan_ranges_per_driver_seq, <span class="type">int</span> node_id,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> pipeline_dop, <span class="type">bool</span> enable_tablet_internal_parallel,</span></span></span><br><span class="line"><span class="params"><span class="function">        TTabletInternalParallelMode::type tablet_internal_parallel_mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scan_ranges_per_driver_seq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> morsel_queue,</span><br><span class="line">                         <span class="built_in">convert_scan_range_to_morsel_queue</span>(global_scan_ranges, node_id, pipeline_dop,</span><br><span class="line">                                                            enable_tablet_internal_parallel,</span><br><span class="line">                                                            tablet_internal_parallel_mode, global_scan_ranges.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="type">int</span> scan_dop = std::<span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, morsel_queue-&gt;<span class="built_in">max_degree_of_parallelism</span>()), pipeline_dop);</span><br><span class="line">        <span class="type">int</span> io_parallelism = scan_dop * <span class="built_in">io_tasks_per_scan_operator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If not so much morsels, try to assign morsel uniformly among operators to avoid data skew</span></span><br><span class="line">        <span class="keyword">if</span> (scan_dop &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">dynamic_cast</span>&lt;pipeline::FixedMorselQueue*&gt;(morsel_queue.<span class="built_in">get</span>()) &amp;&amp;</span><br><span class="line">            morsel_queue-&gt;<span class="built_in">num_original_morsels</span>() &lt;= io_parallelism) &#123;</span><br><span class="line">            <span class="keyword">auto</span> morsel_queue_map = <span class="built_in">uniform_distribute_morsels</span>(std::<span class="built_in">move</span>(morsel_queue), scan_dop);</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::IndividualMorselQueueFactory&gt;(std::<span class="built_in">move</span>(morsel_queue_map),</span><br><span class="line">                                                                            <span class="comment">/*could_local_shuffle*/</span> <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::SharedMorselQueueFactory&gt;(std::<span class="built_in">move</span>(morsel_queue), scan_dop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> num_total_scan_ranges = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, scan_ranges] : scan_ranges_per_driver_seq) &#123;</span><br><span class="line">            num_total_scan_ranges += scan_ranges.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::map&lt;<span class="type">int</span>, pipeline::MorselQueuePtr&gt; queue_per_driver_seq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dop, scan_ranges] : scan_ranges_per_driver_seq) &#123;</span><br><span class="line">            <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> queue, <span class="built_in">convert_scan_range_to_morsel_queue</span>(</span><br><span class="line">                                                 scan_ranges, node_id, pipeline_dop, enable_tablet_internal_parallel,</span><br><span class="line">                                                 tablet_internal_parallel_mode, num_total_scan_ranges));</span><br><span class="line">            queue_per_driver_seq.<span class="built_in">emplace</span>(dop, std::<span class="built_in">move</span>(queue));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::IndividualMorselQueueFactory&gt;(std::<span class="built_in">move</span>(queue_per_driver_seq),</span><br><span class="line">                                                                        <span class="comment">/*could_local_shuffle*/</span> <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下一部分从 SourceOperator 角度看怎么获取 Morsels 去存储层获取数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;MorselQueue 用于存放本次待读取的数据源 Morsels 集合，继承派生体系如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipel</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="Pipeline" scheme="https://szza.github.io/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>COLUMBIA 查询优化器如何提升性能（上）</title>
    <link href="https://szza.github.io/2023/06/15/Paper/Columbia-Query-Optimizer-1/"/>
    <id>https://szza.github.io/2023/06/15/Paper/Columbia-Query-Optimizer-1/</id>
    <published>2023-06-15T02:20:00.000Z</published>
    <updated>2023-08-08T15:13:07.693Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>COLUMBIA 项目聚焦于效率：如何在不损害拓展性的前提下，使设计实现的 Columbia Query Optimizer 获得巨大的<em>性能</em>提升。</p><p>本项目是基于 Cascades Optimizer Framework 的 Top-Down 优化算法，并通过重构搜索空间和搜索算法来简化 Top-Down 优化器设计：通过实现两种裁剪技术（pruning techniques）取得了极大的性能提升。此外，通过增加友好的用户接口和广泛的跟踪支持（extensive tracing support）来提升本项目的可用性。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>尽管查询优化（query optimization）成为研究项目已经超过15年，但是 query optimizers 仍是关系数据库中最大最复杂模型之一，这使得他们的开发和变动成为困难且耗时的任务。随着现代数据库的需要发展，这一情形会变得更加复杂，因此催生了新的技术。</p><p>在过去的几年里，也开发了几代商业和研究性质的优化器，在拓展性和效率做出提升：</p><ol><li>第一代致力于可拓展的优化器技术，认识到在新数据模型（new data models）、查询类别（query class）、语言和评估技术（evaluation techniques）等方面存在需求。因此诞生了一些列项目，诸如 Exodus、Starburst，他们的目标是使优化器更加模块化，更易于拓展。他们使用到的技术包括 layering of components、基于规则的转化等。这些成果存在一些短处，比如增加拓展的复杂度、搜索性能以及更加偏向于于面向记录的数据模型(record-oriented data module)</li><li>第二代可拓展的优化器，诸如 Volcano optimizer generator，增加了更加复杂的搜索技术，更多地使用了物理属性来指导搜索以及更好地控制搜索策略来实现更好的搜索性能。虽然这些优化器在一定程度上更加灵活了，但是仍难以拓展</li><li>第三代优化器，诸如 Cascades、OPT++, EROC 和 METU，开始使用面向对象技术（object-oriented design）来简化实现、拓展和更改优化器，与之同时保持效率并且是的搜索策略更为灵活。这最新一代的优化器已经达到的复杂程度，已可以满足现代商业数据库系统的要求。这一点可以从他们的工业实现（Cascades by Microsoft and Tandem, EROC by NCR）也可以看出。</li></ol><p>按照<em>搜索策略</em>划分，这三代查询优化器可以被归位两类：</p><ol><li>Starburst style: bottom-up dynamic programming optimizers </li><li>Cascades style: top-down branch and bound rule-driven cost based optimizers</li></ol><p>bottom-up 优化算法当前广泛用于传统商业数据库系统中，因为至少在传统应用中被认为是有效的。但是由于 bottom-up 算法要求将原始问题分解为子问题，使其相比较 Top-down 算法，bottom-up 优化算法与生俱来就缺乏可拓展性。此外，为了在大查询中实现可以接受的性能，bottom-up 类算法中必须要用启发式（heuristics）策略。</p><p>尽管在此之前的 top-down 优化器实现已表明此类优化器难以实现和 DownTop相匹敌的性能，但是本论文认为 top-down 优化器在<em>效率</em>上和拓展能力一样有优势。因此为论证这一观点，本论文的剩余部分就是描述我们如何设计另一个 top-down 优化器: Columbia </p><p>Columbia 优化器在 Cascades Optimizer Framework 的基础上，广泛利用 C++ 面向对象的特性以及细心的工程师，来啊简化 top-down 算法，进而维持 top-down 拓展性的同时实现提升性能的目的，本论文算法只定义了少量关键的带有虚函数的抽象基类，根据这些基类来完整实现搜索策略。这些搜索策略调用这些基类的虚函数来执行具体地搜索，并基于成本（cost-based）对搜索空间进行裁剪。</p><p>因此，<em>从这些抽象基类派生新的子类并重写基类虚函数</em>，就可以轻松拓展优化器来操作其他的复杂数据模型、添加新的 operators 和转化规则。故而本文聚焦于关系数据模型中的优化，不再讨论优化器的拓展性。</p><p>为了，减少 CPU 和 Memory 的使用率，本论文的 Columbia 框架会使用几个工程技术来提升效率，诸如：</p><ul><li>一个快速的 hash function 来消除重复的表达式；</li><li>一个 group exepression 中 logical expressions 和 physical expressions 的分离</li><li>小而紧凑的数据结构</li><li>有效的算法来优化分组和输入</li><li>efficient way to handle enforcers (that is what</li></ul><p>Columbia 优化器提供了两个重要的技术：</p><ol><li><p><em>group pruning</em>：这个技术这极大地裁剪了搜索空间，并且毫不损害生成的执行计划。在低层次（low-level）物理计划生成前，优化器会先计算高层次（high-level）物理计划的代价（cost），这些提前计算的代价用于后续优化代价上限，本文后面将会展示在很多场景下，这些上限可以避免生成整个 group expressions，进而裁剪搜索空间中大量可能的查询计划。</p></li><li><p><em>global epsilon pruning</em>：这个技术通过生成可以接受的次优方案（close-to-optimal solutions）来裁剪搜索空间。当一个solution足够接近最优方案，那么这个优化目标就算完成了，进而许多其他的路径就可以忽略。</p></li></ol><h2 id="2-Terminology"><a href="#2-Terminology" class="headerlink" title="2. Terminology"></a>2. Terminology</h2><p>本章主要回顾查询优化文献中的术语和基本概念，这些也将用于描述 Columbia 框架的设计和实现。</p><h3 id="2-1-Query-Optimization"><a href="#2-1-Query-Optimization" class="headerlink" title="2.1. Query Optimization"></a>2.1. Query Optimization</h3><p>查询处理的目的是从 DML 提取出表达式，并基于数据库的数据进行评估。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/optimizer-1.jpg?raw=true" alt="optimizer-1"></p><p>图1 展示了查询处理的步骤，</p><ol><li>DML 语句中的原始查询被解析成代数上的逻辑表达式树（logical expression tree），</li><li>接着这逻辑表达式树传递给查询优化器，将逻辑查询转换为物理计划：物理执行计划就可以在真正持有数据的数据结构上执行</li></ol><p>这个过程会执行两种转化：</p><ul><li><p><em>Logical transformations</em>：创建查询可能的逻辑形式（logical forms）</p></li><li><p><em>physical transformations</em>：选择一个特别的物理算法来实现一个逻辑算子（logical operator），比如使用 sort-merge join 来实现 logical join</p><p>  通常，这个过程会生成大量的执行计划来实现逻辑查询树，因此需要查询优化器主要关注的就是如何找到最优的执行计划，即代价最低的路径。只要选中一个最优物理计划，就会被传递给查询执行引擎（query execution engine）。查询执行引擎使用有序数据作为输入来执行物理计划，得到的查询到结果即整个输出。</p></li></ul><p>如果我们只关注用户层，那么查询处理过程就被隐藏在查询处理器的黑盒之中。用户提交SQL请求时，希望系统正确又快速输出结果。正确性（Correctness）是查询处理器的基本要求，而性能（performance）是查询处理器所需要的特性和主要关注点。从查询处理的系统层次看，查询优化器在数据库系统的高性能至关重要。</p><p>生成的物理计划中，包含了大量能完成正确性的执行计划，但是具有迥异的执行性能（execution performance），优化器的目标之一就是发现最佳执行性能的物理计划。<code>一个朴素的方法就是生成所有可能的路径，然后遍历选择代价最低的路径</code>。但是，遍历所有可能的路径的代价是极其高的，因此即便是非常简单的查询语句都会生成大量的路径，因此优化器必须以某种方式缩小搜索空间。</p><p>查询优化是个复杂的搜索问题，研究表名这个问题的简单版本就是NP-hard。一个搜索策略对于优化器成功与否至关重要。</p><h3 id="2-2-Logical-Operators-and-Query-Tree"><a href="#2-2-Logical-Operators-and-Query-Tree" class="headerlink" title="2.2. Logical Operators and Query Tree"></a>2.2. Logical Operators and Query Tree</h3><p>逻辑算子 <em>Logical operators</em> 属于高级（high level）算子，仅表征了数据转换关系，并不指定使用哪种具体的物理执行算法。在关系数据模型中，Logical operators 接受多个表作为输入，并产生单表输出。每个 logical operator 接受固定数量的输入（输入的数量叫做 <em>arity</em>），并有多个用于区分 operators 变体的参数。</p><p>有两个经典的 logical operators：</p><ul><li><em>GET Operator</em>：即Scan操作，他没有输入的table，并且有一个表名参数。GET Operator 从磁盘中获取数据，并输出给后续的Operators</li><li><em>EQJOIN Operator</em>：有两个输入table，即进行JOIN操作的左表、右表，输入的参数包含着和左表、右表相关的predicates。</li></ul><p>查询树（query tree） 是 query 的树形结构表征方式，并被用于优化器的输入。一般地，查询树会被表征为 logical operators 的树形结构，每个 TreeNode 都是一个 logical operator，有零个或者多个 logical operators 作为输入，这个 TreeNode 的子节点数量等于输入的 logical operators 的数量，也即 <em>arity</em>。这个查询树的叶结点即 <em>arity &#x3D; 0</em> 的 operators（比如 GET Operator）。</p><p>图-2 是个查询的树形表征的例子。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/optimizer-2.jpg?raw=true" alt="optimizer-2"></p><p>query trees 用于指定执行 operators 的顺序，比如为了执行查询树上的 top operator，那他的输入就必须先执行。在图-2的例子中 EQJOIN operator 的两个输入，接受的就是两个 GET operators 的输出。而 EQJOIN 的输入参数，即 <code>Emp.dno=Dept.dno</code>，描述的就是 JOIN 的条件。而这个 EQJOIN 的输出即整个查询所需的结果。GET operators 没有输入，因此他们就是叶节点，用于产生本次查询评估所需的数据源，而 GET operator 的输入参数表征的是所需读取表的表名，比如 Empt、Dept。</p><h3 id="2-3-Physical-Operators-and-Execution-Plan"><a href="#2-3-Physical-Operators-and-Execution-Plan" class="headerlink" title="2.3. Physical Operators and Execution Plan"></a>2.3. Physical Operators and Execution Plan</h3><p>Physical operators 表征的实现特定数据操作的具体算法。在数据库中，对于一个 logical operators，通常存在一个或者多个 physical operators 实现。</p><ul><li>EQJOIN logical operator 可以使用 nested-loops、sort-merge join 或者其他算法来啊实现，而具体的算法也可以使用不同的 physical operator来实现，比如 nested-loops 一般是用 LOOP-JOIN physical operator实现，而 sort-merge 算法一般是用 MERGE-JOIN physical operator实现。</li><li>GET logical operator 的经典实现算法是按照表的存储顺序进行 scan，一般是使用 FILE_SCAN physcail operator。</li></ul><p>将查询树中的 logical operators 替换为 physical operators 就产生了一棵 physical operators 树，一般叫做执行计划（<em>Execution Plan</em>）。图-3 展示了由图-2查询计划生成的两个执行计划。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/optimizer-3.jpg?raw=true" alt="optimizer-3"></p><p>执行计划具体说明了如何评估查询（evaluate the query）：每个执行计划都有一个执行成本，对应着 cost model 和catalog infomation。对于一个指定查询，优化器生成的最优执行计划会作为查询执行引擎的输入，执行引擎会基于数据库系统中的数据执行整个算法来产生本次查询的输出结果。</p><h3 id="2-4-Groups"><a href="#2-4-Groups" class="headerlink" title="2.4. Groups"></a>2.4. Groups</h3><p>给定的查询可以由另一个在逻辑上等价的查询树来表征：如果两个查询树在任何主流的数据库上的输出都完全相同，则他们是 <em>逻辑上等价的</em>。通常，每一个查询树都有一个或者多个执行计划来实现查询树并产生完全相同的结果，那么这些执行计划就是逻辑上等价的。</p><p>图-4 展示了几个逻辑等价的查询树以及实现这些查询树产生逻辑等价的执行计划。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/optimizer-4.jpg?raw=true" alt="optimizer-4"></p><p>如图-4所示，我们使用 $\Join$ 符号来表征 EQJOIN operator，$\Join_L$ 表征 LOOPS_JOIN operator，$\Join_M$ 表征 MERGE_JOIN。出于简洁的目的，使用参数表征 GET，加上下标F表征 FILE_SCAN，比如图-4中使用 $C$ 表征 GET(“C”)，用 $C_F$ 表征 FILE_SCAN(“C”)。</p><p>图4(a) 和 图4(b) 是两个逻辑等价的查询树，差别只在于 logical operator 的顺序；(a-i) 个 (a-ii)是两个逻辑等价的执行计划，他们的区别在于使用不同的JOIN算法。</p><p>那么我就可以使用 <em>expressions</em> 来表征查询树和执行计划（以及他们的子节点）：一个 expression 由一个 operator 和它的零个或者多个输入组成，根据 operator 的类型这个 expression 也被区分为 logical expression 和 physical expression，因此查询树即 <em>logical expressions</em>，执行计划即 <em>physcical expressions</em>。</p><p>考虑到一个 logical expression 就存在大量逻辑等价的 logical expressions 以及生成的 physical expressions，如果将他们都放入到一个 <em>group</em> 中并定义他们的共同特征（common characteristics）就变得非常有用。</p><p><em>Group</em> 是一组逻辑等价的 exprssions 集合。<code>一般地，一个 group 包含所有逻辑等价的 logical expressions，以及基于他们生成的逻辑等价的 physical expressions</code>。显然，group 中的每个 logical expression 对应的 physical expressions 不止一个。图-5展示的 group 包含了图-4中表达式的以及其他的等价表达式，</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/optimizer-5.jpg?raw=true" alt="optimizer-5"></p><p>我们通常用其中一个 logical expressions 来表示一个 <em>group</em>，比如 $(A \Join B) \Join C$，或直接使用 $[ABC]$。图-5 中展示了 $[ABC]$ group 中所有等价的逻辑表达式及部分物理表达式。从图-5中可以看到，即便是逻辑表达式也存在大量等价的表达形式。</p><p>为了减少 group 中表达式的数量，引入 <em>Multi-Expressions</em>。一个  <em>Multi-Expressions</em> 有一个 logical&#x2F;physical operator，并将 groups 作为输入。 multi-expression 和 expression 不同点在于输入： 前者以 groups 作为输入，后者以其他 expressions 作为输入。比如 Multi-expression $[A \Join B] \Join [C]$ 表示 EQJOIN operator 的输入是 $[A \Join B]$ 和  $[C]$ 两个 group。由于在一个 group 中鲜有等价的 multi-expression，因此能极大得节省搜索空间。</p><p>图-6 展示了 group [ABC] 中等价的 <em>Multi-Expressions</em>，相比较图-5 中 Expression 的数量更少。 也就说通过使用 <em>Multi-Expressions</em>，就可以将 group 重新定义为一系列等价 <em>Multi-Expressions</em> 的集合。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/optimizer-6.jpg?raw=true" alt="optimizer-6"></p><p>在查询的通用处理过程中，在生成最终结果前会先产生许多中间结果，即许多tuples的集合。而中间结果就是通过计算一个 group 对应的执行计划得到的。换言之，group 就对应着中间结果，而这些groups被叫为 <em>intermediate groups</em>，而生成最终结果的group，就叫做 <em>final group</em>。</p><p>The Logical properties of a group are defined as the logical properties of the result, regardless of how the result is physically computed and organized. These properties include the cardinality (number of tuples), the schema, and other properties. Logical properties apply to all expressions in a group</p><h4 id="logical-properties"><a href="#logical-properties" class="headerlink" title="logical properties"></a>logical properties</h4><p>一个group中的所有expressions共享一个 <em>logical properties</em>，它被定义为这个group输出结果的逻辑属性，而不在乎结果实际上的计算、组织方式。 <em>logical properties</em> 包括：</p><ul><li>cardinality: tuples 的数量，即行数</li><li>schema</li><li>其他属性</li></ul><h3 id="2-5-The-Search-Space"><a href="#2-5-The-Search-Space" class="headerlink" title="2.5. The Search Space"></a>2.5. The Search Space</h3><p><em>search space</em> 表示给定初始查询的逻辑查询树和物理计划。为了节省搜索空间，将 search space 表征为 group 集合，每个 group 都将其他 groups 作为输入，而最上层的 group 也就是 final group(root group)，它对应着初始查询的最终结果。 图-7 展示了一个查询的初始搜索空间(initial search space)。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/optimizer-7.jpg?raw=true" alt="optimizer-7"></p><p>在 initial search space 中，每个 group 仅包含一个源自于 initial query tree 的 logical expression。</p><blockquote><p>也就是说，在生成初始搜索空间后，每个 group 需要基于已有的 logical expression 生成逻辑等价的新表达式。</p></blockquote><p>在图-7 中，最上层的 group $[ABC]$ 就是该查询的最终输出，即 final group，它就是图-7中三个 join 的最终结果。</p><p>我们可以从一个 <em>initial search space</em> 获得一个 <em>initial query tree</em>。query tree 上的每个节点（node）都对应着搜索空间中每个 group 的 Multi-expression 上的 operator。</p><p>比如，fig-7 中有 final group $[ABC]$ ，它由 $EQJOIN$ operator 和 $[AB], [C]$ 两个输入 groups 组成。我们可以获得这么一个 query tree：以 EQJOIN 作为最上层的 operator，输入的 Operator 源于 $[AB], [C]$  两个 groups，然后分别递归 $[AB], [C]$ 两个 groups 直到遇到没有输入的groups，即叶子组。</p><p>从 initial search space 派生出来的 query tree 就刚好是 initial query tree。换言之，initial search space 表征了 initial query tree。</p><p>在优化的过程中， 每个 group 会生成大量逻辑上等价的 logical expressions 和 physical expressions，进而导致搜索空间急剧膨胀。与此同时，在生成 physical expressions 的过程中，这些 physical expressions 的执行代价（ execution costs）也都会被计算出来。在某种意义上，生成所有的 physical expressions 就是优化器的目标，然后从中找到代价最低的 physical expression即可。但是为了生成所有 physical expressions，就必须先构造出所有的 logical expressions，这是因为physical expression 只是 logical expression 的一种实现。</p><p>一个完全被膨胀的搜索空间被叫作 final search space，即表示了一个查询的所有逻辑上等价的 expressions。</p><p>实际上，使用递归的方式可以从 final search space 获得所有可能的 query tree 和 exec plan，就像使用递归方式从 initial serach space 获得 initial query tree。 在搜索空间中，每个 Multi-expressions 上的 operator 对应着着 query tree 上的一个 operator node 或者一个执行计划。</p><p>由于搜索空间中的一个 group 就包含了大量逻辑上等价的表达式，那么 final search space 也会呈现了大量的 query trees 和 execution plans。</p><p>表-1 显示了由 N 个表 JOIN 得到的完整逻辑搜索空间（仅显示了 logical expressions 的数量）。比如， 4 个表进行 JOIN 的逻辑搜索空间就有15个 groups，包含了 54 个 logical expressions，呈现了120个query trees。</p><p>从表-1可以看出，即便只考虑 logical expressions，搜索空间的大小也会随着 JOIN 的表增多而呈现指数趋势增长。而 logical expressions 的数量取决于 logical operator 有多少种算法实现。比如当前搜索空间中有 N 个 logical expressions，并且数据库系统支持 M (M &gt;&#x3D; 1) 种  join 算法实现，那么搜索空间就将会有 $M * N$ 个 logical expressions，也就说 physical expressions 的数量不会少于 logical expressions 的数量。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/optimizer-table-1.jpg?raw=true" alt="optimizer-table-1"></p><h3 id="2-6-Rules"><a href="#2-6-Rules" class="headerlink" title="2.6. Rules"></a>2.6. Rules</h3><p><em>rule</em> 描述得是如何将一个表达式转化为一个在逻辑上等价的新表达式。因此，许多优化器会通过使用 rules 来对一个 initial query 生成一系列逻辑上等价的表达式，达到扩充 initial search space 的目的。</p><p>每个 rule 都会被定义为一个pair:</p><ul><li><em>pattern</em>: 定义的是输入的 logical expressions 的结构，即什么样的输入表达式可以应用这条 rule（注意: rule 仅能用应用于 logical expressions），</li><li><em>subsitute</em>: 定义的是输入表达式在应用这条规则之后，输出结果的结构</li></ul><p>当扩充搜索空间时，优化器会审视每个 logical expression 并检查 rules set 中是否存在 rule 的 pattern 能与该表达式相匹配。如果存在，则会根据 rule 中 substitute 定义的输出表达式结构，应用这条规则来生成新的逻辑上等价的表达式。</p><p>Cascades 使用表达式来表示 pattern 和 substitues: 其中 pattern 总是 logical expressions，而 subsitutes 即可以是 logical expressions 也可以是 physical expressions。</p><p>rules 的两种通用类型是:</p><ul><li><em>Transformation rules</em>: 当 substitute 是 logical expression 时， rule 被叫做 transformation rules。</li><li><em>implementation rules</em>: 当 substitute 是 physical expression 时， rule 被叫做 implementation rules。</li></ul><p>如图-8，$EQJOIN_LTOR$ 就是一种 transformation rule，$EQJOIN_MERGEJOIN$ 就是一种 implementation rules。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/optimizer-8.jpg?raw=true" alt="optimizer-8"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h2&gt;&lt;p&gt;COLUMBIA 项目聚焦于效率：如何在不损害拓展性的前提下，使设计实现的 Columbia</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="Papers" scheme="https://szza.github.io/tags/Papers/"/>
    
  </entry>
  
  <entry>
    <title>Overview: StarRocks Pipeline Query Executor</title>
    <link href="https://szza.github.io/2023/05/07/Pipeline/Overview/"/>
    <id>https://szza.github.io/2023/05/07/Pipeline/Overview/</id>
    <published>2023-05-07T08:00:02.000Z</published>
    <updated>2023-08-08T07:18:42.608Z</updated>
    
    <content type="html"><![CDATA[<p>如图-1是 StarRocks Pipeline 的整体执行结构:</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-1.svg?raw=true" alt="pipeline-1"></p><p>对比论文中 Morsel-Driven Parallelism[1] 第三节中的 figure-5 与 StarRocks Pipeline 实现中，概念映射关系大致如下：</p><ul><li>QEPObject 即 PipelineDriverPoller，负责将前置依赖都已经 Ready 的 Pipeline 传递给 Dispatcher</li><li>Task 即 PipelineDriver，是可执行任务单元，由两部分组成：输入（Morsel） + 处理流（PipelineJob）。</li><li>Dispatcher 即 DriverQueue，是存储 PipelineDriver 的任务队列，可以根据优先级（Resource Group）或者 FIFO 方式任务分发</li><li><em>Morsel List</em> 即 MorselQueue，根据优化器，自动选择不同的 MorselQueue</li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-5.jpg?raw=true" alt="figure-5"> </p><h2 id="GlobalDriverExecutor"><a href="#GlobalDriverExecutor" class="headerlink" title="GlobalDriverExecutor"></a>GlobalDriverExecutor</h2><p>所有的任务都是在一组固定的线程池 <code>GlobalDriverExecutor::_thread_pool</code> 中执行。默认是使用当前CPU的核数 <em>CpuInfo::num_cores()<em>，也可以设置参数</em>config::pipeline_exec_thread_pool_thread_num</em> 指定线程池数目。 在 <code>GlobalDriverExecutor::initialize</code> 函数中启动 _max_executor_threads 个线程，函数入口 是 <code>GlobalDriverExecutor::work_thread</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in ExecEnv::_init(const std::vector&lt;StorePath&gt;&amp; store_paths)</span></span><br><span class="line">std::unique_ptr&lt;ThreadPool&gt; driver_executor_thread_pool;</span><br><span class="line">_max_executor_threads = CpuInfo::<span class="built_in">num_cores</span>();</span><br><span class="line"><span class="keyword">if</span> (config::pipeline_exec_thread_pool_thread_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    _max_executor_threads = config::pipeline_exec_thread_pool_thread_num;</span><br><span class="line">&#125;</span><br><span class="line">_max_executor_threads = std::<span class="built_in">max</span>&lt;<span class="type">int64_t</span>&gt;(<span class="number">1</span>, _max_executor_threads);</span><br><span class="line"><span class="built_in">RETURN_IF_ERROR</span>(<span class="built_in">ThreadPoolBuilder</span>(<span class="string">&quot;pip_executor&quot;</span>) <span class="comment">// pipeline executor</span></span><br><span class="line">                        .<span class="built_in">set_min_threads</span>(<span class="number">0</span>)</span><br><span class="line">                        .<span class="built_in">set_max_threads</span>(_max_executor_threads)</span><br><span class="line">                        .<span class="built_in">set_max_queue_size</span>(<span class="number">1000</span>)</span><br><span class="line">                        .<span class="built_in">set_idle_timeout</span>(MonoDelta::<span class="built_in">FromMilliseconds</span>(<span class="number">2000</span>))</span><br><span class="line">                        .<span class="built_in">build</span>(&amp;driver_executor_thread_pool));</span><br><span class="line">_driver_executor = <span class="keyword">new</span> pipeline::<span class="built_in">GlobalDriverExecutor</span>(<span class="string">&quot;pip_exe&quot;</span>, std::<span class="built_in">move</span>(driver_executor_thread_pool), <span class="literal">false</span>);</span><br><span class="line">_driver_executor-&gt;<span class="built_in">initialize</span>(_max_executor_threads);</span><br></pre></td></tr></table></figure><h2 id="Morsel"><a href="#Morsel" class="headerlink" title="Morsel"></a>Morsel</h2><p>Morsel 是 PipelineDriver 的输入。StarRocks 中一个 Morsel 的结构如下：</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-morsel-1.svg?raw=true" alt="pipeline-morsel-1"></p><p>顶层基类 <em>Morsel</em> 中的 <code>_from_version</code> 是为了实现 Query Cache，只需要从文件系统中增量读取 <code>[_from_version, version]</code> 部分的数据，而 <code>[0, _from_version)</code> 部分的数据就可以从 Lrucache 中读取，其中<code>_version</code> 存储在子类 ScanMorsel 中。</p><p>基类 <em>ScanMorsel</em> 更加具体化地存储了本次要读取的数据元信息 <code>&#123;_tablet_id, _version&#125;</code>。如果 Morsel 可以进一步在划分，根据划分方式派生了两个子类。</p><h3 id="OlapScanNode-convert-scan-range-to-morsel-queue"><a href="#OlapScanNode-convert-scan-range-to-morsel-queue" class="headerlink" title="OlapScanNode::convert_scan_range_to_morsel_queue"></a>OlapScanNode::convert_scan_range_to_morsel_queue</h3><p>如下代码，是将本次待查询的 <code>scan_ranges</code> 根据 Pipeline 并行度 <code>pipeline_dop</code> 转化为 OlapScanOperator 中待查询数据的元信息，即 <code>Morsel</code>对象。流程如下：</p><ol><li><p>先将 <em>scan_ranges</em> 一一对应的方式转化为 ScanMorsel</p></li><li><p>如果不开启 tablet 内并行，则使用 FixedMorselQueue 数据结构来存储本次 query 待处理的数据源 <code>Morsels</code></p><p> <code>enable_tablet_internal_parallel</code> 默认值是 true，是个 SessionVariable，用户在每次查询中都可以更改该值。即便该值为 true，也不一定真会进行子划分， 由 Morsel-Driven Parallelism[1] 论文可知，Morsel Size 不建议太小，否则会带因为多线程竞争导致性能惩罚。因此 <code>_could_tablet_internal_parallel</code> 函数会基于本次查询的数据量进行估计，判断是否真需要开启。</p></li><li><p>如果开启，则每个 Morsel Size 估计在 <code>splitted_scan_rows</code> 左右。</p><p> 具体的划分方式由 <code>_could_split_tablet_physically</code> 函数来确定。</p></li></ol><p>这个函数是在构建 Pipelines 的过程中：数据源划分好后，一个 MorselQueue 和一个 Pipeline 构成一个 PipelineDriver。一个完整的 Scan 任务被划分为 pipline_dop 个 OlapScanOperator 并行执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;pipeline::MorselQueuePtr&gt; <span class="title">OlapScanNode::convert_scan_range_to_morsel_queue</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;TScanRangeParams&gt;&amp; scan_ranges, <span class="type">int</span> node_id, <span class="type">int32_t</span> pipeline_dop,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> enable_tablet_internal_parallel, TTabletInternalParallelMode::type tablet_internal_parallel_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">size_t</span> num_total_scan_ranges)</span> </span>&#123;</span><br><span class="line">    pipeline::Morsels morsels;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; scan_range : scan_ranges) &#123;</span><br><span class="line">        morsels.<span class="built_in">emplace_back</span>(std::<span class="built_in">make_unique</span>&lt;pipeline::ScanMorsel&gt;(node_id, scan_range));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// None tablet to read shouldn&#x27;t use tablet internal parallel.</span></span><br><span class="line">    <span class="keyword">if</span> (morsels.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::FixedMorselQueue&gt;(std::<span class="built_in">move</span>(morsels));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Disable by the session variable shouldn&#x27;t use tablet internal parallel.</span></span><br><span class="line">    <span class="keyword">if</span> (!enable_tablet_internal_parallel) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::FixedMorselQueue&gt;(std::<span class="built_in">move</span>(morsels));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> scan_dop;</span><br><span class="line">    <span class="type">int64_t</span> splitted_scan_rows;</span><br><span class="line">    <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> could,</span><br><span class="line">                     _could_tablet_internal_parallel(scan_ranges, pipeline_dop, num_total_scan_ranges,</span><br><span class="line">                                                     tablet_internal_parallel_mode, &amp;scan_dop, &amp;splitted_scan_rows));</span><br><span class="line">    <span class="keyword">if</span> (!could) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::FixedMorselQueue&gt;(std::<span class="built_in">move</span>(morsels));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Split tablet physically.</span></span><br><span class="line">    <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="type">bool</span> ok, _could_split_tablet_physically(scan_ranges));</span><br><span class="line">    <span class="keyword">if</span> (ok) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::PhysicalSplitMorselQueue&gt;(std::<span class="built_in">move</span>(morsels), scan_dop, splitted_scan_rows);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::LogicalSplitMorselQueue&gt;(std::<span class="built_in">move</span>(morsels), scan_dop, splitted_scan_rows);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MorselQueueFactory"><a href="#MorselQueueFactory" class="headerlink" title="MorselQueueFactory"></a>MorselQueueFactory</h3><p>MorselQueueFactory 的集成关系如下：<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-morsel-2.svg?raw=true" alt="pipeline-morsel-2"></p><p><code>IndividualMorselQueueFactory</code> 是针对每个 pipeline 都创建一个 MorselQueue。而 <code>SharedMorselQueueFactory</code> 即在多个 pipeline 之间共享一个 MorselQueue。</p><p><code>convert_scan_range_to_morsel_queue_factory</code> 函数是为 Pipeline 创建数据源 MorselQueue。<code>scan_ranges_per_driver_seq</code> 参数是由 front-end（fe）优化器生成的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;pipeline::MorselQueueFactoryPtr&gt; <span class="title">ScanNode::convert_scan_range_to_morsel_queue_factory</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::vector&lt;TScanRangeParams&gt;&amp; global_scan_ranges,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::map&lt;<span class="type">int32_t</span>, std::vector&lt;TScanRangeParams&gt;&gt;&amp; scan_ranges_per_driver_seq, <span class="type">int</span> node_id,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> pipeline_dop, <span class="type">bool</span> enable_tablet_internal_parallel,</span></span></span><br><span class="line"><span class="params"><span class="function">        TTabletInternalParallelMode::type tablet_internal_parallel_mode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (scan_ranges_per_driver_seq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> morsel_queue,</span><br><span class="line">                         <span class="built_in">convert_scan_range_to_morsel_queue</span>(global_scan_ranges, node_id, pipeline_dop,</span><br><span class="line">                                                            enable_tablet_internal_parallel,</span><br><span class="line">                                                            tablet_internal_parallel_mode, global_scan_ranges.<span class="built_in">size</span>()));</span><br><span class="line">        <span class="type">int</span> scan_dop = std::<span class="built_in">min</span>&lt;<span class="type">int</span>&gt;(std::<span class="built_in">max</span>&lt;<span class="type">int</span>&gt;(<span class="number">1</span>, morsel_queue-&gt;<span class="built_in">max_degree_of_parallelism</span>()), pipeline_dop);</span><br><span class="line">        <span class="type">int</span> io_parallelism = scan_dop * <span class="built_in">io_tasks_per_scan_operator</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If not so much morsels, try to assign morsel uniformly among operators to avoid data skew</span></span><br><span class="line">        <span class="keyword">if</span> (scan_dop &gt; <span class="number">1</span> &amp;&amp; <span class="built_in">dynamic_cast</span>&lt;pipeline::FixedMorselQueue*&gt;(morsel_queue.<span class="built_in">get</span>()) &amp;&amp;</span><br><span class="line">            morsel_queue-&gt;<span class="built_in">num_original_morsels</span>() &lt;= io_parallelism) &#123;</span><br><span class="line">            <span class="keyword">auto</span> morsel_queue_map = <span class="built_in">uniform_distribute_morsels</span>(std::<span class="built_in">move</span>(morsel_queue), scan_dop);</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::IndividualMorselQueueFactory&gt;(std::<span class="built_in">move</span>(morsel_queue_map),</span><br><span class="line">                                                                            <span class="comment">/*could_local_shuffle*/</span> <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::SharedMorselQueueFactory&gt;(std::<span class="built_in">move</span>(morsel_queue), scan_dop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">size_t</span> num_total_scan_ranges = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, scan_ranges] : scan_ranges_per_driver_seq) &#123;</span><br><span class="line">            num_total_scan_ranges += scan_ranges.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::map&lt;<span class="type">int</span>, pipeline::MorselQueuePtr&gt; queue_per_driver_seq;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [dop, scan_ranges] : scan_ranges_per_driver_seq) &#123;</span><br><span class="line">            <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> queue, <span class="built_in">convert_scan_range_to_morsel_queue</span>(</span><br><span class="line">                                                 scan_ranges, node_id, pipeline_dop, enable_tablet_internal_parallel,</span><br><span class="line">                                                 tablet_internal_parallel_mode, num_total_scan_ranges));</span><br><span class="line">            queue_per_driver_seq.<span class="built_in">emplace</span>(dop, std::<span class="built_in">move</span>(queue));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_unique</span>&lt;pipeline::IndividualMorselQueueFactory&gt;(std::<span class="built_in">move</span>(queue_per_driver_seq),</span><br><span class="line">                                                                        <span class="comment">/*could_local_shuffle*/</span> <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MorselQueue"><a href="#MorselQueue" class="headerlink" title="MorselQueue"></a>MorselQueue</h3><p>MorselQueue 的继承体系如下。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-morsel-3.svg?raw=true" alt="pipeline-morsel-3"></p><h2 id="DriverQueue"><a href="#DriverQueue" class="headerlink" title="DriverQueue"></a>DriverQueue</h2><p>DriverQueue 的继承派生关系如下：</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-driver-queue-1.svg?raw=true" alt="pipeline-driver-queue-1"></p><p><em>QuerySharedDriverQueue</em> 是由于多级反馈队列远离实现，没有指定资源组的 query 都会进行这个队列中。<em>WorkGroupDriverQueue</em> 是针对设置 {cpu, mem} 资源限制 的 query，都是在 <code>GlobalDriverExecutor</code> 中初始化。</p><p>在 StarRocks Be(backend) 中是同时存在两个 GlobalDriverExecutor 对象，不同之处是分别用于实例化 QuerySharedDriverQueue 和 WorkGroupDriverQueue。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GlobalDriverExecutor::<span class="built_in">GlobalDriverExecutor</span>(std::string name, std::unique_ptr&lt;ThreadPool&gt; thread_pool,</span><br><span class="line">                                           <span class="type">bool</span> enable_resource_group)</span><br><span class="line">        : <span class="built_in">Base</span>(std::<span class="built_in">move</span>(name)),</span><br><span class="line">          _driver_queue(enable_resource_group ? std::<span class="built_in">unique_ptr</span>&lt;DriverQueue&gt;(std::<span class="built_in">make_unique</span>&lt;WorkGroupDriverQueue&gt;())</span><br><span class="line">                                              : std::<span class="built_in">make_unique</span>&lt;QuerySharedDriverQueue&gt;()),</span><br><span class="line">          _thread_pool(std::<span class="built_in">move</span>(thread_pool)),</span><br><span class="line">          _blocked_driver_poller(<span class="keyword">new</span> <span class="built_in">PipelineDriverPoller</span>(_driver_queue.<span class="built_in">get</span>())),</span><br><span class="line">          _exec_state_reporter(<span class="keyword">new</span> <span class="built_in">ExecStateReporter</span>()) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="PipelineDriverPoller"><a href="#PipelineDriverPoller" class="headerlink" title="PipelineDriverPoller"></a>PipelineDriverPoller</h2><p>轮询判断某个 blocked_pipeline_driver 前置依赖是否已经 ready，ready 则加入 <code>_driver_queue</code>。</p><h2 id="PipelineDriver"><a href="#PipelineDriver" class="headerlink" title="PipelineDriver"></a>PipelineDriver</h2><p>执行单元，在每次执行前后会更新统计信息，Executor 会基于统计信息进行下一次调度。</p><p>StarRocks Pipeline 的设计还是挺复杂的，比 Morsel-Driven Parallelism[1] 论文做了很多的优化。后续再针对每个具体的数据结构进行分析。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>[1] <a href="https://db.in.tum.de/~leis/papers/morsels.pdf">Morsel-Driven Parallelism</a></li><li>[2] <a href="https://zhuanlan.zhihu.com/p/573181686">StarRocks Pipeline 执行框架（上)</a></li><li>[3] <a href="https://zhuanlan.zhihu.com/p/575526096">StarRocks Pipeline 执行框架（下)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如图-1是 StarRocks Pipeline 的整体执行结构:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-1.svg?raw</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="Pipeline" scheme="https://szza.github.io/tags/Pipeline/"/>
    
  </entry>
  
  <entry>
    <title>Hyper-Pipelining Query Execution(下)</title>
    <link href="https://szza.github.io/2023/05/03/Paper/Hyper-Pipelining-Query-Execution-2/"/>
    <id>https://szza.github.io/2023/05/03/Paper/Hyper-Pipelining-Query-Execution-2/</id>
    <published>2023-05-03T02:08:23.000Z</published>
    <updated>2023-08-10T03:50:37.387Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-X100-A-Vectorized-Query-Processor"><a href="#4-X100-A-Vectorized-Query-Processor" class="headerlink" title="4. X100: A Vectorized Query Processor"></a>4. X100: A Vectorized Query Processor</h2><p>上一篇翻译了 <a href="https://szza.github.io/2023/05/01/Paper/Hyper-Pipelining-Query-Execution-1">Hyper-Pipelining Query Execution</a> 上半部分，核心思想就是 RDBMS 和 MonetDB 的优缺点。后半部分，就是如何从零开始设计新的查询处理引擎 X100。</p><p>新的 X100 查询处理引擎目标主要有三个：</p><ol><li>高性能：以高 CPU 效率处理大数据量查询</li><li>拓展性：能够拓展到其他应用领域，比如 data-mining、multi-media retrieval等，并且能通过拓展代码在这些领域也能实现同样高的效率</li><li>伸缩性：能随着最低存储层次结构（比如磁盘）的大小进行伸缩</li></ol><p>为了实现我们的目标，X100 必须与整个计算机架构中的瓶颈进行博弈：</p><ol><li><p>Disk: X100 的 ColumnBM <u>I&#x2F;O 子系统</u>面向高效的顺序数据访问。为降低对带宽的要求，它使用了垂直分段的数据布局（vertically fragmented data layout），在某些情况下，这种布局通过轻量级数据压缩得到了增强。</p></li><li><p>RAM: 与 I&#x2F;O 类似，RAM 的访问路线是 memory-to-cache 和 cache-to-memory，其中可能会包含与硬件相关的优化，比如使用 SSE 指令预取（Prefetching）数据以及一些汇编指令来移动数据。</p></li><li><p>Cache: CPU Cache 是唯一与内存带宽无关的地方。</p><p>基于向量化处理（<em>vectorized processing</em>）模型，我们使用 Volcano-like execution pipeline。</p><p>本文把比较小（比如 1000个值）的能留在 CPU Cache 的数据块(chunk)，叫 “vectors”，这也是 X100 查询执行的基本单位。X100查询处理算子都是 cache-conscious：因为会把巨大的数据集分割成 cache-chunk，只会在 cache 中进行随机访问。</p></li><li><p>CPU: 先让编译器生成 loop-pipelined 代码。为进一步提高 CPU 吞吐（主要是减少 <code>mix</code> 指令中 LOAD&#x2F;STOR 的次数），X100 也包含为整个表达式子树而不是单个函数编译向量化原语（<em>vectorized primitives</em>）的工具。目前，此编译是静态引导的，但它最终可能成为优化器强制执行的运行时活动（比如 LLVM JIT）。</p></li></ol><p>为了保持本文的重点，我们仅简要描述磁盘存储问题，也是因为 ColumnBM Buffer Manager 仍在开发中。 在我们所有的实验中，X100 使用 MonetDB 作为其存储管理器（如图-5 所示），它在 in-memory BATs 上运行。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/Hyper-Pipelining-5.jpg?raw=true" alt="Hyper-Pipelining-5"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-X100-A-Vectorized-Query-Processor&quot;&gt;&lt;a href=&quot;#4-X100-A-Vectorized-Query-Processor&quot; class=&quot;headerlink&quot; title=&quot;4. X100: A Vectorized </summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="Papers" scheme="https://szza.github.io/tags/Papers/"/>
    
  </entry>
  
  <entry>
    <title>Hyper-Pipelining Query Execution(上)</title>
    <link href="https://szza.github.io/2023/05/01/Paper/Hyper-Pipelining-Query-Execution-1/"/>
    <id>https://szza.github.io/2023/05/01/Paper/Hyper-Pipelining-Query-Execution-1/</id>
    <published>2023-05-01T13:58:02.000Z</published>
    <updated>2023-08-09T13:49:52.037Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>在计算密集型（compute-intensive）的应用领域中，数据库系统在现代 CPU 上往往只能实现较低的 IPC（Instructions-Per-Cycle）效率。基于这一问题，本文的主要工作分为如下两个方面：</p><ol><li><p>通过 TPCH benchmark，深入分析 IPC 效率不高的原因，即为什么每个周期（Cycle）执行的指令（Instructions）非常少。通过对不同的关系型数据库和 MonetDB[1] 进行分析，得到了一个设计查询处理器（Query Processor）的新指南。</p></li><li><p>本文的第二部分， 基于上述分析得到的查询处理器设计指南，如何为我们的 MonetDB 设计新的查询引擎 X100。</p><p> 表面上， X100 类似于基于 Volcano 模型设计的引擎，关键区别在于 X100 所有的执行都是基于矢量处理 （vector processing）的概念，使得 X100 引擎的 CPU 效率非常高。</p></li></ol><p>我们在 TPCH benchmark 输入数据为 100GB 的版本上评估了 MonetDB&#x2F;X100 的性能，结果显示其原始执行能力（即未经过调优）比以前的技术实现高出一到两个数量级。</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><p>现代 CPU 每秒可以执行大量计算，但前提是能够找到大量不存在依赖关系的任务，才利用其并行执行能力。在过去的十年里硬件飞速发展，这使得 CPU 以最大吞吐量运行（full throughput）和最小吞吐量（minimal throughput）运行时之间的速度差异可能存在着一个数量级。</p><p>那么大家就期望查询密集型工作负载（workload），比如 decision support, OLAP, data-mining 等，这些应用场景中都存在着大量不相关的计算，那么此时就应该让 Modern-CPUs 有机会发挥出接近最优的 IPC 效率。</p><p>然而研究却表名当前数据库在这些应用场景中，在 Modern-Cpus 上实现的 IPC 效率非常低。这就让人感到困惑。因此本文详细研究了在查询密集型应用场景中，关系数据库是如何与 Modern super-scalar（Hyper-Pipelined） CPUs 交互的，尤其是在 TPCH benchmark 场景中。</p><p>从该调查研究中我们得到的主要结论是：<strong>绝大多数 DBMSs 采用的架构阻碍了编译器使用最关键的性能优化技术（即 Pipeline），从而导致 CPU 效率低下</strong>。比如，在 Modern-CPUs 的流水线技术(Pipelined Prcoessing)架构下，非常火的 Volcano 模型的最通用实现，执行过程中数据传递方式是 <code>tuple-at-a-time</code>（即一次传输一个tuple），1）不仅会产生高额的解释开销（interpretation overhead），还会阻止编译器让 CPU 并行的机会。</p><p>除此之外，我们也分析了内存数据库 MonetDB 的性能，这是由本文作者团队使用 MIL 语言开发的数据库。MonetDB&#x2F;MIL 的执行模型是 <code>Column-at-a-time</code>，因此不会有 <code>tuple-at-a-time</code> 执行模型中的解释开销问题（即被分摊了）。然而，它使用全列具体化（Full Column Materialization）的策略会导致在查询执行过程中产生大量数据。比如，我们就发现在 Decision Support 应用场景中，MonetDB&#x2F;MIL 就被内存带宽严重限制，导致 CPU 效率急剧下降。</p><blockquote><p>Materialization: 在这表达的语义是 “具体化”</p></blockquote><p>因此，我们任务应该将 MonetDB 的 <code>Coumn-at-a-time</code> 执行流程和 Volcano 模型 Pipeline 实现中的增量具体化（Incremental Materialization）技术结合起来。我们从零为 MonetDB 设计并实现了一个新的查询处理引擎，即 X100，它使用的是向量化查询处理模型（<strong>vectorized</strong> query processing model）。</p><h2 id="2-How-CPUs-Work"><a href="#2-How-CPUs-Work" class="headerlink" title="2. How CPUs Work"></a>2. How CPUs Work</h2><p>如图-1 显示了过去十年中每年最快的 CPU（按照 MHz 衡量 ）、最高性能，以及当年最先进的芯片制造技术。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/Hyper-Pipelining-1.jpg?raw=true" alt="Hyper-Pipelining-1"></p><p>CPU MHz 提升的根本原因是芯片制造工艺规模的进步，通常每18个月缩小1.4倍（又称摩尔定律）。制造规模每缩小一倍，晶体管数量就会增加一倍（1.4 的平方），晶体管也会缩小一倍，布线距离和信号延迟也会缩小 1.4 倍。</p><p>因此，人们会期望 CPU MHz 随着反向信号（inverted singal）延迟的增加而增加，但是图1显示时钟速度已经进一步增加。</p><blockquote><p>这句话不太理解，翻译不好：Thus one would expect CPU MHz to increase with inverted signal latencies, but Figure 1 shows that clock speed has increased even further.</p></blockquote><p>这主要是由 <strong>Pipelining</strong> 技术完成的：<u>将 CPU 指令的工作划分为多个阶段，减少每个阶段的工作量意味着可以提高 CPU 频率</u>。1988 年的 Intel 80386 CPU 需要一个（或多个）周期才能执行一条指令，而 1993 年的 Pentium 已经有 5 级流水线，1999 年的 PentiumIII 增加到 14 级，而 2004 年的 Pentium4 有 31 级流水线。</p><p>但是 Pipeines 技术引入了两个风险： <strong>(1)</strong> 如果一条指令需要前一条指令的结果，则不能立即将其推入 pipeline，必须等到前一条指令（或其大部分）通过 pipeline，（即前一条指令执行完）； <strong>2）</strong> 在 <u>IF-a-THEN-b-ELSE-c</u> 条件分支代码中，CPU 必须要预测 a 的计算结果是 true or false。它可能预测为 false，并在 a 之后将 c 放入 pipeline 之中。经过许多阶段后，当 a 的计算结果出现了，CPU 可能确定自己前面猜错了（mispredicted the branch），那么就需要 Flush  Pipeline（即丢弃 Pipeline 中所有待执行的指令），然后重新将分支 b 的指令填充到 pipeline 中。很明显，Pipeline 越长，被丢弃的指令就越多，性能惩罚也就越高。</p><p>对应到数据库系统，依赖于数据的分支是无法预测的（比如在选择性不是很高也不是很低的数据上进行分支预测），并且会显著降低查询执行速度。</p><p>此外，Super-scalar CPUs（又名 Hyper-Pipelined CPUs）提供了并行执行多条指令（前提是他们之间是不存在依赖关系）的可能性。也就说，CPU 不是只有一条，而是有多条 Pipelines。因此，在每个指令周期，新的指令可以被放入到每个 Pipeline 中，只要他们与所有正在的指令之间不存在依赖关系。因此，Super-scalar CPUs 的 IPC &gt; 1。 图 1 显示了现实世界中 CPU 性能比 CPU 频率增长得更快，就是因为这个原因。</p><p>Modern-CPUs 总是会以不同的方式进行平衡。</p><ul><li>Intel Itanium2 具有多个并行 Pipelines 的 VLIW （<strong>V</strong>ery <strong>L</strong>arge <strong>I</strong>nstruction <strong>W</strong>ord）处理器，它只有非常少的 7-stage Pipeline，但是在一个指令周期内能执行多达 6 个指令，因此它的拥有一个相对低的时钟速度，为 1.5GHz。</li><li>相比之下，Intel Itanium4 拥有长达 31-stage Pipeline，拥有 3.6GHz 的时钟速度，但是一个指令周期却最多只能执行3个指令。</li></ul><p>无论使用哪种方式，为了达到 CPU 理论上的最大吞吐量， Itanium2 在任何时刻都需要 7 * 6 &#x3D; 42 个没有依赖关系的指令，而 Itanium4 却需要 31 * 3 &#x3D; 93 个。由于不总是能找到满足最大吞吐量的条件，因此许多程序使用 Itanium2 的计算资源效果比 Itanium4 更好，这解释了为什么在 benchmark 中，尽管时钟速度差异很大，但两种 CPU 的性能表现却相似。</p><p>绝大多数编程语言并不会要求程序员在他们的代码中显式指定哪些指令（或者表达式）之间不存在依赖关系，因此。编译器优化（<em>compiler optimizations</em>）对于获得良好的 CPU 利用率就变得至关重要。其中最重要的技术就是 <em>loop pipelining</em>，一个由多个相互依赖的算子（F(), G()）组成的算子从</p><p>$F(A[0])$, $G(A[0])$, $F(A[1])$, $G(A[1])$, …$F(A[N])$, $G(A[N])$</p><p>转化成</p><p>$F(A[0])$, $F(A[1])$, $F(A[2])$, …$F(A[N])$, $G(A[0])$, $G(A[1])$, $G(A[2])$, …$G(A[N])$</p><blockquote><p>即将两两相互依赖的算子变成不依赖的</p></blockquote><p>假设: F() 的 Pipeline 依赖延迟是 2 cycles，且当 G(A[0]) 送入 Pipeline 执行时，F(A[0]) 的执行结果已经可用。</p><p>在 Itanium2 处理器上，compiler optimizations 的重要性甚至更强:</p><ul><li>因为编译器必须要在编译期<u>找到可以进入不同 Pipelines 的指令</u>，而其他 CPUs 可以通过乱序执行（<em>Out-of-Order</em> Execution）在运行完成这项任务。由于 Itanium2 不需要任何复杂的逻辑来查找 Out-of-Order Execution 的机会，因此它可以包含更多的 Pipelines 来完成实际工作。</li><li>此外，Itanium2 还有个叫做 <strong>branch predication</strong> 的特性，可以用于消除 <em>branch mispredictions</em>（允许并行执行 THEN 和 ELSE 两个分支，并在条件 a 的计算结果确定后，立即丢弃错误分支的执行结果）。而检测 <u>branch predication</u> 的机会也是编译器的任务。</li></ul><p>图-2 展示了查询 <code>SELECT oid FROM table WHERE col &lt; X</code> 的 mirco-benchmark，其中 X 是均匀随机分布在 <code>[0, 100]</code> 区间，并且我们从 0 到 100 变动着 X。<br>由于分支预测错误，像 AthlonMP 这样的普通 CPU 显示出大约 50% 的最坏情况行为。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/Hyper-Pipelining-2.jpg?raw=true" alt="Hyper-Pipelining-2"></p><p>通过采纳 [17] 中的建议，通过巧妙地重写代码，将分支预测转换为 boolean 计算（即predicated 的变体）。尽管这个重写后的代码与分支选择性无关了，但是却引入了更高的均摊成本（average cost）。然而有趣的是，在 Itanium2 处理器上，”branch” 版本却有着更高的效率，并且也和分支选择性无关，这是因为编译器将分支转化为硬件预测（hardware-predicated）代码。</p><p>最后，我们也应该提以下片上缓存（on-chip cache，即 L1, L2）对 CPU 吞吐量的重要性。CPU 执行的所有指令中大约 30% 会有内存加载（memory load）和写入内存（memory store）操作，即需要访问 DRAM 芯片中的数据，而这些 DRAM 芯片距离主板上的CPU有几英寸，这对内存延迟施加了大约 50ns 的物理下限，（即 CPU 访问 DRAM 中的数据至少有 50ns 的物理延迟）。在频率为 3.6G 的 Itanium4 CPUs 上，这个 50ns 的最小延迟（还是理想情况下）就会转化为 180个等待周期，因此只有当程序访问的内存绝大多数都已经缓存在 L1&#x2F;L2 等高速缓存中时，Modern-CPUs 才有机会以其最大吞吐量运行。</p><p>最近的数据库研究表明，内存访问成本（cache misses）严重损害了 DBMS 的性能，并且如果使用缓存敏感型（cache-conscious）数据结构，比如 cache-aligned B-Trees，或者使用 <strong>column-wise</strong> 数据布局（比如 PAX 、MonetDB 中的 DSM），就可以显著改善数据库性能。此外，将随机内存访问模型（random memory access patterns）限制在某一个区域，使其适合 CPU 缓存，这样的查询处理算法（例如 radix-partitioned hash-join 算法）也是可以极大提高数据查询性能。</p><p>总的来说， Modern-CPUs 已经变成一个高度复杂的设备，处理器的指令吞吐量可能会相差几个数量级，这主要取决于一下四个因素：</p><ol><li>memory loads 和 memory stores 的 cache 命中率</li><li>分支的数量以及他们是否能被预测</li><li>编译器和 CPU 平均能检测到的不相关指令数量</li></ol><p>研究表名，即便是在商业数据库中，查询执行引擎的 IPC 也才 0.7，也就是说每个指令周期执行的指令少于1个。相比之下，科学计算（例如矩阵乘法）或多媒体处理却可以从 Modern-CPUs 中获得的平均 IPC 高达 2。因此我们认为数据库不应该表现得这么糟糕，特别是在需要检查数百万 tuples 并计算表达式的大规模分析任务中。这些任务具有大量的独立性，应该能够完全填满 CPUs 所能提供的所有 Pipelines。因此，本文目标是调整数据库架构，尽可能将其暴露给编译器和 CPU，从而显着提高查询处理吞吐量。</p><h2 id="3-Micro-benchmark-TPCH-Q1"><a href="#3-Micro-benchmark-TPCH-Q1" class="headerlink" title="3. Micro-benchmark: TPCH Q1"></a>3. Micro-benchmark: TPCH Q1</h2><p>虽然我们总体上以查询处理的 CPU 效率为目标，但我们首先关注表达式计算（expression calculation），放弃更复杂的关系操作（比如 JOIN）以简化我们的分析。我们选择 TPCH benchmark Q1（如图-3所示）来进行分析，因为在我们测试的所有 RDBMSs 上，该 Query 都是CPU 密集型的（CPU-bound）。此外，这个Q1的执行计划非常简单，以至于几乎不需要优化和花哨的 JOIN 实现。因此，所有数据库都在一个公平的竞争环境中运行，并主要突出它们计算表达式的效率。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/Hyper-Pipelining-3.jpg?raw=true" alt="Hyper-Pipelining-3"></p><p>TPCH benchmark 运行在 1G 大小的数据仓库上，这个大小可以通过 <code>Scaling Factor</code> (SF) 来调节。Q1 是对大小为 SF * 6M tuples 的表 <em>lineitem</em> 进行 scan，几乎选择了该表的所有的数据（SF * 5.9M tuples），并计算了多个 fixed-point 十进制表达式：两个 column-to-const 减法，一个 column-to-const 加法，三个 column-to-column 乘法以及8个聚合计算（四个 SUM，三个 AVG和一个 COUNT）。聚合分组是针对两个单字符列（two single-character column），并仅产生四个唯一的组合，因此通过小的 hashtable 就能高效完成，不需要额外的 IO，甚至不需要 CPU 缓存命中。</p><p>下面，我们先分析Q1在关系型数据库上的性能，然后分析在 MonetDB&#x2F;MIL 上的性能，最后是通过 hand-coded 实现的性能。</p><h3 id="3-1-Q1-on-Relational-Database-Systems"><a href="#3-1-Q1-on-Relational-Database-Systems" class="headerlink" title="3.1 Q1 on Relational Database Systems"></a>3.1 Q1 on Relational Database Systems</h3><p>从 RDBMSs 早期开始，他们的查询执行功能就是通过实现物理关系代数（Physical Relational Algebra）来提供的，这通常遵循 Volcano 流水线处理模型。然而，关系代数的参数有很高的自由度。比如，即使是一个简单的 ScanSelect(R, b, P) 也只能在查询时（query-time）才能完全了解:</p><ul><li>输入关系 R 的格式（列数、列类型和记录偏移量，</li><li>布尔选择表达式 b (可以是任何形式），以及</li><li>定义输出关系的 projection 表达式 P 的列表（每个表达式的复杂度都是任意的)</li></ul><p>实际上，为了处理所有可能的 (R,b,P)，DBMS 开发者必须实现一个可以处理任意复杂度表达式的表达式解释器（expression interpreter）。</p><p>这样一个 interpreter 的问题在于做有用功的成本（即执行 query 中出现的表达式）仅仅占整个查询执行成本（total query execution cost）的一小部分，尤其是当 interpretation 的粒度是 tuple 时更为严重。我们可以在表-2 中看到这种情况，该表显示了 SF&#x3D;1 时，MySQL-4.1 执行 TPCH Q1 时的 gprof 记录。 </p><ul><li>cum: 第一列是第二列的累加和</li><li>excl: 第二列显示函数所消耗的时间占总执行时间百分比，不包括该函数调用其他函数所花费的时间。</li><li>calls: 第三列显示该函数的调用次数 </li><li>第四列和第五列显示每次调用函数的平均指令数，以及实现的 IPC</li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/Hyper-Pipelining-table-2.jpg?raw=true" alt="Hyper-Pipelining-table-2"></p><p>从表-2可得如下两个结论：</p><ol><li><p>耗时组成： 完成所有“工作”（表-2中以粗体显示）的五个操作仅相当于总执行时间的 10%。另外 28% 的时间用于聚合操作中 HashTable 的创建和查询，还有剩余的 62% 的时间消耗在 <code>rec_get_nth_field</code> 等函数上，用于将产生的结果复制给用户。而其他因素，比如锁的开销（pthread_mutex_unlock, mutex_test_and_set）或者 buffer page 的开销（buf_frame_align）似乎可以忽略不计。</p></li><li><p>“Item” 操作的成本与查询的计算工作相呼应。比如，<code>Item_func_plus::val</code> 函数每次执行都消耗 38 个指令。这个性能记录是在配备了 MIPS R1200 CPU 的SGI机器上获得的，该机器可以在一个指令周期执行 3 个整数或浮点指令和一次 load&#x2F;store，平均操作延迟约为 5 cycles。</p><p>一个简单的 “+” 算法用 RISC 指令实如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">plus</span><span class="params">(<span class="type">double</span> src1, <span class="type">double</span> src2)</span> </span>&#123;</span><br><span class="line"> LOAD src1, reg1</span><br><span class="line"> LOAD src2, reg2</span><br><span class="line"> ADD reg1, reg2, reg3</span><br><span class="line"> STOR dst, reg3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码中的限制因素是三个 LOAD&#x2F;STOR 指令，因此 MIPS 处理器每 3 个周期才能可以执行一次加法操作。而 MYSQL 执行一次 <em>Item_func_plus::val</em> 所需的周期是是 <strong>#ins&#x2F;IPC &#x3D; 38&#x2F;0.8 &#x3D; 49 cycles</strong>。</p><p>对于如此高昂的成本，一个解释就是没有 <em>loop pipelining</em>，因此这个加法是由四个存在依赖关系的指令组成，必须彼此等待。由于指令平均延迟为 5 cycles，这就解释了大约 20cycles 的成本，49 cycles 中的剩余其他 cycels 则消耗在函数之间的跳转、函数的入栈出栈。</p><blockquote><p>我觉得这解释有点牵强</p></blockquote></li></ol><p>MYSQL 以 “tuple-at-a-time” 策略执行表达式的结果有两点影响：</p><ol><li><em>Item_func_plus::val</em> 只执行一次加法，阻碍了编译器创建 <em>pipelined loop</em>。因为一个操作（比如这里的一次加法操作）的指令是具有高度依赖的，必须生成空的 pipeline slot 来等待（甚至停顿等待）指令延迟，以至于 loop 的成本变成 20cycles 而不是 3cycles。</li><li>函数调用的成本（大约 20cycles）只能在一次操作中分摊，这使得该操作成本翻倍。</li></ol><p>总而言之，<strong>tuple-at-a-time</strong> 即一次只针对一个数据进行操作，导致无法 pipelined loop + 无法分摊成本。</p><p>此外，我们也在知名的商业数据库上测试了相同的查询 Q1，如表-1 第一行所示。虽然我们没有该产品的源码，无法获得 gprof 性能记录，但是该 RDBMS 的查询评估成本和 MYSQL 是极其相似的。表-1的下半部分是从 TPC 网站获取的一些官方 TPCH Q1 结果。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/Hyper-Pipelining-table-1.jpg?raw=true" alt="Hyper-Pipelining-table-1"></p><h3 id="3-2-Q1-on-MonetDB-MIL"><a href="#3-2-Q1-on-MonetDB-MIL" class="headerlink" title="3.2 Q1 on MonetDB&#x2F;MIL"></a>3.2 Q1 on MonetDB&#x2F;MIL</h3><p>MonetDB&#x2F;MIL 是由本论文作者团队开发的，因使用垂直分片（vertical fragmentation），按列存储表（storing tables column-wise）而知名。</p><p>我们使用 MonetDB&#x2F;MIL SQL frontend 将 TPCH Q1 转化为 MIL 语言后再执行。表-3显示了 20个 MIL 调用情况，它们总共占用了 99% 以上的查询运行时间。基于 TPCH Q1，MonetDB&#x2F;MIL 是明显快于 MYSQL 和同一机器上的商业 DBMS，并且和表-1中已公布的 TPCH 结果也具有竞争力。然而，仔细观察表-3会发现，几乎所有 MIL 操作都是内存密集型（Memory-bound）而不是CPU密集型操作（CPU-bound），即受限于内存而无法充分利用 CPU 资源。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/Hyper-Pipelining-table-3.jpg?raw=true" alt="Hyper-Pipelining-table-3"></p><p>在将 TPCH 数据集的规模系数 $SF &#x3D; 0.001$ 时，再运行相同的查询计划，表 <strong>lineitem</strong> 所有使用到的列和产生的中间结果（intermediate results）此时都都能填充到 CPU Cache 中，这就消除了CPU和内存之间的流量，然后，MonetDB&#x2F;MIL 的速度几乎是原来的两倍。</p><p>表-3的第 2 列和第 4 列显示的是各个 MIL 操作实现的 bandwidth（BW，以 MB&#x2F;s 为单位），同时计算了输入 BAT（Binary Association Table） 的大小和生成的输出 BAT。</p><ul><li>在 SF&#x3D;1 时，MonetDB 带宽上限卡在 500MB&#x2F;s，这是在该硬件上可持续的最大带宽</li><li>在 SF&#x3D;0.001 时，能够完全在 CPU 缓存中运行，此时带宽上限可以达到 1.5GB&#x2F;s。</li></ul><p>对于乘法 <code>[*]()</code>，bandwidth 只有 500 MB&#x2F;s 意味着 tuples 速度是 20M&#x2F;s （16 个字节输入，8 个字节输出），因此在我们的 1533 MHz CPU 上每个乘法需要 75 cycles，这比 MySQL 还要拉胯。</p><p>因此，MonetDB&#x2F;MIL 的 <strong>column-at-a-time</strong> 策略表现出两面性：</p><ul><li><p>优点： MonetDB 不容易遇到 MySQL 的问题，即 90% 的查询执行时间都消耗在 “tuple-at-a-time” 模型的解释开销上。</p><p> 这是因为乘法是操作整个 BATs (这是个数组，其 layout 在编译时就已知)，那么编译器能够使用 loop-pipelining 技术，使得这些运算具有很高的 CPU 效率，具体体现在表-3 SF&#x3D;0.001 的结果中。</p></li><li><p>缺点：Full Materialization</p><p> 当基于大量 tuples 进行复杂逻辑表达式计算时，查询将为表达式中的每个函数 materialize 整个结果列。然而，这样的中间结果对于整个查询而言并不是必要的，它只是作为表达式中其他函数的输入。比如。在一个查询计划中，聚合操作是最顶层的算子（即执行计划的根节点），那么最终输出的结果大小甚至可以忽略不计（比如TPCH Q1）。在这种情况下，MIL 产生的中间数据远多于实际所需的，导致非常高的带宽消耗（即所需的带宽也远多于实际所需的）。</p><p> 而这个问题在 Volcano-like 查询执行引擎中并不存在，它可以一次性完成选择、计算和聚合，而不具体化任何数据（即不会产生无用的中间数据）。</p></li></ul><p><strong>所以就是要结合 Volcano-like 和 MonetDB 各自的优点重新设计新的 X100。</strong></p><h3 id="3-3-Q1-Baseline-Performance"><a href="#3-3-Q1-Baseline-Performance" class="headerlink" title="3.3 Q1 Baseline Performance"></a>3.3 Q1 Baseline Performance</h3><p>为了获得现代硬件对 Q1 等问题的处理能力的 baseline，我们将其实现为 MonetDB 中的一个 UDF，如图 4 所示，该 UDF 仅在查询涉及的那些列中传递。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/Hyper-Pipelining-4.jpg?raw=true" alt="Hyper-Pipelining-4"></p><p>从 表-1 可以看出这个 UDF 实现（标记为“hand-code”）居然将查询成本降低到了 0.22s。 然而，表-1也可以看出，新的 X100 查询处理器（见下一篇博客）能够达到此 UDF 版本的 2 倍以内（也就是虽然慢了一倍，但还是算很快，毕竟编译器自动生成的肯定比不上大佬手写的）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Abstract&quot;&gt;&lt;a href=&quot;#Abstract&quot; class=&quot;headerlink&quot; title=&quot;Abstract&quot;&gt;&lt;/a&gt;Abstract&lt;/h2&gt;&lt;p&gt;在计算密集型（compute-intensive）的应用领域中，数据库系统在现代 CPU 上</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="Papers" scheme="https://szza.github.io/tags/Papers/"/>
    
  </entry>
  
  <entry>
    <title>Radix-Join Cluster Algorithm</title>
    <link href="https://szza.github.io/2023/04/22/Paper/Radix-Join/"/>
    <id>https://szza.github.io/2023/04/22/Paper/Radix-Join/</id>
    <published>2023-04-22T02:12:01.000Z</published>
    <updated>2023-08-07T09:24:46.055Z</updated>
    
    <content type="html"><![CDATA[<p>现在很多 JOIN 算法在进行 JOIN 操作之前，会先将输入划分成多个 clusters&#x2F;partitions，再在每个 cluster 内部进行 JOIN，以便使用多线程等来加速 JOIN。现在主流的分区算法大都是基于 radix-cluster algorithm[1] 及其衍生对输入进行分区。</p><blockquote><p>现在的 join 算法为提高性能，基本都是想着如何充分发挥硬件的特性，比如线程，NUMA 内存分配特性，SIMD，TLB entries、cache lines等。</p></blockquote><p>本文只是作为后续 JOIN 算法的一个铺垫，因此主要介绍 radix-cluster algorithm 本身，其他部分可参考原文[1]。</p><h2 id="PARTITIONED-HASH-JOIN"><a href="#PARTITIONED-HASH-JOIN" class="headerlink" title="PARTITIONED HASH-JOIN"></a>PARTITIONED HASH-JOIN</h2><p>Shatdal et al.[2] 提出了一种在 main-memory 下 Grace Join 算法的变体。</p><p>该算法先基于一个 hash-number 将两个输入划分都分别为 H 个不同的 clusters，使得每个分区都能纳入 memory cache，这种方式比常规基于 bucket-chained hash join 性能更好。该算法简单明了，直接使用了一个分簇算法(clustering-algorithm)： <strong>只扫描输入一次，并将每个被扫描的 tuple 插入到输出中一个 cluster</strong></p><p>如图-8所示，将左侧的输入随机的划分到 H 个单独的 cluster 中。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-1.jpg?raw=true" alt="radix-join-1"></p><p>这个算法，问题就出在随机上，因为会破坏内存访问的局部性，这点从图-8可以看出，输出的H个 clusters 和输入分布基本没啥关系。而且由于需要把每个 cluster 都尽可能纳入 memory-cache 中，就需要 H 尽可能大，使得产生的每个 cluster 就会尽可能小才能一次性纳入cpu cache。那么当 H 非常大时，又有两个因素会导致性能退化：</p><ul><li>如果 H 超过 TLB entries 的数量，那么每次访问内存（memory reference）都会产生一次 TLB miss；</li><li>如果 H 超过了 L1 or L2 可用的 cache lines 数量，cache thrashing 现象就会出现，进而导致 cache miss 次数激增。</li></ul><p>为解决这两个问题，提出了 Radix-Cluster Algorithm ，使得即便H非常大，也具有非常低的随机访问，进而提高性能。</p><h2 id="Radix-Cluster-Algorithm"><a href="#Radix-Cluster-Algorithm" class="headerlink" title="Radix-Cluster Algorithm"></a>Radix-Cluster Algorithm</h2><p>如图 9 所示，radix-cluster algorithm 使用多个阶段（论文中叫 pass）将输入划分为 H 个 clusters，</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-2.jpg?raw=true" alt="radix-join-2"></p><p>下面会先阐述下算法，然后以图-9为例进行说明算法。</p><p>radix-clustering 算法是基于某列生成的整数 hash value 的低 $B$ bits 上实现的：<br>该算法有连续的 P 个 pass ，每个 pass 都基于输入 tuple 的 $B_p$ 个 bits 对输入进行分区，且该 $B_p$ 个 bits 的位置是从最左侧开始计算的 $\sum_1^pB_p$ bits。</p><p>比如图-9中 $B &#x3D; 3$，其中 $P&#x3D;2$，$B_1 &#x3D; 2$，$B_2&#x3D;1$：</p><ul><li>第一个 pass 先使用 $B_1$ bits，目前总共使用的是从最左侧开始计算的 $2&#x3D;\sum^{p&#x3D;1}_1B_p$ 个 bits 进行对一个 pass 输入进行分区；</li><li>第二个 pass 再使用 $B_2$ bits，目前总共使用的是从最左侧开始计算的 $3&#x3D;\sum^{p&#x3D;2}_1B_p$ 个 bits 对第二个 pass 输入进行分区</li></ul><blockquote><p>第二个 pass 是在第一个 pass 的基础上再进行分区，因此看似只使用了一个 bit，实际上包含了第一个 pass 中两个bits的影响，因此说第二个 pass 使用从最左侧开始的 3 个 bits也没问题。</p></blockquote><p>radix-cluster 算法创建的 clusters 数量 $H &#x3D; \prod^p_1 H_p$，其中后一个 pass 会基于上一个 pass 输出的每个 cluster 继续子划分为 $H_p &#x3D; 2^{B_p}$ 个新的 cluster。</p><p>因此当算法开始时，整个输入就被视为一个完整的 cluster，第一个 pass 就被划分为 $H_1 &#x3D; 2^{B_1}$ 个新的 clusters，然后在下一个 pass 继续基于 $H_1$ 个 clusters 再次划分，每个 cluster 又产生 $H_2 &#x3D; 2^{B_2}$ 个新的 clusters，因此两个 pass 就一共产生了 $H_1 * H_2$ 个 clusters。</p><p>特别地，当 $P &#x3D; 1$ 时，radix-cluster 算法即类似上述简单明了的划分算法。</p><blockquote><ul><li>为什么说 radix-cluster 算法在 H 很大时局部性更好？这个观察图-9两个pass的输出应该能得出结论。</li><li>此外，为便于演示，在图-9所示的整数值表中没有使用哈希函数。然而，在实际中，即便是整数值，最好也使用一个hash函数，来确保值的所有位数都能发挥作用。</li></ul></blockquote><p>radix-cluster 算法有诸多好处：</p><ol><li>通过多个 pass 可以实现在具有非常大 H 的情况下，还可以将随机访问的 $H_x$ 数量保持在很低的水平。更具体地说，就是如果我们能保证 $H_x &#x3D; 2^{B_x}$ 同时小于 cache lines 的数量和 TLB entries 的数量，那么我们就可以在每个pass的分区中完全避免 TLB  miss 和 cache miss。</li><li>在基于某列（一般是 join-key cloumn）的 $B$ bits 进行 radix-clustering 之后，该列的hash值中具有相同 $B$ bits 的所有 tuples 表现出连续性，通常会形成每 $C&#x2F;2^B$ tuples 为一组的 chunks，其中 C 是输入的基数（cardinality）。因此，就没有必要使用额外的数据结构来记录这些 cluster 的边界：<strong>只需查看这些 clusters 的低 $B$ bits，就可以确定每个 cluster 的边界</strong>，这样就引入任何额外的开销。</li><li>此外，这种 radix-cluster 算法得到的输出还是基于 radix-bits 排序的。</li></ol><p>图-9 中：</p><ul><li>在第一个 pass 中，取最左侧 2 bits 来划分，能得到 $4 &#x3D; 2^2$ 个 clusters；</li><li>在第二个 pass 中，此时取从最左侧开始的 $3^{th}$ bit，对第一个 pass 输出的每个 cluster 再进子行划分，此时总共得到 $8 &#x3D; 2^1 * 4$ 个 clusters</li></ul><p>对输出的 clusters 进行观察可得：</p><ul><li>有界性：即不需要额外的数据结构就可以确定每个 cluster 的边界。比如，我们可以观察最终输出数组中的hash值的低 $B&#x3D;3$ bits 就能确定 <code>&#123;57, 17, 81, 75&#125;</code> 属于一个 cluster，而 96 和他们不是一个 cluster，并且这四个数字仍然保持原始输入中的顺序；</li><li>有序性：最终输出的8个cluster是基于 3bits 进行排序的，即按照 <code>000 --&gt; 001 --&gt;... --&gt; 111</code> 顺序递增</li></ul><h2 id="Experimental"><a href="#Experimental" class="headerlink" title="Experimental"></a>Experimental</h2><p>radix-cluster 算法有三个参数会对性能造成影响，${B, P, B_p}$，论文进行试验，保持其中一个参数不变，变化另外两个参数对算法进行量化分析。</p><h3 id="radix-bits"><a href="#radix-bits" class="headerlink" title="radix-bits"></a>radix-bits</h3><p>图-10展示了不同 CPU 架构下 1-pass 时不同 radix-bits 时执行时间分布细节。结论：</p><ul><li>纯CPU消耗的时间基本是恒定的，具体的数值在不同CPU架构上略有不同；</li><li>radix-bits 越小， memory 和 TLB 耗时越低，两者成正相关，即 radix-bits 增加，相应的耗时也会增加，比如当 radix-bits 超过 6 时，生成的 clusters 则超过了 TLB entries 的数量（$64 &#x3D; 2^6）$，此时造成的 TLB miss 次数增加了，对应的耗时也会激增。cache miss 也类似。</li></ul><blockquote><p>不同 CPU 的 TLB entries 和 cache lines 数量都不一样，所以图 10 显示的 radix-bits 影响不同；</p></blockquote><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-3.jpg?raw=true" alt="radix-join-3"></p><h3 id="multi-pass"><a href="#multi-pass" class="headerlink" title="multi-pass"></a>multi-pass</h3><p>图-11 展示了不同 passs 数量的影响。multipass radix-cluster 的核心思想是以增加 CPU 耗时来保证每个pass生成的 clusters 数量比较低，并降低内存耗。从图-11可得：</p><ul><li>在 radix-bits &gt; 6 时，即便通过 2-pass 设计，CPU 的耗时成本过高以至于无法避免 TLB 的耗时；</li><li>只有当 radix-bits &gt; 15 时，即 内存耗时超过 CPU 耗时，2-passes 才超过 1-pass<blockquote><p>by the way，关于这两点的原文不知道是我理解错了，还是原文写错了，似乎结论和图-11不匹配，且这两点就互相矛盾。原文如下：</p><ul><li>Obviously, the CPU costs are too high to avoid the TLB costs by using two passes with more than 6 radix-bits. </li><li>Only with more than 15 radix-bits (i.e., when the memory costs exceed the CPU costs) will two passes win over one pass</li></ul></blockquote></li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-4.jpg?raw=true" alt="radix-join-4"></p><p>注意：图-11 展示的仅是分区这一个操作的耗时，当分区数据增多这个耗时不可避免的增加，但是分区 + join 操作的总体耗时不一定会增加，甚至可能会锐减。这里引用论文[3]中的一个分区和join操作总体耗时的图，更能说明问题。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-4-1.jpg?raw=true" alt="radix-join-4-1"></p><p>论文认为唯一改善图-11中问题的方法是降低 CPU 开销，图12是论文 1-pass 的 radix-cluster 算法源码，multi-pass 也是类似，所做的一个优化（图-12中的右侧两行代码）就是去掉了两个函数调用：</p><ul><li>将 hashFcn 变成宏；</li><li>将 memcpy 替换为复制操作</li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-5.jpg?raw=true" alt="radix-join-5"></p><p>如图-13所示，优化之后，CPU 开销几乎降低了接近4倍，论文给出的两个理由是：</p><ul><li>some CPU cycles are saved;</li><li>the CPUs can benefit more from the internal parallel capabilities using speculative execution as the code has become simpler and parallelization options more predictable</li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/radix-join-6.jpg?raw=true" alt="radix-join-6"></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://ir.cwi.nl/pub/11143/11143B.pdf">Optimizing Main-Memory Join on Modern Hardware</a></li><li><a href>Cache Conscious Algorithms for Relational Query Processing</a></li><li><a href="https://15721.courses.cs.cmu.edu/spring2016/papers/kim-vldb2009.pdf">Sort vs. Hash Revisited: Fast Join Implementation on Modern Multi-Core CPUs</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;现在很多 JOIN 算法在进行 JOIN 操作之前，会先将输入划分成多个 clusters&amp;#x2F;partitions，再在每个 cluster 内部进行 JOIN，以便使用多线程等来加速 JOIN。现在主流的分区算法大都是基于 radix-cluster algori</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="Papers" scheme="https://szza.github.io/tags/Papers/"/>
    
  </entry>
  
  <entry>
    <title>Morsel-Driven Parallelism: A NUMA-Aware Query Evaluation Framework</title>
    <link href="https://szza.github.io/2023/04/02/Paper/Morsel-Driven%20Parallelism/"/>
    <id>https://szza.github.io/2023/04/02/Paper/Morsel-Driven%20Parallelism/</id>
    <published>2023-04-02T13:58:02.000Z</published>
    <updated>2023-08-08T13:55:47.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ABSTRACT"><a href="#ABSTRACT" class="headerlink" title="ABSTRACT"></a>ABSTRACT</h2><p>随着现代计算机架构的演进，与并行查询执行引擎中两个问题产生了矛盾：</p><ol><li>为了充分利用多核，所有的查询工作必须很快均匀地分布在数百个线程中才能实现良好的性能加速；</li><li>然而，由于现代 CPU out-of-order 的复杂性，即使有准确的数据统计，也很难将工作均匀分配</li></ol><p>因此，现有的针对 Volcano 的 <code>&quot;Plan Driven&quot;</code> 的并行方法遇到了负载均衡问题（load balancing） 和 上下文切换 （context switch）瓶颈，无法随着CPU架构的升级进行伸缩。许多多核架构面临的第三个问题就是 Memory controller 的去中心化，进而引起 NUMA（Non-Uniform Memory Access）问题。</p><p>因此，本文提出了一种 <code>&quot;Morsel Driven&quot;</code> 查询引擎执行框架，调度变成了一个细粒度的 runtime 任务，且能利用 NUMA 特性。Morsel- Driven 查询处理引擎接受输入数据的一小片段（”morsels”），然后将 morsels 调度给 work 线程，这些 work 线程运行着完整的 operator pipeline，直到遇到下一个 pipeline 才会中断。</p><p>每个 work 线程运行着一个 pipeline，pipeline 中填充着不同的 operators 来操作数据。只要输入 morsels，就会依次从 SourceOperator 向 SinkOperator 流去。</p><p>并行度（degree of parallelism, dop）并不是个固定值，是可以在查询执行期间弹性地更改，因此 dispatcher 可以对不同 morsels 的执行速度作出反应，也可以动态地调整资源以响应工作负载中的新查询。此外。dispatcher 是能感知到 NUMA-local morsels 和算子状态（operator state）的数据局部性，以便绝大多数任务执行发生了 NUMA-Local 内存上。</p><h2 id="1-INTRODUCTION"><a href="#1-INTRODUCTION" class="headerlink" title="1. INTRODUCTION"></a>1. INTRODUCTION</h2><p>硬件都朝着提升多核性能的方向发展，本文使用术语 “many-cores” 来描述具有数十上百线程的CPU架构。与此同时，每台服务器的内存容量能增加到几TB，这也带动了内存数据库系统的发展。在这样的系统中，查询处理不再受 I&#x2F;O 限制，并且可以真正利用多核的巨大并行计算资源。不幸的是，将 Memory Controller 转移至芯片中，以及将吞吐量拓展到几TB的巨大内存所需的内存访问分散化（decentralization of memory access）的趋势，产生的 NUMA。本质上，计算机本身已经成为一个网络，因为数据项的访问成本取决于数据和访问线程所在的芯片。因此，”many-cores” 并行化需要将 RAM 和cache 的层次结构纳入考虑范围，尤其要仔细考虑 RAM 的 NUMA 划分，以确保大部分线程在 NUMA-Local 数据上工作。</p><blockquote><p>核心思想就是如何减少跨 core 通信：每个线程尽量访问自己核上的数据。RocksDB 中有个数据d结构 <a href="https://github.com/facebook/rocksdb/blob/9a2a6db2a9c5e628b38a5c8cceb90e1e5dbc39a4/util/core_local.h#L23">CoreLocalArray</a>，给每个 core 分配一个对象，让线程访问数据时直接访问线程所在core，减少与 remote core 之间的跨核通信</p></blockquote><p>在此之前的并发模型是 <strong>Volcano</strong> 模型，这种模型中 operators 是没有并行度可言的。因为并行的概念被封装成 Exchange Operator，这个算子在多线程间路由数据流，每个线程都执行着查询计划中完全相同的 pipelined 部分。这种设计就是 <em>plan driven</em>: 基于统计数据优化器在生成执行计划的编译期就确定需要启动多少线程，为每个线程实例化一个查询算子（query operator）并通过 exchange operators 实现这些 operators 间的通信。</p><p>本文提出 <em>morsel driven</em> 查询执行框架，如 fig-1 是执行三表 join 查询 $R \Join_A S \Join_B T$ 的示意图，并行性是通过并行处理不同 cores 上的每个pipeline 实现的。如图所示，有红色和蓝色两个 pipelines。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-1.jpg?raw=true" alt="morsel-driven-1"></p><p>该框架的核心是调度机制（scheduling mechanism）即图中的 <em>dispatcher</em>，使得可以灵活地并行执行 operator pipleine，甚至可以在查询执行期间改变并行度。</p><p>一个 query 会划分成多个 segments，每个可执行的 segments 都会接受输入的一小部分（即 morsel）作为数据源，然后执行，直到遇到下一个 pipeline 才会输出具体的结果。</p><p>如 fig-1 中的红蓝所示，该 morsel 框架也支持 NUMA 局部处理：线程 T1 在一个 NUMA-Local 上输出输入，并且将其结果写入 NUMA-Local 存储区域，全程都没有跨 NUMA 结构。</p><p>fig-1 中的 <em>dispatcher</em> 运行着与机器相关的固定数量的线程，这样即便新的 queries 到来，也不会出现资源的过度消耗，并且这些工作线程与 cpu core 绑在一起，这样就不会因为操作系统将线程移动到其他CPU core 导致 NUMA 局部性失效。</p><blockquote><p>一般工作线程数和 <a href="https://en.cppreference.com/w/cpp/thread/thread/hardware_concurrency">std::thread::hardware_concurrency()</a> 函数返回值一致，而这个函数的返回值一般和机器有关。</p></blockquote><p>morsel-driven 的调度机制核心特性是 task 的分配在 runtime 时完成的，并且完全弹性的，即可以通过增加或者降低正在执行的查询的并行度，来处理运行时变化的 workloads，这样就能实现完美的负载均衡（load balancing）。</p><p>morsel-driven 框架的思想从调度拓展到整个查询执行框架，即所有的物理查询算子都必须在他们所有的执行阶段都能实现 morsel 级别（morsel-wise）的并行，比如 HashJoin 的 build 和 probe 阶段。根据 Amdahl 定律，这对实现 many-core 可伸缩性至关重要。</p><p>morsel-wise 框架的一个重要特性就是能感知到数据局部性（data locality），这个起始于输入 morsels 和输出 buffer 的的局部性，并且拓展到 operator state 的局部性（operator state，一般是数据结构，比如 Aggregator 中的 HashTable）。尽管 operator state 是个可能被任何 cores 都访问到的共享数据结构，但是 operator state 确实仍有高度的 NUMA 局部性。</p><p>在为了实现 load balance 时，会需要从其他 core 获取一小部分 morsels，这时才会发生 remote NUMA 访问，即损失了 NUMA 局部性。</p><p>也就是说，通过主要访问 NUMA-Local 内存，可以优化内存延迟（memory latency），并将可能减慢其他线程速度的 cross-socket 内存流量降到最低。</p><p>本文，主要贡献是以下三点：</p><ol><li><p>Morsel-driven query execution</p><p> 这是一个新的查新计算框架，与传统的 Volcano 模型的不同点主要是使用 work-stealing 方式在线程间动态分配任务。这可以防止由于负载不均衡（load imbalance）导致CPU资源未被使用，并且可以实现弹性，即可以随时在不同查询之间重新分配 CPU 资源。</p></li><li><p>一些并行算法。见后文的 HashJon、Aggregate、Sort 并行算法</p></li><li><p>将 NUMA-Awareness 融入到数据库的方法</p></li></ol><h2 id="2-MORSEL-DRIVEN-EXECUTION"><a href="#2-MORSEL-DRIVEN-EXECUTION" class="headerlink" title="2. MORSEL-DRIVEN EXECUTION"></a>2. MORSEL-DRIVEN EXECUTION</h2><p>使用 fig-1 中的 $\sigma(R) \Join \sigma(S) \Join \sigma(R)$ 来展示本文并行 pipeline 查询引擎的执行流程。假设 $R$ 是过滤之后最大的表，优化器将选择 $R$ 作为 HashJoin 的 probe 侧输入，而使用 $S$ 和 $T$ 来 build HashTable。</p><p>如fig-2左侧，根据 cost-based 优化器得到的查询计划由三条 pipelines 组成：</p><ol><li>扫描、过滤表 T 后，构建 T 的 HashTable $HT(T)$</li><li>扫描、过滤表 S 后，构建 S 的 HashTable $HT(S)$</li><li>扫描、过滤表 R 后，再 probe $HT(S)$ 和 $HT(T)$，将结果存在输出区域</li></ol><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-2.jpg?raw=true" alt="morsel-driven-2"></p><!-- HyPer 使用 JIT 技术生成高效的机器码（machine code）。每个 pipeline 都被编译到 code fragment，这实现了非常高的性能。此外，pipeline 中的 operators 也不会产生中间结果，这都已经由 VectorWise 实现了。 --><p>morsel-driven 框架中，代数计划的执行是由 <em>QEPobject</em> 来控制的，它会将可执行的 pipelines 传递给 <em>dispatcher</em>。因此，<em>QEPobject</em> 需要爱去检测数据的的前置依赖， 比如fig-2的例子中，只有在前两个 pipelines 执行完，3-rd pipeline 才能执行。在具体的每个 pipeline 中，<em>QEPobject</em> 会分配临时存储区（temporary storage areas），执行 pipeline 的并行线程会将结果写入到这个临时存储区。</p><p>在整个 pipeline 执行完后，临时存储区在逻辑上会被重新分割为同等大小的 morsels，这样后续的 pipeline 就可以从大小均等的新 morsels 上启动，而不是在 pipelines 之间保留 morsels 边界（容易导致数据倾斜）。任意时刻执行 pipelines 的线程数都受处理器硬件线程数量的限制，即上限是 <code>std::thread::hardware_concurrency()</code>。</p><p>为了写入 NUMUA-Local 并避免在输出中间结果时线程同步，<em>QEPobject</em> 为每个执行 pipeline 的 thread&#x2F;core 分配一个存储区域。</p><p>$HT(T)$ pipeline 的并行处理如 fig-3 所示。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-3.jpg?raw=true" alt="morsel-driven-3"></p><p>先重点关注第一阶段：每个线程先过滤输入 T，然后将过滤后得数据 tuples 存放在临时存储区。</p><p>在图中，有三个并行线程，每个线程一次操作一个 morsel。由于表 T 是以 morsel 为单位存储在多个 NUMA Node 的内存中，那么只要有可能（比如内存足够）那么 scheduler 就会将线程 T 所属的 NUMA Node 上的 morsel 分配给线程T。</p><p>比如在 fig-3 中颜色所表征的意思：在红色 Numa Node 上的 core 运行着红色线程，被赋予的任务就是处理红色 morsel。</p><p>只要线程 T 处理完了赋予的 morsel，要么被委托去执行其他任务（即work-steal 其他颜色的 morsels）或者获取同一个 Numa Node 上的 morsel（即相同颜色）来作为下一个任务。</p><p>fig-3 左侧标记了该 pipeline 被划分后的两个阶段。</p><ol><li><p>在第一阶段，过滤后的数据直接写入了 NUMA-Local 存储区域，也就是说对于每个 core 都有个单独存储区域来避免线程同步。</p><p>为了保持后续处理阶段的的 NUMA 局部性，在同一个socket上本地分配特定 core 的存储区域。即该core的存储区域总是在一个 socket 上分配。</p><blockquote><p>这里的 socket 是插槽。</p></blockquote></li><li><p>当表 T 的所有 morsels 在第一阶段都已经处理完，在第二阶段会被位于相同 core 上的线程再次扫描，并且插入一个指向 $HT(T)$ 的指针。</p></li></ol><p>之所以将构建 HashTable 分成两个阶段，是因为第一阶段完成后，数据的准确数据是已知的，就可以完美地确定全局 hashtable 的大小。这个大小确定的 gloabl hashtable 将会被系统中不同 NUMA Node 上的线程探测（probe）。因此，为避免竞争，这个 gloabl hashtable 就不应该位于特定的 NUMA 区域，而是应该分散在所有的 NUMA node上。由于许多线程都竞争着将输入插入 gloabl hashtable，那么必不可少地要实现一个 lock-free hashtable。</p><p>在 $HT(T)$ 和 $HT(S)$ 都构建完之后，probe pipeline 就可以被调度执行了。probe pipeline 的详细处理见 fig-4.</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-4.jpg?raw=true" alt="morsel-driven-4"></p><p>一个线程会向 dispatcher 请求任务，dispatcher 会在对应的 NUMA Node上 赋予该线程一个 morsel。也就是，如果线程位于红色 NUMA Node 上的 core，就会被分配表 R 在红色 NUMA Node 上的 morsel。Probe pipeline 的结果也会存储在 Numa 局部区域来保留后续处理阶段的局部性（这部分并没在图中画出）。</p><p>总得来说，morsel-driven 并行执行多个 pipelines 有点类似经典的 Volcano 模型实现，但是不同点在于 pipeline 是独立的，没有依赖的。也就是说，pipeline 共享数据结构并且 operators 能感知到并行执行的，因此最终必须执行线程同步（这一步需要通过有效的 lock-free 机制）。</p><p>未来可能的不同点，是执行 pipelines 的线程数也是完全弹性。也就是说，不仅在不同的 pipelines 之间的线程数不同，如 fig-2 所示，而且在查询执行期间，同一个 pipelien 内部也可能不同。</p><h2 id="3-DISPATCHER"><a href="#3-DISPATCHER" class="headerlink" title="3. DISPATCHER"></a>3. DISPATCHER</h2><p><em>dispatcher</em> 管控并将计算资源分配给并行的 pipelines。我们为每个机器提供的硬件线程（预）创建一个工作线程（work thread），并将每个工作线程永久地和他绑定在一起。</p><p>一个赋给 work thread 的 <code>task</code> 由两部分组成：pipeline job 和 pipeline job 的操作对象 morsel。由于 Task 的抢占发生在碎片边界，从而消除了可能代价高昂的中断机制。通过实验确定，morsel 大约在 100,000 个元组时，可以在即时弹性调整、负载平衡和低维护开销之间产生良好的权衡。</p><p>给指定 core 上运行的线程分配 Task 时，有三个主要目标:</p><ol><li>Locality: 保留 NUMA-Locality</li><li>Full elasticity: 关于查询的并行度，具有完全的弹性</li><li>Load balance: 要求所有参与 query pipeline 的核同时完成工作，防止先完成工作的 (fast)cores 等待其他的 (slow)cores。这个通过 worksteal 线程模型实现。</li></ol><p><em>dispatcher</em> 的架构如图 fig-5 所示，它维持了一个指向 pending pipeline jobs 的链表，这个链表中的 pipeline job 的前置依赖都已经处理完成。比如上面的 join 查询案例中，buidc pipeline job 会先插入到 pending jobs，只有在前两个 build pipelines 完成后，才会插入 proeb pipeline。正如前文所述，每个活跃的 queries 都是由 <em>QEPobject</em> 控制，它负责将可执行的 pipelines 传递给 <em>dispatcher</em>。 因此，<em>dispatcher</em> 只需要维护一个前置依赖都处理完成的 pipeline jobs 链表。</p><p>通常来说，<em>dispatcher</em> 的链表中包含的 pending pipeline jobs 是来自于并行执行的不同 queries，来适应 inter-query 的并行性。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-5.jpg?raw=true" alt="morsel-driven-5"></p><h3 id="3-1-Elasticity"><a href="#3-1-Elasticity" class="headerlink" title="3.1 Elasticity"></a>3.1 Elasticity</h3><p>通过 “morsel-at-a-time” 分发 pipeline jobs 来实现完全弹性并行性（fully elastic parallelism），允许根据服务质量模型智能调度这些查询间并行的 pipeline jobs。这样就能够在查询处理的任何阶段，优雅地降低长时间运行的查询Q1的并行度，以便优先考虑可能更重要的交互式查询Q2。一旦高优先级的 Q2 完成了，就会将时间片切给 Q2，这时候就可以给大多数甚至全部 cores 都分发 Q1 的 Tasks。会在 5.4 节展示弹性实验。</p><blockquote><p>当前的实现中，所有的查询都是相同优先级，因此线程是均匀分发给当前所有查询，基于优先级的调度机制不在本文介绍之列。</p></blockquote><p>对于每个 <strong>pipeline job</strong>，dispatcher 也为每个 pipeline job 维护了多个 moersls 链表，这是该 pipeline jobs 本次需要处理的数据源。对于每个 <em>core</em>，也存在一个单独的链表来实现局部性，比如对于 <code>core0</code> 上的任务请求一个 morsel，确保返回的 morsel 是来自于 <code>core0</code> 所在的 Numa Node 上。这两点可以从 fig-5 中的不同颜色看出。只要 <code>core0</code>  完成了分配的 morsel 及其 pipeline job 处理流程，就会请求一个新的任务，既可能来自于相同的 pipeline job，当然也可能不一定。这取决于正在执行的不同查询的不同 pipeline jobs 的优先级。比如，如果一个更高优先级的查询进入系统，那么就可能导致当前查询并行度降低。<code>&quot;Morsel-wise&quot;</code> 框架可以在不剧烈中断任务的情况下给不同的 pipeline jobs 重新分配不同的 cores。</p><h3 id="3-2-Implementation-Overview"><a href="#3-2-Implementation-Overview" class="headerlink" title="3.2 Implementation Overview"></a>3.2 Implementation Overview</h3><p>出于说明目的，fig-5 中我们直接给每个 core 都分配了一长串 morsels，但是实际上，我们为每个 core&#x2F;NUMA Node 都维护了一个存储区域并且按需将这个大的存储区域划分小的 morsels，即当 core 向 dispatcher 请求 Task 时。</p><p>此外，fig-5 中的 dispatcher 看起来像个独立运行的的线程，但是这会带来两个问题：</p><ol><li>dispatcher 本身需要一个 core 来运行，这可能会和执行 queries 的线程产生竞争；</li><li>因为 dispatcher 要分发任务，因此 dispatcher 本身可能会变成一个产生竞争的源泉（source of contention），成为性能热点，尤其当 morsels sized 被配置得特别小时</li></ol><p>因此，dispatcher 仅被实现为一个数据结构，dispatcher 的代码被 work thread 自己来执行，即由 work-thread 自己从 dispatcher 中取出 Task，那么dispatcher 就很自然地和这个 work thread 在一个 core 上执行。</p><blockquote><p>RocksDB 的 WriteThread 也是这个设计，WriteThread 本身就是 dispatcher 作用，并不会内部再启动一个线程来维护写入的 pending_writes。</p></blockquote><p>因此，基于 lock-free 实现 pipeline jobs queue 和 morsels queue，即便同时有多个查询工作线程同时向 dispatcher 请求 Task，也能降低竞争。类似地，QEPobject 被实现为被动状态机，即通过观察 pipeline 数据之间的依赖关系来推动查询进度，比如在 probe hashtable 之前必须先之前 buid hashtable。只要一个 pipeline job 执行完了，QEPobject 就会被调用，因为某些 Task 无法向 dispatcher 申请到新的 morsel，需要判断该完成的 pipelin job 是不是其他 pipeline jobs 的前置依赖。而此状态机，是在最初向 dispatcher 请求 Task 的 work thread 的不再使用的 core 上执行的。</p><p>除了能在任意时刻将一个 core 赋值给不同 queries 的能力（即 Elasticit），该 morsel-wise 处理流程也能保证 load balance 和 skew resistance。如果一个 core 完成了自己 NUMA-Local 上的所有 Morsels，则 dispatcher 会将 NUMA-Remote 上的 Morsels 分配给他，即 WorkSteal。在有些 NUMA 系统中，不是所有 NUMA Node 都是直连的，因此应该优先从较近的 NUMA-Node 上的 steal。尽管在正常的环境下，从 NUMA-Remote steal work 发生的概率很低，但是仍有必要去避免线程处于空闲状态。由于总是将结果写入 NUMA-Local 的存储区域，因此在 WorkSteal 场景下，coreA 从 coreB 窃取任务，执行完结果还是写入 coreA 的 NUMA-Local 区域。</p><p>目前主要讨论了 pipeline 的内部并行实现，但是我们的并行机制也支持多个 pipelines 并行。比如上面的三表 join 案例中，由于 HT(S) 和 HS(T) 之间没有依赖关系，可以同时并发执行。但是这种形式的并行带来的收益是有限的：因为独立没有依赖的关系的 pipelines 的数量是远小于 CPU cores 的数量，并且每个 pipeline 中的工作量通常也不相同。此外，pipelines 间并行可能会因为破坏 cache locality 导致性能降低。因此，当前的实现中会避免一个查询中同时并发执行多个 pipelines。在本文的JOIN案例中，会先执行 pipeline T，T 执行完了再将 pipeline S 添加到 dispatcher 的 pending pipeline jobs 中。</p><p>除了 Elasticity，本文的 morsel-driven 查询处理框架也实现了简单而又优雅地查询取消功能（query canceling）。无论是因为用户中止了查询，还是因为OOM等系统故障，被取消的查询会在 dispatcher 中被标记 marker。只要该 query 的一个 morsel 处理完，就会去检测 marker，因此很快该查询的所有 work threads 都会停止。这个方式比让操作系统去 kill 所有线程更加合理，可以去执行每个 work threads 的 CleanUp 操作（比如，释放内存等）。</p><h3 id="3-3-Morsel-Size"><a href="#3-3-Morsel-Size" class="headerlink" title="3.3 Morsel Size"></a>3.3 Morsel Size</h3><p>与 Vectorwise 和 IBM’s BLU 数据库不同，这些数据库以 vector 为单位在 operators 间传递，本文数据库不会因为 morsel 无法填充到 cache 中带来性能惩罚。Morsels 是用于将大型任务分解为小的、大小恒定的工作单元（work unit），这样便于 work steal。因此，Morsel 大小对于性能来说并不是很关键，它只需要足够大以分摊调度开销，同时提供良好的响应时间。在第五章会通过实验来衡量 morsel size 对查询 <code>select min(a) from R</code> 性能的影响。因为这个query非常简单，因此会尽可能突显出 work-stealing 数据结构的重要性。</p><p>fig-6 显示，在开销可以忽略不计的情况下，Morsel 大小应设置为尽可能小的值，在本例中，设置高于 1000 的值即可。尽管最优的设置依赖于硬件，但是很容易通过试验的方式获得。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-6.jpg?raw=true" alt="morsel-driven-6"></p><p>在多核系统中，共享的数据结构即便是通过 LOCK-FREE 的方式实现，最终也很可能会成为性能瓶颈。然而，在我们的 WorkSteal 数据结构中，有许多方面因素可以阻止这个问题。</p><ol><li><p>在论文的实现中，完整的任务在最初就在所有的线程间完成分解，因此每个线程都临时拥有着一份 local range。由于我们将 cacheline 对齐到每个 range，因此在 cacheline 层不可能存在冲突。只有当 local range 处理完，尝试从另一个线程窃取 range 时才会发生冲突。</p></li><li><p>如果多个查询同时并发执行，对这个数据结构的压力则进一步减少。？？？</p></li><li><p>总是可以增加 morsel 的大小，来减少竞争</p><p> 这就导致非常小的几率访问 work-stealing 数据结构。即便在最坏的情况，morsel size 非常大会造成无法充分利用线程资源，但是如果当前系统有足够多的查询，则也不会影响系统的吞吐量。</p><p> 即一个查询虽然不会充分利用线程资源，多个查询一起就行了。</p></li></ol><h2 id="4-PARALLEL-OPERATOR-DETAILS"><a href="#4-PARALLEL-OPERATOR-DETAILS" class="headerlink" title="4. PARALLEL OPERATOR DETAILS"></a>4. PARALLEL OPERATOR DETAILS</h2><p>为了能够完整地并行每个 pipeline，pipeline 中的每个 operator 都需要满足：1）既能并行地读取 tuple；2）也需要能够并行地输出 tuple。在这一章，会讨论最重要的几个并行算子。</p><h2 id="4-1-HashJoin"><a href="#4-1-HashJoin" class="headerlink" title="4.1 HashJoin"></a>4.1 HashJoin</h2><p>正如第二节 fig-3 中所示，HashJoin 的 HashTable 的构建由两个阶段组成。</p><p>OuterJoin 是上述算法的小变动: 在每个 tuple 中，会额外分配一个 marker 来表征这个 tuple 是否已经有匹配了。来 probe 阶段如果有相匹配的就会设置该 marker，因此在设置该 marker 之前，先检查下该 marker 是否尚未被设置，有利于减少不必要的竞争。Semi&#x2F;Anti Joins 实现也是类似。</p><p>尽管 Balkesen 等[1]使用了大量的 single-operator benchmark 来表明一个高度优化的 radix-join 比 single-table join 达到个更高的性能。但是相比 radix-join，本文的 single-table join 具有以下特点：</p><ul><li>对于较大的输入表，single-table join 是可以完全 pipelined，因此可以使用更少的空间（因为可以就地处理 probe input）</li><li>是个 “good team player”</li><li>可以从倾斜的key分布中获益</li><li>对 tuple size 不敏感</li><li>没有硬件相关的参数</li></ul><p>由于上述实践中的优点，single-table join 在复杂查询中是要优于 radix-join。</p><blockquote><p>radix-join 可以参考我的另一篇博客: <a href>JOIN 分区算法：Radix-Cluster Algorithm</a>。但是我不太明白这里 single-table join 的含义，论文提及的几篇 HashJoin 论文都是 15721 中的论文，后续会再阅读一次，也可能会继续翻译，来加深理解。</p></blockquote><h3 id="4-2-Lock-Free-Tagged-Hash-Table"><a href="#4-2-Lock-Free-Tagged-Hash-Table" class="headerlink" title="4.2 Lock-Free Tagged Hash Table"></a>4.2 Lock-Free Tagged Hash Table</h3><p>本文 HashJoin 使用的 HashTable 有个优化：提前过滤（early-filter）。核心思想就是使用一个小的filter来标记 HashTable 的 bucket list（一个 bucket 实现为一个list），该 list 的所有元素都被 hash 来设置其中 1 bit。</p><p>如 fig-7 所示的插入过程，带插入的元素 <code>entry-&gt;hash</code> 基于某个算法预计算好，在 <code>insert</code> 函数中，需要基于 <code>entry-&gt;hash</code> 计算 entry 所属的 slot&#x2F;bucket。</p><p>并采用头插法，将 <code>entry-&gt;next = removeTag(old)</code>，其中 old 是 slot 当前的头节点，removeTag(old) 才是当前 head 节点真正地址。</p><p>完成上述操作后，就需要给当前首节点加上 Tag 信息:</p><ol><li>old &amp; TagMask 需要取出当前已有的 Tag 信息，其中 TagMask 即 <em>0xFF000000</em></li><li>计算新节点的 Tag 信息: tag(entry-&gt;hash)</li><li>将所有的的 Tag 信息存在 entry 的前 16bit 中</li></ol><p>结合起来，就是 fig-7 中第9行的计算公式。再通过 CAS 操作将 new 插入到 HashTable[slot] 中。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/PaperReading/morsel-driven-7.jpg?raw=true" alt="morsel-driven-7"></p><p>这样就相当于首节点中使用 16 bit 就实现了一个微型 BloomFilter，可以在 O(1) 探测出来 unmatched 情况。相比较单独实现一个 BloomFilter 开销小很多，比如：</p><ol><li>没有带来多余的内存访问，而单独的 BloomFilter 会引入额外的内存访问，甚至多次 IO；</li><li>对于大表，一个单独的 BloomFilter 数据结构难以填充到 CPU Cache;</li><li>不依赖优化器决策，是否需要走 BloomFilter 索引；</li><li>除了 join，这对于聚合场景也是有效的</li></ol><p>实现中，我们对 HashTable 和 tuple 的存储区都使用 2MB 的 virtual memory page，这样的好处点：</p><p>降低了 TLB miss 的次数，page table 能保证填入到 L1 Cache，在 build 阶段产生的太多 kernel page 中断导致的拓展性问题也可以避免；</p><p>此外，我们使用 <code>mmap</code> 为 HashTable 分配内存。因为现代操作系统并不会立即分配内存，而是在第一次某个page有数据写入时才会触发。这样的好处是：1）不需要额外再添加一个阶段手动将 HashTable 内存初始化为 0；2）其次，HashTable 会自适应分布在 NUMA Node 上，因为这些 page 位于的 Numa Node，与首次写入该 page 的线程处在相同的 NUMA Node 上。</p><p>如果所有线程并发构建 HashTable，则会伪随机地分布在所有 Numa Node 上。如果只有来自单个 NUMA Node 上线程构建 HashTable，则该表就位于一个 Numa Node 上 – 这就是预期的情况。</p><blockquote><p>说实在的，我感觉这篇论文夸大了 Lock-Free 的作用，似乎在这篇论文中是神器，但是 Lock-Free 也是有适用场景的。</p></blockquote><h3 id="4-3-NUMA-Aware-Table-Partitioning"><a href="#4-3-NUMA-Aware-Table-Partitioning" class="headerlink" title="4.3 NUMA-Aware Table Partitioning"></a>4.3 NUMA-Aware Table Partitioning</h3><p>为了实现 NUMA-Local Table Scan，表必须在所有的 Memory Nodes 上。最直接的方式即 round-robin。更好的方式是使用一些重要属性列的 Hash 值来对表进行分区。这样的好处是，如果JOIN的两个表都以 join-key 进行分区，那么匹配的 tuples 就通常位于同一个 NUMA Node 上。尽管 work-stealing 和 load imbalance 还是可能导致 remote-Numa 内存访问，但是大多数参与 JOIN 的pair 还是来自于同一个 NUMA Node。</p><p>比如，经典的 TPCH benchmakr 中，<code>orders</code> 和 <code>lineitem</code> 两个表都是按照 <code>orderkey</code> 进行分区，那么这两个表在基于 <code>orderkey</code> 进行 join 时，就能有很好的优化。</p><p>比如 Doris&#x2F;StarRocks 针对这种情况，就提了个 Colocate Join 优化，他们在 TPCH 测试中这两个表的建表 SQL 如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> lineitem (</span><br><span class="line">    l_shipdate    <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_orderkey    <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_linenumber  <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    l_partkey     <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_suppkey     <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    l_quantity    <span class="type">decimal</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_extendedprice  <span class="type">decimal</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_discount    <span class="type">decimal</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_tax         <span class="type">decimal</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_returnflag  <span class="type">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_linestatus  <span class="type">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_commitdate  <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_receiptdate <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_shipinstruct <span class="type">VARCHAR</span>(<span class="number">25</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_shipmode     <span class="type">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    l_comment      <span class="type">VARCHAR</span>(<span class="number">44</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)ENGINE<span class="operator">=</span>OLAP</span><br><span class="line">DUPLICATE KEY(`l_shipdate`, `l_orderkey`)</span><br><span class="line">COMMENT &quot;OLAP&quot;</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`l_orderkey`) BUCKETS <span class="number">96</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">    &quot;replication_num&quot; <span class="operator">=</span> &quot;1&quot;,</span><br><span class="line">    &quot;colocate_with&quot; <span class="operator">=</span> &quot;lineitem_orders&quot;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders  (</span><br><span class="line">    o_orderkey       <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_orderdate      <span class="type">DATE</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_custkey        <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_orderstatus    <span class="type">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_totalprice     <span class="type">decimal</span>(<span class="number">15</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_orderpriority  <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_clerk          <span class="type">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_shippriority   <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">    o_comment        <span class="type">VARCHAR</span>(<span class="number">79</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span></span><br><span class="line">)ENGINE<span class="operator">=</span>OLAP</span><br><span class="line">DUPLICATE KEY(`o_orderkey`, `o_orderdate`)</span><br><span class="line">COMMENT &quot;OLAP&quot;</span><br><span class="line">DISTRIBUTED <span class="keyword">BY</span> HASH(`o_orderkey`) BUCKETS <span class="number">96</span></span><br><span class="line">PROPERTIES (</span><br><span class="line">    &quot;replication_num&quot; <span class="operator">=</span> &quot;1&quot;,</span><br><span class="line">    &quot;colocate_with&quot; <span class="operator">=</span> &quot;lineitem_orders&quot;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ABSTRACT&quot;&gt;&lt;a href=&quot;#ABSTRACT&quot; class=&quot;headerlink&quot; title=&quot;ABSTRACT&quot;&gt;&lt;/a&gt;ABSTRACT&lt;/h2&gt;&lt;p&gt;随着现代计算机架构的演进，与并行查询执行引擎中两个问题产生了矛盾：&lt;/p&gt;
&lt;ol&gt;
&lt;li</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="Papers" scheme="https://szza.github.io/tags/Papers/"/>
    
  </entry>
  
  <entry>
    <title>WAL、MemTable 的生命周期管理(3)</title>
    <link href="https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/"/>
    <id>https://szza.github.io/2022/04/16/rocksdb/WritePath/WAL_3/</id>
    <published>2022-04-16T06:15:35.000Z</published>
    <updated>2023-08-07T09:26:04.729Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 WAL&#x2F;MemTable 生命周期的完结篇，主要关注 FlushJob 执行流程以及如何确定哪些 WAL&#x2F;MmmTable 可以安全地删除。</p><h2 id="PickMemTable"><a href="#PickMemTable" class="headerlink" title="PickMemTable"></a>PickMemTable</h2><p>FlushJob 首先需要从 <em>ColumnFamilyData::imm_</em> 中挑选出本次所需的 <em>FlushJob::mems_</em> ，这部分功能由 <code>PickMemTable</code> 函数实现。最大可以选择的 MemTable::id_ 是 <em>max_memtable_id_</em> ，该参数值的设置见由上一节 <a href="https://szza.github.io/2022/04/05/rocksdb/WritePath/WAL_2">WAL、MemTable 的生命周期管理(2)</a>。</p><p>每个 FlushJob 选中的 <em>mems_</em> 是基于 MemTable 的创建时间排序，即 <code>mems_[0]</code> 是最早创建的，<code>mems.back()</code> 是最晚创建的。具体从 imm_ 获取 <em>mems_</em> 的逻辑由 <code>PickMemtablesToFlush</code> 函数实现。</p><p>每次 Flush 操作都产生一个 VersionEdit。FlushJob 将 VersionEdit 信息记录在 <code>mems_[0]-&gt;edit_</code> 中，edit_ 中 <code>log_number_</code> 主要是用于追踪 WAL 的生命周期，其值是<code>max_next_log_number</code>，如何与WAL生命周期产生联系可见后文分析。</p><p>此外，<code>FlushJob::meta_</code> 中记录着成功 Flush 后生成的 level0 SST 文件的元信息数据。</p><p>PickMemTable 核心代码逻辑如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlushJob::PickMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  pick_memtable_called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> max_next_log_number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the earliest memtable as a new Table</span></span><br><span class="line">  cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">PickMemtablesToFlush</span>(max_memtable_id_, &amp;mems_,</span><br><span class="line">                                    &amp;max_next_log_number);</span><br><span class="line">  <span class="keyword">if</span> (mems_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* m = mems_[<span class="number">0</span>];</span><br><span class="line">  edit_ = m-&gt;<span class="built_in">GetEdits</span>();</span><br><span class="line">  edit_-&gt;<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);</span><br><span class="line">  edit_-&gt;<span class="built_in">SetLogNumber</span>(max_next_log_number);</span><br><span class="line">  edit_-&gt;<span class="built_in">SetColumnFamily</span>(cfd_-&gt;<span class="built_in">GetID</span>());</span><br><span class="line"></span><br><span class="line">  meta_.fd = <span class="built_in">FileDescriptor</span>(versions_-&gt;<span class="built_in">NewFileNumber</span>(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  meta_.epoch_number = cfd_-&gt;<span class="built_in">NewEpochNumber</span>();</span><br><span class="line"></span><br><span class="line">  base_ = cfd_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  base_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PickMemtablesToFlush"><a href="#PickMemtablesToFlush" class="headerlink" title="PickMemtablesToFlush"></a>PickMemtablesToFlush</h3><p>SwitchMemTable 函数在调用 <code>MemTableList::Add</code> 函数向 imm_ 中插入新的 ImmtableMemTable 时，是在 <code>current-&gt;memlist_</code> 头部插入节点，因此 memlist_ 尾部是最旧的 ImmutableMemTable，头部是最新的。因此需要逆序遍历 memlist_，才能获得按照 MemTable 创建顺序的 <code>FlushJob::mems_</code>。</p><p>当前可能多个 FlushJob 在并发地执行，因此从 <code>current-&gt;memtables_</code> 选择 MemTable 时，需要过滤掉不符合条件的:</p><ul><li><p>MemTable::id_ &lt; max_memtable_id</p></li><li><p>MemTable::flush_in_progress_ 为 false: 即当前没有被其他 FlushJob 选中</p><p>由于 Flush MemTable 以及后续的 COMMIT 操作都需要保持顺序，因此，如果发现 flush_in_progress_ 为 true，则中断本次 Pick 操作，这样能保证选中的 <code>mems_</code> 是连续创建的。</p></li></ul><p>在 SwitchMemTable 函数中，将 old_mem 添加到 <code>current-&gt;memlist_</code> 之前会先调用 <code>MemTableList::FlushRequested</code>，将 <em>flush_requested_</em> 设置为 true，表示该 CF 的 memlist_ 当前等待 Flush 操作。接着在 <code>MemTable::Add</code> 函数中会递增 <em>num_flush_not_started_</em> ，表示 memlist_ 中尚未被 Picked 的 MemTable 数量。</p><p>当 flush_requested_ 为 true 并且 num_flush_not_started_ &gt; 0，则 <code>IsFlushPending</code> 返回 true，则该 CF 可以触发下一次 FlushJob。</p><p>直到 <code>PickMemtablesToFlush</code> 函数执行完，如果 <em>num_flush_not_started_</em> 为 0， 会将 <code>flush_requested_</code> 设置为 false，表示已经所有待 Picked 的 MemTable 都已选中了，准备进行 Flush。如果后续 Flush 流程失败，会调用 <code>RollbackMemtableFlush</code> 函数进行回滚，恢复状态。</p><p>最后，有个基于 RAII 设计的类 <code>AutoThreadOperationStageUpdater</code>，用来表征当前 FlushJob 线程的执行状态。 该函数核心代码及注释如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTableList::PickMemtablesToFlush</span><span class="params">(<span class="type">uint64_t</span> max_memtable_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        autovector&lt;MemTable*&gt;* ret,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint64_t</span>* max_next_log_number)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_PICK_MEMTABLES_TO_FLUSH)</span></span>;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; memlist = current_-&gt;memlist_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = memlist.<span class="built_in">rbegin</span>(); it != memlist.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    MemTable* m = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤超过 max_memtable_id 的 MemTable</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;<span class="built_in">GetID</span>() &gt; max_memtable_id) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;flush_in_progress_) &#123;</span><br><span class="line">      <span class="comment">// 还没被添加到某个 Flush 任务中</span></span><br><span class="line">      num_flush_not_started_--;</span><br><span class="line">      <span class="keyword">if</span> (num_flush_not_started_ == <span class="number">0</span>) &#123;</span><br><span class="line">        imm_flush_needed.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置标志位: 表示被 Picked</span></span><br><span class="line">      m-&gt;flush_in_progress_ = <span class="literal">true</span>;  </span><br><span class="line">      <span class="keyword">if</span> (max_next_log_number) &#123;</span><br><span class="line">        *max_next_log_number =</span><br><span class="line">            std::<span class="built_in">max</span>(m-&gt;<span class="built_in">GetNextLogNumber</span>(), *max_next_log_number);</span><br><span class="line">      &#125;</span><br><span class="line">      ret-&gt;<span class="built_in">push_back</span>(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ret-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// 遇到已经被其他 Flush 线程选中的 memtable，中断</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (num_flush_not_started_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// start-flush request is complete</span></span><br><span class="line">    flush_requested_ = <span class="literal">false</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RollbackMemtableFlush"><a href="#RollbackMemtableFlush" class="headerlink" title="RollbackMemtableFlush"></a>RollbackMemtableFlush</h3><p>如果后续的 Flush 任务执行失败，<em>mems_</em> 不会从 <code>memlist_</code> 中删除，则只需要把 PickMemtablesToFlush 中修改的状态重置即可，等待下一次 Flush。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTableList::RollbackMemtableFlush</span><span class="params">(<span class="type">const</span> autovector&lt;MemTable*&gt;&amp; mems,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">uint64_t</span> <span class="comment">/*file_number*/</span>)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_MEMTABLE_ROLLBACK)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置状态</span></span><br><span class="line">  <span class="keyword">for</span> (MemTable* m : mems) &#123;</span><br><span class="line">    m-&gt;flush_in_progress_ = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;flush_completed_ = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;edit_.<span class="built_in">Clear</span>();</span><br><span class="line">    num_flush_not_started_++;</span><br><span class="line">  &#125;</span><br><span class="line">  imm_flush_needed.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FlushJob-Run"><a href="#FlushJob-Run" class="headerlink" title="FlushJob::Run"></a>FlushJob::Run</h2><p>FlushJob 目前（branch-8.2.fb）有两种实现：</p><ul><li>默认将 MemTables 中的数据写入 level0，</li><li>设置 <em>experimental_mempurge_threshold &gt; 0</em>，开启内存裁剪（Memory Purge）。</li></ul><p>本文只讲解默认实现，MemoryPurge 后续有空再说。默认的 FlushJob::Run 流程主要有两个部分：</p><ol><li>根据选中的 <em>mems_</em> 生成 SST 并写入 level0，由 <code>file_meta</code> 记录该 SST 文件元数据</li><li>如果 step(1) 成功则更新 CF 的 version，并将本次更新记录 <em>FlushJob::edit_</em> 序列化后写入到 MANIFEST 中</li><li>如果 step(1) 不成功，则 <code>RollbackMemtableFlush</code> 进行回滚。</li></ol><p><code>FlushJob::Run</code> 核心代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FlushJob::Run</span><span class="params">(LogsWithPrepTracker* prep_tracker, FileMetaData* file_meta,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">bool</span>* switched_to_mempurge)</span> </span>&#123;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_run</span><span class="params">(ThreadStatus::STAGE_FLUSH_RUN)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mems_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 1. 将 mems_ 写入 level0</span></span><br><span class="line">  Status s = <span class="built_in">WriteLevel0Table</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 2. 判断 Flush 结果</span></span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">RollbackMemtableFlush</span>(mems_, meta_.fd.<span class="built_in">GetNumber</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (write_manifest_) &#123;</span><br><span class="line">    <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">    s = cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">TryInstallMemtableFlushResults</span>(</span><br><span class="line">        cfd_, mutable_cf_options_, mems_, prep_tracker, versions_, db_mutex_,</span><br><span class="line">        meta_.fd.<span class="built_in">GetNumber</span>(), &amp;job_context_-&gt;memtables_to_free, db_directory_,</span><br><span class="line">        log_buffer_, &amp;committed_flush_jobs_info_, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; file_meta != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *file_meta = meta_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteLevel0Table"><a href="#WriteLevel0Table" class="headerlink" title="WriteLevel0Table"></a>WriteLevel0Table</h3><p>WriteLevel0Table 核心部分主要有三个部分，每个部分都很复杂，值得单独开一期讲解，这里主要讲解下每个部分的作用：</p><ul><li><p>NewMergingIterator: 用于将输入的多个 MemTable&#x2F;SST 合并成一个有序的数据流</p><p>在 <code>merger_test.cc</code> 的测试用例中，对于多批次随机数据，<code>NewMergingIterator</code> 合并多个数据流后表现和 <code>VectorIterator</code> 表现的一致，都是有序输出。</p><p>多批输入数据流打平后再输入给 VectorIterator，在 VectorIterator 构造函数中对输入的数据流基于 <code>std::sort</code> 排序，因此 VectorIterator 的输出是全局有序的。而 NewMergingIterator 的输出和 VectorIterator 是一致的，则说明 NewMergingIterator 的作用是合并输入流并使输出有序，不过更加高效。</p></li><li><p>range_del_iter</p><p>NewMergingIterator 只是将输入数据排序好，但是通常上层应用也会进行删除操作。在 MemTable 中，专门为 <em>DeleteRange</em> 操作单独分配了个 range_del_table_。当插入数据是 kTypeRangeDeletion 类型时，则将数据写入 range_del_table_。因此，在遍历 MemTable 时，也需要考虑 range_del_iter 来过滤那些已经被删除的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in MemTable::Add function</span></span><br><span class="line">std::unique_ptr&lt;MemTableRep&gt;&amp; table =</span><br><span class="line">    type == kTypeRangeDeletion </span><br><span class="line">    ? range_del_table_ </span><br><span class="line">    : table_;</span><br></pre></td></tr></table></figure><p>关于 range_delete 操作的详细设计可以参考 <a href="https://github.com/facebook/rocksdb/wiki/DeleteRange-Implementation">DeleteRange-Implementation</a>，后续有时间再讲解其中细节。</p></li><li><p>BuildTable</p><p>内部流程：<code>CompactionIterator</code> 基于 {NewMergingIterator, range_del_iter} 过滤已删除数据并输出全局有序的数据，可以通过 CompactionIterator::Next 进行迭代遍历，获得输出 <code>&#123;key, value&#125;</code>，再用 TableBuilder::Add 函数将该 {key, value} 添加到 level0 的新 SST 文件中。运行结束，新生成的 level0 SST 的元信息保存在 <em>meta_</em> 中。</p></li></ul><p>实际上，Compaction 的核心流程也是这三个部分，逻辑流程都是一样的，后续会专注分析每个具体的部分。<code>WriteLevel0Table</code> 核心流程如下代码注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FlushJob::WriteLevel0Table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_FLUSH_WRITE_L0)</span></span>;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  std::vector&lt;BlobFileAddition&gt; blob_file_additions;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> write_hint = cfd_-&gt;<span class="built_in">CalculateSSTWriteHint</span>(<span class="number">0</span>);</span><br><span class="line">    Env::IOPriority io_priority = <span class="built_in">GetRateLimiterPriorityForWrite</span>();</span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;InternalIterator*&gt; memtables;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;FragmentedRangeTombstoneIterator&gt;&gt;</span><br><span class="line">        range_del_iters;</span><br><span class="line">    ReadOptions ro;</span><br><span class="line">    ro.total_order_seek = <span class="literal">true</span>;</span><br><span class="line">    ro.io_activity = Env::IOActivity::kFlush;</span><br><span class="line">    Arena arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从 MemTables 构建 range_delete_iter，获悉哪些 keys 已被删除</span></span><br><span class="line">    <span class="keyword">for</span> (MemTable* m : mems_) &#123;</span><br><span class="line">      <span class="keyword">auto</span>* range_del_iter = m-&gt;<span class="built_in">NewRangeTombstoneIterator</span>(</span><br><span class="line">          ro, kMaxSequenceNumber, <span class="literal">true</span> <span class="comment">/* immutable_memtable */</span>);</span><br><span class="line">      <span class="keyword">if</span> (range_del_iter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        range_del_iters.<span class="built_in">emplace_back</span>(range_del_iter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 2. 合并多个 memtable 迭代器，使得 memtables 能有序输出</span></span><br><span class="line">      <span class="function">ScopedArenaIterator <span class="title">iter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          NewMergingIterator(&amp;cfd_-&gt;internal_comparator(), memtables.data(),</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">static_cast</span>&lt;<span class="type">int</span>&gt;(memtables.size()), &amp;arena))</span></span>;</span><br><span class="line">      <span class="type">int64_t</span> _current_time = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">auto</span> status = clock_-&gt;<span class="built_in">GetCurrentTime</span>(&amp;_current_time);</span><br><span class="line">      <span class="type">const</span> <span class="type">uint64_t</span> current_time = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(_current_time);</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> oldest_key_time = mems_.<span class="built_in">front</span>()-&gt;<span class="built_in">ApproximateOldestKeyTime</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// It&#x27;s not clear whether oldest_key_time is always available. In case</span></span><br><span class="line">      <span class="comment">// it is not available, use current_time.</span></span><br><span class="line">      <span class="type">uint64_t</span> oldest_ancester_time = std::<span class="built_in">min</span>(current_time, oldest_key_time);</span><br><span class="line"></span><br><span class="line">      meta_.oldest_ancester_time = oldest_ancester_time;</span><br><span class="line">      meta_.file_creation_time = current_time;</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> num_input_entries = <span class="number">0</span>;</span><br><span class="line">      <span class="type">uint64_t</span> memtable_payload_bytes = <span class="number">0</span>;</span><br><span class="line">      <span class="type">uint64_t</span> memtable_garbage_bytes = <span class="number">0</span>;</span><br><span class="line">      IOStatus io_s;</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> std::string* <span class="type">const</span> full_history_ts_low =</span><br><span class="line">          (full_history_ts_low_.<span class="built_in">empty</span>()) ? <span class="literal">nullptr</span> : &amp;full_history_ts_low_;</span><br><span class="line">      <span class="function">TableBuilderOptions <span class="title">tboptions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          *cfd_-&gt;ioptions(), mutable_cf_options_, cfd_-&gt;internal_comparator(),</span></span></span><br><span class="line"><span class="params"><span class="function">          cfd_-&gt;int_tbl_prop_collector_factories(), output_compression_,</span></span></span><br><span class="line"><span class="params"><span class="function">          mutable_cf_options_.compression_opts, cfd_-&gt;GetID(), cfd_-&gt;GetName(),</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="number">0</span> <span class="comment">/* level */</span>, <span class="literal">false</span> <span class="comment">/* is_bottommost */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          TableFileCreationReason::kFlush, oldest_key_time, current_time,</span></span></span><br><span class="line"><span class="params"><span class="function">          db_id_, db_session_id_, <span class="number">0</span> <span class="comment">/* target_file_size */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          meta_.fd.GetNumber())</span></span>;</span><br><span class="line">      <span class="type">const</span> SequenceNumber job_snapshot_seq =</span><br><span class="line">          job_context_-&gt;<span class="built_in">GetJobSnapshotSequence</span>();</span><br><span class="line">      <span class="function"><span class="type">const</span> ReadOptions <span class="title">read_options</span><span class="params">(Env::IOActivity::kFlush)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 合并多个 memtables 的数据，输出到 level0 sst 中</span></span><br><span class="line">      s = <span class="built_in">BuildTable</span>(dbname_, versions_, db_options_, tboptions, file_options_,</span><br><span class="line">                     read_options, cfd_-&gt;<span class="built_in">table_cache</span>(), iter.<span class="built_in">get</span>(),</span><br><span class="line">                     std::<span class="built_in">move</span>(range_del_iters), &amp;meta_, &amp;blob_file_additions,</span><br><span class="line">                     existing_snapshots_, earliest_write_conflict_snapshot_,</span><br><span class="line">                     job_snapshot_seq, snapshot_checker_,</span><br><span class="line">                     mutable_cf_options_.paranoid_file_checks,</span><br><span class="line">                     cfd_-&gt;<span class="built_in">internal_stats</span>(), &amp;io_s, io_tracer_,</span><br><span class="line">                     BlobFileCreationReason::kFlush, seqno_to_time_mapping_,</span><br><span class="line">                     event_logger_, job_context_-&gt;job_id, io_priority,</span><br><span class="line">                     &amp;table_properties_, write_hint, full_history_ts_low,</span><br><span class="line">                     blob_callback_, base_, &amp;num_input_entries,</span><br><span class="line">                     &amp;memtable_payload_bytes, &amp;memtable_garbage_bytes);</span><br><span class="line">     <span class="comment">//... handle error</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 4. 尝试 SYNC SST 目录</span></span><br><span class="line">     <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; output_file_directory_ != <span class="literal">nullptr</span> &amp;&amp; sync_output_directory_) &#123;</span><br><span class="line">      s = output_file_directory_-&gt;<span class="built_in">FsyncWithDirOptions</span>(</span><br><span class="line">          <span class="built_in">IOOptions</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">          <span class="built_in">DirFsyncOptions</span>(DirFsyncOptions::FsyncReason::kNewFileSynced));</span><br><span class="line">    &#125;</span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  base_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> has_output = meta_.fd.<span class="built_in">GetFileSize</span>() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 将生成的 level0 文件元数据信息写入 VersionEdit </span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; has_output) &#123;</span><br><span class="line">    <span class="comment">// Add file to L0</span></span><br><span class="line">    edit_-&gt;<span class="built_in">AddFile</span>(<span class="number">0</span> <span class="comment">/* level */</span>, meta_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Piggyback FlushJobInfo on the first first flushed memtable.</span></span><br><span class="line">  mems_[<span class="number">0</span>]-&gt;<span class="built_in">SetFlushJobInfo</span>(<span class="built_in">GetFlushJobInfo</span>());</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TryInstallMemtableFlushResults"><a href="#TryInstallMemtableFlushResults" class="headerlink" title="TryInstallMemtableFlushResults"></a>TryInstallMemtableFlushResults</h3><p>如果上一步 <code>WriteLevel0Table</code> 成功，则需要将 Flush 的信息 COMMIT 到 MANIFEST。实际上 MANIFEST 可以视为 transaction log，保存着每次 Flush&#x2F;Compaction 的记录。</p><p>当前可能有多个线程在并发执行 Flush 操作，但是只能有一个线程能 COMMIT：率先进入的此函数的线程，它先将 <code>commit_in_progress_</code> 设置为 true，来阻止后来的线程。因此判断 commit_in_progress_ 是否为 true 是个分界点：</p><ul><li><p>之前：所有 Flush 线程都都先更新 mems[i] 的 {flush_completed_, file_number_} 状态</p><p> flush_completed_ 表示 mems[i] 已经成功 Flush，file_number_ 则是指向 Flush 后生成的 SST 文件。 由于 mems 是 Flush 线程的局部变量，因此这一步操作线程安全。</p></li><li><p>之后</p><p>由于只有一个线程能进行 COMMIT。因此 COMMIT 对象是 <em>memlist_</em> 中所有已经 Flushed MemTable，即进入此函数的线程会将所有 Flush 线程中的 mems 一起 COMMIT。 后面进入此函数的线程发现 commit_in_progress_ 为 false 则直接返回。</p><p>其次，COMMIT 也需要按照 MemTable 的创建顺序，即 <code>MemTable::id_</code> 递增的顺序，因此需要逆序遍历 memlist_，并且如果中途某个 MemTable 在 WriteLevel0Table 中失败了，则需要中断当前 COMMIT 操作，只能将前面成功 Flush 的连续 MemTables 的 VersionEdit 写入 MANIFEST，并在回调函数 <code>RemoveMemTablesOrRestoreFlags</code> 中将这部分 MemTable 从 memlist_ 中删除。</p><p>因此，Flush 失败的 MemTable 就会变成 oldeest memtable，等待下一次 FlushJob 再次选择它，重复上述执行流程。</p></li></ul><p>这部分代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MemTableList::TryInstallMemtableFlushResults</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ColumnFamilyData* cfd, <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> autovector&lt;MemTable*&gt;&amp; mems, LogsWithPrepTracker* prep_tracker,</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionSet* vset, InstrumentedMutex* mu, <span class="type">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">    autovector&lt;MemTable*&gt;* to_delete, FSDirectory* db_directory,</span></span></span><br><span class="line"><span class="params"><span class="function">    LogBuffer* log_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::list&lt;std::unique_ptr&lt;FlushJobInfo&gt;&gt;* committed_flush_jobs_info,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> write_edits)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_MEMTABLE_INSTALL_FLUSH_RESULTS)</span></span>;</span><br><span class="line">  mu-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> ReadOptions <span class="title">read_options</span><span class="params">(Env::IOActivity::kFlush)</span></span>;</span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 更改所有成功 Flush 的 MemTable 状态</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mems.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    mems[i]-&gt;flush_completed_ = <span class="literal">true</span>;</span><br><span class="line">    mems[i]-&gt;file_number_ = file_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 分界点: 只有一个线程可以 commit</span></span><br><span class="line">  <span class="keyword">if</span> (commit_in_progress_) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 commit 流程</span></span><br><span class="line">  commit_in_progress_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; memlist = current_-&gt;memlist_;</span><br><span class="line">    <span class="comment">// 3. 遇到 Flush 失败的 memtable 则中断</span></span><br><span class="line">    <span class="keyword">if</span> (memlist.<span class="built_in">empty</span>() || !memlist.<span class="built_in">back</span>()-&gt;flush_completed_) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> batch_file_number = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> batch_count = <span class="number">0</span>;</span><br><span class="line">    autovector&lt;VersionEdit*&gt; edit_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照 memtable 创建的顺序 scan and commit</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = memlist.<span class="built_in">rbegin</span>(); it != memlist.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">      MemTable* m = *it;</span><br><span class="line">      <span class="comment">// 3.1 遇到 Flush 失败的 memtable 则中断</span></span><br><span class="line">      <span class="keyword">if</span> (!m-&gt;flush_completed_) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遇到一个新的 FlushJob</span></span><br><span class="line">      <span class="comment">// 此时 file_number_ 和 edit 都是新的</span></span><br><span class="line">      <span class="keyword">if</span> (it == memlist.<span class="built_in">rbegin</span>() || batch_file_number != m-&gt;file_number_) &#123;</span><br><span class="line">        batch_file_number = m-&gt;file_number_;</span><br><span class="line">        edit_list.<span class="built_in">push_back</span>(&amp;m-&gt;edit_);</span><br><span class="line">        std::unique_ptr&lt;FlushJobInfo&gt; info = m-&gt;<span class="built_in">ReleaseFlushJobInfo</span>();</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          committed_flush_jobs_info-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(info));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      batch_count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 commit 已经 Flush 成功的</span></span><br><span class="line">    <span class="keyword">if</span> (batch_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 计算当前 oldest_wal</span></span><br><span class="line">      <span class="type">uint64_t</span> min_wal_number_to_keep =</span><br><span class="line">          <span class="built_in">PrecomputeMinLogNumberToKeepNon2PC</span>(vset, *cfd, edit_list);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// logfile_num &lt; min_wal_number_to_keep 都应该删除</span></span><br><span class="line">      VersionEdit wal_deletion;</span><br><span class="line">      wal_deletion.<span class="built_in">SetMinLogNumberToKeep</span>(min_wal_number_to_keep);</span><br><span class="line">      <span class="keyword">if</span> (vset-&gt;<span class="built_in">db_options</span>()-&gt;track_and_verify_wals_in_manifest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_wal_number_to_keep &gt;</span><br><span class="line">            vset-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">GetMinWalNumberToKeep</span>()) &#123;</span><br><span class="line">          wal_deletion.<span class="built_in">DeleteWalsBefore</span>(min_wal_number_to_keep);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      edit_list.<span class="built_in">push_back</span>(&amp;wal_deletion);</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> manifest_write_cb = [<span class="keyword">this</span>, cfd, batch_count, log_buffer,</span><br><span class="line">                                      to_delete, mu](<span class="type">const</span> Status&amp; status) &#123;</span><br><span class="line">        <span class="comment">// 从 memlist_ 中删除 flushed memtable</span></span><br><span class="line">        <span class="built_in">RemoveMemTablesOrRestoreFlags</span>(status, cfd, batch_count, log_buffer,</span><br><span class="line">                                      to_delete, mu);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 写入 MANIFEST</span></span><br><span class="line">      s = vset-&gt;<span class="built_in">LogAndApply</span>(cfd, mutable_cf_options, read_options, edit_list,</span><br><span class="line">                            mu, db_directory, <span class="comment">/*new_descriptor_log=*/</span><span class="literal">false</span>,</span><br><span class="line">                            <span class="comment">/*column_family_options=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">                            manifest_write_cb);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 退出 commit 流程</span></span><br><span class="line">  commit_in_progress_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PrecomputeMinLogNumberToKeepNon2PC"><a href="#PrecomputeMinLogNumberToKeepNon2PC" class="headerlink" title="PrecomputeMinLogNumberToKeepNon2PC"></a>PrecomputeMinLogNumberToKeepNon2PC</h3><p>PrecomputeMinLogNumberToKeepNon2PC 函数返回的 <code>min_wal_number_to_keep</code> 用来删除满足 logfile_num &lt; min_wal_number_to_keep 条件的 WAL。由于 min_wal_number_to_keep 也写入 VersionEdit 并最终序列化到 MANIFEST，因此在 Recovery 过程中，如果磁盘上存在部分这些 WAL 也会被忽略，不会被加载。</p><p>min_log_number_to_keep 的计算分为三个阶段：</p><ol><li>每个 <code>FlushJob::edit_</code> 中记录的 <code>log_number_</code> 是在 <code>FlushJob::PickMemTable</code> 函数中设置，指向了每个 CF 最大可以删除的 WAL</li></ol><p>  因为 CF memlist_ 指向的 WAL 对于当前 CF 来说都是可以删除的，因此 FlushJob::mems_[-1]-&gt;GetNextLogNumber() 就是FlushJob::edit_::log_numer_ 能取到的最大值。通过迭代不同 FlushJob 的 edit_，则可以获得所有 FlushJobs 中最小的 log_number_ ，作为 min_log_number_to_keep</p><ol start="2"><li><p>ColumnFamilyData::log_number_ 字段记录了 CF 当前指向的 WAL 文件。因此小于 <code>ColumnFamilyData::log_number_</code> 的 WAL 对于当前 CF 来说都可以删除。</p><p>这一步和 step(1) 是互斥的，如果没有成功执行的 FlushJobs，则 step(1) 中不会修改 min_log_number_to_keep 的值，此时就会进入 step(2)，来获得他们中最小的 <code>min_log_number_to_keep</code>；</p></li><li><p>再检查没有执行 Flush 的或者 Flush 失败的的 CFs 的 <code>ColumnFamilyData::log_number_</code> 字段，和 <code>min_log_number_to_keep</code> 进行比较最小值</p></li></ol><p>上述三步结束，所得的 <code>min_log_number_to_keep</code> 即生命周期没有结束的最小 WAL：所有满足 <code>logfile_num &lt; min_log_number_to_keep</code> 的 WAL 可以安全地从磁盘上删除了，Recovery 期间也不会被加载了，即生命周期可以结束了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">PrecomputeMinLogNumberToKeepNon2PC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionSet* vset, <span class="type">const</span> autovector&lt;ColumnFamilyData*&gt;&amp; cfds_to_flush,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> autovector&lt;autovector&lt;VersionEdit*&gt;&gt;&amp; edit_lists)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> min_log_number_to_keep = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 检测 min_log_number_to_keep</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edit_list : edit_lists) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> log = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edit_list) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e-&gt;<span class="built_in">HasLogNumber</span>()) &#123;</span><br><span class="line">        log = std::<span class="built_in">max</span>(log, e-&gt;<span class="built_in">GetLogNumber</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (log != <span class="number">0</span>) &#123;</span><br><span class="line">      min_log_number_to_keep = std::<span class="built_in">min</span>(min_log_number_to_keep, log);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如果 edit_lists 为空</span></span><br><span class="line">  <span class="keyword">if</span> (min_log_number_to_keep == std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">    min_log_number_to_keep = cfds_to_flush[<span class="number">0</span>]-&gt;<span class="built_in">GetLogNumber</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; cfds_to_flush.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      min_log_number_to_keep =</span><br><span class="line">          std::<span class="built_in">min</span>(min_log_number_to_keep, cfds_to_flush[i]-&gt;<span class="built_in">GetLogNumber</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 检测没有 Flush 或者 Flush 失败的 CFs</span></span><br><span class="line">  <span class="function">std::unordered_set&lt;<span class="type">const</span> ColumnFamilyData*&gt; <span class="title">flushed_cfds</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      cfds_to_flush.begin(), cfds_to_flush.end())</span></span>;</span><br><span class="line">  min_log_number_to_keep =</span><br><span class="line">      std::<span class="built_in">min</span>(min_log_number_to_keep,</span><br><span class="line">               vset-&gt;<span class="built_in">PreComputeMinLogNumberWithUnflushedData</span>(flushed_cfds));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> min_log_number_to_keep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">PreComputeMinLogNumberWithUnflushedData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">const</span> ColumnFamilyData* cfd_to_skip)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="type">uint64_t</span> min_log_num = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> cfd : *column_family_set_) &#123;</span><br><span class="line">   <span class="comment">// 跳过 step(2) 中处理过的 CF</span></span><br><span class="line">   <span class="keyword">if</span> (cfd == cfd_to_skip) &#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 和 min_log_num 取较小值</span></span><br><span class="line">   <span class="keyword">if</span> (min_log_num &gt; cfd-&gt;<span class="built_in">GetLogNumber</span>() &amp;&amp; !cfd-&gt;<span class="built_in">IsDropped</span>()) &#123;</span><br><span class="line">     min_log_num = cfd-&gt;<span class="built_in">GetLogNumber</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> min_log_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FindObsoleteFiles"><a href="#FindObsoleteFiles" class="headerlink" title="FindObsoleteFiles"></a>FindObsoleteFiles</h2><p>上述获得 <code>min_log_number_to_keep</code> 后，会生成一个 VersionEdit 对象 wal_deletion，它写入 MANIFEST 的过程中，会更新<code>VersionSet::min_log_number_to_keep_</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in function: VersionSet::ProcessManifestWrites</span></span><br><span class="line"><span class="type">uint64_t</span> last_min_log_number_to_keep = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : batch_edits) &#123;</span><br><span class="line">  <span class="comment">//... other code</span></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;has_min_log_number_to_keep_) &#123;</span><br><span class="line">    last_min_log_number_to_keep =</span><br><span class="line">        std::<span class="built_in">max</span>(last_min_log_number_to_keep, e-&gt;min_log_number_to_keep_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (last_min_log_number_to_keep != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">MarkMinLogNumberToKeep</span>(last_min_log_number_to_keep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 FindObsoleteFiles 函数中，会根据 <code>VersionSet::min_log_number_to_keep_</code> 来判断一个 WAL 的生命周期是否已经结束：已经结束的则加入 <code>JobContextl::log_delete_files</code> 中，在 <code>PurgeObsoleteFiles</code> 函数中从磁盘上删除该文件，再释放 <code>JobContextl::logs_to_free_</code> 中记录的 <code>LogWriter</code> 内存。</p><p>到此，一个 WAL 生命周期才算结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VersionSet::MarkMinLogNumberToKeep</span><span class="params">(<span class="type">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (min_log_number_to_keep_.<span class="built_in">load</span>(std::memory_order_relaxed) &lt; number) &#123;</span><br><span class="line">   min_log_number_to_keep_.<span class="built_in">store</span>(number, std::memory_order_relaxed);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::FindObsoleteFiles</span><span class="params">(JobContext* job_context, <span class="type">bool</span> force,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> no_full_scan)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//... ignore other code...</span></span><br><span class="line">  job_context-&gt;log_number = versions_-&gt;<span class="built_in">min_log_number_to_keep</span>();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (alive_log_files_.<span class="built_in">empty</span>() || logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!alive_log_files_.<span class="built_in">empty</span>() &amp;&amp; !logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// logfile_num &lt;= min_log_number 都应该删除</span></span><br><span class="line">    <span class="type">uint64_t</span> min_log_number = job_context-&gt;log_number;</span><br><span class="line">    <span class="type">size_t</span> num_alive_log_files = alive_log_files_.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检测新的 obsoleted WAL files，即生命周期已结束的</span></span><br><span class="line">    <span class="keyword">while</span> (alive_log_files_.<span class="built_in">begin</span>()-&gt;number &lt; min_log_number) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; earliest = *alive_log_files_.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否回收，不收回则加入待删除队列</span></span><br><span class="line">      <span class="keyword">if</span> (immutable_db_options_.recycle_log_file_num &gt; log_recycle_files_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        log_recycle_files_.<span class="built_in">push_back</span>(earliest.number);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        job_context-&gt;log_delete_files.<span class="built_in">push_back</span>(earliest.number);</span><br><span class="line">      &#125;</span><br><span class="line">      alive_log_files_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检测待释的 LogWriter</span></span><br><span class="line">    log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    <span class="keyword">while</span> (!logs_.<span class="built_in">empty</span>() &amp;&amp; logs_.<span class="built_in">front</span>().number &lt; min_log_number) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; log = logs_.<span class="built_in">front</span>();</span><br><span class="line">      <span class="keyword">if</span> (log.<span class="built_in">IsSyncing</span>()) &#123;</span><br><span class="line">        log_sync_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      logs_to_free_.<span class="built_in">push_back</span>(log.<span class="built_in">ReleaseWriter</span>());</span><br><span class="line">      logs_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job_context-&gt;logs_to_free = logs_to_free_;</span><br><span class="line">  logs_to_free_.<span class="built_in">clear</span>();</span><br><span class="line">  log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 回收</span></span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  job_context-&gt;log_recycle_files.<span class="built_in">assign</span>(log_recycle_files_.<span class="built_in">begin</span>(),</span><br><span class="line">                                        log_recycle_files_.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是 WAL&amp;#x2F;MemTable 生命周期的完结篇，主要关注 FlushJob 执行流程以及如何确定哪些 WAL&amp;#x2F;MmmTable 可以安全地删除。&lt;/p&gt;
&lt;h2 id=&quot;PickMemTable&quot;&gt;&lt;a href=&quot;#PickMemTable&quot; cl</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WAL、MemTable 的生命周期管理(2)</title>
    <link href="https://szza.github.io/2022/04/05/rocksdb/WritePath/WAL_2/"/>
    <id>https://szza.github.io/2022/04/05/rocksdb/WritePath/WAL_2/</id>
    <published>2022-04-05T06:15:35.000Z</published>
    <updated>2023-08-07T09:26:04.729Z</updated>
    
    <content type="html"><![CDATA[<p>本文简要讲下在 Flush  MemTable 之前，WAL 需要进行 SYNC 的原因。更多设计思考可以阅读 <a href="https://github.com/facebook/rocksdb/wiki/Track-WAL-in-MANIFEST">Track-WAL-in-MANIFEST</a></p><h3 id="WHY-NEED-to-SYNC-WAL"><a href="#WHY-NEED-to-SYNC-WAL" class="headerlink" title="WHY NEED to SYNC WAL"></a>WHY NEED to SYNC WAL</h3><p>出于性能考虑，默认情况下 RocksDB 不会每写入一次数据就进行一次 SYNC WAL 操作。但没有 SYNC WAL 会带来两个影响：</p><ol><li><p>在 recovery 时，就无法检查 WAL 是否存在磁盘上，这是因为当机器挂了，WAL 的 innode 元数据可能尚未持久化到磁盘。</p><p>除此之外，默认情况下误删 WAL 目录下的 log 文件，也没有机制来检测是否有 WAL 丢失以及哪个文件丢失。此时 DB::Open 是会成功，但是 log 中对应的数据 <em>“悄悄地”</em> 丢失了。</p></li><li><p>在 recovery 期间也无法判断 WAL 的大小是否正常，因为如果不主动 SYNC，则 SYNC WAL 操作则由操作系统来完成的，这对 RocksDB 并不透明：无法知道在 RocksDB 退出前， WAL 持久化到磁盘的大小。</p></li></ol><p>目前 SYNC WAL 有四种场景：</p><ol><li>上层应用调用 <code>DB::SyncWAL</code> 函数，会主动 SYNC 所有生命周期还没结束的 WALs</li><li>上层应用调用 <code>DB::FlushWAL(true)</code> 函数，内部也是调用 SyncWAL 函数</li><li>写入数据时，设置 <code>WriteOption::sync</code> 为 <em>true</em>，即每写入一次数据，就会进行一次 SYNC WAL</li><li>在 Flush MemTable 前，如果不止一个 ColumnFamily ，会 SYNC 所有 <em>closed_wals</em>，即除了当前WAL之外的所有生命周期尚未结束的 WALs</li></ol><p>case(1,2) 交给应用层调用，case(3) 虽然安全但是效率太低，一般不会开启。因此，交给 RocksDB 自己需要 SYNC WAL 的场景就剩下case(4)。 SYNC WAL 主要是为了防止机器宕机，而不是进程crash。虽然 case(4) 还是有丢数据的风险，但是在生产环境中，一般都会配备多副本来冗余。除非是一个副本的数据在一个机房，一个机房的数据又全部挂了，为了防止这种情况，又搞出来了跨机房部署。</p><blockquote><p>BUT, 该挂的还是会挂。</p></blockquote><p>因此，在执行 FlushJob 前，会将本次 <em>synced_wals</em> 大小信息记录到 <code>VersionEdit</code> 中，再序列化到 MANIFEST 中，在 recovery 期间可以对 WALs 进行强制检查：1）MANIFEST 中记录的 WAL 也应该存在磁盘上；2）磁盘上 WAL 的大小不应该小于 MANIFEST 中记录的 WAL 大小。</p><p>case(4) 是否需要 SYNC 的判断条件如下: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 判断本次 Flush 前是否需要 sync closed_wals</span></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> needs_to_sync_closed_wals =</span><br><span class="line">    logfile_number_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    versions_-&gt;<span class="built_in">GetColumnFamilySet</span>()-&gt;<span class="built_in">NumberOfColumnFamilies</span>() &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><p><em>needs_to_sync_closed_wals</em> 为 true 时，需要记录当前 CF 的 <em>max_memtable_id</em>，这样后续 FlushJob::PickMemTable 函数选择待 Flush 的MemTable时，会过滤掉满足 MemTable::id_ &gt; max_memtable_id 的 memtable。</p><p>这是因为在执行 <code>SyncClosedLogs</code> 函数会 DBImpl::mutex_.Unlock，而当前 CF 的 SwitchMemTable 函数可能会在这个期间执行，新增 new_mem，通过 max_memtable_id 来过滤掉这个期间新增的 new_mm。</p></li><li><p><em>needs_to_sync_closed_wals</em> 为 false，会使得 max_memtable_id 为 UINT64_MAX，表示要 Flush 所有的 ImmutableMemtables</p></li></ul><p>这部分代码上下文逻辑如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 设置 max_memtable_id</span></span><br><span class="line"><span class="type">uint64_t</span> max_memtable_id = needs_to_sync_closed_wals</span><br><span class="line">    ? cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">GetLatestMemTableID</span>()</span><br><span class="line">    : std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//... other middle codes</span></span><br><span class="line">IOStatus log_io_s = IOStatus::<span class="built_in">OK</span>();</span><br><span class="line"><span class="keyword">if</span> (needs_to_sync_closed_wals) &#123;</span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 释放 mutex_, 再进行 sync</span></span><br><span class="line">  VersionEdit synced_wals;</span><br><span class="line">  log_io_s = <span class="built_in">SyncClosedLogs</span>(job_context, &amp;synced_wals);</span><br><span class="line">  </span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  <span class="comment">// 4. write to MANIFEST</span></span><br><span class="line">  <span class="keyword">if</span> (log_io_s.<span class="built_in">ok</span>() &amp;&amp; synced_wals.<span class="built_in">IsWalAddition</span>()) &#123;</span><br><span class="line">    log_io_s = <span class="built_in">status_to_io_status</span>(<span class="built_in">ApplyWALToManifest</span>(</span><br><span class="line">          <span class="built_in">ReadOptions</span>(Env::IOActivity::kFlush), &amp;synced_wals));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SyncClosedLogs"><a href="#SyncClosedLogs" class="headerlink" title="SyncClosedLogs"></a>SyncClosedLogs</h3><p>SyncClosedLogs 函数需要在 <em>log_write_mutex_</em> 保护下。如果此时仍持有 <code>DBImpl::mutex_</code> 会影响增加其他其线程阻塞时间，比如写路径过程中的 <code>PreprocessWrite</code>，因此在进入 SyncClosedLogs 函数前会释放 <code>DBImpl::mutex_</code>，让其他的线程可以执行。</p><p>SyncClosedLogs 函数的目标是 [logs_.front().number, logfile_number_) 区间的 WALs，其中 logfile_number_ 指向当前最新的 WAL。由于在后台线程池中可能会同时执行多个 FlushMemTable 任务，只要一个 WAL 的生命周期还没结束，那么每次 FlushMemTables 前都会 SYNC WAL 一次，并使用 VersionEdit 记录该 WAL 的元信息再写入 MANIFEST。 因此在 SyncClosedLogs 函数开始，会先尝试阻塞等待其他线程完成对该 WAL 的 SYNC 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOStatus <span class="title">DBImpl::SyncClosedLogs</span><span class="params">(JobContext* job_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                                VersionEdit* synced_wals)</span> </span>&#123;</span><br><span class="line">  <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;log_write_mutex_)</span></span>;</span><br><span class="line">  autovector&lt;log::Writer*, <span class="number">1</span>&gt; logs_to_sync;</span><br><span class="line">  <span class="type">uint64_t</span> current_log_number = logfile_number_;</span><br><span class="line">  <span class="comment">// 1. 阻塞等待其他线程完成 SYNC</span></span><br><span class="line">  <span class="keyword">while</span> (logs_.<span class="built_in">front</span>().number &lt; current_log_number &amp;&amp;</span><br><span class="line">         logs_.<span class="built_in">front</span>().<span class="built_in">IsSyncing</span>()) &#123;</span><br><span class="line">    log_sync_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2. 获取所有待 SYNC 的对象: logs_to_sync</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = logs_.<span class="built_in">begin</span>();</span><br><span class="line">       it != logs_.<span class="built_in">end</span>() &amp;&amp; it-&gt;number &lt; current_log_number; ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; log = *it;</span><br><span class="line">    log.<span class="built_in">PrepareForSync</span>();</span><br><span class="line">    logs_to_sync.<span class="built_in">push_back</span>(log.writer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  IOStatus io_s;</span><br><span class="line">   <span class="comment">// 3. SYNC</span></span><br><span class="line">  <span class="keyword">if</span> (!logs_to_sync.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 操作局部变量 logs_to_sync 不需要 log_write_mutex_</span></span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">for</span> (log::Writer* log : logs_to_sync) &#123;</span><br><span class="line">      <span class="comment">// 每个文件进行 SYNC</span></span><br><span class="line">      io_s = log-&gt;<span class="built_in">file</span>()-&gt;<span class="built_in">Sync</span>(immutable_db_options_.use_fsync);</span><br><span class="line">      <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 关闭</span></span><br><span class="line">      <span class="keyword">if</span> (immutable_db_options_.recycle_log_file_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        io_s = log-&gt;<span class="built_in">Close</span>();</span><br><span class="line">        <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只要有一个 WAL 需要 SYNC ，整个目录都需要 SYNC</span></span><br><span class="line">    <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      io_s = directories_.<span class="built_in">GetWalDir</span>()-&gt;<span class="built_in">FsyncWithDirOptions</span>(</span><br><span class="line">          <span class="built_in">IOOptions</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">          <span class="built_in">DirFsyncOptions</span>(DirFsyncOptions::FsyncReason::kNewFileSynced));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要操作 active_logs_, logs_ 因此需要 log_write_mutex_</span></span><br><span class="line">    log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 标记是否完成</span></span><br><span class="line">    <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">MarkLogsSynced</span>(current_log_number - <span class="number">1</span>, <span class="literal">true</span>, synced_wals);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">MarkLogsNotSynced</span>(current_log_number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> io_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MarkLogsSynced"><a href="#MarkLogsSynced" class="headerlink" title="MarkLogsSynced"></a>MarkLogsSynced</h4><p><code>MarkLogsSynced</code> 函数记录 SYNCed WALs 信息:</p><p>选项 <em>DBOptions.track_and_verify_wals_in_manifest</em> 用于追踪 WAL 大小信息便于在 Recovery 期间进行校验。默认值为 false，但是 RocksDB 建议在生产环境设置为 true，防止误删或者损坏 WAL 目录下的文件而无法察觉。因此每次 Flush MemTable 前会记录 WAL 的 <code>&#123;wal.number, prev_synced_szie&#125;</code> 信息，那么当 recovery 时，存放 WAL 的目录下必须存在 <code>wal.number</code> 文件，且文件大小至少是 <code>prev_synced_szie</code>。</p><p>此外，还会更新 <code>logs_</code>：</p><ul><li>由于 WAL 在 SyncClosedLogs 函数中再次 SYNC。如果最新一次 SYNC 完成后 WAL 大小和上次 SYNC 的大小 prev_sync_size 相同，表示该 WAL 已完成持久化，则可以从 <code>logs_</code> 中删除，加入 <code>logs_to_free_</code> 队列，在 FlushJob 完成后，在 <code>FindObsoleteFiles</code> 函数中删除。</li><li>否则，还需要进行下一次 SYNC，将本次 SYNC 操作标记为完成，等待下一次 Flush 后台任务；</li></ul><p>由于 <code>MarkLogsSynced</code> 函数会对 <code>logs_</code> 和 <code>logs_to_free_</code> 进行操作，因此需要在 <code>log_write_mutex_</code> 保护下执行，执行完再阻塞唤醒所有阻塞等待在 <code>log_sync_cv_</code> 的地方。</p><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MarkLogsSynced</span><span class="params">(<span class="type">uint64_t</span> up_to, <span class="type">bool</span> synced_dir,</span></span></span><br><span class="line"><span class="params"><span class="function">                            VersionEdit* synced_wals)</span> </span>&#123;</span><br><span class="line">  log_write_mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = logs_.<span class="built_in">begin</span>(); it != logs_.<span class="built_in">end</span>() &amp;&amp; it-&gt;number &lt;= up_to;) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; wal = *it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wal.number &lt; logs_.<span class="built_in">back</span>().number) &#123;</span><br><span class="line">      <span class="comment">// Inactive WAL</span></span><br><span class="line">      <span class="keyword">if</span> (immutable_db_options_.track_and_verify_wals_in_manifest &amp;&amp;</span><br><span class="line">          wal.<span class="built_in">GetPreSyncSize</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        synced_wals-&gt;<span class="built_in">AddWal</span>(wal.number, <span class="built_in">WalMetadata</span>(wal.<span class="built_in">GetPreSyncSize</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (wal.<span class="built_in">GetPreSyncSize</span>() == wal.writer-&gt;<span class="built_in">file</span>()-&gt;<span class="built_in">GetFlushedSize</span>()) &#123;</span><br><span class="line">        <span class="comment">// Fully synced</span></span><br><span class="line">        logs_to_free_.<span class="built_in">push_back</span>(wal.<span class="built_in">ReleaseWriter</span>());</span><br><span class="line">        it = logs_.<span class="built_in">erase</span>(it);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(wal.<span class="built_in">GetPreSyncSize</span>() &lt; wal.writer-&gt;<span class="built_in">file</span>()-&gt;<span class="built_in">GetFlushedSize</span>());</span><br><span class="line">        wal.<span class="built_in">FinishSync</span>();</span><br><span class="line">        ++it;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Active WAL</span></span><br><span class="line">      <span class="built_in">assert</span>(wal.number == logs_.<span class="built_in">back</span>().number);</span><br><span class="line">      wal.<span class="built_in">FinishSync</span>();</span><br><span class="line">      ++it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  log_sync_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplyWALToManifest"><a href="#ApplyWALToManifest" class="headerlink" title="ApplyWALToManifest"></a>ApplyWALToManifest</h3><p><code>ApplyWALToManifest</code> 函数是将 <code>MarkLogsSynced</code> 函数中获得 synced_wals 序列化写入到 MANIFEST，写入 MANIFEST 的数据都需要指定一个所属 CF，由于 WAL 是RocksDB 中所有 CFs 共享的，而 DefaultCF 是第一个 ColumnFamily，因此将 WAL 的数据归属给 default_cf。</p><p>至于 <code>LogAndApplyToDefaultColumnFamily</code> 内部怎么 MANIFEST 交互，后面会讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::ApplyWALToManifest</span><span class="params">(<span class="type">const</span> ReadOptions&amp; read_options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  VersionEdit* synced_wals)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// not empty, write to MANIFEST.</span></span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  Status status = versions_-&gt;<span class="built_in">LogAndApplyToDefaultColumnFamily</span>(</span><br><span class="line">      read_options, synced_wals, &amp;mutex_, directories_.<span class="built_in">GetDbDir</span>());</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>() &amp;&amp; versions_-&gt;<span class="built_in">io_status</span>().<span class="built_in">IsIOError</span>()) &#123;</span><br><span class="line">    status = error_handler_.<span class="built_in">SetBGError</span>(versions_-&gt;<span class="built_in">io_status</span>(),</span><br><span class="line">                                       BackgroundErrorReason::kManifestWrite);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h3><p>在开启了 <em>track_and_verify_wals_in_manifest</em> 后，在 <code>DBImpl::Recover</code> 中，VersionSet 从 MANIFEST 恢复过来后，会将 MANIFEST 中记录的 WAL 元信息和 WAL 目录下的文件进行对比校验。如果该标志没有开启，则需要删除 MANIFEST 中记录的 WAL 信息，防止后续开启后，MANIFEST 中的记录的 WAL 文件已经被删除了，导致校验失败，无法恢复 RocksDB 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (immutable_db_options_.track_and_verify_wals_in_manifest) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!immutable_db_options_.best_efforts_recovery) &#123;</span><br><span class="line">    <span class="comment">// Verify WALs in MANIFEST.</span></span><br><span class="line">    s = versions_-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">CheckWals</span>(env_, wal_files);</span><br><span class="line">  &#125; <span class="comment">// else since best effort recovery does not recover from WALs, no need</span></span><br><span class="line">    <span class="comment">// to check WALs.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!versions_-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">GetWals</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  WalNumber max_wal_number =</span><br><span class="line">      versions_-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">GetWals</span>().<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">  edit.<span class="built_in">DeleteWalsBefore</span>(max_wal_number + <span class="number">1</span>);</span><br><span class="line">  recovery_ctx-&gt;<span class="built_in">UpdateVersionEdits</span>(</span><br><span class="line">      versions_-&gt;<span class="built_in">GetColumnFamilySet</span>()-&gt;<span class="built_in">GetDefault</span>(), edit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckWals"><a href="#CheckWals" class="headerlink" title="CheckWals"></a>CheckWals</h4><p><code>CheckWals</code> 函数是将从 MANIFEST 中获得的 WAL 最后一次 SYNC 大小 <code>synced_size</code> 和实际磁盘上的 WAL 文件大小 <code>log_file_size</code> 进行对比校验，起码要满足 <code>synced_size &lt;= log_file_size</code>，校验才能通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WalSet::CheckWals</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Env* env,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::unordered_map&lt;WalNumber, std::string&gt;&amp; logs_on_disk)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [log_number, wal_meta] : wals_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!wal_meta.<span class="built_in">HasSyncedSize</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. MANIFEST 中有存在的 WALs，磁盘上也必须存在</span></span><br><span class="line">    <span class="keyword">if</span> (logs_on_disk.<span class="built_in">find</span>(log_number) == logs_on_disk.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(fmt::format(</span><br><span class="line">        <span class="string">&quot;Missing WAL with log number: &#123;&#125;&quot;</span>, log_number));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 磁盘上的 WAL 文件大小 &gt;= 最后一次 SYNC 大小</span></span><br><span class="line">    <span class="type">uint64_t</span> log_file_size = <span class="number">0</span>;</span><br><span class="line">    s = env-&gt;<span class="built_in">GetFileSize</span>(logs_on_disk.<span class="built_in">at</span>(log_number), &amp;log_file_size);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log_file_size &lt; wal_meta.<span class="built_in">GetSyncedSizeInBytes</span>()) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(fmt::format(</span><br><span class="line">        <span class="string">&quot;Size mismatch: WAL (log number: &#123;&#125; ) in MANIFEST is &#123;&#125; bytes, &quot;</span></span><br><span class="line">        <span class="string">&quot;but actually is  &#123;&#125; bytes on disk.&quot;</span>,</span><br><span class="line">        log_number, wal_meta.<span class="built_in">GetSyncedSizeInBytes</span>(), log_file_size));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文简要讲下在 Flush  MemTable 之前，WAL 需要进行 SYNC 的原因。更多设计思考可以阅读 &lt;a href=&quot;https://github.com/facebook/rocksdb/wiki/Track-WAL-in-MANIFEST&quot;&gt;Track-WA</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WAL、MemTable 的生命周期管理(1)</title>
    <link href="https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/"/>
    <id>https://szza.github.io/2022/03/01/rocksdb/WritePath/WAL_1/</id>
    <published>2022-03-01T06:15:35.000Z</published>
    <updated>2023-08-07T09:26:04.729Z</updated>
    
    <content type="html"><![CDATA[<p>WAL 在 DB::Open 时就会创建，用于持久化 MemTable 中尚未 Flush 的数据。具体写入 WAL 的格式可以参考 <a href="https://github.com/facebook/rocksdb/wiki/Write-Ahead-Log-File-Format">Write-Ahead-Log-File-Format</a> 及其对应实现 DBImpl::WriteToWAL 函数，本文及后续几期主要关注 WAL&#x2F;MemTable 的生命周期管理。</p><h3 id="PreprocessWrite"><a href="#PreprocessWrite" class="headerlink" title="PreprocessWrite"></a>PreprocessWrite</h3><p>在写 WAL&#x2F;MemTable 之前，会先在 <code>DBImpl::PreprocessWrite</code> 函数中基于当前 RocksDB 的一些指标判断是否需要 Flush MemTable，创建新的 WAL&#x2F;MemTable 再接受本次写入：</p><ol><li>当前 WAL 的大小 <code>total_log_size_</code> 是否超过阈值 <code>DBOptions::max_total_wal_size</code></li><li>根据 write_buffer_manager_ 判断当前 MemTable 是否需要 Flush</li><li>flush_scheduler_.empty() 为 false，则说明上次某个 CF MemTable 写满了</li></ol><p>上述三种触发条件的处理方式，都需要先创建新的 WAL&#x2F;MemTable，然后生成 Flush 请求 flush_request，并且触发后台线程去消费该 flush_request。</p><ul><li>正常情况下，发起 Flush 请求后，不用等待后台 Flush 完成，新的 WAL&#x2F;MemTable 就可以继续接受后续读写请求，</li><li>但是如果写的压力过大，则会进一步限制，比如 DelayWrite，WriteStall，恢复正常后才会继续接受新的写入。</li></ul><p>上述三种的不同触发条件，不同在于如何选择 ColumnFamily。比如 条件（1）WAL 的大小超过阈值，则所有 ColumnFamilys 都需要进行更换 WAL&#x2F;MemTable；而条件（3）则只是需要某个具体的 CF MemTable 满了。因此只是 FlushReason 不同，处理过程都类似。</p><p>下面针对核心处理流程开始讲解。</p><h3 id="SwitchMemTable"><a href="#SwitchMemTable" class="headerlink" title="SwitchMemTable"></a>SwitchMemTable</h3><p>SwitchMemtable 函数是针对具体的 ColumnFamily 创建 WAL&#x2F;MemTable ，因此需要上层先筛选出需要切换 MemTable 的 CF，再传递给此函数。</p><p>由前文可知，进入 PreprocessWrite 函数时已经是单线程操作，而 SwitchMemtable 函数仍需要在 <code>DBImpl::_mutex</code> 的保护下才能调用，这是为了与后台 Flush 线程互斥。</p><p>根据 <code>log_empty_</code> 字段来判断是否需要创建新的 WAL，即当前 WAL 是否有数据写入，如果没有则不创建新的 WAL。主要是可能要为多个 CFs 创建新的 WAL&#x2F;MemTable，但是 WAL 是共享的，只需要第一次创建 WAL 即可，后续的 ColumnFamily 检测到 <code>log_empty_</code> 为空，则不再重复创建。</p><p>每个 WAL 都有一个对应的编号 <code>logfile_num</code>，由 <code>VersionSet::NewFileNumber</code> 函数来生成。</p><p><em>DBOptions::recycle_log_file_num</em> 决定是否复用生命周期已结束的 WALs，<code>log_recycle_files_</code> 字段用于保存生命周期已结束待删除的 WALs。此如果 <code>recycle_log_file_num &gt; 0</code> 则按照 FIFO 规则从 <code>log_recycle_files_</code> 取出生命周期最早结束的 WAL 的 logfile_number，因此可以 truncate 旧 WAL 文件再接受新数据。</p><p>在 RocksDB 中，数据存储目录在 <em>DBOptions::wal_dir</em>，其值就是 db_name，每个 WAL 文件名就是<code>wal_dir</code>+<code>logfile_number</code>+<code>.log</code>。因此，后文一般提及 log 都是指 WAL 文件。</p><p>比如：编译完 RocksDB，并执行 <em>build&#x2F;examples&#x2F;simple_example</em>，在 <em>&#x2F;tmp&#x2F;rocksdb_simple_example</em> 目录下会有如下以 log 为后缀的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ll /tmp/rocksdb_simple_example</span><br><span class="line">total 1832</span><br><span class="line">-rw-r--r-- 1 root root  1045 Jul 10 08:27 000326.sst</span><br><span class="line">-rw-r--r-- 1 root root   999 Jul 24 14:17 000331.sst</span><br><span class="line">-rw-r--r-- 1 root root    68 Jul 24 14:18 000332.<span class="built_in">log</span></span><br><span class="line">-rw-r--r-- 1 root root   999 Jul 24 14:18 000336.sst</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p><code>log_recycle_files_</code> 等字段会收到 FlushJob 的影响，因此需要在 <code>DBImpl::mutex_</code> 的保护下调用。而 CreateWAL 只是影响局部变量 new_log，不需要 mutex_ 保护，同理构建新的 MemTable 对象 new_mem 也不需要 mutex_。</p><p>下面是创建 new_log 和 new_mem 的核心代码及其注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::SwitchMemtable</span><span class="params">(ColumnFamilyData* cfd, WriteContext* context)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  log::Writer* new_log = <span class="literal">nullptr</span>;</span><br><span class="line">  MemTable* new_mem = <span class="literal">nullptr</span>;</span><br><span class="line">  IOStatus io_s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免多个 CFs 创建不同的 WAL</span></span><br><span class="line">  <span class="type">bool</span> creating_new_log = !log_empty_;</span><br><span class="line">  <span class="type">uint64_t</span> recycle_log_number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (creating_new_log &amp;&amp; immutable_db_options_.recycle_log_file_num &amp;&amp;</span><br><span class="line">      !log_recycle_files_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    recycle_log_number = log_recycle_files_.<span class="built_in">front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint64_t</span> new_log_number =</span><br><span class="line">      creating_new_log ? versions_-&gt;<span class="built_in">NewFileNumber</span>() : logfile_number_;</span><br><span class="line">  <span class="type">const</span> MutableCFOptions mutable_cf_options = *cfd-&gt;<span class="built_in">GetLatestMutableCFOptions</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为啥这个函数也需要保护 ???</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> preallocate_block_size =</span><br><span class="line">      <span class="built_in">GetWalPreallocateBlockSize</span>(mutable_cf_options.write_buffer_size);</span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 WAL</span></span><br><span class="line">  <span class="keyword">if</span> (creating_new_log) &#123;</span><br><span class="line">    io_s = <span class="built_in">CreateWAL</span>(new_log_number, recycle_log_number, preallocate_block_size,</span><br><span class="line">                     &amp;new_log);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// WAL 创建成功后，再创建 MemTable</span></span><br><span class="line"> <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    SequenceNumber seq = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">    new_mem = cfd-&gt;<span class="built_in">ConstructNewMemtable</span>(mutable_cf_options, seq);</span><br><span class="line">    context-&gt;superversion_context.<span class="built_in">NewSuperVersion</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用于 delete_range</span></span><br><span class="line">  cfd-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">ConstructFragmentedRangeTombstones</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// mutex_.Lock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CreateWAL"><a href="#CreateWAL" class="headerlink" title="CreateWAL"></a>CreateWAL</h4><p>WAL 的创建也比较简单，如代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOStatus <span class="title">DBImpl::CreateWAL</span><span class="params">(<span class="type">uint64_t</span> log_file_num, <span class="type">uint64_t</span> recycle_log_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">size_t</span> preallocate_block_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                           log::Writer** new_log)</span> </span>&#123;</span><br><span class="line">  IOStatus io_s;</span><br><span class="line">  std::unique_ptr&lt;FSWritableFile&gt; lfile;</span><br><span class="line"></span><br><span class="line">  DBOptions db_options =</span><br><span class="line">      <span class="built_in">BuildDBOptions</span>(immutable_db_options_, mutable_db_options_);</span><br><span class="line">  FileOptions opt_file_options =</span><br><span class="line">      fs_-&gt;<span class="built_in">OptimizeForLogWrite</span>(file_options_, db_options);</span><br><span class="line">  std::string wal_dir = immutable_db_options_.<span class="built_in">GetWalDir</span>();</span><br><span class="line">  std::string log_fname = <span class="built_in">LogFileName</span>(wal_dir, log_file_num);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 生成底层 wal 文件</span></span><br><span class="line">  <span class="keyword">if</span> (recycle_log_number) &#123;</span><br><span class="line">    std::string old_log_fname = <span class="built_in">LogFileName</span>(wal_dir, recycle_log_number);</span><br><span class="line">    io_s = fs_-&gt;<span class="built_in">ReuseWritableFile</span>(log_fname, old_log_fname, opt_file_options,</span><br><span class="line">                                  &amp;lfile, <span class="comment">/*dbg=*/</span><span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    io_s = <span class="built_in">NewWritableFile</span>(fs_.<span class="built_in">get</span>(), log_fname, &amp;lfile, opt_file_options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    lfile-&gt;<span class="built_in">SetWriteLifeTimeHint</span>(<span class="built_in">CalculateWALWriteHint</span>());</span><br><span class="line">    lfile-&gt;<span class="built_in">SetPreallocationBlockSize</span>(preallocate_block_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; listeners = immutable_db_options_.listeners;</span><br><span class="line">    FileTypeSet tmp_set = immutable_db_options_.checksum_handoff_file_types;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建写 wal 的 writer</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;WritableFileWriter&gt; <span class="title">file_writer</span><span class="params">(<span class="keyword">new</span> WritableFileWriter(</span></span></span><br><span class="line"><span class="params"><span class="function">        std::move(lfile), log_fname, opt_file_options,</span></span></span><br><span class="line"><span class="params"><span class="function">        immutable_db_options_.clock, io_tracer_, <span class="literal">nullptr</span> <span class="comment">/* stats */</span>, listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="literal">nullptr</span>, tmp_set.Contains(FileType::kWalFile),</span></span></span><br><span class="line"><span class="params"><span class="function">        tmp_set.Contains(FileType::kWalFile)))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 封装 log_writer</span></span><br><span class="line">    *new_log = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(std::<span class="built_in">move</span>(file_writer), log_file_num,</span><br><span class="line">                               immutable_db_options_.recycle_log_file_num &gt; <span class="number">0</span>,</span><br><span class="line">                               immutable_db_options_.manual_wal_flush,</span><br><span class="line">                               immutable_db_options_.wal_compression);</span><br><span class="line">    io_s = (*new_log)-&gt;<span class="built_in">AddCompressionTypeRecord</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> io_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConstructNewMemtable"><a href="#ConstructNewMemtable" class="headerlink" title="ConstructNewMemtable"></a>ConstructNewMemtable</h4><p>WAL 创建成功后，由 MemTable 所属的 ColumnFamily 构建 MemTable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MemTable* <span class="title">ColumnFamilyData::ConstructNewMemtable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options, SequenceNumber earliest_seq)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_, ioptions_, mutable_cf_options,</span><br><span class="line">                      write_buffer_manager_, earliest_seq, id_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ColumnFamily"><a href="#ColumnFamily" class="headerlink" title="ColumnFamily"></a>ColumnFamily</h3><p>上面 new_log, new_mem 成功创建完后，下面对 ColumnFamily 的 WAL&#x2F;MemTable 相关的元信息进行更新。</p><p>首先需要将当前 cur_log_writer 中已有的数据 flush 到操作系统中。实际上在 LogWriter::AddRecord 内部，每次写完都会进行一次 flush，将数据刷操作系统page cache 中，由操作系统决定何时将数据写入文件。flush 只能保证 RocksDB 进程中途挂了再重启数据不会丢，但是如果机器挂了数据还是有丢的可能，如果想要进一步保证安全就需要 sync 操作，将操作系统缓存层的数据同步到磁盘，很显然这个操作会拖慢写入速度。RocksDB 也配置了开启选项 <em>WriteOptions::sync: bool</em>，默认 false。</p><p><code>logs_</code>字段是个map，映射关系是{logfile_number_, log_writer}，记录了每一个log_writer及其对应的logfile_number，<code>alive_log_files_</code>记录是 logfile_number及其log_writer写入的数据量大小。由于 WAL 的生命周期和 ColumnFamily 有关，因此需要 <code>logs_</code> 和 <code>alive_log_files_</code> 来记录一个 RocksDB 实例中所有生命周期尚未结束的 WALs。</p><p>因此，当创建了新的 WAL ，需要在 log_write_mutex_ 的保护下添加新的记录。后续 FLushJob 完成了，也会相应删除生命周期结束的 WAL 记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//... above code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面 Unlock, 现在恢复 Lock</span></span><br><span class="line">mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"><span class="keyword">if</span> (recycle_log_number != <span class="number">0</span>) &#123;</span><br><span class="line">  log_recycle_files_.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; creating_new_log) &#123;</span><br><span class="line">  <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;log_write_mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 1. Flush</span></span><br><span class="line">  <span class="keyword">if</span> (!logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    log::Writer* cur_log_writer = logs_.<span class="built_in">back</span>().writer;</span><br><span class="line">    io_s = cur_log_writer-&gt;<span class="built_in">WriteBuffer</span>();</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. Flush 成功后，更新 log 相关元信息</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    logfile_number_ = new_log_number;</span><br><span class="line">    log_empty_ = <span class="literal">true</span>;</span><br><span class="line">    log_dir_synced_ = <span class="literal">false</span>;</span><br><span class="line">    logs_.<span class="built_in">emplace_back</span>(logfile_number_, new_log);</span><br><span class="line">    alive_log_files_.<span class="built_in">push_back</span>(<span class="built_in">LogFileNumberSize</span>(logfile_number_));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前置工作已经完成，下面要开始更新 ColumnFaimly了。</p><p>由于传递给 SwitchMemTable 的 CF 并非都是因为自己的 MemTable 满了，可能是因为某个 CF0 把 WAL 写满了，导致所有的 MmeTable 都要切换，比如上述条件（1）。有些 CF1 可能仍然是空的，此时就需要更新 CF1 当前的 LogNumber。 这样就可以删除 CF1 之前指向的 WAL。</p><p>比如：CF0，CF1 当前都指向 log1，由于 CF0 一直写入数据，导致 log1 满了。此时需要创建新的 WAL 文件 log2。但是 CF1 一直没有写入数据，此时同步将 CF1 当前 log 指针 <code>log_number_</code> 指向 log2，使得指向 log1 的引用就是0，因此就可以在 MemTable 完成 Flush 完成后，将 log1 删除。</p><p>其余解释见代码，这部分代码简化如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...above code</span></span><br><span class="line"><span class="type">bool</span> empty_cf_updated = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!empty_cf_updated) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> cf : *versions_-&gt;<span class="built_in">GetColumnFamilySet</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cf-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (creating_new_log) &#123;</span><br><span class="line">        cf-&gt;<span class="built_in">SetLogNumber</span>(logfile_number_);</span><br><span class="line">      &#125;</span><br><span class="line">      cf-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">SetCreationSeq</span>(versions_-&gt;<span class="built_in">LastSequence</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CF 当前 Memtable 下一个活跃的 logfile_numer_，</span></span><br><span class="line"><span class="comment">// 选择需要 Flush 的 ImmutableMemTables 使用</span></span><br><span class="line">cfd-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">SetNextLogNumber</span>(logfile_number_);</span><br><span class="line"><span class="comment">// 将当前 Memtable 添加到 ImmutableMemTable 链表中，等待 Flush 删除。</span></span><br><span class="line">cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">Add</span>(cfd-&gt;<span class="built_in">mem</span>(), &amp;context-&gt;memtables_to_free_);</span><br><span class="line"><span class="comment">// 设置新的 MemTable</span></span><br><span class="line">new_mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">cfd-&gt;<span class="built_in">SetMemtable</span>(new_mem);</span><br><span class="line"><span class="comment">// 更新 superversion</span></span><br><span class="line"><span class="built_in">InstallSuperVersionAndScheduleWork</span>(cfd, &amp;context-&gt;superversion_context,</span><br><span class="line">                                   mutable_cf_options);</span><br></pre></td></tr></table></figure><h4 id="GenerateFlushRequest"><a href="#GenerateFlushRequest" class="headerlink" title="GenerateFlushRequest"></a>GenerateFlushRequest</h4><p>SwitchMemTable，完成了 WAL&#x2F;MemTable 的切换。紧接着就会尝试发起一次 flush 请求。Flush 的对象是从每个 CF 的 ImmutableMemtables 中提取的，因此 FlushRequest 需要保存每个 CF 的 max_memtable_id。</p><p>CF 中的每个 MemTable 都有一个单增的 <code>id_</code>，用于追踪 Flush。在使用 <code>ColumnFamilyData::SetMemtable</code> 函数添加到 CF 中时更新 <code>MemTable::id_</code> 字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::GenerateFlushRequest</span><span class="params">(<span class="type">const</span> autovector&lt;ColumnFamilyData*&gt;&amp; cfds,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  FlushReason flush_reason, FlushRequest* req)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(req != <span class="literal">nullptr</span>);</span><br><span class="line">  req-&gt;flush_reason = flush_reason;</span><br><span class="line">  req-&gt;cfd_to_max_mem_id_to_persist.<span class="built_in">reserve</span>(cfds.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> cfd : cfds) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == cfd) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// max_memtable_id 即最新加入 ImmutableMemtables 的 memtable 的 Id</span></span><br><span class="line">    <span class="type">uint64_t</span> max_memtable_id = cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">GetLatestMemTableID</span>();</span><br><span class="line">    req-&gt;cfd_to_max_mem_id_to_persist.<span class="built_in">emplace</span>(cfd, max_memtable_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SchedulePendingFlush"><a href="#SchedulePendingFlush" class="headerlink" title="SchedulePendingFlush"></a>SchedulePendingFlush</h4><p> <code>flush_queue_</code> 用于保存MemTables的Flush请求，<code>SchedulePendingFlush</code> 将上述生成的flush请求压入flush_queue_，再调度后台任务线程从 flush_queue_中取出FlushRequest执行。</p><p>这里也有个设计，如果开启了 <em>DBOptions::atomic_flush</em> 则会让多个 CFs 的 Flush 请求放到一个线程去执行，这样就可以保证 Flush 的原子性。否则，每次只 flush。但是其默认值为 false，因为只要开启了 WAL，就能保证跨多个 CFs 的写操作是原子性的，即便 flush 操作挂了也还有 WAL 可以恢复。</p><p>部分代码如下。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::SchedulePendingFlush</span><span class="params">(<span class="type">const</span> FlushRequest&amp; flush_req)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">if</span> (flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!immutable_db_options_.atomic_flush) &#123;</span><br><span class="line">    <span class="comment">// only one</span></span><br><span class="line">    <span class="built_in">assert</span>(flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">size</span>() == <span class="number">1</span>);</span><br><span class="line">    ColumnFamilyData* cfd =</span><br><span class="line">        flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">begin</span>()-&gt;first;</span><br><span class="line">    <span class="keyword">if</span> (!cfd-&gt;<span class="built_in">queued_for_flush</span>() &amp;&amp; cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">IsFlushPending</span>()) &#123;</span><br><span class="line">      cfd-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">      cfd-&gt;<span class="built_in">set_queued_for_flush</span>(<span class="literal">true</span>);</span><br><span class="line">      ++unscheduled_flushes_;</span><br><span class="line">      flush_queue_.<span class="built_in">push_back</span>(flush_req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [cfd, _] : flush_req.cfd_to_max_mem_id_to_persist) &#123;</span><br><span class="line">      cfd-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ++unscheduled_flushes_;</span><br><span class="line">    flush_queue_.<span class="built_in">push_back</span>(flush_req);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MaybeScheduleFlushOrCompaction"><a href="#MaybeScheduleFlushOrCompaction" class="headerlink" title="MaybeScheduleFlushOrCompaction"></a>MaybeScheduleFlushOrCompaction</h4><p>RocksDB 的后台任务线程调度是主动触发的，并没有 loop 线程在阻塞等待 <code>flush_queue_</code> 加入新元素后就从 <code>flush_queue_</code> 提取请求去执行。</p><p>因此，在向 <code>flush_req</code> 加入有新请求后，需要主动通过 <code>MaybeScheduleFlushOrCompaction</code> 函数调度后台线程执行 <code>DBImpl::BackgroundCallFlush</code> 函数执行 FlushRequest 请求。</p><p>最大后台任务有 <code>bg_job_limits</code> 限制，<code>unscheduled_flushes_</code> 表征当前有多少待 flush 的请求，<code>bg_flush_scheduled_</code> 表征当前已经调度了多少 flush 请求，配合 <code>bg_job_limits</code> 参数限制后台 flush 任务。</p><p><code>DBImpl::BGWorkFlush</code> 函数用于执行 FlushRequest，<code>DBImpl::UnscheduleFlushCallback</code> 函数则是执行 FlushRequest 完的回调函数，用于释放 <code>FlushThreadArg</code> 对象。</p><p><code>MaybeScheduleFlushOrCompaction</code> 函数执行，是个分界点：</p><ul><li>提交完 Flush 请求后，如果没有触发 DelayWrite，WriteStall，就会接受新的读写请求了；</li><li>后台线程池接受到 <code>BGWorkFlush</code> 请求后，就开始执行 FlushReqeust</li></ul><p>这部分相关代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MaybeScheduleFlushOrCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="comment">//... precondition check</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bg_job_limits = <span class="built_in">GetBGJobLimits</span>();</span><br><span class="line">  <span class="type">bool</span> is_flush_pool_empty =</span><br><span class="line">      env_-&gt;<span class="built_in">GetBackgroundThreads</span>(Env::Priority::HIGH) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!is_flush_pool_empty &amp;&amp; unscheduled_flushes_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         bg_flush_scheduled_ &lt; bg_job_limits.max_flushes) &#123;</span><br><span class="line">    bg_flush_scheduled_++;</span><br><span class="line">    FlushThreadArg* fta = <span class="keyword">new</span> FlushThreadArg;</span><br><span class="line">    fta-&gt;db_ = <span class="keyword">this</span>;</span><br><span class="line">    fta-&gt;thread_pri_ = Env::Priority::HIGH;</span><br><span class="line">    env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWorkFlush, fta, Env::Priority::HIGH, <span class="keyword">this</span>,</span><br><span class="line">                   &amp;DBImpl::UnscheduleFlushCallback);</span><br><span class="line">    --unscheduled_flushes_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_flush_pool_empty) &#123;</span><br><span class="line">    <span class="keyword">while</span> (unscheduled_flushes_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           bg_flush_scheduled_ + bg_compaction_scheduled_ &lt;</span><br><span class="line">               bg_job_limits.max_flushes) &#123;</span><br><span class="line">      bg_flush_scheduled_++;</span><br><span class="line">      FlushThreadArg* fta = <span class="keyword">new</span> FlushThreadArg;</span><br><span class="line">      fta-&gt;db_ = <span class="keyword">this</span>;</span><br><span class="line">      fta-&gt;thread_pri_ = Env::Priority::LOW;</span><br><span class="line">      env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWorkFlush, fta, Env::Priority::LOW, <span class="keyword">this</span>,</span><br><span class="line">                     &amp;DBImpl::UnscheduleFlushCallback);</span><br><span class="line">      --unscheduled_flushes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//.. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BackgroundCallFlush"><a href="#BackgroundCallFlush" class="headerlink" title="BackgroundCallFlush"></a>BackgroundCallFlush</h3><p>DBImpl::BGWorkFlush 只是个 <code>BackgroundCallFlush</code> 的 wrapper。 进入 <code>BackgroundCallFlush</code> 函数后，需要获取 <code>DBImpl::mutex_</code> 来执行 <code>BackgroundFlush</code>，执行成功后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::BackgroundCallFlush</span><span class="params">(Env::Priority thread_pri)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> made_progress = <span class="literal">false</span>;</span><br><span class="line">  <span class="function">JobContext <span class="title">job_context</span><span class="params">(next_job_id_.fetch_add(<span class="number">1</span>), <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 需要 DBImpl::mutex_</span></span><br><span class="line">    <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>; </span><br><span class="line">    num_running_flushes_++;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;std::list&lt;<span class="type">uint64_t</span>&gt;::iterator&gt;</span><br><span class="line">        <span class="built_in">pending_outputs_inserted_elem</span>(<span class="keyword">new</span> std::list&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">iterator</span>(</span><br><span class="line">            <span class="built_in">CaptureCurrentFileNumberInPendingOutputs</span>()));</span><br><span class="line">    FlushReason reason;</span><br><span class="line"></span><br><span class="line">    Status s = <span class="built_in">BackgroundFlush</span>(&amp;made_progress, &amp;job_context, &amp;log_buffer,</span><br><span class="line">                               &amp;reason, thread_pri);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(num_running_flushes_ &gt; <span class="number">0</span>);</span><br><span class="line">    num_running_flushes_--;</span><br><span class="line">    bg_flush_scheduled_--;</span><br><span class="line">    <span class="comment">// See if there&#x27;s more work to be done</span></span><br><span class="line">    <span class="built_in">MaybeScheduleFlushOrCompaction</span>();</span><br><span class="line">    atomic_flush_install_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">    bg_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BackgroundFlush"><a href="#BackgroundFlush" class="headerlink" title="BackgroundFlush"></a>BackgroundFlush</h4><p><code>PopFirstFromFlushQueue</code> 函数从 <code>flush_request_</code> 中取出待 Flush 的请求，过滤掉不符合条件的的CF，符合结果的存在 <code>bg_flush_args</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::BackgroundFlush</span><span class="params">(<span class="type">bool</span>* made_progress, JobContext* job_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                               LogBuffer* log_buffer, FlushReason* reason,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Env::Priority thread_pri)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  autovector&lt;BGFlushArg&gt; bg_flush_args;</span><br><span class="line">  std::vector&lt;SuperVersionContext&gt;&amp; superversion_contexts =</span><br><span class="line">      job_context-&gt;superversion_contexts;</span><br><span class="line">  autovector&lt;ColumnFamilyData*&gt; column_families_not_to_flush;</span><br><span class="line">  <span class="keyword">while</span> (!flush_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// This cfd is already referenced</span></span><br><span class="line">    <span class="keyword">auto</span> [flush_reason, cfd_to_max_mem_id_to_persist] =</span><br><span class="line">        <span class="built_in">PopFirstFromFlushQueue</span>();</span><br><span class="line">    superversion_contexts.<span class="built_in">clear</span>();</span><br><span class="line">    superversion_contexts.<span class="built_in">reserve</span>(cfd_to_max_mem_id_to_persist.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [cfd, max_mem_id] : cfd_to_max_mem_id_to_persist) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cfd-&gt;<span class="built_in">GetMempurgeUsed</span>()) &#123;</span><br><span class="line">        cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">FlushRequested</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cfd-&gt;<span class="built_in">IsDropped</span>() || !cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">IsFlushPending</span>()) &#123;</span><br><span class="line">        <span class="comment">// can&#x27;t flush this CF, try next one</span></span><br><span class="line">        column_families_not_to_flush.<span class="built_in">push_back</span>(cfd);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      superversion_contexts.<span class="built_in">emplace_back</span>(<span class="built_in">SuperVersionContext</span>(<span class="literal">true</span>));</span><br><span class="line">      bg_flush_args.<span class="built_in">emplace_back</span>(cfd, max_mem_id,</span><br><span class="line">                                 &amp;(superversion_contexts.<span class="built_in">back</span>()), flush_reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有待 Flush 的 CF</span></span><br><span class="line">    <span class="keyword">if</span> (!bg_flush_args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得具有 Flush 条件的 <code>bg_flush_args</code>，下面就是真正的准备执行 FlushJob。<code>FlushJob</code> 由 <code>FlushMemTablesToOutputFiles</code> 函数执行，这个后续再讲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (!bg_flush_args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span> bg_job_limits = <span class="built_in">GetBGJobLimits</span>();</span><br><span class="line">  status = <span class="built_in">FlushMemTablesToOutputFiles</span>(bg_flush_args, made_progress,</span><br><span class="line">                                       job_context, log_buffer, thread_pri);</span><br><span class="line">  *reason = bg_flush_args[<span class="number">0</span>].flush_reason_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; arg : bg_flush_args) &#123;</span><br><span class="line">    ColumnFamilyData* cfd = arg.cfd_;</span><br><span class="line">    <span class="keyword">if</span> (cfd-&gt;<span class="built_in">UnrefAndTryDelete</span>()) &#123;</span><br><span class="line">      arg.cfd_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> cfd : column_families_not_to_flush) &#123;</span><br><span class="line">  cfd-&gt;<span class="built_in">UnrefAndTryDelete</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;WAL 在 DB::Open 时就会创建，用于持久化 MemTable 中尚未 Flush 的数据。具体写入 WAL 的格式可以参考 &lt;a href=&quot;https://github.com/facebook/rocksdb/wiki/Write-Ahead-Log-File</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WriteThread 如何使用 Pipeline 提升写入吞吐，降低延迟</title>
    <link href="https://szza.github.io/2022/02/13/rocksdb/WritePath/write_thread_4/"/>
    <id>https://szza.github.io/2022/02/13/rocksdb/WritePath/write_thread_4/</id>
    <published>2022-02-13T06:15:35.000Z</published>
    <updated>2023-08-07T09:26:04.729Z</updated>
    
    <content type="html"><![CDATA[<p>在前面几篇讲解了从 WriteBatch 的内部序列化流程 和 WriteThread 如何控制并发写入的基本流程，本文进一步讲解 WriteThread 如何使用 PipelinedWrite 来提升写吞吐，其中和前文相似的逻辑不再细说。</p><p>通过设置选项 <code>DBOptions::enable_pipelined_write = true</code> 来开启，开启后整个db的 WriteThread 都是通过 PipelinedWrite 方式控制写入流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (immutable_db_options_.enable_pipelined_write) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">PipelinedWriteImpl</span>(write_options, my_batch, callback, log_used,</span><br><span class="line">                            log_ref, disable_memtable, seq_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WAL-Pipelined-Write"><a href="#WAL-Pipelined-Write" class="headerlink" title="WAL: Pipelined Write"></a>WAL: Pipelined Write</h4><p>在之前的 WriteThread 写入控制流程中， 是依次有序地将数据写入 WAL 和 MemTable，那么如何使得 WAL 和 MemTable 的写入操作并行起来？</p><p>在多个 writers 并发写入同一个 RocksdB 实例时，只要前一个 <code>writer_group0</code> 将数据写入 WAL 了，那么下一个 <code>writer_group1</code> 就不必等待 writer_group0 完成 MemTable 写入流程，writer_group1 就可以开始自己的 WAL 写入流程: 因此 writer_group0 的 MemTable 写流程和 writer_group1 的 WAL 写流程就可以并行起来。</p><p>上述就是 <code>PipelinedWrite</code> 的核心思想。因此 PipelinedWrite 需要开启 WAL，来保证 writer_group0 写入 WAL 的数据不会丢。</p><h4 id="MemTable-Concurrent-Write"><a href="#MemTable-Concurrent-Write" class="headerlink" title="MemTable: Concurrent Write"></a>MemTable: Concurrent Write</h4><p>已经写入 WAL 的数据不会丢，那么是否可以在写入 MemTable 时，允许多个 writers 并发地写 MemTable，而不是原先由 leader-writer 来完成 memtable_write_group 的写入？</p><p>选项 <code>DBOptions::allow_concurrent_memtable_write</code> 默认值为 true，即默认支持并发写入 MemTable，但实际上当前只有基于 skiplist 实现的 MemTable 才支持这一特性（ <code>SkipListRep</code> 也是 MemTable 的默认实现）。</p><p>因此，在写路径使用 <code>PipelineWrite</code> 实现时，实际上就有了两种优化：</p><ul><li>WriteGroup 之间可以 Pipeline</li><li>MemTable 可以并发写入</li></ul><p>从实现角度，可以粗略地将有 <code>PipelinedWriteImpl</code> 函数划分成三个阶段（任务）:</p><ul><li><p>T1：完成当前 write_group0 的 WAL 写入流程，</p></li><li><p>T2：通知 write_group1 开启 WAL 写入流程，即 write_group1 无需等待 write_group0 完成 MemTable 写入流程才开启自己的 WAL 写入流程；</p></li><li><p>T3：write_group0 的 WAL 写入流程完成后，需要启动 write_group0 的并发写 MemTable 流程。</p><p>实际上，在 T3 阶段可能会携带其他 write_group 的 writers 一起进入 T3 阶段，来提升性能，详情见后文。</p></li></ul><p>由于后两个任务都需要等待第一个任务完成，因此三个任务的分界点就可以设置在 <code>WrriteThread::ExitAsBatchGroupLeader</code> 函数中: T1 在写 WAL 期间需要整个 RocksDB 只有一个 leader-writer，在 T1 任务结束后就可以不再担任 leader 角色。此时有两件事需要做 <em>1）</em> 挑选出下一个 WriteGroup 中的 leader-writer，让 T2 任务可以 pipeline 执行；<em>2）</em> 开启当前 WriteGroup 并发写入 MemTable 流程。</p><p>整个设计如下图：</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_write_thread_4_1.png?raw=true" alt="write_path_4_1"></p><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>T1 任务的流程和 <a href="https://szza.github.io/2022/01/15/rocksdb/WritePath/write_thread_2/">WriteThread 如何控制并发写入流程</a> 的基本一致，都需要经过 <code>JoinBatchGroup</code> -&gt; <code>EnterAsBatchGroupLeader</code> -&gt; <code>ExitAsBatchGroupLeader</code>， 只是将原来 leader-writer 作用范围（WriteToWAL 和 MemTable::Add） 范围缩小到了仅有 WALs。</p><p>因此，只有当 <code>JoinBatchGroup</code> 函数返回的 writer 是 leader-writer 时才会进入 WAL 写流程，而且当前 write_group0 的其他 writers 和后续 write_group1 等都会阻塞在 <code>JoinBatchGroupl</code> 函数处。</p><p>具体的阻塞逻辑可以参考 <a href="https://szza.github.io/2022/02/02/rocksdb/WritePath/write_thread_3/">WriteThread 如何自适应优化线程同步</a>。PipelineWriteImpl 的函数入口代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WriteThread::Writer <span class="title">w</span><span class="params">(write_options, my_batch, callback, log_ref,</span></span></span><br><span class="line"><span class="params"><span class="function">                      disable_memtable, <span class="comment">/*_batch_cnt=*/</span><span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="comment">/*_pre_release_callback=*/</span><span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">write_thread_.<span class="built_in">JoinBatchGroup</span>(&amp;w);</span><br><span class="line"><span class="keyword">if</span> (w.state == WriteThread::STATE_GROUP_LEADER) &#123;</span><br><span class="line">  WriteThread::WriteGroup wal_write_group;</span><br><span class="line">  last_batch_group_size_ =</span><br><span class="line">      write_thread_.<span class="built_in">EnterAsBatchGroupLeader</span>(&amp;w, &amp;wal_write_group);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w.status.<span class="built_in">ok</span>() &amp;&amp; !write_options.disableWAL) &#123;</span><br><span class="line">    <span class="comment">// 将当前 wal_write_group 数据写入 WAL</span></span><br><span class="line">    io_s =</span><br><span class="line">        <span class="built_in">WriteToWAL</span>(wal_write_group, log_context.writer, log_used,</span><br><span class="line">                   log_context.need_log_sync, log_context.need_log_dir_sync,</span><br><span class="line">                   current_sequence, log_file_number_size);</span><br><span class="line">    w.status = io_s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  write_thread_.<span class="built_in">ExitAsBatchGroupLeader</span>(wal_write_group, w.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，PipelinedWrite 如何关联前后 writer_group 的核心就在 <code>ExitAsBatchGroupLeader</code> 函数中了。</p><h4 id="ExitAsBatchGroupLeader"><a href="#ExitAsBatchGroupLeader" class="headerlink" title="ExitAsBatchGroupLeader"></a>ExitAsBatchGroupLeader</h4><p>在前文 <a href="https://szza.github.io/2022/01/15/rocksdb/WritePath/write_thread_2">WriteThread 如何控制并发写入流程</a> 已经详细讲解了 <code>ExitAsBatchGroupLeader</code> 函数在 <code>enable_pipelined_write == false</code> 时的执行流程，下面来讲另一个分支。主要有两个任务：</p><ul><li><p>T2：选出下一个 write_group1 中的 leader-writer，使其也进入写 WAL 流程</p></li><li><p>T3：由 <code>CompleteLeader</code> 和 <code>CompleteFollower</code> 函数提前将不用写入 MemTable 的 writrs 从 write_group0 链表中删除。将 <code>write_group0</code> 中剩余的 writers 移动到 <code>newest_memtable_writer_</code> 指向的链表。</p><p>只有 leader-memtable-writer 才能开启并发写 MemTable 的流程，<code>w-&gt;state</code> 状态会变成 <code>STATE_MEMTABLE_WRITER_LEADER</code>。</p><p>如果此时多个 write_group（wg0，wg1）的 leader-writer 都想变成 leader-memtable-writer，假设最终 wg0-&gt;leader 成功，则新的 memtable_write_group 实际上会包含 (wg0, wg1)，并且 wg1-&gt;link_older &#x3D; wg0 的方式串联起来。</p><p>接着，leader-memtable-writer 通过 <code>LaunchParallelMemTableWriters</code> 函数来启动 <code>memtable_write_group</code> 并发写 MemTables 的流程，follower-writer 才会解除阻塞等待， 进入 MemTable::Add 写入流程。</p></li></ul><p>整体代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::ExitAsBatchGroupLeader</span><span class="params">(WriteGroup&amp; write_group,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Status&amp; status)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enable_pipelined_write_) &#123;</span><br><span class="line">    Writer dummy;</span><br><span class="line">    Writer* head = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="comment">// 1. 在当前 write_group0 和下一个 write_group1 中间插入一个 dummy 节点</span></span><br><span class="line">    <span class="keyword">if</span> (head != last_writer ||</span><br><span class="line">        !newest_writer_.<span class="built_in">compare_exchange_strong</span>(head, &amp;dummy)) &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">CreateMissingNewerLinks</span>(head);</span><br><span class="line">      <span class="built_in">assert</span>(last_writer-&gt;link_newer != <span class="literal">nullptr</span>);</span><br><span class="line">      last_writer-&gt;link_newer-&gt;link_older = &amp;dummy;</span><br><span class="line">      dummy.link_newer = last_writer-&gt;link_newer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提前删除不用写 MemTable 的 writers 节点</span></span><br><span class="line">    <span class="keyword">for</span> (Writer* w = last_writer; w != leader;) &#123;</span><br><span class="line">      Writer* next = w-&gt;link_older;</span><br><span class="line">      w-&gt;status = status;</span><br><span class="line">      <span class="keyword">if</span> (!w-&gt;<span class="built_in">ShouldWriteToMemtable</span>()) &#123;</span><br><span class="line">        <span class="built_in">CompleteFollower</span>(w, write_group);</span><br><span class="line">      &#125;</span><br><span class="line">      w = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!leader-&gt;<span class="built_in">ShouldWriteToMemtable</span>()) &#123;</span><br><span class="line">      <span class="built_in">CompleteLeader</span>(write_group);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 (T3) 将 write_group0 中剩余的 writers 转移到</span></span><br><span class="line">    <span class="comment">//     newest_memtable_writer_  指向的链表</span></span><br><span class="line">    <span class="keyword">if</span> (write_group.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">LinkGroup</span>(write_group, &amp;newest_memtable_writer_)) &#123;</span><br><span class="line">        <span class="comment">// 设置 leader-memtable-writer</span></span><br><span class="line">        <span class="built_in">SetState</span>(write_group.leader, STATE_MEMTABLE_WRITER_LEADER);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. (T2) 选取 writ_group1 中 leader-writer</span></span><br><span class="line">    head = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (head != &amp;dummy ||</span><br><span class="line">        !newest_writer_.<span class="built_in">compare_exchange_strong</span>(head, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      <span class="built_in">CreateMissingNewerLinks</span>(head);</span><br><span class="line">      Writer* new_leader = dummy.link_newer;</span><br><span class="line">      <span class="built_in">assert</span>(new_leader != <span class="literal">nullptr</span>);</span><br><span class="line">      new_leader-&gt;link_older = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="built_in">SetState</span>(new_leader, STATE_GROUP_LEADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 等待 leader-memtable-writer 调用 LaunchParallelMemTableWriters</span></span><br><span class="line">    <span class="built_in">AwaitState</span>(leader,</span><br><span class="line">               STATE_MEMTABLE_WRITER_LEADER | STATE_PARALLEL_MEMTABLE_WRITER |</span><br><span class="line">                   STATE_COMPLETED,</span><br><span class="line">               &amp;eabgl_ctx);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//... enable_pipelined_write_ == false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompleteFollower"><a href="#CompleteFollower" class="headerlink" title="CompleteFollower"></a>CompleteFollower</h4><p>WriteThread 是逆序从 <code>[last_writer, leader)</code> 来删除不需要写入 MemTable 的 writers-follower 节点。这个 write_group 的 writers list 首尾节点是 <code>leader</code> 和 <code>last_writer</code>。 CompleteFollower 删除的都是 followers 节点，因此在删除时需要注意下是不是尾部节点 last_writer 即可。</p><p>这里只需要将 w 从 write_group 中剔除即可，并不需要 delete w，而是将 <code>w-&gt;state</code> 状态设置为 <code>STATE_COMPLETED</code>。这是因为 w 这份资源由 w 所属的线程去释放，将其状态更改为 <code>STATE_COMPLETED</code> 后，w 所属的线程就会解除阻塞，去释放这份资源，回到应用层。</p><p><code>CompleteLeader</code> 逻辑也类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::CompleteFollower</span><span class="params">(Writer* w, WriteGroup&amp; write_group)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(write_group.size &gt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">assert</span>(w != write_group.leader);</span><br><span class="line">  <span class="keyword">if</span> (w == write_group.last_writer) &#123;</span><br><span class="line">    w-&gt;link_older-&gt;link_newer = <span class="literal">nullptr</span>;</span><br><span class="line">    write_group.last_writer = w-&gt;link_older;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    w-&gt;link_older-&gt;link_newer = w-&gt;link_newer;</span><br><span class="line">    w-&gt;link_newer-&gt;link_older = w-&gt;link_older;</span><br><span class="line">  &#125;</span><br><span class="line">  write_group.size -= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">SetState</span>(w, STATE_COMPLETED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkGroup"><a href="#LinkGroup" class="headerlink" title="LinkGroup"></a>LinkGroup</h4><p><code>LinkGroup</code> 函数的作用是将当前 write_group0 中需要向 MemTable 写数据的 writers 转移到 <code>newest_memtable_writer_</code> 中来，并且保持 write_group0 中的顺序。</p><ol><li><p>先断开 <code>(leader, last_writer]</code> 区间所有的 <code>w-&gt;link_newer/prev</code> 指针（leader-&gt;link_newer 已经是 NULL)。这是因为 <code>LinkGroup</code> 可能会将多个 WriteGroup 的 writers 串到一个 <code>newest_memtable_writer_</code> 指针中，后续需要重新建立 prev 指针。</p></li><li><p>通过 <code>compare_exchange_weak</code> 尝试让 <code>newest_memtable_writer_</code> 指向 <code>last_writer</code>。多个并发的 WriteGroup 通过 link_older 指针串联起来。</p><p> 因此，在 <code>ExitAsBatchGroupLeader</code> 函数末尾会有个 <code>AwaitState(leader, state)</code> 代码，用于阻塞那些被串在 memtable_write_group 中的 follower-memtable-writers，等待 leader-memtable-writer 调用 <code>LaunchParallelMemTableWriters</code> 函数才能解除阻塞。</p></li></ol><p>原理和 <code>LinkOne</code> 函数差不多，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteThread::LinkGroup</span><span class="params">(WriteGroup&amp; write_group,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::atomic&lt;Writer*&gt;* newest_writer)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader; <span class="comment">// head</span></span><br><span class="line">  Writer* last_writer = write_group.last_writer; <span class="comment">// tail</span></span><br><span class="line">  Writer* w = last_writer;</span><br><span class="line">  <span class="comment">// 1. 断开 [last_writer, leader) 区间 w-&gt;link_newer 指针</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    w-&gt;link_newer = <span class="literal">nullptr</span>;</span><br><span class="line">    w-&gt;write_group = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (w == leader) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    w = w-&gt;link_older;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 将 newest_writer 指向 last_writer</span></span><br><span class="line">  Writer* newest = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    leader-&gt;link_older = newest; <span class="comment">// leader-&gt;next = newest</span></span><br><span class="line">    <span class="keyword">if</span> (newest_writer-&gt;<span class="built_in">compare_exchange_weak</span>(newest, last_writer)) &#123;</span><br><span class="line">      <span class="comment">// newest_writer = last_writer</span></span><br><span class="line">      <span class="keyword">return</span> (newest == <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>T1 在 <code>ExitAsBatchGroupLeader</code> 函数中已经选出 write_group1 的 leader-writer， 因此不会等待 write_group0 完成，T2 就会直接启动。重复write_group0 的 T1 流程。</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>write_group0 执行完 T1 任务后就进入 T3 阶段，准备并发写 MemTables 操作。这个阶段的写流程如下:</p><p>leader-memtable-writer 会通过 <code>EnterAsMemTableWriter</code> 获取 <code>memtable_write_group</code>，</p><ul><li><p>如果 memtable_write_group 的 writers 数量大于 1 则调用 <code>LaunchParallelMemTableWriters</code> 函数启动所有的 writers 进入 MemTable::Add 阶段。</p></li><li><p>否则，当前 leader-memtable-writer 就直接写 MemTable。</p><p>写 MemTable 的操作是由 <code>WriteBatchInternal::InsertInto</code> 函数完成。</p></li></ul><p>而 follower-memtable-writers 会一直阻塞等待在两个的地方:</p><ul><li>当前 write_group0 的 followers 会阻塞在 PipelineWriteImpl 函数开始的 JoinBatchGroup 处</li><li>其他 write_group1 的 followers 会阻塞在 ExitAsBatchGroupLeader 函数末尾的 AwaitState 处</li></ul><p>因此，当 leader-memtable-writer 调用 <code>LaunchParallelMemTableWriters</code> 函数，则会解除上述两处阻塞状态的 writers，进入 T3 阶段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">WriteThread::WriteGroup memtable_write_group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (w.state == WriteThread::STATE_MEMTABLE_WRITER_LEADER) &#123;</span><br><span class="line">  <span class="comment">// memtable-writer-leader reach here</span></span><br><span class="line">  write_thread_.<span class="built_in">EnterAsMemTableWriter</span>(&amp;w, &amp;memtable_write_group);</span><br><span class="line">  <span class="keyword">if</span> (memtable_write_group.size &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">      immutable_db_options_.allow_concurrent_memtable_write) &#123;</span><br><span class="line">    write_thread_.<span class="built_in">LaunchParallelMemTableWriters</span>(&amp;memtable_write_group);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    memtable_write_group.status = WriteBatchInternal::<span class="built_in">InsertInto</span>(</span><br><span class="line">        memtable_write_group, w.sequence, column_family_memtables_.<span class="built_in">get</span>(),</span><br><span class="line">        &amp;flush_scheduler_, &amp;trim_history_scheduler_,</span><br><span class="line">        write_options.ignore_missing_column_families, <span class="number">0</span> <span class="comment">/*log_number*/</span>, <span class="keyword">this</span>,</span><br><span class="line">        <span class="literal">false</span> <span class="comment">/*concurrent_memtable_writes*/</span>, seq_per_batch_, batch_per_txn_);</span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(memtable_write_group.last_sequence);</span><br><span class="line">    write_thread_.<span class="built_in">ExitAsMemTableWriter</span>(&amp;w, memtable_write_group);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// memtable-writer-follower reach here</span></span><br><span class="line">  memtable_write_group.status.<span class="built_in">PermitUncheckedError</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EnterAsMemTableWriter"><a href="#EnterAsMemTableWriter" class="headerlink" title="EnterAsMemTableWriter"></a>EnterAsMemTableWriter</h4><p><code>EnterAsMemTableWriter</code> 函数和 <code>EnterAsBatchGroupLeader</code> 工作逻辑类似，从 <code>newest_memtable_writer_</code> 中取出memtable-writers，组成一个由 <code>[leader, last_writer]</code> 组成的 memtable_write_group。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::EnterAsMemTableWriter</span><span class="params">(Writer* leader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        WriteGroup* write_group)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> size = WriteBatchInternal::<span class="built_in">ByteSize</span>(leader-&gt;batch);</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  leader-&gt;write_group = write_group;</span><br><span class="line">  write_group-&gt;leader = leader;</span><br><span class="line">  write_group-&gt;size = <span class="number">1</span>;</span><br><span class="line">  Writer* last_writer = leader;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (allow_concurrent_memtable_write_ &amp;&amp; !leader-&gt;batch-&gt;<span class="built_in">HasMerge</span>()) &#123;</span><br><span class="line">    Writer* newest_writer = newest_memtable_writer_.<span class="built_in">load</span>();</span><br><span class="line">    <span class="built_in">CreateMissingNewerLinks</span>(newest_writer);</span><br><span class="line"></span><br><span class="line">    Writer* w = leader;</span><br><span class="line">    <span class="keyword">while</span> (w != newest_writer) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(w-&gt;link_newer);</span><br><span class="line">      w = w-&gt;link_newer;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w-&gt;batch == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w-&gt;batch-&gt;<span class="built_in">HasMerge</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      w-&gt;write_group = write_group;</span><br><span class="line">      last_writer = w;</span><br><span class="line">      write_group-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write_group-&gt;last_writer = last_writer;</span><br><span class="line">  write_group-&gt;last_sequence =</span><br><span class="line">      last_writer-&gt;sequence + WriteBatchInternal::<span class="built_in">Count</span>(last_writer-&gt;batch) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LaunchParallelMemTableWriters"><a href="#LaunchParallelMemTableWriters" class="headerlink" title="LaunchParallelMemTableWriters"></a>LaunchParallelMemTableWriters</h4><p><code>LaunchParallelMemTableWriters</code> 函数即遍历 <code>memtable_write_group</code> 中所有的 writers，将其 w-&gt;state 设置为 <code>STATE_PARALLEL_MEMTABLE_WRITER</code> 来解除阻塞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::LaunchParallelMemTableWriters</span><span class="params">(WriteGroup* memtable_write_group)</span> </span>&#123;</span><br><span class="line">  memtable_write_group-&gt;running.<span class="built_in">store</span>(memtable_write_group-&gt;size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> w : *memtable_write_group) &#123;</span><br><span class="line">    <span class="built_in">SetState</span>(w, STATE_PARALLEL_MEMTABLE_WRITER);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompleteParallelMemTableWriter"><a href="#CompleteParallelMemTableWriter" class="headerlink" title="CompleteParallelMemTableWriter"></a>CompleteParallelMemTableWriter</h4><p>所有的 <code>w-&gt;state</code> 都在 LaunchParallelMemTableWriters 函数中被更改 <code>STATE_PARALLEL_MEMTABLE_WRITER</code>，此时已经没有主从 writers 的概念。</p><p>每个 writer 都并发地调用 WriteBatchInternal::InsertInto 函数向 MemTable 写数据。每个 writer 写完 MemTable，都会调用一次 CompleteParallelMemTableWriter 来检测自己是不是 memtable_write_group 中最后一个完成写 MemTable 的 writer。最后一个 memtable-writers 在 <code>ExitAsMemTableWriter</code> 函数中做善后工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.state == WriteThread::STATE_PARALLEL_MEMTABLE_WRITER) &#123;</span><br><span class="line">  <span class="function">ColumnFamilyMemTablesImpl <span class="title">column_family_memtables</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      versions_-&gt;GetColumnFamilySet())</span></span>;</span><br><span class="line">  w.status = WriteBatchInternal::<span class="built_in">InsertInto</span>(</span><br><span class="line">      &amp;w, w.sequence, &amp;column_family_memtables, &amp;flush_scheduler_,</span><br><span class="line">      &amp;trim_history_scheduler_, write_options.ignore_missing_column_families,</span><br><span class="line">      <span class="number">0</span> <span class="comment">/*log_number*/</span>, <span class="keyword">this</span>, <span class="literal">true</span> <span class="comment">/*concurrent_memtable_writes*/</span>,</span><br><span class="line">      <span class="literal">false</span> <span class="comment">/*seq_per_batch*/</span>, <span class="number">0</span> <span class="comment">/*batch_cnt*/</span>, <span class="literal">true</span> <span class="comment">/*batch_per_txn*/</span>,</span><br><span class="line">      write_options.memtable_insert_hint_per_batch);</span><br><span class="line">  <span class="keyword">if</span> (write_thread_.<span class="built_in">CompleteParallelMemTableWriter</span>(&amp;w)) &#123;</span><br><span class="line">    <span class="built_in">MemTableInsertStatusCheck</span>(w.status);</span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(w.write_group-&gt;last_sequence);</span><br><span class="line">    write_thread_.<span class="built_in">ExitAsMemTableWriter</span>(&amp;w, *w.write_group);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次 memtable-writer 写完 MemTable，都会进入 <code>CompleteParallelMemTableWriter</code> 将 <code>memtable_write_group-&gt;running</code> 减 1: 如果不是最后一个 memtable-writer，则阻塞等待最后一个 memtable-writer 完成后在 <code>ExitAsMemTableWriter</code> 函数中将所有的 writers 状态更改为 STATE_COMPLETED，则本次并发写 MemTable 操作结束。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteThread::CompleteParallelMemTableWriter</span><span class="params">(Writer* w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* write_group = w-&gt;write_group;</span><br><span class="line">  <span class="keyword">if</span> (!w-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(write_group-&gt;leader-&gt;StateMutex())</span></span>;</span><br><span class="line">    write_group-&gt;status = w-&gt;status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_group-&gt;running-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// we&#x27;re not the last one</span></span><br><span class="line">    <span class="built_in">AwaitState</span>(w, STATE_COMPLETED, &amp;cpmtw_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// else we&#x27;re the last parallel worker and should perform exit duties.</span></span><br><span class="line">  w-&gt;status = write_group-&gt;status;</span><br><span class="line">  <span class="comment">// Callers of this function must ensure w-&gt;status is checked.</span></span><br><span class="line">  write_group-&gt;status.<span class="built_in">PermitUncheckedError</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ExitAsMemTableWriter"><a href="#ExitAsMemTableWriter" class="headerlink" title="ExitAsMemTableWriter"></a>ExitAsMemTableWriter</h4><p><code>ExitAsMemTableWriter</code> 函数和 <code>ExitAsBatchGroupLeader</code> 函数类似，主要有两个作用：</p><ul><li><p>选出下一轮 memtable_write_group1 的的 leader-memtable-writer，将其 state 设置为 <code>STATE_MEMTABLE_WRITER_LEADER</code>，使下一轮 memtable_write_group1 能尽快进入 T3 阶段；</p></li><li><p>将本轮 memtable_write_group0 的所有 memtable-writers 的状态更改为 <code>STATE_COMPLETED</code>，解除阻塞在 <code>CompleteParallelMemTableWriter</code> 函数处阻塞的 writers，让他们释放资源返回应用层。</p><p>这里需要让 leader-memtable-writer 最后一个退出，因为它拥有 memtable_write_group 所有权：如果它不是最后一个释放，会造成 <code>ExitAsMemTableWriter</code> 函数在执行过程中 coredump。</p></li></ul><p>这部分代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::ExitAsMemTableWriter</span><span class="params">(Writer* <span class="comment">/*self*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       WriteGroup&amp; write_group)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. </span></span><br><span class="line">  Writer* newest_writer = last_writer;</span><br><span class="line">  <span class="keyword">if</span> (!newest_memtable_writer_.<span class="built_in">compare_exchange_strong</span>(newest_writer,</span><br><span class="line">                                                       <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="built_in">CreateMissingNewerLinks</span>(newest_writer);</span><br><span class="line">    Writer* next_leader = last_writer-&gt;link_newer;</span><br><span class="line">    <span class="built_in">assert</span>(next_leader != <span class="literal">nullptr</span>);</span><br><span class="line">    next_leader-&gt;link_older = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">SetState</span>(next_leader, STATE_MEMTABLE_WRITER_LEADER);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.</span></span><br><span class="line">  Writer* w = leader;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!write_group.status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      w-&gt;status = write_group.status;</span><br><span class="line">    &#125;</span><br><span class="line">    Writer* next = w-&gt;link_newer;</span><br><span class="line">    <span class="keyword">if</span> (w != leader) &#123;</span><br><span class="line">      <span class="built_in">SetState</span>(w, STATE_COMPLETED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (w == last_writer) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(next);</span><br><span class="line">    w = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//! Note that leader has to exit last, since it owns the write group.</span></span><br><span class="line">  <span class="built_in">SetState</span>(leader, STATE_COMPLETED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前面几篇讲解了从 WriteBatch 的内部序列化流程 和 WriteThread 如何控制并发写入的基本流程，本文进一步讲解 WriteThread 如何使用 PipelinedWrite 来提升写吞吐，其中和前文相似的逻辑不再细说。&lt;/p&gt;
&lt;p&gt;通过设置选项 &lt;c</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WriteThread 如何自适应优化线程同步</title>
    <link href="https://szza.github.io/2022/02/02/rocksdb/WritePath/write_thread_3/"/>
    <id>https://szza.github.io/2022/02/02/rocksdb/WritePath/write_thread_3/</id>
    <published>2022-02-02T06:15:35.000Z</published>
    <updated>2023-08-07T09:26:04.729Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>ROCKSDB_NAMESPACE::WriteThread</code> 中，通过 <a href="https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d2b39/db/write_thread.cc#L64">WriteThread::AwaitState</a> 和 <a href="https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d2b39/db/write_thread.cc#L212">WriteThread::SetState</a> 两个函数来 writers 的控制并发写入行为。 这一期主要来分析 RocksDB 中 WriteThread::AwaitState 中的优化，是如何尽可能地缩短阻塞等待时间。</p><h2 id="WriteThread-AwaitState"><a href="#WriteThread-AwaitState" class="headerlink" title="WriteThread::AwaitState"></a>WriteThread::AwaitState</h2><p><code>AwaitState</code> 函数用于阻塞等待直到满足 <code>w-&gt;state &amp; goal_mask != 0</code> 这一条件。如 <a href="https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d2b39/db/write_thread.cc#L401">JoinBatchGroup</a> 函数中新插入的 w 需要阻塞等待 <code>w-&gt;state</code> 变成 <code>goal_mask</code> 中的一种才能继续执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::JoinBatchGroup</span><span class="params">(Writer* w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... above code</span></span><br><span class="line">    <span class="keyword">if</span> (!linked_as_leader) &#123; </span><br><span class="line">        <span class="built_in">AwaitState</span>(</span><br><span class="line">            w,</span><br><span class="line">            <span class="comment">// goal_mask</span></span><br><span class="line">            STATE_GROUP_LEADER | </span><br><span class="line">            STATE_MEMTABLE_WRITER_LEADER |</span><br><span class="line">            STATE_PARALLEL_MEMTABLE_WRITER | </span><br><span class="line">            STATE_COMPLETED,</span><br><span class="line">            &amp;jbg_ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RocksDB 为尽可能降低阻塞时间，将等待情况分为三种:</p><ul><li><em>short-uncontended</em>: 几乎无竞争，直接使用 <code>spin-wait loop</code> 就能解决；</li><li><em>short-contended</em>: 存在竞争，但是预测阻塞时间不会太久，使用 <code>loop + yield</code> 应对</li><li><em>long</em>: 竞争激烈，使用 <code>mutex + condition_variable</code> 应对。</li></ul><p>如果开启了上帝视角，即事先知道本次 <em>AwaitState</em> 要等待的时间，就可以直接使用 <code>spin-wait loop</code>  来应对 short-uncontended, <code>mutex</code> 来应对 long。显然没有这样的上帝视角，那么就只能通过一种自适应的方式来判断了。</p><h3 id="pause-based-spin-wait-loop"><a href="#pause-based-spin-wait-loop" class="headerlink" title="pause-based spin-wait loop"></a><a href="https://stackoverflow.com/questions/12894078/what-is-the-purpose-of-the-pause-instruction-in-x86">pause-based spin-wait loop</a></h3><p><code>spin-wait loop</code> 是应对阻塞时间很短 (short-periods) 场景的常用方式，即占据着 CPU 做空转阻塞等待 <code>w-&gt;state</code> 变成预期值，这样可以减少线程上下文切换（context switch）带来的开销。如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="type">uint8_t</span> state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquired);</span><br><span class="line">    <span class="keyword">if</span> (state &amp; goal_mask != <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这么简单的写法却有问题，一般都会在 spin-wait loop 中加上一条 “<em>Pause</em>“ 指令来提升性能。在 <a href="https://www.felixcloutier.com/x86/pause">Pause</a> 指令中有这么一段描述：</p><blockquote><p>When executing a ‘spin-wait loop’, processors will suffer a severe performance penalty when exiting the loop because it detects a <code>possible memory order violation</code></p></blockquote><p>意思就是说，如果 spin-wait loop 里如果不加上 <em>Pause</em> 指令，则很可能因为 memory order violation 问题导致退出 loop 时遭受严重的性能惩罚</p><h4 id="memory-order-violation"><a href="#memory-order-violation" class="headerlink" title="memory order violation"></a>memory order violation</h4><p>如下从 <a href="https://cdrdv2-public.intel.com/671488/248966-Software-Optimization-Manual-R047.pdf">Intel 64 and IA-32 Architectures Optimization Reference Manual</a> 中选取的示例代码，来解释为什么退出loop时会带来性能惩罚。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Spin_Lock:</span><br><span class="line">    CMP lockvar, <span class="number">0</span>;       <span class="comment">// (1) Check if lock is free.</span></span><br><span class="line">    JE Get_Lock;          <span class="comment">// (1.1) lockvar == 0</span></span><br><span class="line">    JMP Spin_Lock;        <span class="comment">// (1.2) lockvar != 0</span></span><br><span class="line">Get_Lock:</span><br><span class="line">    MOV EAX, <span class="number">1</span>;</span><br><span class="line">    XCHG EAX, lockvar;    <span class="comment">// (2) Try to get lock</span></span><br><span class="line">    CMP EAX, <span class="number">0</span>;           <span class="comment">// (3) Test if successful.</span></span><br><span class="line">    JNE Spin_Lock;</span><br><span class="line">Critical_Section:</span><br><span class="line">    <span class="comment">// critical section cod&gt;</span></span><br><span class="line">    MOV lockvar, <span class="number">0</span>;      <span class="comment">// (4) Release lock</span></span><br></pre></td></tr></table></figure><p>当线程 T1 spin-wait loop 几轮迭代后，条件分支(1)处一直都是 false，即 <code>lockvar</code> 一直不是 0。这种情况下，CPU 的分支预测器会认为条件(1) 永远不会为 true，就会将 JMP(1.2) 的指令填充整个 pipeline。</p><p>当线程 T2 将 <code>lockvar</code>  写为 0 时，由于此时 T1 的 <em>pipeline</em> 已经被错误的预测指令 (1.2) 填充满，即(1) 处的 <code>lockvar</code>  已经预测为0。这时 <em>memory order violation</em> 就会发生了：T1 线程看到 T2 线程对 <code>lockvar</code>  的修改后，就会在 T1 的 pipeline 中搜索访问了 <code>lockvar</code>  变量且还没执行的预测指令（1.2），如果发现了则会使得这部分预测指令失效，并且 flush pipeline 来删除这部分预测指令。获取锁后，就会退出 spin-wait loop。</p><p>在退出时 flush pipeline 的代价会很高。</p><p>因此，每次进入 spin-wait loop ，就会在满足条件退出 spin-wait loop 时带来严重的性能惩罚，比预期的同步时间要久。</p><p>加上 <em>PAUSE</em> 指令，是通过引入轻微的延迟来 <code>de-pipelined</code>，使得 pipeline 中不会填充错误的预测指令: 插入 PAUSE 指令后，会等待 PAUSE 之前的 pipeline 执行完变空，然后再执行下一轮 CMP，如果 T2 线程将 lockvar 的值为 0，则 T1 能立即检测到。因此现在 CMP 指令就是顺序执行，消除了预测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spin_Lock:</span><br><span class="line">    CMP lockvar, <span class="number">0</span>;       <span class="comment">// (1) Check if lock is free.</span></span><br><span class="line">    JE Get_Lock</span><br><span class="line">        PAUSE;            <span class="comment">// (2) short a delay, wait for memory pipeline to become empty</span></span><br><span class="line">    JMP Spin_Lock;</span><br><span class="line">Get_Lock:</span><br></pre></td></tr></table></figure><p>从使用角度来说，”PAUSE” 指令<em>甚至是专门</em>用于优化 spin-wait loop 的，需要搭配使用。</p><p>而 RocksDB 进入 <em>AwaitState</em> 后率先使用 <code>spin-wait loop</code> 迭代两百次(大约 1us)来尝试满足 short-uncontended 场景。原生代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">AwaitState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> goal_mask, AdaptationContext* ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> tries = <span class="number">0</span>; tries &lt; <span class="number">200</span>; ++tries) &#123;</span><br><span class="line">        state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span> ((state &amp; goal_mask) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line">        port::<span class="built_in">AsmVolatilePause</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">由于 <span class="string">&quot;PAUSE&quot;</span> 指令随着架构的变化，latency 也会更改，甚至差一个数量级，故而这里如果想要更准确的控制 wait 的时间可以使用 `__rdtsc()` 函数来控制:</span><br><span class="line">```cpp</span><br><span class="line">    <span class="comment">// __rdtsc intrinsic is used to read the time stamp counter</span></span><br><span class="line">    <span class="comment">// This allows the loop to run for a fixed number of cycles</span></span><br><span class="line">    <span class="type">uint64_t</span> prev = __rdtsc();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span> ((state &amp; goal_mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line">        port::<span class="built_in">AsmVolatilePause</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (__rdtsc() - prev &lt; max_spin_time);</span><br></pre></td></tr></table></figure><h3 id="std-this-thread-yield"><a href="#std-this-thread-yield" class="headerlink" title="std::this_thread::yield"></a>std::this_thread::yield</h3><p>如果第一阶段的 spin-wait loop 没能等到 <code>w-&gt;state</code> 的值变更为预期值，说明还是存在竞争，则进入第二阶段 <code>short-contended</code>。 这一阶段由 <code>DBOptions::enable_write_thread_adaptive_yield</code> 配置是否开启，默认值为 true。</p><p>这一段有两个问题:</p><ul><li>如何从 <code>short-contended</code> 阶段进入 <code>long</code> 阶段</li><li>如何判断下一次是否需要再进入 <code>short-contended</code> 阶段</li></ul><p>当进入 <code>short-contended</code> 阶段说明存在竞争，<em>但是假设竞争可能不大</em>。比如线程数可能不超过 CPU cores 数目，这种情况下使用 <code>std::thread::yield()</code> 并不会导致 cotext switch，效果比 pthread_mutex 要好。</p><blockquote><p>注意：从 RocksDB 开发者角度，没有上帝视角，只能先假设没有竞争（short-uncontended），不满足则再假设存在竞争但是不激烈（<code>short-contended</code>），如果还没不满足再考虑mutex阻塞。</p></blockquote><p>因此，需要对调用 <code>std::thread::yield()</code> 前后的 latency 进行统计，粗略判断竞争激烈程度：</p><ul><li><p><code>max_yield_usec_</code>: 默认 100us，控制 <code>short-contended</code> 阶段最大等待时间</p></li><li><p><code>slow_yield_usec_</code>: 默认 3us, 是 <code>yield</code> 的 latency 上限，用来反应是否有其他线程也想占据当前 cpu core</p><p>如果当前竞争比较激烈，那么调用 <code>std::thread::yield()</code> 前后的 latency 肯定会增加，(比如 threads &gt; cpu-cores 时，甚至会产生 context switch），最终导致 latency &gt; <code>slow_yield_usec_</code>。如果累计 <code>kMaxSlowYieldsWhileSpinning = 3</code> 次都超过该值，则可以跳出 <code>short-contended</code> 阶段，直接进入 <code>long</code> 阶段，阻塞等待。</p></li></ul><p>开启第二阶段的开关有3个，这一部分代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> would_spin_again = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> update_ctx = <span class="literal">false</span>;</span><br><span class="line"><span class="type">uint64_t</span> sampling_base = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">if</span> (max_yield_usec_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  update_ctx = Random::<span class="built_in">GetTLSInstance</span>()-&gt;<span class="built_in">OneIn</span>(sampling_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (update_ctx || yield_credit.<span class="built_in">load</span>(std::memory_order_relaxed) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// short-contended code...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>max_yield_usec_ &gt; 0</code>: 默认情况下总是开启</p></li><li><p><code>update_ctx</code>: 表示是否更新 <code>yield_credit</code> 的值。当且仅当基于均匀分布从 <em>[0, 255]</em> 区间获得 0 时值为 true，即 <code>Random::OneIn(sampling_base)</code> 返回 true 的概率为 <em>1&#x2F;256</em></p><p>  <em>would_spin_again</em> 表示 <code>w-&gt;state</code> 是否在第二阶段等到预期值，如果成功则 <code>yield_credit</code> 值增加，反之降低。<code>yield_credit</code> 的更新公式如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (update_ctx) &#123;</span><br><span class="line">   <span class="keyword">auto</span> v = yield_credit.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">   v = v - (v / <span class="number">1024</span>) + (would_spin_again ? <span class="number">1</span> : <span class="number">-1</span>) * <span class="number">131072</span>;</span><br><span class="line">   yield_credit.<span class="built_in">store</span>(v, std::memory_order_relaxed);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>yield_credit</code>: 默认值为 0，在是否开启第二阶段中起着决定性作用。基本上需要满足 <code>yield_credit &gt;= 0</code> 才能进入第二阶段</p><p>  <em>yield_credit</em> 值在两种情况下会更改，也是<strong>自适应</strong>原理：</p><p>  1）进入了第二阶段，但是因为竞争太激烈，没有在第二阶段实现 <code>w-&gt;state &amp; goal_mask != 0</code>，此时会将 update_ctx &#x3D; true，再由上述公式降低 <em>yield_credit</em> 的值，使其小于 0，这样 AwaitState 函数下次不会再进入第二阶段；</p><ol start="2"><li>如果长时间 <code>yield_credit &lt; 0</code> 会一直无法进入第二阶段。但是由均匀分布可知，存在 1&#x2F;256 的概率将 update_ctx &#x3D; true，进入第二阶段，来<em>试探</em>现在竞争是否没那么激烈了。如果此时在第二阶段等到了 <code>w-&gt;state &amp; goal_mask != 0</code> ，那么就会再根据上述公式将 <code>yield_credit</code> 调节为非负数，使得下一次 AwaitState 函数仍能进入第二阶段。</li></ol></li></ul><p>这里的 <code>yield_credit</code> 值记录在 <code>AdaptationContext::value</code> 中，<code>AdaptationContext</code> 的所有对象在 <code>WriteThread</code> 中都是 static 变量，因此会一直反应着进程生命周期中线程竞争状态，故而上述的 <code>update_ctx</code> 中的 <code>ctx</code> 即 <code>yield_credit</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AdaptationContext</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">  std::atomic&lt;<span class="type">int32_t</span>&gt; value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AdaptationContext</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name0)</span> : name(name0), value(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的介绍大致介绍了 <code>short-contended</code> 阶段的自适应原理，下面来看看核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; yield_credit = ctx-&gt;value;</span><br><span class="line"><span class="type">bool</span> update_ctx = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> would_spin_again = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (update_ctx || yield_credit.<span class="built_in">load</span>(std::memory_order_relaxed) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">auto</span> spin_begin = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超过 slow_yield_usec_ 的次数</span></span><br><span class="line">  <span class="type">size_t</span> slow_yield_count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> iter_begin = spin_begin;</span><br><span class="line">  <span class="comment">// 最多消耗的时间片: max_yield_usec_</span></span><br><span class="line">  <span class="keyword">while</span> (iter_begin - spin_begin) &lt;= </span><br><span class="line">            std::chrono::<span class="built_in">microseconds</span>(max_yield_usec_) &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line">    state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> ((state &amp; goal_mask) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 1. 成功，则退出第二阶段</span></span><br><span class="line">      would_spin_again = <span class="literal">true</span>; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 2. latency 超过 slow_yield_usec_</span></span><br><span class="line">    <span class="keyword">if</span> (now == iter_begin ||</span><br><span class="line">        now - iter_begin &gt;= std::chrono::<span class="built_in">microseconds</span>(slow_yield_usec_)) &#123;</span><br><span class="line">      ++slow_yield_count;</span><br><span class="line">      <span class="comment">// 2.1 累计超过 kMaxSlowYieldsWhileSpinning 次则退出第二阶段，</span></span><br><span class="line">      <span class="comment">//     并设置 update_ctx =true，后续更新 yield_credit</span></span><br><span class="line">      <span class="keyword">if</span> (slow_yield_count &gt;= kMaxSlowYieldsWhileSpinning) &#123;</span><br><span class="line">        update_ctx = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iter_begin = now;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BlockingAwaitState"><a href="#BlockingAwaitState" class="headerlink" title="BlockingAwaitState"></a>BlockingAwaitState</h3><p>如果不幸，<code>w-&gt;state</code> 的值仍然没有变更为预期值，则需要进入第三阶段：使用 Mutex + ConditionVarable 进行阻塞等待。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((state &amp; goal_mask) == <span class="number">0</span>) &#123;</span><br><span class="line">  state = <span class="built_in">BlockingAwaitState</span>(w, goal_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlockingAwaitState</code> 函数比较简单：先再次判断 <code>w-&gt;state</code> 是否变更为预期值 <code>goal_mask</code>； 没有，则将 w-&gt;state 设置为 <code>STATE_LOCKED_WAITING</code> 状态，等待唤醒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">WriteThread::BlockingAwaitState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> goal_mask)</span> </span>&#123;</span><br><span class="line">  w-&gt;<span class="built_in">CreateMutex</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="built_in">assert</span>(state != STATE_LOCKED_WAITING);</span><br><span class="line">  <span class="keyword">if</span> ((state &amp; goal_mask) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      w-&gt;state.<span class="built_in">compare_exchange_strong</span>(state, STATE_LOCKED_WAITING)) &#123;</span><br><span class="line">    <span class="comment">// we have permission (and an obligation) to use StateMutex</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(w-&gt;StateMutex())</span></span>;</span><br><span class="line">    w-&gt;<span class="built_in">StateCV</span>().<span class="built_in">wait</span>(guard, [w] &#123;</span><br><span class="line">      <span class="keyword">return</span> w-&gt;state.<span class="built_in">load</span>(std::memory_order_relaxed) != STATE_LOCKED_WAITING;</span><br><span class="line">    &#125;);</span><br><span class="line">    state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// else tricky.  Goal is met or CAS failed.  In the latter case the waker</span></span><br><span class="line">  <span class="comment">// must have changed the state, and compare_exchange_strong has updated</span></span><br><span class="line">  <span class="comment">// our local variable with the new one.  At the moment WriteThread never</span></span><br><span class="line">  <span class="comment">// waits for a transition across intermediate states, so we know that</span></span><br><span class="line">  <span class="comment">// since a state change has occurred the goal must have been met</span></span><br><span class="line">  <span class="built_in">assert</span>((state &amp; goal_mask) != <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WriteThread-SetState"><a href="#WriteThread-SetState" class="headerlink" title="WriteThread::SetState"></a>WriteThread::SetState</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::SetState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> new_state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(w);</span><br><span class="line">  <span class="keyword">auto</span> state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span> (state == STATE_LOCKED_WAITING ||</span><br><span class="line">      !w-&gt;state.<span class="built_in">compare_exchange_strong</span>(state, new_state)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(state == STATE_LOCKED_WAITING);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(w-&gt;StateMutex())</span></span>;</span><br><span class="line">    <span class="built_in">assert</span>(w-&gt;state.<span class="built_in">load</span>(std::memory_order_relaxed) != new_state);</span><br><span class="line">    w-&gt;state.<span class="built_in">store</span>(new_state, std::memory_order_relaxed);</span><br><span class="line">    w-&gt;<span class="built_in">StateCV</span>().<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;code&gt;ROCKSDB_NAMESPACE::WriteThread&lt;/code&gt; 中，通过 &lt;a href=&quot;https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WriteThread 如何控制并发写入流程</title>
    <link href="https://szza.github.io/2022/01/15/rocksdb/WritePath/write_thread_2/"/>
    <id>https://szza.github.io/2022/01/15/rocksdb/WritePath/write_thread_2/</id>
    <published>2022-01-15T06:15:35.000Z</published>
    <updated>2023-08-07T09:26:04.729Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>建议先阅读上一篇文章 <a href="https://szza.github.io/2022/01/10/rocksdb/WritePath/write_thread_1/">WriteBatch 写入前的准备工作</a> 了解一些基本概念</p></blockquote><p>本篇博客讲解批量写流程的控制流程，了解这个流程之后再来讲解 <em>PipelineWriteImpl</em> 中优化。</p><p>整个写入流程大致如下：<br><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_write_thread_2_1.png?raw=true" alt="write_path_2_1"></p><h3 id="WriteThread-JoinBatchGroup"><a href="#WriteThread-JoinBatchGroup" class="headerlink" title="WriteThread::JoinBatchGroup"></a>WriteThread::JoinBatchGroup</h3><p><code>JoinBatchGroup</code> 函数充当着锁的作用：能成为 leader 的 writer 才能真正执行 <code>WriteToWAL</code> 和 <code>MemTable::Add</code> 操作，其他 writers 只能阻塞等待 leader-writer 完成。</p><p>在 <code>WriteThread</code> 中有个 <code>newest_writer_</code> 字段总是指向最新插入的 <code>Writer</code> 对象：</p><ol><li>如果新插入一个 <code>Writer</code> 对象 w，则会尝试让 <code>newest_writer_</code> 指向该 w 。如果当前触发了 <em>WriteStall</em> 则会等待 <code>WriteStall</code> 被解除，才会再次尝试让 <code>newest_writer_</code> 指向该 w</li><li>如果 w 插入时，<code>newest_writer_ == NULL</code> ，则 w 能顺利通过 <code>JoinBatchGroup</code> 函数，进入后续写入流程</li><li>否则，说明当前已经存在 leader-writer，则只能阻塞等待 <code>w-&gt;state</code> 更改为下面其中一种才能解除阻塞:<ul><li><code>STATE_GROUP_LEADER</code>: 变成下一个 write_group 的 leader，执行写入</li><li><code>STATE_COMPLETED</code>: 说明已经存在一个 leader-writer 替自己完成了写入，解除阻塞后就可以直接返回应用层</li><li><code>STATE_MEMTABLE_WRITER_LEADER</code>: …</li><li><code>STATE_PARALLEL_MEMTABLE_WRITER</code>: …</li></ul></li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::JoinBatchGroup</span><span class="params">(Writer* w)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(w-&gt;batch != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 1. 让 nnewest_writer_ 指向 w</span></span><br><span class="line">  <span class="type">bool</span> linked_as_leader = <span class="built_in">LinkOne</span>(w, &amp;newest_writer_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (linked_as_leader) &#123;</span><br><span class="line">    <span class="built_in">SetState</span>(w, STATE_GROUP_LEADER);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!linked_as_leader) &#123;</span><br><span class="line">     <span class="comment">// 2. 阻塞等待 w-&gt;state &amp; mask != 0</span></span><br><span class="line">    <span class="built_in">AwaitState</span>(w,</span><br><span class="line">               STATE_GROUP_LEADER | STATE_MEMTABLE_WRITER_LEADER |</span><br><span class="line">                   STATE_PARALLEL_MEMTABLE_WRITER | STATE_COMPLETED,</span><br><span class="line">               &amp;jbg_ctx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteThread-LinkOne"><a href="#WriteThread-LinkOne" class="headerlink" title="WriteThread::LinkOne"></a>WriteThread::LinkOne</h3><p><code>LinkOne</code>的功能其实就是在链表头发插入一个节点，不过需要先检查一个前提 <em>WriteStall</em>。</p><h4 id="WriteStall"><a href="#WriteStall" class="headerlink" title="WriteStall"></a>WriteStall</h4><p>如果写操作触发了 <em>WriteStall</em> ，会向 WriterThread 中写入一个 <code>write_stall_dummy_</code> 标志。因此在尝试将 <code>newest_writer_</code> 指向新加入的 <code>w</code> 时都需要先检查下 <code>newest_writer_</code> 是否等于 <code>write_stall_dummy_</code>。如果等于，有以下两种情况：</p><ul><li><p><code>Writer::no_slowdown == false</code>，这是默认情况，即基于条件变量 <code>stall_cv_</code> 阻塞等待 <em>WriteStall</em> 解除。解除后则需要重新读取 <code>newest_writer_</code></p><p>条件变量一般配合 while 一起使用，防止虚假唤醒，因此 <code>stall_cv_</code> 被唤醒后会 <em>continue</em> 并进行下一轮 while 循环，确认 <code>newest_writer_</code> 不是 <code>write_stall_dummy_</code> 才能继续下一步。</p></li><li><p><code>Writer::no_slowdown == true</code>，此时将错误 <code>Status::Incomplete</code> 返回给上层应用，让其自行决定如何处理 <code>WriteStall</code>，这就类似网络编程的非阻塞行为。</p></li></ul><h4 id="compare-exchange-weak"><a href="#compare-exchange-weak" class="headerlink" title="compare_exchange_weak"></a>compare_exchange_weak</h4><p>当没有 <em>WriteStall</em> 或者有已经解除，则可以继续写入，将 <code>w-&gt;link_older = writers</code>。这里的 <code>link_older</code> 的语义其实就是 <code>next</code> 指针，效果即 <code>w-&gt;next = writers</code>。</p><p>完成这一步后 <font color="red"> 却并没有执行 writers-&gt;prev &#x3D; w 操作</font>，为什么呢？这是为了在 leader-writer 写流程结束时能通过 <code>link_newer/prev</code> 是否为 NULL 选出下一轮的 leader-writer，详见后文的 <code>ExitAsBatchGroupLeader</code> 函数。</p><p>再通过 <code>compare_exchange_weak</code> 操作将 <code>newest_writer_</code> 指向最新插入的 w，</p><ul><li><p>成功，则通过判断 <code>writers</code> 是否为 NULL，来判断 w 是不是下一轮 writer_group 的 leader-writer </p><p>这是因为上一个 write_group 完成后就会尝试将 <code>newest_writer_</code> 设置为 NULL，只需要通过判断 <code>writers ==  NULL</code> 就可以确定新插入的 w 是不是下一轮 write_group 的 leader。</p></li><li><p>失败，则说明有个并发 <code>w0</code> 在自己之前完成了 <code>compare_exchange_weak</code> 操作，则自己会在下一轮 while 循环中完成此操作，使得 <code>newest_writer_</code> 指向 w，并形成 <code>w-&gt;next = w0</code> 连接。</p></li></ul><p>每次有新的 w，都只是改变 <code>newest_writer_</code>，并通过 <code>link_older/next</code> 指针把所有插入的 writers 串联起来，<em>且不重不漏</em>。由于每次只有 leader-writer 具有写权限，再让 leader-writer 在将所有的 writers 打包成一个 writer_group 时，给缺失的 <code>link_newer/prev</code> 指针赋值，就完成了双链表创建。由于此时实际上已经是单线程操作，因此不需要借助任何同步措施也没有并发的风险。</p><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteThread::LinkOne</span><span class="params">(Writer* w, std::atomic&lt;Writer*&gt;* newest_writer)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(newest_writer != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(w-&gt;state == STATE_INIT);</span><br><span class="line">  Writer* writers = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(writers != w);</span><br><span class="line">    <span class="keyword">if</span> (writers == &amp;write_stall_dummy_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (w-&gt;no_slowdown) &#123;</span><br><span class="line">        w-&gt;status = Status::<span class="built_in">Incomplete</span>(<span class="string">&quot;Write stall&quot;</span>);</span><br><span class="line">        <span class="built_in">SetState</span>(w, STATE_COMPLETED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function">MutexLock <span class="title">lock</span><span class="params">(&amp;stall_mu_)</span></span>;</span><br><span class="line">        writers = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (writers == &amp;write_stall_dummy_) &#123;</span><br><span class="line">          stall_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">          <span class="comment">// Load newest_writers_ again since it may have changed</span></span><br><span class="line">          writers = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    w-&gt;link_older = writers;</span><br><span class="line">    <span class="keyword">if</span> (newest_writer-&gt;<span class="built_in">compare_exchange_weak</span>(writers, w)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (writers == <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteThread-AwaitState"><a href="#WriteThread-AwaitState" class="headerlink" title="WriteThread::AwaitState"></a>WriteThread::AwaitState</h4><p><code>WriteThread::AwaitState</code> 中的优化点较多，下一期单独开一篇讲解这里的优化。这个函数的作用是阻塞等待直到满足 <code>w-&gt;state &amp; goal_mask != 0</code>。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">AwaitState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> goal_mask, AdaptationContext* ctx)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="WriteThread-CreateMissingNewerLinks"><a href="#WriteThread-CreateMissingNewerLinks" class="headerlink" title="WriteThread::CreateMissingNewerLinks"></a>WriteThread::CreateMissingNewerLinks</h4><p>缺失的 <code>prev</code> 指针由 <code>CreateMissingNewerLinks</code> 函数补全。</p><p>传入的 <code>head</code> 即 <code>newest_writer_</code> 的值，目前所有待执行的 writers 已经通过 next 指针串联起来了，这里要做的就是将其 prev 指针补全。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::CreateMissingNewerLinks</span><span class="params">(Writer* head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Writer* next = head-&gt;link_older;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">nullptr</span> || next-&gt;link_newer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(next == <span class="literal">nullptr</span> || next-&gt;link_newer == head);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next-&gt;link_newer = head; <span class="comment">// next-&gt;prev = head;</span></span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteThread-EnterAsBatchGroupLeader"><a href="#WriteThread-EnterAsBatchGroupLeader" class="headerlink" title="WriteThread::EnterAsBatchGroupLeader"></a>WriteThread::EnterAsBatchGroupLeader</h3><p>writer 没有阻塞在 <code>WriteThread::JoinBatchGroup</code> 函数，则说明 <code>writer</code> 目前已经成为 leader-writer，则需要由 leader-writer 尝试将目前所有待执行的 writers 封装到一个 write_group 中，这个由 <code>EnterAsBatchGroupLeader</code> 函数完成。</p><p>执行到 <code>EnterAsBatchGroupLeader</code> 函数时，<code>newest_writer_</code> 可能一直在更改，即不断指向最新的 writer。但是没关系，因为此时 leader-writer 已经诞生了，更新的 writer 在执行 <code>WriteThread::JoinBatchGroup</code> 时候会被阻塞在 <code>AwaitState</code>，如果此时 leader-writer 刚好执行到 <code>EnterAsBatchGroupLeader</code> 函数，则会由 leader-writer 将 <em>[leader-writer, newest_writer]</em> 区间的所有 writers 封装到 writer_group 中，由 leader-writer 来统一执行批量写入。其中 <code>write_group-&gt;last_writer</code> 指向的就是当前最新的 newest_writer。</p><p>在上一篇文章，讲解了 <code>WriteGroup</code> 内部封装了迭代器，那么就可以使用如下方式并以 <code>leader_writer -&gt; newst_writer</code> 顺序遍历所有 writers。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> writer : *writer_group) &#123;</span><br><span class="line">  <span class="comment">// 批量写入 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如下4步：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">WriteThread::EnterAsBatchGroupLeader</span><span class="params">(Writer* leader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            WriteGroup* write_group)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;batch != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(write_group != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> size = WriteBatchInternal::<span class="built_in">ByteSize</span>(leader-&gt;batch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. write_group 大小限制</span></span><br><span class="line">  <span class="type">size_t</span> max_size = max_write_batch_group_size_bytes;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> min_batch_size_bytes = max_write_batch_group_size_bytes / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= min_batch_size_bytes) &#123;</span><br><span class="line">    max_size = size + min_batch_size_bytes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 初始化 write_group</span></span><br><span class="line">  leader-&gt;write_group = write_group;</span><br><span class="line">  write_group-&gt;leader = leader;</span><br><span class="line">  write_group-&gt;last_writer = leader;</span><br><span class="line">  write_group-&gt;size = <span class="number">1</span>;</span><br><span class="line">  Writer* newest_writer = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 补全 [leader-writer, newest_writer] 丢失的 prev 指针</span></span><br><span class="line">  <span class="built_in">CreateMissingNewerLinks</span>(newest_writer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 封装到 write_group</span></span><br><span class="line">  Writer* w = leader;</span><br><span class="line">  <span class="keyword">while</span> (w != newest_writer) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(w-&gt;link_newer);</span><br><span class="line">    w = w-&gt;link_newer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other break conditions</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size + WriteBatchInternal::<span class="built_in">ByteSize</span>(w-&gt;batch) &gt; max_size) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w-&gt;write_group = write_group; <span class="comment">// 设置 w 属于当前 write_group</span></span><br><span class="line">    size += batch_size;           <span class="comment">// 这个 write_group 的数据量大小</span></span><br><span class="line">    write_group-&gt;last_writer = w; <span class="comment">// 更新 last_writer</span></span><br><span class="line">    write_group-&gt;size++;          <span class="comment">// writer_group 中 writers 的个数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteThread-ExitAsBatchGroupLeader"><a href="#WriteThread-ExitAsBatchGroupLeader" class="headerlink" title="WriteThread::ExitAsBatchGroupLeader"></a>WriteThread::ExitAsBatchGroupLeader</h3><p>这里暂时不关注 <em>enable_pipelined_write_</em>, 这是开启 <em>PipelineWriteImpl</em> 的标志位。</p><p>当数据都已经写入 WAL 和 MemTable，则会调用 <code>ExitAsBatchGroupLeader</code>，此时需要判断在当前 write_group 写入过程中是否出现了新的 writers：</p><ul><li>是：则需要从等待的 writers 中挑选出<em>新的</em> leader-writer</li><li>否：则需要将 <code>newest_writer_</code> 赋值为 NULL</li></ul><p>需要先读取 <code>newest_writer_</code> 的最新值 <em>head</em>，来判断是否有新的 <code>writer</code> 插入: </p><ul><li><p>如果 <code>head != last_writer</code> 则说明在当前 write_group 写操作过程中有出现新的 writers ，并阻塞等待在 <code>JoinBatchGroup</code></p></li><li><p>如果 <code>head == last_writer</code> 但是 <code>newest_writer_.compare_exchange_strong(head, nullptr)</code> 为 false，则说明在 <code>newest_writer_</code> load <em>之后</em>并在 <code>compare_exchange_strong</code> <em>之前</em> 有新的 writers 出现</p><p>上述两种情况，都需要将 <em>[<code>last_writer</code>, <code>head</code>]</em> 区间所有 writers 缺失的 prev 指针补全，因为补全后 <code>last_writer-&gt;prev</code> 指向的就是新的 leader-writer。</p><p>这是因为 <code>last_writer-&gt;prev</code> 是在 last_writer 之后最早插入的 writer，为保持顺序性，这就是新的 leader-writer。</p></li></ul><p>完成上述操作，剩下的就是将当前 write_group 中的所有 writers 状态更改为 <em>STATE_COMPLETED</em> 解除他们在 <code>JoinBatchGroup</code> 处的阻塞，尽快返回应用层。这一步也有个小细节，见代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::ExitAsBatchGroupLeader</span><span class="params">(WriteGroup&amp; write_group,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Status&amp; status)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enable_pipelined_write_) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Writer* head = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (head != last_writer ||</span><br><span class="line">        !newest_writer_.<span class="built_in">compare_exchange_strong</span>(head, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      <span class="comment">// 存在新插入的 writer</span></span><br><span class="line">      <span class="built_in">assert</span>(head != last_writer);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1. 补全 [last_writer, head] 的 prev指针</span></span><br><span class="line">      <span class="built_in">CreateMissingNewerLinks</span>(head);</span><br><span class="line">      <span class="built_in">assert</span>(last_writer-&gt;link_newer != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="built_in">assert</span>(last_writer-&gt;link_newer-&gt;link_older == last_writer);</span><br><span class="line">      <span class="comment">// 2. 断开链表</span></span><br><span class="line">      last_writer-&gt;link_newer-&gt;link_older = <span class="literal">nullptr</span>; </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 设置新的 leader-writer</span></span><br><span class="line">      <span class="built_in">SetState</span>(last_writer-&gt;link_newer, STATE_GROUP_LEADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 将 [leader, last_writer] 区间的 writers 状态设置为 STATE_COMPLETED</span></span><br><span class="line">    <span class="comment">//    即解除阻塞，让 follower-writer 返回应用层</span></span><br><span class="line">    <span class="keyword">while</span> (last_writer != leader) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(last_writer);</span><br><span class="line">      last_writer-&gt;status = status;</span><br><span class="line">      <span class="comment">// 需要先获取 next指针，再更改状态为 STATE_COMPLETED</span></span><br><span class="line">      <span class="comment">// 因为先更改 STATE_COMPLETED 很可能导致 last_writer 就被正在阻塞的线程销毁了</span></span><br><span class="line">      <span class="comment">// 再获取 next 指针就会触发 coredump</span></span><br><span class="line">      <span class="keyword">auto</span> next = last_writer-&gt;link_older;</span><br><span class="line">      <span class="built_in">SetState</span>(last_writer, STATE_COMPLETED); <span class="comment">// 解除阻塞</span></span><br><span class="line"></span><br><span class="line">      last_writer = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="By-the-Way"><a href="#By-the-Way" class="headerlink" title="By the Way"></a>By the Way</h3><ul><li>这篇文章里面用了许多原子操作以及一些内存序，诸如 <code>compare_exchange_strong/compare_exchange_weak</code> 区别，<code>acquire/release</code>语义，等后面有空再单独讲解下这个问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;建议先阅读上一篇文章 &lt;a href=&quot;https://szza.github.io/2022/01/10/rocksdb/WritePath/write_thread_1/&quot;&gt;WriteBatch 写入前的准备工作&lt;/a&gt; 了解一些基本概念&lt;/p</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>WriteBatch 写入前的准备工作</title>
    <link href="https://szza.github.io/2022/01/10/rocksdb/WritePath/write_thread_1/"/>
    <id>https://szza.github.io/2022/01/10/rocksdb/WritePath/write_thread_1/</id>
    <published>2022-01-10T06:15:35.000Z</published>
    <updated>2023-08-07T09:26:04.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WriteBatch"><a href="#WriteBatch" class="headerlink" title="WriteBatch"></a>WriteBatch</h2><blockquote><p>无论 <code>Put/Delete/DeleteRange</code> 都是向 RocksDB 插入一对 {key, value}，在不至于引起误解的前提下，下面不加以区分地统一表述为 <strong>写入</strong> 操作</p></blockquote><p>写入一条 <code>&#123;key, value&#125;</code> 数据需要先在 <em>WriteBatch</em> 内部序列化到 <code>WriteBatch::rep_</code>字段中。其整体格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时上是一行连续存储，为便于阅读多行显示</span></span><br><span class="line">  |sequence|count|</span><br><span class="line">  |serialized-kv-1|</span><br><span class="line">  |serialized-kv-2|</span><br></pre></td></tr></table></figure><p><code>WriteBatch::rep_</code> 在首部需要 <code>KHeader=12</code> 个字节存储本次 <code>writer_batch</code> 的元数据信息:</p><ul><li><code>sequence: uint64_t</code>: 8个字节，类似主键 id，记录的是当前 write_batch 是自从 RocksDB 创建以来第几个 write_batch。即便 RocksDB 挂了重启也不会更改，只会单增；</li><li><code>count: uint32_t</code>: 4个字节，记录本次 write_batch 写入了多少个 <code>&#123;key, value&#125;</code>，每次写入一条数据就会递增一次。下面的<code>Put</code> 案例操作可见。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  WriteBatch::<span class="built_in">WriteBatch</span>(<span class="type">size_t</span> reserved_bytes, <span class="type">size_t</span> max_bytes,</span><br><span class="line">                         <span class="type">size_t</span> protection_bytes_per_key, <span class="type">size_t</span> default_cf_ts_sz)</span><br><span class="line">    : <span class="built_in">content_flags_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">max_bytes_</span>(max_bytes),</span><br><span class="line">      <span class="built_in">default_cf_ts_sz_</span>(default_cf_ts_sz) &#123;</span><br><span class="line">    rep_.<span class="built_in">reserve</span>((reserved_bytes &gt; WriteBatchInternal::kHeader)</span><br><span class="line">                   ? reserved_bytes</span><br><span class="line">                   : WriteBatchInternal::kHeader);</span><br><span class="line">    rep_.<span class="built_in">resize</span>(WriteBatchInternal::kHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元信息 <code>sequence/count</code> 的 <em>setter</em>&#x2F;<em>getter</em> 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SequenceNumber <span class="title">WriteBatchInternal::Sequence</span><span class="params">(<span class="type">const</span> WriteBatch* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SequenceNumber</span>(<span class="built_in">DecodeFixed64</span>(b-&gt;rep_.<span class="built_in">data</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::SetSequence</span><span class="params">(WriteBatch* b, SequenceNumber seq)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(&amp;b-&gt;rep_[<span class="number">0</span>], seq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">WriteBatchInternal::Count</span><span class="params">(<span class="type">const</span> WriteBatch* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(b-&gt;rep_.<span class="built_in">data</span>() + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::SetCount</span><span class="params">(WriteBatch* b, <span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">EncodeFixed32</span>(&amp;b-&gt;rep_[<span class="number">8</span>], n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h3><p>RocksDB 中数据本身基本按照 <code>|xxx_length|xxx_bytes|</code> 格式编码。</p><p>下面将写入的 <code>&#123;key, value&#125;</code> 序列化成 <code>Record</code>，根据是否指定 ColumnFamily 有两种格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">default cf:</span><br><span class="line">  |KTypeValue|</span><br><span class="line">  |key_size|key_bytes|</span><br><span class="line">  |value_length|value_bytes|</span><br><span class="line"></span><br><span class="line">specify cf:    </span><br><span class="line">  |kTypeColumnFamilyValue|column_family_id|</span><br><span class="line">  |key_size|key_bytes|</span><br><span class="line">  |value_length|value_bytes|</span><br></pre></td></tr></table></figure><p>在 <code>Record</code> 前面有两个字段:</p><ul><li><code>ValueType: uint8_t</code>: 1个字节，表征本次是 <code>Put/Delete</code> 等具体操作类型，以及是否指定了 ColumnFamily</li><li><code>column_family_id: uint32_t</code>: 4个字节，只有指定了 ColumnFamily，才会有这个字段</li></ul><p>下面的 <code>WriteBatchInternal::Put</code> 实现就是按照上述格式封装 <code>&#123;key, value&#125;</code> 后续写入WAL 和 MemTable。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatchInternal::Put</span><span class="params">(WriteBatch* b, <span class="type">uint32_t</span> column_family_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="function">LocalSavePoint <span class="title">save</span><span class="params">(b)</span></span>;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(b, WriteBatchInternal::<span class="built_in">Count</span>(b) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (column_family_id == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeValue));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b-&gt;rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeColumnFamilyValue));</span><br><span class="line">    <span class="built_in">PutVarint32</span>(&amp;b-&gt;rep_, column_family_id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;b-&gt;rep_, key);</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;b-&gt;rep_, value);</span><br><span class="line">  b-&gt;content_flags_.<span class="built_in">store</span>(</span><br><span class="line">      b-&gt;content_flags_.<span class="built_in">load</span>(std::memory_order_relaxed) | ContentFlags::HAS_PUT,</span><br><span class="line">      std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> save.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LocalSavePoint"><a href="#LocalSavePoint" class="headerlink" title="LocalSavePoint"></a>LocalSavePoint</h3><p>LocalSavePoint 是基于 RAII 机制来判断 WriteBatch 写入的数据量累计是否已经超过限制: 是则回滚到生成 <em>save</em> 的位置，即调用本次 <code>WriteBatchInternel::Put</code> 之前的状态，然后返回 <code>Status::MemoryLimit</code> 错误，阻止本次写入流程。源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalSavePoint</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">LocalSavePoint</span><span class="params">(WriteBatch* batch)</span></span></span><br><span class="line"><span class="function">    : batch_(batch), </span></span><br><span class="line"><span class="function">      // savepoint 记录初始状态</span></span><br><span class="line"><span class="function">      savepoint_(batch-&gt;GetDataSize(), </span></span><br><span class="line"><span class="function">                 batch-&gt;Count(),</span></span><br><span class="line"><span class="function">                 batch-&gt;content_flags_.load(std::memory_order_relaxed))</span></span><br><span class="line"><span class="function">  &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 超过限制则 rollack 到初始状态</span></span><br><span class="line">    <span class="keyword">if</span> (batch_-&gt;max_bytes_ &amp;&amp; batch_-&gt;rep_.<span class="built_in">size</span>() &gt; batch_-&gt;max_bytes_) &#123;</span><br><span class="line">      batch_-&gt;rep_.<span class="built_in">resize</span>(savepoint_.size);</span><br><span class="line">      WriteBatchInternal::<span class="built_in">SetCount</span>(batch_, savepoint_.count);</span><br><span class="line">      batch_-&gt;content_flags_.<span class="built_in">store</span>(savepoint_.content_flags,</span><br><span class="line">                                   std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">MemoryLimit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  WriteBatch* batch_;</span><br><span class="line">  SavePoint savepoint_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 Savepoint 也是个简单的 <em>struct</em>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SavePoint</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> size;  <span class="comment">// size of rep_</span></span><br><span class="line">  <span class="type">int</span> count;    <span class="comment">// count of elements in rep_</span></span><br><span class="line">  <span class="type">uint32_t</span> content_flags;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SavePoint</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">count</span>(<span class="number">0</span>), <span class="built_in">content_flags</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SavePoint</span>(<span class="type">size_t</span> _size, <span class="type">int</span> _count, <span class="type">uint32_t</span> _flags)</span><br><span class="line">      : <span class="built_in">size</span>(_size), <span class="built_in">count</span>(_count), <span class="built_in">content_flags</span>(_flags) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    content_flags = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_cleared</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (size | count | content_flags) == <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Deserializtion"><a href="#Deserializtion" class="headerlink" title="Deserializtion"></a>Deserializtion</h3><p>WriteBatch 序列化时将数据连续存储，反序列化时则可以顺序读取，具有更好的局部性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ReadRecordFromWriteBatch</span><span class="params">(Slice* input, <span class="type">char</span>* tag,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint32_t</span>* column_family, Slice* key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Slice* value, Slice* blob, Slice* xid)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(key != <span class="literal">nullptr</span> &amp;&amp; value != <span class="literal">nullptr</span>);</span><br><span class="line">  *tag = (*input)[<span class="number">0</span>];</span><br><span class="line">  input-&gt;<span class="built_in">remove_prefix</span>(<span class="number">1</span>);</span><br><span class="line">  *column_family = <span class="number">0</span>;  <span class="comment">// default</span></span><br><span class="line">  <span class="keyword">switch</span> (*tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> kTypeColumnFamilyValue:</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">GetVarint32</span>(input, column_family)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad WriteBatch Put&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> kTypeValue:</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">GetLengthPrefixedSlice</span>(input, key) ||</span><br><span class="line">          !<span class="built_in">GetLengthPrefixedSlice</span>(input, value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad WriteBatch Put&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// other value   </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>数据写入 WriteBatch 后，下面就要写入 WAL 和 MemTable，先来看看写入操作之前的一些逻辑。</p><h2 id="WriteThread"><a href="#WriteThread" class="headerlink" title="WriteThread"></a>WriteThread</h2><p>基于 RocksDB 构建的上层应用向 RocksDB 多线程写入数据时，由 <code>RocksDB::WriteThread</code> 保障多线程写入的有序性，并通过内部优化尽可能提高写入效率，不阻塞后来的写入流程，具体优化下一期再来详解，下面先讲解一些基础逻辑。</p><p>上层应用向 RocksDB 写入的数据序列化到 <code>WriteBatch</code> 后，再把 WriteBatch 封装到 <code>WriteThread::Writer</code>，生成一个 writer 并向 <code>WriteThread</code> 申请写入许可。</p><h3 id="WriteThread-Writer"><a href="#WriteThread-Writer" class="headerlink" title="WriteThread::Writer"></a>WriteThread::Writer</h3><p><code>WriterThread::Writer</code> 是个链表:</p><ul><li><code>link_older</code> 指向 <code>this</code> 之前插入的 <code>Writer</code>，类似 <code>next</code></li><li><code>link_newer</code> 指向 <code>this</code> 后面插入的 <code>Writer</code>，类似 <code>prev</code></li></ul><p>每个 writer 节点内部存储着本次写入的数据 batch:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WriteThread</span>::Writer &#123;</span><br><span class="line">  WriteBatch* batch;</span><br><span class="line">  <span class="comment">//.. too many other fields ..</span></span><br><span class="line"></span><br><span class="line">  std::atomic&lt;<span class="type">uint8_t</span>&gt; state;</span><br><span class="line">  std::aligned_storage&lt;<span class="built_in">sizeof</span>(std::mutex)&gt;::type state_mutex_bytes;</span><br><span class="line">  std::aligned_storage&lt;<span class="built_in">sizeof</span>(std::condition_variable)&gt;::type state_cv_bytes;</span><br><span class="line">  Writer* link_older;  <span class="comment">// this 之前之前写入的 writers</span></span><br><span class="line">  Writer* link_newer;  <span class="comment">// this 之后写入的 writers</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//... methods</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用 <code>std::aligned_storage</code> 进行内存对齐的原理可以参考之前写的一篇文章 <a href="https://szza.github.io/2022/01/01/C++/align/">内存对齐之 alignof、alignas 、aligned_storage、align 剖析</a></p></blockquote><h3 id="WriteThread-WriteGroup"><a href="#WriteThread-WriteGroup" class="headerlink" title="WriteThread::WriteGroup"></a>WriteThread::WriteGroup</h3><p>如果每次只有一个 writer 能写入数据，其他 writers 只能阻塞等待，那 RocksDB 也就毫无写性能可言。于是乎，RocksDB 每次将一批 writers 组成一个 <code>WriteGroup</code> 统一写入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WriteThread</span>::WriteGroup &#123;</span><br><span class="line">  Writer* leader = <span class="literal">nullptr</span>;</span><br><span class="line">  Writer* last_writer = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//... other fields</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    Writer* writer;</span><br><span class="line">    Writer* last_writer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(Writer* w, Writer* last)</span></span></span><br><span class="line"><span class="function">        : writer(w), last_writer(last) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    Writer* <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> writer; &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">      <span class="built_in">assert</span>(writer != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">if</span> (writer == last_writer) &#123;</span><br><span class="line">        writer = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writer = writer-&gt;link_newer;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> writer != other.writer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Iterator</span>(leader, last_writer); &#125;</span><br><span class="line">  <span class="function">Iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>leader</code> 负责本次 write_group 的写入操作</p></li><li><p><code>last_writer</code> 负责将本次 writer_group 中待写入的所有 writers 对象串联起来。</p><p>last_writr 实际上是 <em>tail node</em>，而 leader 是 <em>head node</em>，通过 last_writer 向 leader 方向迭代，可以遍历整个 writer_group。</p><p>因此就可以通过 <code>leader</code> 和 <code>last_writer</code> 实现 <code>Iterator</code>，进一步可以轻松融入 for-loop 迭代体系，方便后续遍历 writer_group 中所有的 witers</p></li></ul><p>之所以从 last_writer 向 leader 节点遍历，也是为了满足写入的<em>顺序性</em>：tail 是更早写 RocksDB，head 是最晚写 RocksDB，因此需要迭代时使用 <code>link_newer</code>。</p><h3 id="WriteThread-State"><a href="#WriteThread-State" class="headerlink" title="WriteThread::State"></a>WriteThread::State</h3><p>而每个 writer 在写入过程中都有个状态， 由 <code>Writer::state</code> 字段表示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WriteThread</span>::State : <span class="type">uint8_t</span> &#123;</span><br><span class="line">  STATE_INIT = <span class="number">1</span>,</span><br><span class="line">  STATE_GROUP_LEADER = <span class="number">2</span>,</span><br><span class="line">  STATE_MEMTABLE_WRITER_LEADER = <span class="number">4</span>,</span><br><span class="line">  STATE_PARALLEL_MEMTABLE_WRITER = <span class="number">8</span>,</span><br><span class="line">  STATE_COMPLETED = <span class="number">16</span>,</span><br><span class="line">  STATE_LOCKED_WAITING = <span class="number">32</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>writer 创建后，初始化状态 <em>State::STATE_INIT</em> ，然后进入 <code>WriteThread::JoinBatchGroup</code> 函数中尝试更改自己的状态：</p><ol><li>要么成为本次写入流程的 leader，即 <em>State::STATE_GROUP_LEADER</em> 状态，然后组建自己的 writer_group，代替 writer_group 中所有 writers 完成写入，所有的 writers 状态都变成 <em>State::STATE_COMPLETED</em>；</li><li>要么加入一个已经选出 leader 但是尚未执行的 writer_group 成为 follower，让该 leader 代替自己执行完本次写入，完成后自己状态即 <em>State::STATE_COMPLETED</em></li><li>否则，只能阻塞等待前面正在执行写操作的 writer_group 完成</li></ol><h2 id="这一期主要讲解个-WriteBatch-在写入前的准备工作，下一期会开始讲解-WriteThread-内部的调度过程以及一些多线程中的原子操作。"><a href="#这一期主要讲解个-WriteBatch-在写入前的准备工作，下一期会开始讲解-WriteThread-内部的调度过程以及一些多线程中的原子操作。" class="headerlink" title="这一期主要讲解个 WriteBatch 在写入前的准备工作，下一期会开始讲解 WriteThread 内部的调度过程以及一些多线程中的原子操作。 "></a>这一期主要讲解个 WriteBatch 在写入前的准备工作，下一期会开始讲解 <code>WriteThread</code> 内部的调度过程以及一些多线程中的原子操作。 </h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WriteBatch&quot;&gt;&lt;a href=&quot;#WriteBatch&quot; class=&quot;headerlink&quot; title=&quot;WriteBatch&quot;&gt;&lt;/a&gt;WriteBatch&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;无论 &lt;code&gt;Put/Delete/Delet</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>MemTable、WAL、ColumnFamily 简述</title>
    <link href="https://szza.github.io/2022/01/08/rocksdb/WritePath/overview/"/>
    <id>https://szza.github.io/2022/01/08/rocksdb/WritePath/overview/</id>
    <published>2022-01-08T06:15:35.000Z</published>
    <updated>2023-08-12T12:54:33.277Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>尽管 rocksdb wiki 中 <a href="https://github.com/facebook/rocksdb/wiki">rocksdb-overview</a> 已经描述了，本文以自己的理解作为一个补充。</p><p>如图 rocksdb 的总体架构图中主要由 <code>MemTable</code>, <code>WAL</code> 和 <code>sstfile</code> 三个基本组件组成，本文主要阐述下他们之间的协作关系。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb-overview.png?raw=true" alt="rocksdb-overview"></p><h3 id="MemTable"><a href="#MemTable" class="headerlink" title="MemTable"></a>MemTable</h3><p>写入的kv数据会先写入 <code>WriteBatch</code>， 在经过 <code>WriteBatchInternal</code> 封装后写入 MemTable。</p><p>MemTable 是在读写路径中共享，这样可以减少读写路径中和磁盘交互的频次。但由于 MemTable 是个内存结构，为了防止各种故障导致 MemTable 中数据丢失，进而引入 WAL (<code>W</code>rite <code>A</code>head <code>L</code>og)，即每次写入的数据，会先写入 WAL，成功后再写入 MemTable，如果 MemTable 中的数据丢失则从 WAL 中恢复。</p><p>正常情况下，写入的数据会持续写入 MemTable，直到 MemTable 的大小超过阈值，则会变成只具有只读属性的 ImutableMemTable, 同时创建新的 MemTable 接受后续的写入。等待后台线程 <em>Pickup</em> 合适的 ImmutableMemTables，将其 Flush 到 $Level_0$ 中，那么选中的 ImmutableMemTables 对应的 WALs 也可以删除了。</p><p>这里为什么用了 <em>Pickup</em> 这个说法？在 RocksDB-3.0 引入 cf(<code>C</code>olumn<code>F</code>amily) 设计，每个 cf 都有一个自己的 MemTable，但是所有的 cfs 共享一个 WAL：当向其中一个 cf 写入大量数据会导致它的 MemTable full 并转为 ImmtableMemTable。此时能直接删除当前 WAL 吗，由于WAL 可能仍保存着其他 cfs 的 MemTable 数据，这就涉及到 WAL 生命周期的问题。因此在删除 WALs 时，需要挑选出 WALs 生命周期结束的才能删除。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>TiKV 原本的架构是一个 TiKV-Server 上的所有 regions 共享两个 RocksDB 实例: <code>raft-rocksdb</code> 用于存放 raft log，<code>kv-rocksdb</code> 用于存放状态机数据，kv-rocksdb 实例有三个 column family，</p><ol><li>事务 T1 在 prewrite 阶段写入 MemTable 的 lock 信息，在事务 T1 commit 阶段之前可能有其他热点 regions 写入大量数据导致 Flush MemTable，进而导致事务 T1 commit 阶段原本可以在 MemTable 中就可以查询到 lock 信息，现在需要去 sst 文件中查询，无疑增加了成本。</li><li>那么我们是否可以通过每个 region 一个 cf 来实现 region 的隔离？</li></ol><p>  显然也是不行，因为 cf 只是逻辑上的隔离，所有的 cf 仍共享一个 WAL：如果上万个 regions 对应上万个 cfs，如果会造成很多 WALs 生命周期无法结束、得不到释放，势必生成占用大量资源。<br>3. 每个 region 一个 RocksDB 实例</p><p>  在 Release-6.6 提出 Partitioned-TiKV 架构，即每个 region 分配一个 rocksdb 实例，从物理层上实现 region 隔离，这样原本一个 region 只能存储 64M 的存储，现在可以存储10G+的数据，减少了写入过程 region-leader 分裂的频次。</p><p>  <em>Question</em>: 但是也有其他问题，比如 每个 region 一个 rocksdb，是否会因为 MemTable 导致占用的内存增加？尤其本来 TiKV 对硬件要求就很高，如此硬件成本是否会更高，以及内部 region 合并时 两个不同 RocksDB 实例的 regions 数据如何合并。不过由于 tikv region 本身就是按照 kv-range 划分的，不存在重复，合并可能主要需要修改元数据信息。</p><p>  这个设计可以参考: <a href="https://cn.pingcap.com/blog/principle-analysis-of-partitioned-raft-kv">partitioned-raft-kv</a></p><h3 id="SST"><a href="#SST" class="headerlink" title="SST"></a>SST</h3><p>Rocksdb 引擎是个 LSM (<code>L</code>og <code>S</code>tructured <code>M</code>erge) Tree， 其中 $level_0$ ~ $level_N$ 都由 sst(<code>S</code>orted <code>S</code>tring <code>T</code>able) files 组成。</p><p>sstfile 是已经将 kv 数据有序存储在磁盘上，因此和 sstfile 有关的问题不再是数据有没有可能丢失，而是如何减少 LSM Tree 中不同 level 的 sstfiles 中存储的冗余数据。这种方式即 compaction。</p><ul><li>$Level_0$ 存储最新的数据， $Level_N$ 存储最旧的数据。</li><li>$Level_0$ 中的 sstfiles 可能会有重复，$Level_1$ ~ $Level_N$ 中的数据不重复</li></ul><p>当 Compaction 方式是 <code>Level Compaction</code> 时:</p><ul><li><p>$level_0$: 当 MemTable 中的数据 Flush 到 $Level_0$ 时，会导致 $Level_0$ 存在重复的 kv range。当 $Level_0$ 的文件数量达到阈值 <code>$Level_0$_file_num_compaction_trigger</code>，$Level_0$ 会被合并到会和 $Level_1$，并保持使得 $Level_1$ 层的 sstfiles 仍然有序且无重复。</p><p>如图是 $level_0$ 的 compaction 前后过程：</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_pre_l0_compaction.png?raw=true" alt="pre_l0_compaction"></p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_post_l0_compaction.png?raw=true" alt="post_l0_compaction"></p></li><li><p>当 $$Level_1$$ 的数据量越来越大，会触发 $Level_1$(inpit-level)层和 $level_2$ (output-level)层的 compaction。</p><p>如图是 $level_1$ 的 compaction 前后过程：</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_pre_l1_compaction.png?raw=true" alt="rocksdb_pre_l1_compaction"></p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_post_l1_compaction.png?raw=true" alt="rocksdb_post_l1_compaction"></p></li><li><p>以此类推到 LSM 最底层。</p></li></ul><p>这里面需要研究的细节:</p><ul><li>input&#x2F;output level 中的哪些 sstfiles 进行 compaction</li><li>如何选择合适的 compaction 方式，平衡读写放大</li><li>当 value 较大，进行 kv 分离来降低写方大问题</li></ul><p>由于现在新型的数据库的存储引擎基本都是以 LSM Tree 为蓝本， compaction 对内存和磁盘的影响就显得愈发重要，几乎都会借鉴 RocksDB 的设计。因此，在学习 RocksDB 时，compaction 是不可或缺的一点。 </p><h2 id="ColumnFamily"><a href="#ColumnFamily" class="headerlink" title="ColumnFamily"></a>ColumnFamily</h2><p>上面已经简述了 cf，它在逻辑上将 RocksDB 划分为多个 cf，每个 cf 类似一个关系数据库中的分区表的概念。</p><p>如图，cf 的实体是 <code>class ColumnFamilyData</code>，一个 RocksDB 实例可以有多个 cfs，都保存在 <code>ColumnFamilySet</code> 对象中。一个 cf 中要记录三大部分:</p><ul><li><code>version</code>: 表征的是 lsm tree 的 $Level_0$ - $Level_N$ 信息</li><li><code>imm</code>: 表征的是只读的 MemTable，不再接受写入的 MemTable；</li><li><code>mm</code>: 当前最新的 MemTable，接受读写</li></ul><p>同样这里也存在<code>version</code>、<code>imm</code> 生命周期的问题，因为每次 flush&#x2F;comapction，都会对 imm&#x2F;version 产生影响，为了追踪生命周期，</p><ul><li><code>MemTableList</code> 对象 imm 中有个 <code>MemTableListVersion</code> 对象，并有 <em>Ref()</em>&#x2F;<em>Unref()</em> 函数来追踪生命周期；</li><li><code>Version</code> 对象 version 也有 <em>Ref()</em>&#x2F;<em>Unref()</em> 函数来追踪生命周期；</li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/RocksDB/rocksdb_cf.png?raw=true" alt="rocksdb-cf"></p><p>因此，关于 cf 也好理解，在分析这块的时候可以多关注下 WALs、Version 等生命周期的起始。</p><h2 id="Get-MultiGet"><a href="#Get-MultiGet" class="headerlink" title="Get&#x2F;MultiGet"></a>Get&#x2F;MultiGet</h2><p>读取路径会比较复杂，主要是将 mm&#x2F;imm、sstfile 数据有序合并起来再取最新的数据输出，相关的三个迭代器 <code>MergingIterator</code>，<code>CompactionIterator</code>、<code>RangeTomeStoneIterator</code> 放在后续慢慢再讲解。这一部分还有一点就是利用 C++20 的协程实现异步IO来提取读取性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;尽管 rocksdb wiki 中 &lt;a href=&quot;https://github.com/</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>内存分配器之 concurrent_arena</title>
    <link href="https://szza.github.io/2022/01/07/rocksdb/MemoryAllocator/2_concurrent_arena/"/>
    <id>https://szza.github.io/2022/01/07/rocksdb/MemoryAllocator/2_concurrent_arena/</id>
    <published>2022-01-07T06:15:35.000Z</published>
    <updated>2023-08-07T09:26:04.691Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrent-arena"><a href="#concurrent-arena" class="headerlink" title="concurrent_arena"></a>concurrent_arena</h1><p>在上一期的 <a href="./2_arena.md">存分配器之 arena</a> 中，讲解了 RocksDB 是如何混合new、mmap设计一个高效的内存分配器。这一期，我们继续深入探索 RocksDB 是如何设计出一个高效的多线程内存分配器 <code>concurrent_arena</code> 。</p><p>let’s go</p><p>多线程程序的性能关键，有两个关键因素：</p><ul><li><p>减少竞争</p><p>减少竞争，有诸多方式，比如使用原子变量、细粒度锁（fine-grained mutex），threadlocal。</p></li><li><p>False Sharing</p><p>降低false sharing，一般解决办法是将线程间共享的数据大小与cacheline大小对齐（align）。</p></li></ul><p>而 concurrent_arena 即在 arena 的基础上，增加了一些多线程间的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentArena</span> : <span class="keyword">public</span> Allocator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// @brief 参数 @c block_size 与 @c huge_page_size 含义同 Arena 中</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ConcurrentArena</span><span class="params">(<span class="type">size_t</span> block_size = Arena::kMinBlockSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">size_t</span> huge_page_size = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 分配无须对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 分配需要对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Logger* logger = <span class="literal">nullptr</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Shard</span> &#123;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">40</span>] ROCKSDB_FIELD_UNUSED; </span><br><span class="line">    <span class="keyword">mutable</span> SpinMutex mutex;</span><br><span class="line">    <span class="type">char</span>* free_begin_; </span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; allocated_and_unused_; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">Shard</span>() : <span class="built_in">free_begin_</span>(<span class="literal">nullptr</span>), <span class="built_in">allocated_and_unused_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">size_t</span> tls_cpuid; </span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> padding0[<span class="number">56</span>] ROCKSDB_FIELD_UNUSED;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> shard_block_size_;</span><br><span class="line"></span><br><span class="line">  CoreLocalArray&lt;Shard&gt; shards_; <span class="comment">// 存储数据</span></span><br><span class="line"></span><br><span class="line">  Arena arena_;                                     <span class="comment">// 内存分配器</span></span><br><span class="line">  <span class="keyword">mutable</span> SpinMutex arena_mutex_;                   <span class="comment">// 保证使用 arena 分配内存时线程安全</span></span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; arena_allocated_and_unused_;  <span class="comment">// arena_ 剩余可使用的内存 </span></span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; memory_allocated_bytes_;      <span class="comment">// arena 总的分配内存</span></span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; irregular_block_num_;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> padding1[<span class="number">56</span>] ROCKSDB_FIELD_UNUSED;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Shard"><a href="#ConcurrentArena-Shard" class="headerlink" title="ConcurrentArena::Shard"></a>ConcurrentArena::Shard</h3><p>为避免竞争，<code>concurrent_arena</code> 使用将每个线程所需的内存分配在线程所属的cpu核上，如此每个线程在分配内存时都会使用自己的内存，如此就避免了竞争。这也是一种空间换时间的策略，类似于threadlocal思想。</p><p>结构体 <code>Shard</code> 记录了每个核上的内存分配、使用情况。字段 <code>shards_</code> 记录了所有核上shard。</p><p>类<code>CoreLocalArray</code> 本质上是个数组，为了提高多线程的访问效率，要将<code>Shard</code>的大小对齐到cacheline大小，以阻止false sharing现象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shard</span> &#123;</span><br><span class="line">   <span class="comment">// 填充字节以对齐到 cacheline, 避免 false sharding</span></span><br><span class="line">   <span class="type">char</span> padding[<span class="number">40</span>] ROCKSDB_FIELD_UNUSED; </span><br><span class="line">   <span class="comment">// 用于保护 free_begin_ 指向的数据</span></span><br><span class="line">   <span class="keyword">mutable</span> SpinMutex mutex;</span><br><span class="line">   <span class="comment">// 每个core上分配内存地址</span></span><br><span class="line">   <span class="type">char</span>* free_begin_; </span><br><span class="line">   <span class="comment">// 每个core剩余可用内存</span></span><br><span class="line">   std::atomic&lt;<span class="type">size_t</span>&gt; allocated_and_unused_; </span><br><span class="line"></span><br><span class="line">   <span class="built_in">Shard</span>() : <span class="built_in">free_begin_</span>(<span class="literal">nullptr</span>), <span class="built_in">allocated_and_unused_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> CoreLocalArray&lt;Shard&gt; shards_;</span><br></pre></td></tr></table></figure><h4 id="CoreLocalArray"><a href="#CoreLocalArray" class="headerlink" title="CoreLocalArray"></a>CoreLocalArray</h4><p>类 <code>CoreLocalArray</code>  只用于存储数据，本身不是线程安全的，因此需要 <code>Shard::mutex</code> 字段保护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoreLocalArray</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CoreLocalArray</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 数组元素个数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @return 返回当前线程所在core上的数据地址 ptr</span></span><br><span class="line">  <span class="function">T* <span class="title">Access</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AccessElementAndIndex</span>().first;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// @return 不仅返回当前线程所在core上的数据地址 ptr，还返回该core的index</span></span><br><span class="line">  <span class="function">std::pair&lt;T*, <span class="type">size_t</span>&gt; <span class="title">AccessElementAndIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 通过 core_idx 来获取该 core 的数据</span></span><br><span class="line">  <span class="function">T* <span class="title">AccessAtCore</span><span class="params">(<span class="type">size_t</span> core_idx)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::unique_ptr&lt;T[]&gt; data_;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="type">int</span> size_shift_;             </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-CoreLocalArray"><a href="#CoreLocalArray-CoreLocalArray" class="headerlink" title="CoreLocalArray::CoreLocalArray"></a>CoreLocalArray::CoreLocalArray</h5><p>C++11中提供了<code>std::thread::hardware_concurrency</code> 函数，来获取CPU的核数<code>num_cpus</code>，将线程数设置为 <code>num_cpus</code>，如此就能避免在一个进程中线程频繁的在不同的core上来回切换，降低线程切换上下文的开销。</p><ul><li>如果<code>num_cpus &lt;= 8</code>，则启动8个线程；</li><li>否则，开启<code>num_cpus</code>个线程（num_cpus 一般也是2的幂）。</li></ul><p>代码简洁如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CoreLocalArray&lt;T&gt;::<span class="built_in">CoreLocalArray</span>() &#123;</span><br><span class="line">  <span class="type">int</span> num_cpus = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::thread::<span class="built_in">hardware_concurrency</span>());</span><br><span class="line">  size_shift_ = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span> &lt;&lt; size_shift_ &lt; num_cpus) &#123;</span><br><span class="line">    ++size_shift_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每个core上都有类型 T 的数据</span></span><br><span class="line">  data_.<span class="built_in">reset</span>(<span class="keyword">new</span> T[<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-AccessAtCore"><a href="#CoreLocalArray-AccessAtCore" class="headerlink" title="CoreLocalArray::AccessAtCore"></a>CoreLocalArray::AccessAtCore</h5><p><code>AccessAtCore</code> 函数，用于获取核<code>core_idx</code>上的数据，即获取数组<code>data_[core_idx]</code>中数据。</p><p>在这解释下为啥类型<code>T</code>大小需要对齐到 cacheline大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* CoreLocalArray&lt;T&gt;::<span class="built_in">AccessAtCore</span>(<span class="type">size_t</span> core_idx) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">assert</span>(core_idx &lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_);</span><br><span class="line">  <span class="keyword">return</span> &amp;data_[core_idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-AccessElementAndIndex"><a href="#CoreLocalArray-AccessElementAndIndex" class="headerlink" title="CoreLocalArray::AccessElementAndIndex"></a>CoreLocalArray::AccessElementAndIndex</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::pair&lt;T*, <span class="type">size_t</span>&gt; CoreLocalArray&lt;T&gt;::<span class="built_in">AccessElementAndIndex</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="type">int</span> cpuid = port::<span class="built_in">PhysicalCoreID</span>(); <span class="comment">// 获取cpu的物理id</span></span><br><span class="line">  <span class="type">size_t</span> core_idx;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(cpuid &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// cpu id unavailable, just pick randomly</span></span><br><span class="line">    core_idx = Random::<span class="built_in">GetTLSInstance</span>()-&gt;<span class="built_in">Uniform</span>(<span class="number">1</span> &lt;&lt; size_shift_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将 cpuid 映射到 1 &lt;&lt; size_shift_ 以内</span></span><br><span class="line">    core_idx = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(cpuid &amp; ((<span class="number">1</span> &lt;&lt; size_shift_) - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="built_in">AccessAtCore</span>(core_idx), core_idx&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-ShardAllocatedAndUnused"><a href="#ConcurrentArena-ShardAllocatedAndUnused" class="headerlink" title="ConcurrentArena::ShardAllocatedAndUnused"></a>ConcurrentArena::ShardAllocatedAndUnused</h3><p><code>ShardAllocatedAndUnused</code> 则用于记录，<code>shards</code>中各个<code>shard</code>中剩余可用内存大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有已分配但未使用的内存</span></span><br><span class="line"> <span class="function"><span class="type">size_t</span> <span class="title">ConcurrentArena::ShardAllocatedAndUnused</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">   <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; shards_.<span class="built_in">Size</span>(); ++i) &#123;</span><br><span class="line">     total += </span><br><span class="line">       shards_.<span class="built_in">AccessAtCore</span>(i)-&gt;allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> total;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-ConcurrentArena"><a href="#ConcurrentArena-ConcurrentArena" class="headerlink" title="ConcurrentArena::ConcurrentArena"></a>ConcurrentArena::ConcurrentArena</h3><p><code>ConcurrentArena</code> 的构造函数比较简单：</p><ol><li>初始化每个<code>shard</code> 需要分配的内存大小 <code>shard_block_size_</code>；</li><li>初始化 <code>shards_</code> 数组；</li><li>初始化<code>arena</code></li><li>调用<code>Fixup</code>函数，初始化内存使用情况；</li></ol><p>简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentArena::<span class="built_in">ConcurrentArena</span>(<span class="type">size_t</span> block_size,</span><br><span class="line">                                 AllocTracker* tracker,</span><br><span class="line">                                 <span class="type">size_t</span> huge_page_size)</span><br><span class="line">    : <span class="built_in">shard_block_size_</span>(std::<span class="built_in">min</span>(kMaxShardBlockSize, block_size / <span class="number">8</span>)),</span><br><span class="line">      <span class="built_in">shards_</span>(),</span><br><span class="line">      <span class="built_in">arena_</span>(block_size, tracker, huge_page_size) &#123;</span><br><span class="line">  <span class="built_in">Fixup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Fixup"><a href="#ConcurrentArena-Fixup" class="headerlink" title="ConcurrentArena::Fixup"></a>ConcurrentArena::Fixup</h3><p><code>FixUp</code> 函数用于记录当前内存情况。</p><p>下面三个原子变量写入新值时，使用<code>::std::memory_order_relaxed</code>即能满足。关于<code>memory order</code>，花了两个周末的时候重温了下，有时间会再出博客深度讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcurrentArena::Fixup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arena_ 所分配的内存中剩余可使用的内存</span></span><br><span class="line">    arena_allocated_and_unused_.<span class="built_in">store</span>(arena_.<span class="built_in">AllocatedAndUnused</span>(), std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// arena 分配的内存总量</span></span><br><span class="line">    memory_allocated_bytes_.<span class="built_in">store</span>(arena_.<span class="built_in">MemoryAllocatedBytes</span>(), std::memory_order_relaxed);</span><br><span class="line">    irregular_block_num_.<span class="built_in">store</span>(arena_.<span class="built_in">IrregularBlockNum</span>(), std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Repick"><a href="#ConcurrentArena-Repick" class="headerlink" title="ConcurrentArena::Repick"></a>ConcurrentArena::Repick</h3><p><code>Repick</code> 函数，用来初始化线程。把一个线程绑定到所属的核<code>tls_cpuid</code>。这样下次以后这个线程需要内存，直接去对应的<code>shard</code>获取内存。</p><p>注意，<code>tls_cpuid</code> 默认为0，因此对于<code>core_idx</code>为0的线程需要映射到<code>num_cpus</code>，这样就能通过<code>tls_cpuid != 0</code>来判断这个线程是否初始化过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ConcurrentArena::Shard* <span class="title">ConcurrentArena::Repick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> shard_and_index = shards_.<span class="built_in">AccessElementAndIndex</span>();</span><br><span class="line">  <span class="comment">// 用于将 cord_idx 为 0 时 映射为 num_cpus，来体现此线程已初始化 </span></span><br><span class="line">  tls_cpuid = shard_and_index.second | shards_.<span class="built_in">Size</span>();</span><br><span class="line">  <span class="keyword">return</span> shard_and_index.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-AllocateImpl"><a href="#ConcurrentArena-AllocateImpl" class="headerlink" title="ConcurrentArena::AllocateImpl"></a>ConcurrentArena::AllocateImpl</h3><p>整个流程如下：</p><ol><li><p>先判断此次分配内存，是否需要从arena直接分配即可</p><ul><li>超过一个shards内存大小的1&#x2F;4</li><li>上层强制使用 arena</li><li>该线程首次调用<code>AllocateImpl</code> 函数，此时<code>shards</code>中的各个<code>shard-&gt;free_begin</code>尚未指向有效内存地址；</li></ul><p>如果要使用 <code>arena_</code>，则需要使用<code>arena_mutex_</code>保护。</p></li><li><p>尝试从shard中获取内存</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">AllocateImpl</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">bool</span> force_arena, <span class="type">const</span> Func&amp; func)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> cpu;</span><br><span class="line">  <span class="comment">// 直接使用arena分配内存，有两种情况：</span></span><br><span class="line">  <span class="comment">// 1. 待分配的内存比较大。</span></span><br><span class="line">  <span class="comment">// 2. Repick 尚未调用过，并且当前 arena_mutex_ 能直接获得</span></span><br><span class="line">  <span class="function">std::unique_lock&lt;SpinMutex&gt; <span class="title">arena_lock</span><span class="params">(arena_mutex_, std::defer_lock)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; shard_block_size_ / <span class="number">4</span> </span><br><span class="line">      <span class="comment">// 使用 huge_page</span></span><br><span class="line">      || force_arena </span><br><span class="line">      <span class="comment">// 判断条件执行到此，说明 所需的内存 bytes 并不大，比较小</span></span><br><span class="line">      <span class="comment">// 原则上是不需要使用 arena，但是如果同时满足以下二个条件：</span></span><br><span class="line">      <span class="comment">//  1. 没有执行过 Repick 函数</span></span><br><span class="line">      <span class="comment">//  2. 成功获得锁</span></span><br><span class="line">      || ((cpu = tls_cpuid) == <span class="number">0</span>   <span class="comment">// 线程尚未初始化</span></span><br><span class="line">           &amp;&amp; !shards_.<span class="built_in">AccessAtCore</span>(<span class="number">0</span>)-&gt;allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed) </span><br><span class="line">           &amp;&amp; arena_lock.<span class="built_in">try_lock</span>())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arena_lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">      <span class="comment">// 阻塞等待</span></span><br><span class="line">      arena_lock.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="comment">// 获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> rv = <span class="built_in">func</span>(); <span class="comment">// 分配内存的回调函数</span></span><br><span class="line">    <span class="built_in">Fixup</span>();</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 选择一个 shard 来满足此次内存分配</span></span><br><span class="line">  Shard* s = shards_.<span class="built_in">AccessAtCore</span>(cpu &amp; (shards_.<span class="built_in">Size</span>() - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (!s-&gt;mutex.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">    s = <span class="built_in">Repick</span>();</span><br><span class="line">    s-&gt;mutex.<span class="built_in">lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::unique_lock&lt;SpinMutex&gt; <span class="title">lock</span><span class="params">(s-&gt;mutex, std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> avail = s-&gt;allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (avail &lt; bytes) &#123;</span><br><span class="line">    <span class="comment">// reload</span></span><br><span class="line">    <span class="comment">// 此时需要使用 arnea 来分配内存</span></span><br><span class="line">    <span class="comment">// 1. 该 core 所剩的内存不足</span></span><br><span class="line">    <span class="comment">// 2. 第一次执行（本质还是第一种情况）</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;SpinMutex&gt; <span class="title">reload_lock</span><span class="params">(arena_mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> exact = arena_allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">assert</span>(exact == arena_.<span class="built_in">AllocatedAndUnused</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exact &gt;= bytes &amp;&amp; arena_.<span class="built_in">IsInInlineBlock</span>()) &#123;</span><br><span class="line">      <span class="comment">// 如果还没有消耗完 arena 的inline block的内存，则直接使用该内存</span></span><br><span class="line">      <span class="comment">// 这样就可以避免分配新的block，</span></span><br><span class="line">      <span class="keyword">auto</span> rv = <span class="built_in">func</span>(); <span class="comment">// 执行回调函数分配</span></span><br><span class="line">      <span class="built_in">Fixup</span>();</span><br><span class="line">      <span class="keyword">return</span> rv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avail = exact &gt;= shard_block_size_ / <span class="number">2</span> &amp;&amp; exact &lt; shard_block_size_ * <span class="number">2</span></span><br><span class="line">                ? exact</span><br><span class="line">                : shard_block_size_;</span><br><span class="line">    <span class="comment">// 重新分配内存</span></span><br><span class="line">    <span class="comment">// 首次调用即在此分配内存</span></span><br><span class="line">    s-&gt;free_begin_ = arena_.<span class="built_in">AllocateAligned</span>(avail);</span><br><span class="line">    <span class="built_in">Fixup</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可用内存减少</span></span><br><span class="line">  s-&gt;allocated_and_unused_.<span class="built_in">store</span>(avail - bytes, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* rv;</span><br><span class="line">  <span class="keyword">if</span> ((bytes % <span class="built_in">sizeof</span>(<span class="type">void</span>*)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// aligned allocation from the beginning</span></span><br><span class="line">    rv = s-&gt;free_begin_;</span><br><span class="line">    s-&gt;free_begin_ += bytes;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// unaligned from the end</span></span><br><span class="line">    rv = s-&gt;free_begin_ + avail - bytes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concurrent-arena&quot;&gt;&lt;a href=&quot;#concurrent-arena&quot; class=&quot;headerlink&quot; title=&quot;concurrent_arena&quot;&gt;&lt;/a&gt;concurrent_arena&lt;/h1&gt;&lt;p&gt;在上一期的 &lt;a href=</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>内存分配器之 arena</title>
    <link href="https://szza.github.io/2022/01/06/rocksdb/MemoryAllocator/2_arena/"/>
    <id>https://szza.github.io/2022/01/06/rocksdb/MemoryAllocator/2_arena/</id>
    <published>2022-01-06T06:15:35.000Z</published>
    <updated>2023-08-07T09:26:04.691Z</updated>
    
    <content type="html"><![CDATA[<p>今天，就开始逐步更新剖析 RocksDB 源码的博客。思前想后，准备自下而上，因此还是从内存分配器开始叭。</p><p>在 RocksDB 中主要有两类内存分配器<code>MemoryAllocator</code>、<code>Allocator</code>。</p><h4 id="MemoryAllocator"><a href="#MemoryAllocator" class="headerlink" title="MemoryAllocator"></a>MemoryAllocator</h4><p><code>MemoryAllocator</code> 是个基类，RocksDB 提供了两个子类：<code>MemkindKmemAllocator</code>、<code>JemallocNodumpAllocator</code>，而这两个子类，实际上分别是 <a href="https://github.com/memkind/memkind">memkind</a>、<a href="https://github.com/jemalloc/jemalloc">jemalloc</a>两个开源库的 wrapper，即利用两个开源库的函数来实现<code>Allocate</code>、<code>Deallocate</code>操作。<code>jemalloc</code>后者有时间再开专题专门细解，这里就不展开说了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAllocator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">MemoryAllocator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///@note 需要保证线程安全</span></span><br><span class="line">  <span class="comment">///@param 至少分配的内存大小</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///@note 需要保证线程安全</span></span><br><span class="line">  <span class="comment">///@brief 释放之前由 Allocate 分配的内存</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Deallocate</span><span class="params">(<span class="type">void</span>* p)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///@brief 返回 ptr 指向的block的内存大小</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">UsableSize</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> allocation_size)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// default implementation just returns the allocation size</span></span><br><span class="line">    <span class="keyword">return</span> allocation_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h2><p>本节主要详细讲解<code>Allocator</code>及其子类<code>Arena</code>的实现。</p><p>类 <code>Allocator</code> 是个基类，主要有两个接口：</p><ul><li><code>Allocate</code>：分配无须对齐的内存；</li><li><code>AllocateAligned</code>：分配需要经过对齐的内存；</li></ul><p>关于内存对齐，可以参考之前写过的一期博客 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析]，在这一期，通过讲解<code>Allocator</code>，会更加深刻的理解内存对齐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Allocator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">char</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Logger* logger = <span class="literal">nullptr</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">BlockSize</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基类<code>Allocator</code> 有两个子类，<code>Arena</code> 和<code>concurrent_arena</code>，分别用于单线程和多线程内存分配，其中 <code>concurrent_arena</code> 也是个<code>Arena</code>的<code>wrapper</code>，外加了一些措施，保证<code>Arnea</code>在多线程下的安全。因此，本文先详细讲解下<code>Arena</code>，下一节再把注意力集中在concurrent_arena&#96;的多线程设计上。</p><img src="/Users/shuzhuangzhuang/self_study/graph/需求/rocksdb/images/Allocator.jpg" style="zoom:50%;"><h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><p>类<code>Arena</code> 在分配内存时，是以 <code>block</code> 为单位，即每次先分配一个<code>block</code>大小的内存，后续所需<code>bytes</code>大小的内存时，会先尝试从<code>block</code> 中获取，如果这个<code>block</code>中剩余的可用内存能满足<code>bytes</code>，则从<code>block</code>中划出一部分给上层使用，否则才从操作系统中获取。</p><p>一个<code>block</code>容纳的内存大小，由<code>kBlockSize</code>参数来指定。</p><p>现在<code>Arena</code>怎么实现基类中<code>Allocate</code>、<code>AllocateAligned</code>两个接口？</p><p><code>Arena</code> 中有两个指针：<code>aligned_alloc_ptr_</code>、<code>unaligned_alloc_ptr_</code>，当一个<code>block</code>的内存创建完毕时：</p><ul><li><code>aligned_alloc_ptr_</code>：指向该<code>block</code>的首地址（低地址），后续用于分配需要对齐的内存；</li><li><code>unaligned_alloc_ptr_</code>：指向该<code>block</code>的末地址（高地址），后续用于分配不需要对齐的内存。</li></ul><p>示意图如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block : [-------------------------]</span><br><span class="line">        ^                         ^</span><br><span class="line">        |                         | </span><br><span class="line">   aligned_alloc_ptr_    unaligned_alloc_ptr_</span><br></pre></td></tr></table></figure><p>为啥要这么做？</p><p>由于每次内存对齐操作可能存在一定的浪费，而同一个类中所需的内存对齐大小一般是固定的，因此从blokc的一端只分配需要对齐的内存，若内存对齐大小是固定的，那么每次分配的内存也都是连续的，如此就可以减少因为内存对齐带来的浪费。</p><p>从<code>block</code>的另一端分配无需对齐的内存，还能提高内存利用率。</p><blockquote><p>比如，block的大小为7个字节，分配一块需要4字节对齐的内存，还剩下3字节的内存，可以继续用于无须对齐的内存。</p></blockquote><p>下面先整体看看类<code>Arean</code>。</p><blockquote><p>在下面的源码分析中，做了一些简化，去除了一些统计内存大小部分的代码，读者可自行追溯RocksDB中该部分的源码。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Arena</span> : <span class="keyword">public</span> Allocator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  <span class="built_in">Arena</span>(<span class="type">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kInlineSize = <span class="number">2048</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kMinBlockSize;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kMaxBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Arena</span><span class="params">(<span class="type">size_t</span> block_size = kMinBlockSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                 AllocTracker* tracker = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">size_t</span> huge_page_size = <span class="number">0</span>)</span></span>;</span><br><span class="line">  ~<span class="built_in">Arena</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 分配无需对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 分配需要对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Logger* logger = <span class="literal">nullptr</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// 当前已使用内存大小</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">ApproximateMemoryUsage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blocks_memory_ + blocks_.<span class="built_in">capacity</span>() * <span class="built_in">sizeof</span>(<span class="type">char</span>*) - alloc_bytes_remaining_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 总的已分配内存</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">MemoryAllocatedBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> blocks_memory_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 剩余可用内存</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">AllocatedAndUnused</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> alloc_bytes_remaining_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 分配的不对齐block数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">IrregularBlockNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> irregular_block_num; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 一个 block 的内存大小</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">BlockSize</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> kBlockSize; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// blocks_ 是否用的栈上内存</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsInInlineBlock</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blocks_.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">alignas</span>(<span class="type">max_align_t</span>) <span class="type">char</span> inline_block_[kInlineSize];</span><br><span class="line">  <span class="comment">// 一个block分配的内存大小</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> kBlockSize;           </span><br><span class="line">  <span class="keyword">typedef</span> std::vector&lt;<span class="type">char</span>*&gt; Blocks; </span><br><span class="line">  <span class="comment">// 使用new分配的block集合</span></span><br><span class="line">  Blocks blocks_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">MmapInfo</span> &#123;</span><br><span class="line">    <span class="type">void</span>* addr_;</span><br><span class="line">    <span class="type">size_t</span> length_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MmapInfo</span>(<span class="type">void</span>* addr, <span class="type">size_t</span> length) : <span class="built_in">addr_</span>(addr), <span class="built_in">length_</span>(length) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 使用 mmap 分配内存的block集合</span></span><br><span class="line">  std::vector&lt;MmapInfo&gt; huge_blocks_; </span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> irregular_block_num = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span>* unaligned_alloc_ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">char</span>* aligned_alloc_ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 当前block剩余可用内存</span></span><br><span class="line">  <span class="type">size_t</span> alloc_bytes_remaining_ = <span class="number">0</span>; </span><br><span class="line">   <span class="comment">// 目前一共分配的内存</span></span><br><span class="line">  <span class="type">size_t</span> blocks_memory_ = <span class="number">0</span>;        </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="type">size_t</span> hugetlb_size_ = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MAP_HUGETLB</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateFromHugePage</span><span class="params">(<span class="type">size_t</span> bytes)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">bool</span> aligned)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Arena-Arena"><a href="#Arena-Arena" class="headerlink" title="Arena::Arena"></a>Arena::Arena</h3><p>先来看看构造函数 <code>Arena::Arena</code>。这里，主要初始化一些类成员变量：</p><ul><li><p><code>kBlockSize</code></p><p>字段<code>kBlockSize</code> ，表达的是以后每次分配一个block时的内存大小。在初始化之前，使用<code>OptimizeBlockSize</code>函数对传入的参数<code>block_size</code>进行限制，使其满足后续的<code>assert</code>判断。</p><p>通过 <code>OptimizeBlockSize</code> 函数限制<code>block_size</code>的值，减少后续分配需要对齐的内存浪费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> Arena::kMinBlockSize = <span class="number">4096</span>;           <span class="comment">// 最小为 4k</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> Arena::kMaxBlockSize = <span class="number">2u</span> &lt;&lt; <span class="number">30</span>;       <span class="comment">// 最大为 8k</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kAlignUnit = <span class="built_in">alignof</span>(<span class="type">max_align_t</span>); <span class="comment">// 按照 8 byte 对齐</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">OptimizeBlockSize</span><span class="params">(<span class="type">size_t</span> block_size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确保满足： Arena::kMinBlockSize &lt;= block_size &lt;= Arena::kMaxBlockSize</span></span><br><span class="line">  block_size = std::<span class="built_in">max</span>(Arena::kMinBlockSize, block_size);</span><br><span class="line">  block_size = std::<span class="built_in">min</span>(Arena::kMaxBlockSize, block_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保 block_size 是 8 的倍数</span></span><br><span class="line">  <span class="keyword">if</span> (block_size % kAlignUnit != <span class="number">0</span>) &#123;</span><br><span class="line">    block_size = (<span class="number">1</span> + block_size / kAlignUnit) * kAlignUnit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>inline_block_</code></p><p>字段<code>inline_block_</code> ，其中的<code>inline</code>语义是指这块内存分配在栈上，在地址上和<code>Arena</code>是连续的。这对于那些只需要分配小内存的操作具有优势，可以避免从堆上分配内存。当这块内存使用完毕，会再从堆上获取。</p></li><li><p><code>hugetlb_size_</code></p><p>字段<code>hugetlb_size_</code>，是默认情况下使用<code>mmap</code>给block分配的内存大小。如果 <code>hugetlb_size_ == 0</code>，则表示不使用<code>mmap</code>分配内存。</p><p>当然，<code>hugetlb_size_</code> 在构造函数中也是经过向上取整操作，变为 8 的倍数。</p></li></ul><p>现在，可以很好的阅读构造函数 <code>Arena::Arena</code> 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Arena::<span class="built_in">Arena</span>(<span class="type">size_t</span> block_size, </span><br><span class="line">             AllocTracker* tracker, </span><br><span class="line">             <span class="type">size_t</span> huge_page_size)</span><br><span class="line">    : <span class="built_in">kBlockSize</span>(<span class="built_in">OptimizeBlockSize</span>(block_size)) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(kBlockSize &gt;= kMinBlockSize &amp;&amp; kBlockSize &lt;= kMaxBlockSize &amp;&amp;</span><br><span class="line">         kBlockSize % kAlignUnit == <span class="number">0</span>);</span><br><span class="line">  alloc_bytes_remaining_ = <span class="built_in">sizeof</span>(inline_block_);</span><br><span class="line">  blocks_memory_ += alloc_bytes_remaining_;</span><br><span class="line">  <span class="comment">// 对齐侧指向了低地址</span></span><br><span class="line">  aligned_alloc_ptr_ = inline_block_;</span><br><span class="line">  <span class="comment">// 不对齐侧指向了高地址</span></span><br><span class="line">  unaligned_alloc_ptr_ = inline_block_ + alloc_bytes_remaining_;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  hugetlb_size_ = huge_page_size;</span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_ &amp;&amp; kBlockSize &gt; hugetlb_size_) &#123;</span><br><span class="line">    <span class="comment">// hugetlb_size_ 向上取整</span></span><br><span class="line">    hugetlb_size_ = ((kBlockSize - <span class="number">1U</span>) / hugetlb_size_ + <span class="number">1U</span>) * hugetlb_size_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)huge_page_size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateNewBlock"><a href="#Arena-AllocateNewBlock" class="headerlink" title="Arena::AllocateNewBlock"></a>Arena::AllocateNewBlock</h3><p><code>AllocateNewBlock</code> 函数比较普通，本质上就是使用 <code>new</code> 操作从操作系统获取内存。</p><p>这里面稍微有个<code>trick</code>的操作，是<code>blocks_.emplace_back(nullptr);</code> 这行，作用是在<code>blocks_</code>中预留一个指针大小的空间，即 <code>sizeof(Block*)</code>，出于内存泄露的考虑，使用了<code>emplace_back</code>，而不是<code>reserve</code>函数。</p><p>RocksDB 解释如下：</p><ul><li>如果<code>emplace_back</code> 函数抛出异常，不会发生内存泄露，因为此时还没使用<code>new</code>分配内存；</li><li>如果<code>new</code> 抛出异常（即<code>std::bad_alloc</code>异常），也不会发生内存泄露，因为在<code>blocks_</code>中预留的空间将会基于RAII语义被清除。</li></ul><p><code>AllocateNewBlock</code> 函数，直接使用<code>new</code>操作分配内存，不负责进行内存对齐操作。如果需要按照某个<code>alignment</code>大小进行对齐，得调用 <code>AllocateAligned</code>  函数，这个后面再说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///@return 返回指针，指向当前分配的 block</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Reserve space in `blocks_` before allocating memory via new.</span></span><br><span class="line">  <span class="comment">// Use `emplace_back()` instead of `reserve()` to let std::vector manage its</span></span><br><span class="line">  <span class="comment">// own memory and do fewer reallocations.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// - If `emplace_back` throws, no memory leaks because we haven&#x27;t called `new`</span></span><br><span class="line">  <span class="comment">//   yet.</span></span><br><span class="line">  <span class="comment">// - If `new` throws, no memory leaks because the vector will be cleaned up</span></span><br><span class="line">  <span class="comment">//   via RAII.</span></span><br><span class="line">  blocks_.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 分配内存</span></span><br><span class="line">  <span class="type">char</span>* block = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">  <span class="type">size_t</span> allocated_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ROCKSDB_MALLOC_USABLE_SIZE</span></span><br><span class="line">  allocated_size = <span class="built_in">malloc_usable_size</span>(block);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  allocated_size = block_bytes;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 增加已分配内存</span></span><br><span class="line">  blocks_memory_ += allocated_size;</span><br><span class="line">  <span class="comment">// 赋值</span></span><br><span class="line">  blocks_.<span class="built_in">back</span>() = block;</span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来解释下为何使用<code>reserve</code>可能会导致内存泄露，写法如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  blocks_.<span class="built_in">reserve</span>(<span class="number">1</span>);        <span class="comment">// 预留空间</span></span><br><span class="line">  <span class="type">char</span>* block = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">  <span class="type">size_t</span> allocated_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ROCKSDB_MALLOC_USABLE_SIZE</span></span><br><span class="line">  allocated_size = <span class="built_in">malloc_usable_size</span>(block);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  allocated_size = block_bytes;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  blocks_memory_ += allocated_size;</span><br><span class="line">  blocks_.<span class="built_in">emplace_back</span>(block); <span class="comment">// 抛出异常???</span></span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理由很简单：上面这个写法，如果在<code>emplace_back</code>的过程中抛出异常，那么 <code>block</code> 指向的内存将会泄露。</p><p>尽管<code>emplace_back</code>抛异常这种bad case极少出现，但也应该为RocksDB的细致点赞。</p><h3 id="Arena-AllocateFromHugePage"><a href="#Arena-AllocateFromHugePage" class="headerlink" title="Arena::AllocateFromHugePage"></a>Arena::AllocateFromHugePage</h3><p><code>Arena</code> 中有两种方式从操作系统获取内存：</p><ul><li><code>new</code>：即如<code>Arena::AllocateNewBlock</code> 函中数的实现；</li><li><code>mmap</code>：即如 <code>Arena::AllocateFromHugePage</code> 函数中的实现。</li></ul><p><code>mmap</code>、<code>munmap</code>函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>; </span><br><span class="line"><span class="comment">// 释放 mmap 分配的内存</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;   </span><br></pre></td></tr></table></figure><p>使用<code>mmap</code>分配内存，需要<code>linux</code>内核支持  <a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/maz/arm-platforms/+/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2/Documentation/vm/hugetlbpage.txt">HUGE_PAGE</a>，即当前linux内核具有 <code>MAP_HUGETLB</code> 标志位， 即可以如下操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///@return 返回指针，指向当前分配的 block</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateFromHugePage</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先使用 emplace_back 理由同上</span></span><br><span class="line">  huge_blocks_.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span> <span class="comment">/* addr */</span>, <span class="number">0</span> <span class="comment">/* length */</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 mmap 从 hugepage 中分配 bytes 个字节</span></span><br><span class="line">  <span class="type">void</span>* addr = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, </span><br><span class="line">                    bytes, </span><br><span class="line">                    (PROT_READ | PROT_WRITE),</span><br><span class="line">                    (MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB), <span class="comment">// 需要 MAP_HUGETLB 支持</span></span><br><span class="line">                    <span class="number">-1</span>, </span><br><span class="line">                    <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  huge_blocks_.<span class="built_in">back</span>() = <span class="built_in">MmapInfo</span>(addr, bytes);</span><br><span class="line">  blocks_memory_ += bytes;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(addr);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)bytes;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateFallback"><a href="#Arena-AllocateFallback" class="headerlink" title="Arena::AllocateFallback"></a>Arena::AllocateFallback</h3><p>好嘞，介绍完上面两种分配内存的措施，现在来看看统一上述两个操作的<code>AllocateFallback</code>函数。</p><p>当调用<code>AllocateFallback</code>函数时，是上层发现当前<code>block</code>中剩余的内存无法满足<code>bytes</code>个字节的需求，需要重新从操作系统获取内存。运行到<code>AllocateFallback</code>函数时，逻辑如下：</p><ul><li><p>如果所需的内存大小 <code>bytes</code> 超过了<code>kBlockSize / 4</code>，就直接从操作系统中获取<code>bytes</code>大小的内存，返回给<code>AllocateFallback</code>函数的调用方。那么就能避免浪费当前 block 中剩余的内存，这部分可以继续保留，供给下一次内存分配时使用。</p></li><li><p>否则，当前block中剩余的内存就将会被抛弃，重新从操作系统获中分配一个block的内存，供给上层使用。</p><p>此时，由 <code>bytes &lt;= kBlockSize / 4</code>，因此也降低了浪费，</p></li></ul><p>现在，顺着代码注释往下看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">bool</span> aligned)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    ++irregular_block_num;</span><br><span class="line">    <span class="comment">// 如果所需的内存大小 bytes 超过了 block 的1/4，那么就直接分配内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span>* block_head = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_) &#123;</span><br><span class="line">    <span class="comment">// mmap 分配的的一个block内存大小为 hugetlb_size_</span></span><br><span class="line">    size = hugetlb_size_;</span><br><span class="line">    block_head = <span class="built_in">AllocateFromHugePage</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (!block_head) &#123;</span><br><span class="line">    <span class="comment">// block_head == nullptr, 即当前linux内核不支 hugetlb</span></span><br><span class="line">    <span class="comment">// 那么使用 new 来分配内存</span></span><br><span class="line">    size = kBlockSize;</span><br><span class="line">    block_head = <span class="built_in">AllocateNewBlock</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//! 之前block未使用的内存就忽略了，</span></span><br><span class="line">  <span class="comment">//! 但不会内存泄露，因为会在析构函数 ~Arena 中释放</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前block划掉 bytes 个字节后，剩余的可用内存大小</span></span><br><span class="line">  alloc_bytes_remaining_ = size - bytes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (aligned) &#123;</span><br><span class="line">    aligned_alloc_ptr_ = block_head + bytes; <span class="comment">// 从低地址端增加 bytes 字节</span></span><br><span class="line">    unaligned_alloc_ptr_ = block_head + size;</span><br><span class="line">    <span class="comment">// 表示 [block_head, block_head + bytes) 可用</span></span><br><span class="line">    <span class="keyword">return</span> block_head;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    aligned_alloc_ptr_ = block_head; </span><br><span class="line">    unaligned_alloc_ptr_ = block_head + size - bytes; <span class="comment">// 尾部向前推动 bytes</span></span><br><span class="line">    <span class="comment">// 表示 [unaligned_alloc_ptr_, unaligned_alloc_ptr_ + bytes) 可用</span></span><br><span class="line">    <span class="keyword">return</span> unaligned_alloc_ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateAligned"><a href="#Arena-AllocateAligned" class="headerlink" title="Arena::AllocateAligned"></a>Arena::AllocateAligned</h3><p>最后，就是对外提供分配对齐内存的函数 <code>AllocateAligned</code>。</p><p>其输入参数<code>huge_page_size</code>，语义是在使用mmap分配内存时的自定义 <code>alignment</code>，如果 <code>huge_page_size</code>  为 0，只是表示此时不需要自定义的<code>alignment</code>，使用默认的<code>kAlignUnit</code>即可。</p><p>换句话说，当需要自定义<code>alignment</code>时，RcoskDb 是准备使用<code>mmap</code>来分配内存。</p><p>当使用默认的<code>kAlignUnit</code>，如果当前block中剩余的可用内存能满足need个字节（need个字节，是bytes字节按照<code>kAlignUnit</code>对齐的后的大小），则继续从当前block中划分出去need个字节，否则就使用上述的<code>AllocateFallback</code>函数，重新从操作系统分配内存。</p><p>现在，顺着代码注释向下看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">size_t</span> huge_page_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Logger* logger)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Pointer size should be a power of 2</span></span><br><span class="line">  <span class="built_in">assert</span>((kAlignUnit &amp; (kAlignUnit - <span class="number">1</span>)) == <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义的内存对齐值 huge_page_size，只使用mmap来分配</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (huge_page_size &gt; <span class="number">0</span> &amp;&amp; bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(logger != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 将 bytes 向上调整到 huge_page_size 的整倍数</span></span><br><span class="line">    <span class="type">size_t</span> reserved_size = ((bytes - <span class="number">1U</span>) / huge_page_size + <span class="number">1U</span>) * huge_page_size;</span><br><span class="line">    <span class="built_in">assert</span>(reserved_size &gt;= bytes);</span><br><span class="line">    <span class="type">char</span>* addr = <span class="built_in">AllocateFromHugePage</span>(reserved_size);</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">ROCKS_LOG_WARN</span>(logger,</span><br><span class="line">                     <span class="string">&quot;AllocateAligned fail to allocate huge TLB pages: %s&quot;</span>,</span><br><span class="line">                     <span class="built_in">errnoStr</span>(errno).<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)huge_page_size;</span><br><span class="line">  (<span class="type">void</span>)logger;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面则使用默认的 kAlignUnit 对齐大小</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> current_mod =</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(aligned_alloc_ptr_) &amp; (kAlignUnit - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 计算距离对齐还差几个字节</span></span><br><span class="line">  <span class="type">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : kAlignUnit - current_mod);</span><br><span class="line">  <span class="comment">// 对齐后需分配的字节数</span></span><br><span class="line">  <span class="type">size_t</span> needed = bytes + slop;  </span><br><span class="line">  <span class="type">char</span>* result;</span><br><span class="line">  <span class="comment">// 当前block中的剩余内存是否能满足此次 needed 个字节需求</span></span><br><span class="line">  <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="comment">// result 调整到对齐后的位置</span></span><br><span class="line">    result = aligned_alloc_ptr_ + slop; </span><br><span class="line">    <span class="comment">// 调整到对齐后的位置</span></span><br><span class="line">    aligned_alloc_ptr_ += needed;  </span><br><span class="line">    <span class="comment">// block中剩余的字节数</span></span><br><span class="line">    alloc_bytes_remaining_ -= needed;   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前 block 剩余的内存不足，则从操作系统获取</span></span><br><span class="line">    result = <span class="built_in">AllocateFallback</span>(bytes, <span class="literal">true</span> <span class="comment">/* aligned */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>((<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(result) &amp; (kAlignUnit - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>by the way</strong></p><p>这里稍微总结下，如何向上调整、计算对齐后的地址。</p><p>实际上计算的方法有很多种，但是都符合上一期 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析] 最后提到了一点：本质上就是以「<code>alignment</code>进制」向上（下）取为<code>alignment</code>的整倍数。</p><p>比如，在十进制下，12向上取整为10的倍数，即20。</p><p>理解了这一层之后，再来看看下面几个计算方式：</p><ul><li><p>case 1：<code>size_t aligned = ((bytes - 1U) / alignment + 1U) * alignment</code></p><p>单纯地将<code>bytes</code>向上调整为<code>alignment</code>的整倍数，可以实现为  <code>(bytes / alignment + 1U) * alignment</code>，那为啥要 <code>- 1</code> 呢？</p><p>如果<code>bytes</code>本身就已是<code>alignment</code>的整数，按照这 native 实现，会无端将<code>bytes</code>增加了<code>alignment</code>。为了应对这种情况，需要先减少1。</p><p>此外，在 <code>Arena::Arena</code> 中调整<code>hugetlb_size_</code> 时，也是如此计算。而在<code>OptimizeBlockSize</code>函数中，调整<code>block_size</code>时，可以确定<code>block_size</code> 不是 <code>kAlignUnit</code>的整数时，就可将<code>-1</code>去掉，简化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block_size % kAlignUnit != <span class="number">0</span>) &#123;</span><br><span class="line">  block_size = (<span class="number">1</span> + block_size / kAlignUnit) * kAlignUnit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>case 2：<code>size_t aligned = (bytes - 1u + alignment) &amp; -alignment</code></p><p>这种实现，利用位位运算将余数清除，效率较高，这也是<code>std::align</code> 函数的实现方式，这在 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析] 分析过，这里顺带再解释下。</p><p>其中 <code>alignment</code> 是无符号数，<code>-alignment</code> 的值实际上是 <code>::pow(2, n) - alignment</code>。那么<code>bytes - 1u + alignment</code> 对 <code>-alignment</code> 取 <code>&amp;</code>操作，就能保证 <code>bytes - 1u + alignment</code> 的高位不变，而小于<code>alignment</code> 的余数全部清除。</p></li></ul><p>万变不离其宗，理解了这个逻辑，无论是向上调整、亦或是向下调整，都能很好理解了。</p><h3 id="Arena-Allocate"><a href="#Arena-Allocate" class="headerlink" title="Arena::Allocate"></a>Arena::Allocate</h3><p>讲完了上面<code>AllocateAligned</code>函数之后，再看<code>Allocate</code>函数，就非常好理解了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 如果当前block剩余足够的内存，则直接分配</span></span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    unaligned_alloc_ptr_ -= bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> unaligned_alloc_ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不用对齐</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes, <span class="literal">false</span> <span class="comment">/* unaligned */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-Arena-1"><a href="#Arena-Arena-1" class="headerlink" title="Arena::~Arena"></a>Arena::~Arena</h3><p>释放所有已分配的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Arena::~<span class="built_in">Arena</span>() &#123;</span><br><span class="line">  <span class="comment">// 释放所有使用 new 分配的内存</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; block : blocks_) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] block;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; mmap_info : huge_blocks_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mmap_info.addr_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放所有使用 mmap 分配的内存</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">munmap</span>(mmap_info.addr_, mmap_info.length_);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO(sdong): Better handling</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Say-Something"><a href="#Say-Something" class="headerlink" title="Say Something"></a>Say Something</h2><p>一个优秀的开源项目，其单元测试（unitest）也是很好的学习资料。尤其对于RocksDB这类比较大的项目，无法下手的话，可以先从单元测试着手。</p><p>下一期，讲解下多线程内存分配器的设计，会更加硬核，敬请期待。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天，就开始逐步更新剖析 RocksDB 源码的博客。思前想后，准备自下而上，因此还是从内存分配器开始叭。&lt;/p&gt;
&lt;p&gt;在 RocksDB 中主要有两类内存分配器&lt;code&gt;MemoryAllocator&lt;/code&gt;、&lt;code&gt;Allocator&lt;/code&gt;。&lt;/p</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="RocksDb" scheme="https://szza.github.io/tags/RocksDb/"/>
    
  </entry>
  
  <entry>
    <title>内存对齐之 alignof、alignas 、aligned_storage、align 剖析</title>
    <link href="https://szza.github.io/2022/01/01/C++/align/"/>
    <id>https://szza.github.io/2022/01/01/C++/align/</id>
    <published>2022-01-01T06:09:54.000Z</published>
    <updated>2023-08-07T09:25:11.389Z</updated>
    
    <content type="html"><![CDATA[<p>关于内存对齐，有诸多好处，因此常常在分配内存时也会将内存对齐这一因素纳入考量。</p><p>这一节，来讲下内存对齐以及C++11中关于内存对齐引入的<code>alignof</code>、<code>alignas</code>、<code>std::aligned_storage</code>、<code>std::align</code> ，其中前两个为关键字，后两个分别为类和函数。</p><h2 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h2><p>我们知道，C++中的内置的基础类型，比如<code>char</code>、<code>int</code>、<code>float</code>、<code>double</code>，在内存布局上都是按照其 <code>sizeof</code> 大小进行对齐（alignment）。</p><p>什么叫对齐？</p><p>比如，<code>sizoef(int)</code> 值为 4，如果满足内存对齐要求，那么int类型变量<code>a</code>的地址<code>&amp;a</code>对4取余的结果应该是0。</p><p>下面提供一个编译期就能检测内存对齐的宏 <code>CHECK_ALIGN</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_ALIGN(ptr, alignment)                       \</span></span><br><span class="line"><span class="meta">  do&#123;                                                     \</span></span><br><span class="line"><span class="meta">    constexpr size_t status                               \</span></span><br><span class="line"><span class="meta">       = reinterpret_cast<span class="string">&lt;uintptr_t&gt;</span>(ptr) % alignment;    \</span></span><br><span class="line"><span class="meta">    static_assert(status == 0, <span class="string">&quot;ptr must be aligned&quot;</span>);    \</span></span><br><span class="line"><span class="meta">  &#125;while(0)                                               \</span></span><br></pre></td></tr></table></figure><p>下面我们来校验内置类型的内存对齐大小确实等于其<code>sizoef(T)</code>值，demo如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">long</span> l ;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;c, <span class="built_in">sizeof</span>(c));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;i, <span class="built_in">sizeof</span>(i));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;l, <span class="built_in">sizeof</span>(l));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;f, <span class="built_in">sizeof</span>(f));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;i, <span class="built_in">sizeof</span>(l)); <span class="comment">// 编译错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述demo中的 <code>CHECK_ALIGN(&amp;i, sizeof(l));</code> 会导致编译错误，因为<code>int</code>类型变量的内存对齐大小要求是4，而<code>long</code>在gcc下是8个字节，即<code>sizoef(l)</code>为8，故而编译失败。</p><p>到此，我相信你应该明白何为「内存对齐」了。</p><h2 id="alignof"><a href="#alignof" class="headerlink" title="alignof"></a>alignof</h2><p>C++11引入的关键字<code>alignof</code>，可直接获取类型<code>T</code>的内存对齐要求。<code>alignof</code>的返回值类型是<code>size_t</code>，用法类似于<code>sizeof</code>。</p><p>下面先来看看<code>alignof</code>的用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW_SIZEOF_AND_ALIGNOF(T)                                   \</span></span><br><span class="line"><span class="meta">  do &#123;                                                               \</span></span><br><span class="line"><span class="meta">    std::cout &lt;&lt; <span class="string">&quot;sizeof(&quot;</span> &lt;&lt; #T &lt;&lt; <span class="string">&quot;):\t&quot;</span> &lt;&lt; sizeof(T) &lt;&lt; <span class="string">&quot;,\t&quot;</span>     \</span></span><br><span class="line"><span class="meta">              &lt;&lt; <span class="string">&quot;alignof(&quot;</span> &lt;&lt; #T &lt;&lt; <span class="string">&quot;):\t&quot;</span> &lt;&lt; alignof(T)            \</span></span><br><span class="line"><span class="meta">              &lt;&lt; std::endl;                                          \</span></span><br><span class="line"><span class="meta">  &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">char</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">int</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">long</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">float</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">double</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，这也是符合前文关于基础类型内存对齐的论述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(char):   1,      alignof(char):  1</span><br><span class="line">sizeof(int):    4,      alignof(int):   4</span><br><span class="line">sizeof(long):   8,      alignof(long):  8</span><br><span class="line">sizeof(<span class="built_in">float</span>):  4,      alignof(<span class="built_in">float</span>): 4</span><br><span class="line">sizeof(double): 8,      alignof(double):8</span><br></pre></td></tr></table></figure><p>好，到此我相信你已经对内存对齐和<code>alignof</code>有了基本了解。下面我们来看看类的内存对齐。</p><p>现在有类<code>Foo</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1; </span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>考虑下<code>alignof(Foo)</code>和<code>sizeof(Foo)</code>分别会是多少，即下面的demo会输出？？？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(Foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Think Again~~~~</p><p>3</p><p>2</p><p>1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(Foo):    24,     alignof(Foo):   8</span><br></pre></td></tr></table></figure><p>嗯？怎么会是这个结果？</p><p>为了更好地解释这个结果，我准备借助<code>offsetof</code>函数，来获取成员变量距离类起始地址的偏移量，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Offset of member MEMBER in a struct of type TYPE. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(OBJECT_TYPE, MEMBER) __builtin_offsetof (OBJECT_TYPE, MEMBER)</span></span><br></pre></td></tr></table></figure><p>好，现在看下如下代码，并猜测下输出？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">offsetof</span>(Foo, c)  &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">offsetof</span>(Foo, i1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span> </span><br><span class="line">            &lt;&lt; <span class="built_in">offsetof</span>(Foo, i2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">offsetof</span>(Foo, l)  &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">0   <span class="comment"># c 的偏移量为 0 </span></span><br><span class="line">4   <span class="comment"># i1 的偏移量为 4， c  -&gt; i1 中间填充了 3个字节，才满足 4 字节的内存对齐要求</span></span><br><span class="line">8   <span class="comment"># i2 的偏移量为 8,  i1 -&gt; i2 无填充</span></span><br><span class="line">16  <span class="comment"># l 的偏移量为 16， i2 -&gt; l  中间填充了4个字节，才满足8字节的内存对齐要求</span></span><br></pre></td></tr></table></figure><p>好，到此，我准备基于这个输出来解释<code>alignof</code>了。</p><p>对于<code>Foo</code>而言，所谓内存对齐，即<code>Foo</code>中每个字段都要满足内存对齐。而内存对齐最严格（即对齐字节数最大）的字段满足了，其他的字段也就满足了。</p><p>假设现在有三个起始地址，分别是 0、1、4，我们来看看是否都能满足<code>Foo</code>中所有字段的内存对齐要求。</p><p>起始地址分别0、1、4，各个字段的地址如下三列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;   </span><br><span class="line">  <span class="type">char</span> c;     <span class="comment">// 0  |  1  |  4</span></span><br><span class="line">  <span class="type">int</span> i1;     <span class="comment">// 4  |  5  |  8</span></span><br><span class="line">  <span class="type">int</span> i2;     <span class="comment">// 8  |  9  |  12 </span></span><br><span class="line">  <span class="type">long</span> l;     <span class="comment">// 16 |  17 |  20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的右侧三列结果可以看出，只有起始地址为0（8的整倍数）的恰好能满足所有字段内存对齐的要求。因此，<code>alignof(Foo)</code>输出为8。</p><h2 id="alignas"><a href="#alignas" class="headerlink" title="alignas"></a>alignas</h2><p>上面讲述的内存对齐要求都是默认情况下的，有时候考虑到cacheline、以及向量化操作，可能会需要改变一个类的<code>alignof</code>值。</p><p>怎么办？</p><p>在C++11之前，需要依赖靠编译器的扩展指令，C++11之后可以借助<code>alignas</code>关键字。</p><blockquote><p>比如，在C++11之前，gcc实现 <code>alignas(alignment)</code> 效果的方式为  <code>__attribute__((__aligned__((alignment)))</code></p></blockquote><p>仍然以上述的<code>Foo</code>为例子，不过此时你希望<code>Foo</code>对象的起始地址总是32的倍数，C++11之后借助<code>alignas</code>关键字，可以如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>) Foo &#123; </span><br><span class="line">  <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1; </span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  Foo foo;</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;foo, <span class="built_in">alignof</span>(foo));</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(Foo);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">0x16d6f34e0</span><br><span class="line">sizeof(Foo):    32,     alignof(Foo):   32</span><br></pre></td></tr></table></figure><p>说完<code>alignas</code>的基础用法，下面说下使用<code>alignas</code>时的注意事项，即<code>alignas(alignment)</code>中的<code>alignment</code>也不是随意写的，对于类型<code>T</code>，需要满足如下两个条件。</p><h3 id="1-alignment-alignof-T"><a href="#1-alignment-alignof-T" class="headerlink" title="1. alignment &gt;&#x3D; alignof(T)"></a>1. alignment &gt;&#x3D; alignof(T)</h3><p>仍然以<code>Foo</code>为例，在没有<code>alignas</code>修饰时，默认的Foo的内存对齐要求<code>alignof(Foo)</code>为8，现在尝试使用<code>alignas</code>让<code>Foo</code>的对齐要求为4，操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">4</span>) Foo &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1;</span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时 <code>SHOW_SIZEOF_AND_ALIGNOF(Foo);</code>的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(Foo):    24,     alignof(Foo):   8</span><br></pre></td></tr></table></figure><p>可以看出，此时的<code>alignas</code>是失效的，在其他编译器下也许直接编译失败。</p><h3 id="2-alignment-pow-2-N"><a href="#2-alignment-pow-2-N" class="headerlink" title="2. alignment &#x3D;&#x3D; pow(2, N)"></a>2. alignment &#x3D;&#x3D; pow(2, N)</h3><p>即<code>alignas</code> 指定的大小<code>alignment</code>必须是2的正数幂（<code>N&gt;0</code>），否则也是失效，在有些编译器下也许直接编译失败。</p><p>仍然以<code>Foo</code>为例子，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">9</span>) Foo &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1;</span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">main.cc:<span class="number">20</span>:<span class="number">19</span>: error: requested alignment <span class="string">&#x27;9&#x27;</span> is <span class="keyword">not</span> a positive power of <span class="number">2</span></span><br><span class="line">   <span class="number">20</span> | <span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">9</span>) Foo &#123;</span><br><span class="line">      |                   ^~~</span><br></pre></td></tr></table></figure><p>好，到此，我想你应该大致理解了<code>alignof</code>和<code>alignas</code>两个关键字，更多用法可以参&#96;<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a>。</p><h2 id="std-aligned-storage"><a href="#std-aligned-storage" class="headerlink" title="std::aligned_storage"></a>std::aligned_storage</h2><p>在C++11中，也引入了一个满足内存对齐要求的静态内存分配类<code>std::aligned_storage</code>，其类模板原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &lt;type_traits&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; std::<span class="type">size_t</span> Len, </span><br><span class="line">          std::<span class="type">size_t</span> Align = <span class="comment">/*default-alignment*/</span> &gt;</span><br><span class="line"><span class="keyword">struct</span> aligned_storage;</span><br></pre></td></tr></table></figure><p>类<code> std::aligned_storage</code>对象构造完成时，即分配了长度为<code>Len</code>个字节的内存，且该内存满足大小为 <code>Align</code> 的对齐要求。</p><p>下面，我们先来看看 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a> 给的一个demo，来熟悉下怎么使用<code>std::aligned_storage</code>。</p><p>类 <code>StaticVector</code> ，是一个满足内存对齐要求的静态数组，模板参数<code>T</code>是元素类型，<code>N</code>是数组元素个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticVector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StaticVector</span>() &#123; </span><br><span class="line">      std::cout &lt;&lt; <span class="built_in">alignof</span>(T) &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(T)&lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; N; ++idx) &#123; </span><br><span class="line">        std::cout &lt;&lt; &amp;data[idx] &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">StaticVector</span>() &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> pos = <span class="number">0</span>; pos &lt; m_size; ++pos) &#123;</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(data+pos)-&gt;~<span class="built_in">T</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; </span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(m_size &gt;= N) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::bad_alloc&#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">new</span>(data+m_size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">      ++m_size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> T*&gt;(data+pos);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type data[N]; // C++11</span></span><br><span class="line">  std::<span class="type">aligned_storage_t</span>&lt;<span class="built_in">sizeof</span>(T), <span class="built_in">alignof</span>(T)&gt; data[N];        <span class="comment">// c++14</span></span><br><span class="line">  <span class="type">size_t</span> m_size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类<code>StaticVector</code>的使用如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>) Foo &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1; </span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    StaticVector&lt;std::string, <span class="number">2</span>&gt; v1;</span><br><span class="line">    v1.<span class="built_in">emplace_back</span>(<span class="number">5</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    std::cout &lt;&lt; v1[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    StaticVector&lt;Foo, <span class="number">2</span>&gt;v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在输出前，我们预测下：</p><ul><li><code>std:::string</code> 的<code>alignof</code>值是8，那么<code>StaticVector</code>分配的两个<code>std::string</code>对象地址，都应该是8的倍数</li><li><code>Foo</code>的<code>alignof</code>值是32，那么<code>StaticVector</code>为<code>Foo</code> 分配的两个<code>Foo</code>对象地址，都是32的倍数，</li></ul><p>好，现在我们来看下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align_stroe.cc -o as &amp;&amp; ./as</span><br><span class="line">8/32</span><br><span class="line">0x16b5734c0</span><br><span class="line">0x16b5734e0</span><br><span class="line">*****</span><br><span class="line">32/32</span><br><span class="line">0x16b573470</span><br><span class="line">0x16b573490</span><br></pre></td></tr></table></figure><p>所以，到此，你也许理解了<code>std::aligned_storage</code> 中<code>aligned</code>的含义，即每个对象都是经过内存对齐的。</p><p>熟悉了<code>std::aligned_storage</code> 的用法，现在来看看他的实现叭，毕竟没人愿意只做个调包侠（滑稽脸）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in std namespace;</span></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> _Len&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__aligned_storage_msa</span> &#123;</span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">__type</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> __data[_Len];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__attribute__</span>((__aligned__)) &#123; &#125; __align;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> _Len, </span><br><span class="line">      std::<span class="type">size_t</span> _Align = <span class="built_in">alignof</span>(<span class="keyword">typename</span> __aligned_storage_msa&lt;_Len&gt;::__type)&gt;</span><br><span class="line"><span class="keyword">struct</span> aligned_storage &#123;</span><br><span class="line">  <span class="keyword">union</span> type &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> __data[_Len];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">alignas</span>(_Align) &#123; &#125; __align;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>std::aligned_storage</code> 内部，是通过一个<code>union</code>来实现的：</p><ul><li><code>unsigned char __data[_Len];</code>：这一行保证了分配的内存大小是<code>_Len</code>个字节</li><li><code>struct alignas(_Align) &#123; &#125; __align;</code> ：这一行保证了分配的内存是按照<code>Align</code> 大小进行对齐的。</li></ul><p>其中，第二点很好理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">char</span> aligned_data[<span class="number">16</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unaligned: &quot;</span>&lt;&lt; <span class="built_in">alignof</span>(data) &lt;&lt; <span class="string">&quot;, aligned: &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(aligned_data) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unaligned: <span class="number">1</span>, aligned: <span class="number">16</span></span><br></pre></td></tr></table></figure><p>因此，如果只有<code>unsigned char __data[_Len]；</code>，无法保证内存对齐，需要<code>struct alignas(_Align) &#123; &#125; __align</code>的辅助。</p><p>最后再提下 <code>std::__aligned_storage_msa</code>的必要性：在构造类<code>std::aligned_storage</code>对象时，如果没有指定类的第二个模板参数<code>_Align</code>，即内存对齐大小，由<code>std::__aligned_storage_msa</code>为你设置默认的内存对齐大小。</p><p>可以看出，在 <code>std::__aligned_storage_msa</code> 的实现中，<code>__attribute__((__aligned__))</code> 后面是没有参数的，此时gcc即会根据平台生成默认内存对齐大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">1</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">4</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">16</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">32</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align_stroe.cc -o as &amp;&amp; ./as</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>这个大小就是gcc编译器默认的内存大小。</p><h2 id="std-align"><a href="#std-align" class="headerlink" title="std::align"></a>std::align</h2><p>类<code>std::aligned_storage</code> 是一个静态的内存对齐分配器，即在类<code>std::aligned_storage</code>对象构造完时，就已满足设定内存大小、内存对齐要求，但是如果现在有一块内存，想从中取出一块符合某对齐要求的内存，咋办？</p><p>此时就可以使用<code>std::align</code>函数，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param  alignment 是想要分配的内存符合的内存对齐大小</span></span><br><span class="line"><span class="comment">/// @param  size 想要分配内存的大小</span></span><br><span class="line"><span class="comment">/// @param  ptr 是个输入输出参数，输入时指向待使用的内存，输出时调整为符合alignment对齐要求的内存地址</span></span><br><span class="line"><span class="comment">/// @param  space 是ptr指向的内存剩余的空间</span></span><br><span class="line"><span class="comment">/// @return 如果 ptr 经过调整后能满足大小为 alignment 的对齐要求，则返回ptr的值，否则返回 nullptr</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">align</span><span class="params">( std::<span class="type">size_t</span> alignment,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::<span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">void</span>*&amp; ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::<span class="type">size_t</span>&amp; space)</span></span>;</span><br></pre></td></tr></table></figure><p>下面，我们继续先来看看 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a> 中提供的一个demo，熟悉下怎么使用<code>std::align</code>这个函数。</p><p>类<code>Arena</code>内已有一块缓冲区<code>buffer</code>，每次调用<code>AlignedAllocate&lt;T&gt;(size_t alignment)</code>函数时，即需要从<code>buffer</code>中取出大小为<code>sizeof(T)</code>的一块内存<code>ptr</code>，<code>AlignedAllocate</code>函数的输入参数<code>alignment</code>指定了获得的内存<code>ptr</code>满足的内存对齐要求。</p><p>现在来看看实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Arena</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[N];</span><br><span class="line">  <span class="type">void</span>* ptr;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Arena</span>() : <span class="built_in">ptr</span>(buffer), <span class="built_in">size</span>(N) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @return 返回的指针满足大小为 alignment 的内存对齐要求</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T* <span class="title">AlignedAllocate</span><span class="params">(<span class="type">size_t</span> alignment = <span class="keyword">alignof</span>(T))</span> </span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;ptr: &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(ptr) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (std::<span class="built_in">align</span>(alignment, <span class="built_in">sizeof</span>(T), ptr, size)) &#123;</span><br><span class="line">          T* result = <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">          ptr = (<span class="type">char</span>*)ptr + <span class="built_in">sizeof</span>(T);</span><br><span class="line">          size -= <span class="built_in">sizeof</span>(T);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若无，则返回 nullptr</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Arena&lt;<span class="number">64</span>&gt; arena;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* p1 = arena.<span class="built_in">AlignedAllocate</span>&lt;<span class="type">char</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p1) *p1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocated a char at &quot;</span> &lt;&lt; (<span class="type">void</span>*)p1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span>* p2 = arena.<span class="built_in">AlignedAllocate</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p2) *p2 = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocated an int at &quot;</span> &lt;&lt; (<span class="type">void</span>*)p2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span>* p3 = arena.<span class="built_in">AlignedAllocate</span>&lt;<span class="type">int</span>&gt;(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> (p3) *p3 = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocated an int at &quot;</span> &lt;&lt; (<span class="type">void</span>*)p3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下面的输出可以看出，<code>AlignedAllocate</code> 函数返回的内存地址都是符合设定的内存对齐要求的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align.cc -o align &amp;&amp; ./align </span><br><span class="line">ptr: 0x16fc2b4b8, allocated a char at 0x16fc2b4b8     <span class="comment"># 1 byte 内存对齐，指针无须调整</span></span><br><span class="line">ptr: 0x16fc2b4b9, allocated an int at 0x16fc2b4bc     <span class="comment"># 4 byte 内存对齐，指针调整了 3 个字节</span></span><br><span class="line">ptr: 0x16fc2b4c0, allocated an int at 0x16fc2b4c0     <span class="comment"># 32 byte 内存对齐，指针无须调整</span></span><br></pre></td></tr></table></figure><p>最后，我们再来看看<code>std::align</code>函数的实现，稍微简化后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &lt;memory&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="title">align</span><span class="params">(<span class="type">size_t</span> __align, <span class="type">size_t</span> __size, <span class="type">void</span> *&amp;__ptr, <span class="type">size_t</span> &amp;__space)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> __intptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(__ptr);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> __aligned = (__intptr - <span class="number">1u</span> + __align) &amp; -__align;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> __diff = __aligned - __intptr;</span><br><span class="line">  <span class="comment">// 如果没有剩余的空间，直接返回 nullptr</span></span><br><span class="line">  <span class="keyword">if</span> ((__size + __diff) &gt; __space)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">   __space -= __diff;</span><br><span class="line">   <span class="keyword">return</span> __ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(__aligned);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::align</code>的实现里，最为关键的一步，即计算对齐后的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> __aligned = (__intptr - <span class="number">1u</span> + __align) &amp; -__align;</span><br></pre></td></tr></table></figure><p>对于这一步，本来想写个证明啥的，还是举个例子来解释比较通俗。</p><p>按照<code>__align</code>大小进行内存对齐，即可视为按<code>__align</code>进制向上取整。</p><p>什么意思呢？</p><p>比如说，现在按照10进制对齐，有地址12，想让12向上调整到10的倍数，怎么做？</p><ol><li>先加上一个步长：<code>12 + 10 - 1 = 21</code></li><li>将余数1清掉：<code>21 &amp;  (-10) = 20</code>。这一步中，<code>-10</code> 的本质就是保证高位不变，将低位全部变为0，取<code>&amp;</code>之后，取余就全部清理了。</li></ol><p>现在的内存对齐，本质上也是向上取整：<code>__intptr - 1u + __align</code>是为了向前一个步长，再对  <code>-__align</code>取<code>&amp;</code>，来清除余数。</p><p>关于内存对齐，很多项目里都有涉及，最近在阅读RocksDB也再次遇到，于是乎就找了个契机写下了这篇博客，后续会尝试更新RocksDB。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于内存对齐，有诸多好处，因此常常在分配内存时也会将内存对齐这一因素纳入考量。&lt;/p&gt;
&lt;p&gt;这一节，来讲下内存对齐以及C++11中关于内存对齐引入的&lt;code&gt;alignof&lt;/code&gt;、&lt;code&gt;alignas&lt;/code&gt;、&lt;code&gt;std::aligned_s</summary>
      
    
    
    
    <category term="Timeline" scheme="https://szza.github.io/categories/Timeline/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
</feed>
