<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>szza</title>
  
  <subtitle>look code art</subtitle>
  <link href="https://szza.github.io/atom.xml" rel="self"/>
  
  <link href="https://szza.github.io/"/>
  <updated>2025-10-23T13:00:42.964Z</updated>
  <id>https://szza.github.io/</id>
  
  <author>
    <name>fibonaccii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剖析 ETCD.lessor</title>
    <link href="https://szza.github.io/2024/09/29/ETCD/4_lessor/"/>
    <id>https://szza.github.io/2024/09/29/ETCD/4_lessor/</id>
    <published>2024-09-29T15:10:00.000Z</published>
    <updated>2025-10-23T13:00:42.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lessor"><a href="#Lessor" class="headerlink" title="Lessor"></a>Lessor</h1><p><code>Lessor</code> 是 ETCD 中负责管理租约 (Lease) 的核心组件。租约机制是 ETCD 实现分布式锁、会话管理和自动过期清理的重要基础。<code>Lessor</code> 提供了租约的创建、续期、撤销、过期处理等完整功能。</p><h2 id="2-核心接口设计"><a href="#2-核心接口设计" class="headerlink" title="2. 核心接口设计"></a>2. 核心接口设计</h2><h3 id="2-1-Lessor-接口"><a href="#2-1-Lessor-接口" class="headerlink" title="2.1 Lessor 接口"></a>2.1 Lessor 接口</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lessor <span class="keyword">interface</span> &#123;</span><br><span class="line">    <span class="comment">// 设置范围删除器和检查点器</span></span><br><span class="line">    SetRangeDeleter(rd RangeDeleter)</span><br><span class="line">    SetCheckpointer(cp Checkpointer)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 租约生命周期管理</span></span><br><span class="line">    Grant(id LeaseID, ttl <span class="type">int64</span>) (*Lease, <span class="type">error</span>)     <span class="comment">// 创建租约</span></span><br><span class="line">    Revoke(id LeaseID) <span class="type">error</span>                         <span class="comment">// 撤销租约</span></span><br><span class="line">    Renew(id LeaseID) (<span class="type">int64</span>, <span class="type">error</span>)                 <span class="comment">// 续期租约</span></span><br><span class="line">    Checkpoint(id LeaseID, remainingTTL <span class="type">int64</span>) <span class="type">error</span> <span class="comment">// 检查点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 租约项管理</span></span><br><span class="line">    Attach(id LeaseID, items []LeaseItem) <span class="type">error</span>      <span class="comment">// 附加项到租约</span></span><br><span class="line">    Detach(id LeaseID, items []LeaseItem) <span class="type">error</span>      <span class="comment">// 从租约分离项</span></span><br><span class="line">    GetLease(item LeaseItem) LeaseID                 <span class="comment">// 获取项的租约ID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主从管理 callback</span></span><br><span class="line">    Promote(extend time.Duration)                    <span class="comment">// 提升为主节点时的 callback</span></span><br><span class="line">    Demote()                                         <span class="comment">// 降级为从节点的 callback</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询操作</span></span><br><span class="line">    Lookup(id LeaseID) *Lease                        <span class="comment">// 查找租约</span></span><br><span class="line">    Leases() []*Lease                                <span class="comment">// 获取所有租约</span></span><br><span class="line">    ExpiredLeasesC() &lt;-<span class="keyword">chan</span> []*Lease                 <span class="comment">// 过期租约通道</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 恢复和停止</span></span><br><span class="line">    Recover(b backend.Backend, rd RangeDeleter)      <span class="comment">// 从后端恢复</span></span><br><span class="line">    Stop()                                           <span class="comment">// 停止服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-关键数据结构"><a href="#2-2-关键数据结构" class="headerlink" title="2.2 关键数据结构"></a>2.2 关键数据结构</h3><h4 id="Lease-结构体"><a href="#Lease-结构体" class="headerlink" title="Lease 结构体"></a>Lease 结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lease <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID           LeaseID                    <span class="comment">// 租约ID</span></span><br><span class="line">    ttl          <span class="type">int64</span>                      <span class="comment">// 生存时间（秒）</span></span><br><span class="line">    remainingTTL <span class="type">int64</span>                      <span class="comment">// 剩余生存时间</span></span><br><span class="line">    expiryMu     sync.RWMutex               <span class="comment">// 保护过期时间的互斥锁</span></span><br><span class="line">    expiry       time.Time                  <span class="comment">// 过期时间</span></span><br><span class="line">    mu           sync.RWMutex               <span class="comment">// 保护项集合的互斥锁</span></span><br><span class="line">    itemSet      <span class="keyword">map</span>[LeaseItem]<span class="keyword">struct</span>&#123;&#125;     <span class="comment">// 附加的项集合</span></span><br><span class="line">    revokec      <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;              <span class="comment">// 撤销完成信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lessor-结构体"><a href="#lessor-结构体" class="headerlink" title="lessor 结构体"></a>lessor 结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> lessor <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu                      sync.RWMutex</span><br><span class="line">    demotec                 <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;              <span class="comment">// 降级信号通道</span></span><br><span class="line">    leaseMap                <span class="keyword">map</span>[LeaseID]*Lease         <span class="comment">// 租约映射</span></span><br><span class="line">    leaseExpiredNotifier    *LeaseExpiredNotifier      <span class="comment">// 过期通知器</span></span><br><span class="line">    leaseCheckpointHeap     LeaseQueue                 <span class="comment">// 检查点堆</span></span><br><span class="line">    itemMap                 <span class="keyword">map</span>[LeaseItem]LeaseID      <span class="comment">// 项到租约的映射</span></span><br><span class="line">    rd                      RangeDeleter               <span class="comment">// 范围删除器</span></span><br><span class="line">    cp                      Checkpointer               <span class="comment">// 检查点器</span></span><br><span class="line">    b                       backend.Backend            <span class="comment">// 后端存储</span></span><br><span class="line">    minLeaseTTL             <span class="type">int64</span>                      <span class="comment">// 最小TTL</span></span><br><span class="line">    leaseRevokeRate         <span class="type">int</span>                        <span class="comment">// 撤销速率限制</span></span><br><span class="line">    expiredC                <span class="keyword">chan</span> []*Lease              <span class="comment">// 过期租约通道</span></span><br><span class="line">    stopC                   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;              <span class="comment">// 停止信号</span></span><br><span class="line">    doneC                   <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;              <span class="comment">// 完成信号</span></span><br><span class="line">    checkpointInterval      time.Duration              <span class="comment">// 检查点间隔</span></span><br><span class="line">    expiredLeaseRetryInterval time.Duration            <span class="comment">// 过期重试间隔</span></span><br><span class="line">    checkpointPersist       <span class="type">bool</span>                       <span class="comment">// 是否持久化检查点</span></span><br><span class="line">    cluster                 cluster                    <span class="comment">// 集群版本信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-核心功能设计"><a href="#3-核心功能设计" class="headerlink" title="3. 核心功能设计"></a>3. 核心功能设计</h2><h3 id="LeaseExpiredNotifier"><a href="#LeaseExpiredNotifier" class="headerlink" title="LeaseExpiredNotifier"></a>LeaseExpiredNotifier</h3><p><code>LeaseQueue</code> 是 lessor 中的一个核心数据结构，<code>queue</code> 是个基于堆排序的优先级队列，堆顶的元素是最先超时的 lease。 <code>m</code> 用于快速查找某个 lease 是否存在。在 grant 时，会在更新 <code>leaseExpiredNotifier</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LeaseExpiredNotifier is a queue used to notify lessor to revoke expired lease.</span></span><br><span class="line"><span class="comment">// Only save one item for a lease, `Register` will update time of the corresponding lease.</span></span><br><span class="line"><span class="keyword">type</span> LeaseExpiredNotifier <span class="keyword">struct</span> &#123;</span><br><span class="line">m     <span class="keyword">map</span>[LeaseID]*LeaseWithTime</span><br><span class="line">queue LeaseQueue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-1-租约创建（Grant）"><a href="#3-1-租约创建（Grant）" class="headerlink" title="3.1 租约创建（Grant）"></a>3.1 租约创建（Grant）</h3><p><strong>设计要点：</strong></p><ul><li><p>支持最小TTL限制，防止过短的租约， 用户 TTL 只能在 <code>[le.minLeaseTTl, MaxLeaseTTL]</code> 范围</p></li><li><p>主从节点采用不同的过期策略</p></li><li><p>自动注册到 expired notifier 和 checkpoint heap，由后台 goroutine 进行超 ttl 超时检测以及 checkpoint 同步。</p><p> checkpoint 机制后面统一阐述，目的是为了保存 ttl 进度。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span></span> Grant(id LeaseID, ttl <span class="type">int64</span>) (*Lease, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 参数验证</span></span><br><span class="line">    <span class="keyword">if</span> id == NoLease || ttl &gt; MaxLeaseTTL &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, ErrLeaseNotFound/ErrLeaseTTLTooLarge</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 创建租约对象</span></span><br><span class="line">    l := NewLease(id, ttl)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 设置最小TTL</span></span><br><span class="line">    <span class="keyword">if</span> l.ttl &lt; le.minLeaseTTL &#123;</span><br><span class="line">        l.ttl = le.minLeaseTTL</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 根据主从状态设置过期时间</span></span><br><span class="line">    <span class="keyword">if</span> le.isPrimary() &#123;</span><br><span class="line">        l.refresh(<span class="number">0</span>)  <span class="comment">// 主节点：设置正常过期时间</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        l.forever()   <span class="comment">// 从节点：设置为永不过期</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 持久化到后端</span></span><br><span class="line">    le.leaseMap[id] = l</span><br><span class="line">    l.persistTo(le.b)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 注册到 expired notifier 和 checkpoint heap</span></span><br><span class="line">    <span class="keyword">if</span> le.isPrimary() &#123;</span><br><span class="line">        item := &amp;LeaseWithTime&#123;id: l.ID, time: l.expiry&#125;</span><br><span class="line">        le.leaseExpiredNotifier.RegisterOrUpdate(item)</span><br><span class="line">        le.scheduleCheckpointIfNeeded(l)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> l, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-租约续期（Renew）"><a href="#3-2-租约续期（Renew）" class="headerlink" title="3.2 租约续期（Renew）"></a>3.2 租约续期（Renew）</h3><p><strong>设计要点：</strong></p><ul><li>只有主节点可以处理续期请求</li><li>对已过期租约有特殊的等待机制</li><li>支持检查点清除，减少RAFT日志</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span></span> Renew(id LeaseID) (<span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 检查主节点状态</span></span><br><span class="line">    <span class="keyword">if</span> !le.isPrimary() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, ErrNotPrimary</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 查找租约</span></span><br><span class="line">    l := le.leaseMap[id]</span><br><span class="line">    <span class="keyword">if</span> l == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>, ErrLeaseNotFound</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 处理已过期租约</span></span><br><span class="line">    <span class="keyword">if</span> l.expired() &#123;</span><br><span class="line">        <span class="comment">// 等待撤销完成或主节点变更</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-l.revokec:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>, ErrLeaseNotFound</span><br><span class="line">        <span class="keyword">case</span> &lt;-demotec:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>, ErrNotPrimary</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 清除剩余TTL（如果设置了检查点）</span></span><br><span class="line">    clearRemainingTTL := le.cp != <span class="literal">nil</span> &amp;&amp; l.remainingTTL &gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> clearRemainingTTL &#123;</span><br><span class="line">        le.cp(context.Background(), &amp;pb.LeaseCheckpointRequest&#123;</span><br><span class="line">            Checkpoints: []*pb.LeaseCheckpoint&#123;</span><br><span class="line">                &#123;ID: <span class="type">int64</span>(l.ID), Remaining_TTL: <span class="number">0</span>&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 刷新过期时间</span></span><br><span class="line">    l.refresh(<span class="number">0</span>)</span><br><span class="line">    item := &amp;LeaseWithTime&#123;id: l.ID, time: l.expiry&#125;</span><br><span class="line">    le.leaseExpiredNotifier.RegisterOrUpdate(item)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> l.ttl, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-租约撤销（Revoke）"><a href="#3-3-租约撤销（Revoke）" class="headerlink" title="3.3 租约撤销（Revoke）"></a>3.3 租约撤销（Revoke）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span></span> Revoke(id LeaseID) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 查找租约</span></span><br><span class="line">    l := le.leaseMap[id]</span><br><span class="line">    <span class="keyword">if</span> l == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ErrLeaseNotFound</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 删除附加的键值对</span></span><br><span class="line">    <span class="keyword">if</span> le.rd != <span class="literal">nil</span> &#123;</span><br><span class="line">        txn := le.rd()</span><br><span class="line">        keys := l.Keys()</span><br><span class="line">        sort.StringSlice(keys).Sort()  <span class="comment">// 保证删除顺序一致</span></span><br><span class="line">        <span class="keyword">for</span> _, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">            txn.DeleteRange([]<span class="type">byte</span>(key), <span class="literal">nil</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        txn.End()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 从内存和持久化存储中删除</span></span><br><span class="line">    <span class="built_in">delete</span>(le.leaseMap, l.ID)</span><br><span class="line">    le.b.BatchTx().UnsafeDelete(buckets.Lease, int64ToBytes(<span class="type">int64</span>(l.ID)))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 通知撤销完成</span></span><br><span class="line">    <span class="built_in">close</span>(l.revokec)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计要点：</strong></p><ul><li>原子性删除：键值对删除和租约删除在同一事务中</li><li>保证删除顺序一致性，避免不同节点产生不同的哈希值</li><li>通过通道通知撤销完成</li></ul><h3 id="3-4-主从切换机制"><a href="#3-4-主从切换机制" class="headerlink" title="3.4 主从切换机制"></a>3.4 主从切换机制</h3><h4 id="Promote（提升为主节点）"><a href="#Promote（提升为主节点）" class="headerlink" title="Promote（提升为主节点）"></a>Promote（提升为主节点）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span></span> Promote(extend time.Duration) &#123;</span><br><span class="line">    le.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> le.mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 设置主节点标志</span></span><br><span class="line">    le.demotec = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 刷新所有租约的过期时间</span></span><br><span class="line">    <span class="keyword">for</span> _, l := <span class="keyword">range</span> le.leaseMap &#123;</span><br><span class="line">        l.refresh(extend)</span><br><span class="line">        item := &amp;LeaseWithTime&#123;id: l.ID, time: l.expiry&#125;</span><br><span class="line">        le.leaseExpiredNotifier.RegisterOrUpdate(item)</span><br><span class="line">        le.scheduleCheckpointIfNeeded(l)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 处理租约堆积问题</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(le.leaseMap) &gt;= le.leaseRevokeRate &#123;</span><br><span class="line">        le.adjustExpiriesForPileup(leases)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Demote（降级为从节点）"><a href="#Demote（降级为从节点）" class="headerlink" title="Demote（降级为从节点）"></a>Demote（降级为从节点）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span></span> Demote() &#123;</span><br><span class="line">    le.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> le.mu.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 将所有租约设置为永不过期</span></span><br><span class="line">    <span class="keyword">for</span> _, l := <span class="keyword">range</span> le.leaseMap &#123;</span><br><span class="line">        l.forever()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 清理检查点和过期通知器</span></span><br><span class="line">    le.clearScheduledLeasesCheckpoints()</span><br><span class="line">    le.clearLeaseExpiredNotifier()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 关闭降级信号通道</span></span><br><span class="line">    <span class="keyword">if</span> le.demotec != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">close</span>(le.demotec)</span><br><span class="line">        le.demotec = <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计要点：</strong></p><ul><li>主节点负责租约过期管理和续期</li><li>从节点将租约设置为永不过期，避免误删</li><li>支持租约堆积的智能调整，防止大量租约同时过期</li></ul><h3 id="3-5-过期处理机制"><a href="#3-5-过期处理机制" class="headerlink" title="3.5 过期处理机制"></a>3.5 过期处理机制</h3><h4 id="主循环（runLoop）"><a href="#主循环（runLoop）" class="headerlink" title="主循环（runLoop）"></a>主循环（runLoop）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span></span> runLoop() &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="built_in">close</span>(le.doneC)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        le.revokeExpiredLeases()      <span class="comment">// 处理过期租约</span></span><br><span class="line">        le.checkpointScheduledLeases() <span class="comment">// 处理检查点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(<span class="number">500</span> * time.Millisecond):</span><br><span class="line">        <span class="keyword">case</span> &lt;-le.stopC:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过期租约处理"><a href="#过期租约处理" class="headerlink" title="过期租约处理"></a>过期租约处理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span></span> revokeExpiredLeases() &#123;</span><br><span class="line">    <span class="comment">// 1. 速率限制</span></span><br><span class="line">    revokeLimit := le.leaseRevokeRate / <span class="number">2</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 查找过期租约</span></span><br><span class="line">    le.mu.RLock()</span><br><span class="line">    <span class="keyword">if</span> le.isPrimary() &#123;</span><br><span class="line">        ls = le.findExpiredLeases(revokeLimit)</span><br><span class="line">    &#125;</span><br><span class="line">    le.mu.RUnlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 发送到过期通道</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(ls) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> le.expiredC &lt;- ls:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 通道满时跳过，下次再处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计要点：</strong></p><ul><li>500ms 的固定检查间隔，平衡性能和及时性</li><li>速率限制防止大量租约同时过期造成系统压力</li><li>非阻塞的过期通道，避免阻塞主循环</li></ul><h3 id="3-6-检查点机制"><a href="#3-6-检查点机制" class="headerlink" title="3.6 检查点机制"></a>3.6 检查点机制</h3><h4 id="检查点调度"><a href="#检查点调度" class="headerlink" title="检查点调度"></a>检查点调度</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span></span> scheduleCheckpointIfNeeded(lease *Lease) &#123;</span><br><span class="line">    <span class="keyword">if</span> le.cp == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只有当剩余TTL大于检查点间隔时才调度</span></span><br><span class="line">    <span class="keyword">if</span> lease.RemainingTTL() &gt; <span class="type">int64</span>(le.checkpointInterval.Seconds()) &#123;</span><br><span class="line">        heap.Push(&amp;le.leaseCheckpointHeap, &amp;LeaseWithTime&#123;</span><br><span class="line">            id:   lease.ID,</span><br><span class="line">            time: time.Now().Add(le.checkpointInterval),</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="检查点处理"><a href="#检查点处理" class="headerlink" title="检查点处理"></a>检查点处理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span></span> checkpointScheduledLeases() &#123;</span><br><span class="line">    <span class="comment">// 速率限制</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; leaseCheckpointRate/<span class="number">2</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">var</span> cps []*pb.LeaseCheckpoint</span><br><span class="line">        le.mu.Lock()</span><br><span class="line">        <span class="keyword">if</span> le.isPrimary() &#123;</span><br><span class="line">            cps = le.findDueScheduledCheckpoints(maxLeaseCheckpointBatchSize)</span><br><span class="line">        &#125;</span><br><span class="line">        le.mu.Unlock()</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(cps) != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="comment">// 提交到RAFT</span></span><br><span class="line">            le.cp(context.Background(), &amp;pb.LeaseCheckpointRequest&#123;Checkpoints: cps&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计要点：</strong></p><ul><li>使用最小堆管理检查点调度</li><li>批量处理减少RAFT日志数量</li><li>速率限制防止检查点过于频繁</li></ul><h2 id="4-数据结构设计"><a href="#4-数据结构设计" class="headerlink" title="4. 数据结构设计"></a>4. 数据结构设计</h2><h3 id="4-1-过期通知器（LeaseExpiredNotifier）"><a href="#4-1-过期通知器（LeaseExpiredNotifier）" class="headerlink" title="4.1 过期通知器（LeaseExpiredNotifier）"></a>4.1 过期通知器（LeaseExpiredNotifier）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LeaseExpiredNotifier <span class="keyword">struct</span> &#123;</span><br><span class="line">    m     <span class="keyword">map</span>[LeaseID]*LeaseWithTime  <span class="comment">// 租约ID到时间项的映射</span></span><br><span class="line">    queue LeaseQueue                  <span class="comment">// 基于过期时间的最小堆</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计要点：</strong></p><ul><li>使用最小堆按过期时间排序</li><li>支持O(log N)的插入、删除和查找</li><li>映射表提供O(1)的租约查找</li></ul><h3 id="4-2-租约队列（LeaseQueue）"><a href="#4-2-租约队列（LeaseQueue）" class="headerlink" title="4.2 租约队列（LeaseQueue）"></a>4.2 租约队列（LeaseQueue）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> LeaseQueue []*LeaseWithTime</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> LeaseWithTime <span class="keyword">struct</span> &#123;</span><br><span class="line">    id    LeaseID</span><br><span class="line">    time  time.Time</span><br><span class="line">    index <span class="type">int</span>  <span class="comment">// 堆中的索引</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计要点：</strong></p><ul><li>实现标准堆接口</li><li>支持堆修复操作</li><li>索引字段支持O(log N)的堆修复</li></ul><h2 id="5-持久化设计"><a href="#5-持久化设计" class="headerlink" title="5. 持久化设计"></a>5. 持久化设计</h2><h3 id="5-1-后端存储"><a href="#5-1-后端存储" class="headerlink" title="5.1 后端存储"></a>5.1 后端存储</h3><p>租约信息持久化到 <code>buckets.Lease</code> 桶中：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Lease <span class="keyword">struct</span> &#123;</span><br><span class="line">    ID           <span class="type">int64</span>  <span class="comment">// 租约ID</span></span><br><span class="line">    TTL          <span class="type">int64</span>  <span class="comment">// 生存时间</span></span><br><span class="line">    RemainingTTL <span class="type">int64</span>  <span class="comment">// 剩余时间（v3.6+支持）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-恢复机制"><a href="#5-2-恢复机制" class="headerlink" title="5.2 恢复机制"></a>5.2 恢复机制</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(le *lessor)</span></span> initAndRecover() &#123;</span><br><span class="line">    tx := le.b.BatchTx()</span><br><span class="line">    tx.LockOutsideApply()</span><br><span class="line">    </span><br><span class="line">    tx.UnsafeCreateBucket(buckets.Lease)</span><br><span class="line">    lpbs := unsafeGetAllLeases(tx)</span><br><span class="line">    tx.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从持久化数据恢复租约</span></span><br><span class="line">    <span class="keyword">for</span> _, lpb := <span class="keyword">range</span> lpbs &#123;</span><br><span class="line">        ID := LeaseID(lpb.ID)</span><br><span class="line">        le.leaseMap[ID] = &amp;Lease&#123;</span><br><span class="line">            ID:           ID,</span><br><span class="line">            ttl:          lpb.TTL,</span><br><span class="line">            itemSet:      <span class="built_in">make</span>(<span class="keyword">map</span>[LeaseItem]<span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">            expiry:       forever,  <span class="comment">// 初始设置为永不过期</span></span><br><span class="line">            revokec:      <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">            remainingTTL: lpb.RemainingTTL,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    le.leaseExpiredNotifier.Init()</span><br><span class="line">    heap.Init(&amp;le.leaseCheckpointHeap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设计要点：</strong></p><ul><li>租约项（itemSet）不持久化，通过遍历KV恢复</li><li>初始过期时间设为永不过期，等待Promote时刷新</li><li>支持RemainingTTL的版本兼容性</li></ul><h2 id="6-性能优化设计"><a href="#6-性能优化设计" class="headerlink" title="6. 性能优化设计"></a>6. 性能优化设计</h2><h3 id="6-1-速率限制"><a href="#6-1-速率限制" class="headerlink" title="6.1 速率限制"></a>6.1 速率限制</h3><ul><li><strong>撤销速率限制</strong>：<code>leaseRevokeRate</code> 控制每秒最大撤销数量</li><li><strong>检查点速率限制</strong>：<code>leaseCheckpointRate</code> 控制每秒最大检查点数量</li><li><strong>批量处理</strong>：检查点支持批量提交，减少RAFT日志</li></ul><h3 id="6-2-内存优化"><a href="#6-2-内存优化" class="headerlink" title="6.2 内存优化"></a>6.2 内存优化</h3><ul><li><strong>最小堆</strong>：O(log N)的过期时间管理</li><li><strong>映射表</strong>：O(1)的租约查找</li><li><strong>缓冲通道</strong>：避免过期处理阻塞主循环</li></ul><h3 id="6-3-并发安全"><a href="#6-3-并发安全" class="headerlink" title="6.3 并发安全"></a>6.3 并发安全</h3><ul><li><strong>读写锁</strong>：支持并发读操作</li><li><strong>细粒度锁</strong>：租约级别的互斥锁</li><li><strong>通道通信</strong>：避免共享状态竞争</li></ul><h2 id="7-容错设计"><a href="#7-容错设计" class="headerlink" title="7. 容错设计"></a>7. 容错设计</h2><h3 id="7-1-主从切换容错"><a href="#7-1-主从切换容错" class="headerlink" title="7.1 主从切换容错"></a>7.1 主从切换容错</h3><ul><li><strong>短暂双主</strong>：Raft允许短暂的双主状态，通过term保证正确性</li><li><strong>降级保护</strong>：从节点将租约设为永不过期，避免误删</li><li><strong>重试机制</strong>：过期租约的重试间隔机制</li></ul><h3 id="7-2-网络分区容错"><a href="#7-2-网络分区容错" class="headerlink" title="7.2 网络分区容错"></a>7.2 网络分区容错</h3><ul><li><strong>检查点机制</strong>：保存剩余TTL，支持跨重启恢复</li><li><strong>版本兼容</strong>：支持不同版本的检查点行为</li><li><strong>优雅降级</strong>：网络问题时自动降级为从节点</li></ul><h2 id="8-监控和指标"><a href="#8-监控和指标" class="headerlink" title="8. 监控和指标"></a>8. 监控和指标</h2><h3 id="8-1-Prometheus指标"><a href="#8-1-Prometheus指标" class="headerlink" title="8.1 Prometheus指标"></a>8.1 Prometheus指标</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    leaseGranted   = prometheus.NewCounter(...)  <span class="comment">// 租约创建总数</span></span><br><span class="line">    leaseRevoked   = prometheus.NewCounter(...)  <span class="comment">// 租约撤销总数</span></span><br><span class="line">    leaseRenewed   = prometheus.NewCounter(...)  <span class="comment">// 租约续期总数</span></span><br><span class="line">    leaseTotalTTLs = prometheus.NewHistogram(...) <span class="comment">// TTL分布直方图</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="8-2-日志记录"><a href="#8-2-日志记录" class="headerlink" title="8.2 日志记录"></a>8.2 日志记录</h3><ul><li><strong>调试日志</strong>：检查点调度和处理的详细日志</li><li><strong>错误日志</strong>：租约操作失败的错误信息</li><li><strong>性能日志</strong>：关键操作的性能指标</li></ul><h2 id="9-总结"><a href="#9-总结" class="headerlink" title="9. 总结"></a>9. 总结</h2><p>etcd 的 Lessor 设计体现了以下核心特点：</p><ol><li><strong>高可用性</strong>：通过主从切换和检查点机制保证服务连续性</li><li><strong>高性能</strong>：使用最小堆和映射表优化查找性能，支持速率限制</li><li><strong>强一致性</strong>：通过RAFT协议保证租约操作的一致性</li><li><strong>可扩展性</strong>：支持大量租约的高效管理</li><li><strong>容错性</strong>：完善的错误处理和恢复机制</li></ol><p>Lessor 的设计充分考虑了分布式环境下的各种挑战，是一个经过充分验证的租约管理实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Lessor&quot;&gt;&lt;a href=&quot;#Lessor&quot; class=&quot;headerlink&quot; title=&quot;Lessor&quot;&gt;&lt;/a&gt;Lessor&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Lessor&lt;/code&gt; 是 ETCD 中负责管理租约 (Lease) 的核心组件。租约机制是</summary>
      
    
    
    
    
    <category term="ETCD" scheme="https://szza.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>剖析 ETCD.mvcc</title>
    <link href="https://szza.github.io/2024/09/03/ETCD/3_mvcc/"/>
    <id>https://szza.github.io/2024/09/03/ETCD/3_mvcc/</id>
    <published>2024-09-03T11:38:49.000Z</published>
    <updated>2025-10-23T12:59:49.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>mvcc 的核心组件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    etcd MVCC 系统                          │</span><br><span class="line">├─────────────────────────────────────────────────────────────┤</span><br><span class="line">│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │</span><br><span class="line">│  │   KV Store  │  │   Index     │  │      Backend        │ │</span><br><span class="line">│  │             │  │             │  │                     │ │</span><br><span class="line">│  │ • 事务管理   │  │ • B+树索引   │   │ • BoltDB存储引擎    │ │</span><br><span class="line">│  │ • 版本控制   │  │ • 版本管理    │  │ • 事务缓冲           │ │</span><br><span class="line">│  │ • 并发控制   │  │ • 压缩管理    │  │ • 快照管理           │ │</span><br><span class="line">│  └─────────────┘  └─────────────┘  └─────────────────────┘ │</span><br><span class="line">├─────────────────────────────────────────────────────────────┤</span><br><span class="line">│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │</span><br><span class="line">│  │   Watcher   │  │  Compaction │  │      Hash           │ │</span><br><span class="line">│  │             │  │             │  │                     │ │</span><br><span class="line">│  │ • 事件监听   │  │ • 版本清理   │  │ • 数据完整性校验       │ │</span><br><span class="line">│  │ • 事件分发   │  │ • 空间回收   │  │ • 快照验证            │ │</span><br><span class="line">│  │ • 同步机制   │  │ • 压缩调度   │  │                      │ │</span><br><span class="line">│  └─────────────┘  └─────────────┘  └─────────────────────┘ │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>mvcc 的数据流转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐    ┌─────────────┐    ┌─────────────┐</span><br><span class="line">│   Client    │    │   KV Store  │    │   Backend   │</span><br><span class="line">│   Request   │───▶│             │───▶│  (BoltDB)   │</span><br><span class="line">└─────────────┘    └─────────────┘    └─────────────┘</span><br><span class="line">                          │                   │</span><br><span class="line">                          ▼                   ▼</span><br><span class="line">                   ┌─────────────┐    ┌─────────────┐</span><br><span class="line">                   │   Index     │    │   Buffer    │</span><br><span class="line">                   │  (B+Tree)   │    │ (txBuffer)  │</span><br><span class="line">                   └─────────────┘    └─────────────┘</span><br><span class="line">                          │                   │</span><br><span class="line">                          ▼                   ▼</span><br><span class="line">                   ┌─────────────┐    ┌─────────────┐</span><br><span class="line">                   │  Watcher    │    │ Compaction  │</span><br><span class="line">                   │   Events    │    │   Cleanup   │</span><br><span class="line">                   └─────────────┘    └─────────────┘</span><br></pre></td></tr></table></figure><h3 id="Compact"><a href="#Compact" class="headerlink" title="Compact"></a>Compact</h3><p><code>Compact</code> 也是一种<code>两阶段</code>设计思想</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用 Compact(rev)</span><br><span class="line">    ↓</span><br><span class="line">第一阶段: updateCompactRev(rev) - 更新压缩版本号</span><br><span class="line">    ↓  </span><br><span class="line">第二阶段: compact() - 异步调度压缩任务</span><br></pre></td></tr></table></figure><h4 id="updateCompactRev"><a href="#updateCompactRev" class="headerlink" title="updateCompactRev"></a>updateCompactRev</h4><p><code>Cpmpact</code> 任务的第一阶段。 </p><p>在 ETCD 中，存在一些单独的 Bukcet 用于存储一些元数据，比如 <code>Buckets.Meta</code> 存储当前需要调度的 compaction 任务的 revision 。</p><p>因此写入后，需要 <code>ForceCommit</code> 来保证元数据不会丢。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> updateCompactRev(rev <span class="type">int64</span>) (&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    s.revMu.Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 版本号有效性检查</span></span><br><span class="line">    <span class="keyword">if</span> rev &lt;= s.compactMainRev &#123;</span><br><span class="line">        <span class="comment">// 已经压缩过，返回错误</span></span><br><span class="line">        <span class="keyword">return</span> ch, <span class="number">0</span>, ErrCompacted</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> rev &gt; s.currentRev &#123;</span><br><span class="line">        <span class="comment">// 版本号过大，返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, ErrFutureRev</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 更新压缩版本号</span></span><br><span class="line">    compactMainRev := s.compactMainRev</span><br><span class="line">    s.compactMainRev = rev</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 持久化压缩计划到数据库</span></span><br><span class="line">    rbytes := newRevBytes()</span><br><span class="line">    revToBytes(revision&#123;main: rev&#125;, rbytes)</span><br><span class="line">    </span><br><span class="line">    tx := s.b.BatchTx()</span><br><span class="line">    tx.LockInsideApply()</span><br><span class="line">    tx.UnsafePut(buckets.Meta, scheduledCompactKeyName, rbytes)</span><br><span class="line">    tx.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 强制提交，确保压缩计划被持久化</span></span><br><span class="line">    s.b.ForceCommit()</span><br><span class="line">    </span><br><span class="line">    s.revMu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, compactMainRev, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="scheduleCompaction"><a href="#scheduleCompaction" class="headerlink" title="scheduleCompaction"></a>scheduleCompaction</h4><p><code>scheduleCompaction</code> 两阶段压缩：先压缩内存索引，再压缩数据库:</p><ul><li><p>批量处理：分批处理数据，避免长时间锁定</p><p>每次在最多处理的kv数由 <code>s.cfg.CompactionBatchLimit</code> 确定</p></li><li><p>保留策略：根据内存索引的压缩结果决定保留哪些数据</p><p>由 treeIndex Compact 完后的结果 <code>keep</code> 来决定DB中哪些数据是否保留</p></li><li><p>进度控制：每批处理后休眠，避免阻塞其他操作</p></li><li><p>完成标记：设置压缩完成标记，用于状态检查</p><p>更新 <code>buckets.Meta</code> 中的 key <code>finishedCompactKeyName</code> 的值，用于后续状态查询</p></li></ul><p>整体如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> scheduleCompaction(compactMainRev, prevCompactRev <span class="type">int64</span>) (KeyValueHash, <span class="type">error</span>) &#123;</span><br><span class="line">    totalStart := time.Now()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一步：压缩内存索引</span></span><br><span class="line">    keep := s.kvindex.Compact(compactMainRev)</span><br><span class="line">    indexCompactionPauseMs.Observe(<span class="type">float64</span>(time.Since(totalStart) / time.Millisecond))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备压缩范围</span></span><br><span class="line">    end := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line">    binary.BigEndian.PutUint64(end, <span class="type">uint64</span>(compactMainRev+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    batchNum := s.cfg.CompactionBatchLimit</span><br><span class="line">    h := newKVHasher(prevCompactRev, compactMainRev, keep)</span><br><span class="line">    last := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>+<span class="number">1</span>+<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量处理压缩</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> rev revision</span><br><span class="line">        </span><br><span class="line">        start := time.Now()</span><br><span class="line">        </span><br><span class="line">        tx := s.b.BatchTx()</span><br><span class="line">        tx.LockOutsideApply()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取一批需要处理的数据</span></span><br><span class="line">        keys, values := tx.UnsafeRange(buckets.Key, last, end, <span class="type">int64</span>(batchNum))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> keys &#123;</span><br><span class="line">            rev = bytesToRev(keys[i])</span><br><span class="line">            <span class="keyword">if</span> _, ok := keep[rev]; !ok &#123;</span><br><span class="line">                <span class="comment">// 删除不需要保留的数据</span></span><br><span class="line">                tx.UnsafeDelete(buckets.Key, keys[i])</span><br><span class="line">                keyCompactions++</span><br><span class="line">            &#125;</span><br><span class="line">            h.WriteKeyValue(keys[i], values[i])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否处理完成</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(keys) &lt; batchNum &#123;</span><br><span class="line">            <span class="comment">// 设置压缩完成标记</span></span><br><span class="line">            rbytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>+<span class="number">1</span>+<span class="number">8</span>)</span><br><span class="line">            revToBytes(revision&#123;main: compactMainRev&#125;, rbytes)</span><br><span class="line">            tx.UnsafePut(buckets.Meta, finishedCompactKeyName, rbytes)</span><br><span class="line">            tx.Unlock()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录压缩完成信息</span></span><br><span class="line">            hash := h.Hash()</span><br><span class="line">            size, sizeInUse := s.b.Size(), s.b.SizeInUse()</span><br><span class="line">            s.lg.Info(<span class="string">&quot;finished scheduled compaction&quot;</span>, ...)</span><br><span class="line">            <span class="keyword">return</span> hash, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新处理位置</span></span><br><span class="line">        revToBytes(revision&#123;main: rev.main, sub: rev.sub + <span class="number">1</span>&#125;, last)</span><br><span class="line">        tx.Unlock()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 立即提交压缩删除操作</span></span><br><span class="line">        s.b.ForceCommit()</span><br><span class="line">        dbCompactionPauseMs.Observe(<span class="type">float64</span>(time.Since(start) / time.Millisecond))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一个 batch 结束, 休眠一段时间，避免阻塞其他操作</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(s.cfg.CompactionSleepInterval):</span><br><span class="line">        <span class="keyword">case</span> &lt;-s.stopc:</span><br><span class="line">            <span class="keyword">return</span> KeyValueHash&#123;&#125;, fmt.Errorf(<span class="string">&quot;interrupted due to stop signal&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="checkPrevCompactionCompleted"><a href="#checkPrevCompactionCompleted" class="headerlink" title="checkPrevCompactionCompleted"></a>checkPrevCompactionCompleted</h4><p>根据 <code>Buckets.Meta</code> 中 <code>key:finishedCompactKeyName</code> 和 <code>key:scheduledCompactKeyName</code> 的最新值，来判断上次 Compaction 是否完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> checkPrevCompactionCompleted() <span class="type">bool</span> &#123;</span><br><span class="line">    tx := s.b.ReadTx()</span><br><span class="line">    tx.Lock()</span><br><span class="line">    <span class="keyword">defer</span> tx.Unlock()</span><br><span class="line">    </span><br><span class="line">    scheduledCompact, scheduledCompactFound := UnsafeReadScheduledCompact(tx)</span><br><span class="line">    finishedCompact, finishedCompactFound := UnsafeReadFinishedCompact(tx)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查上一次压缩是否完成</span></span><br><span class="line">    <span class="keyword">return</span> scheduledCompact == finishedCompact &amp;&amp; scheduledCompactFound == finishedCompactFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Restore"><a href="#Restore" class="headerlink" title="Restore"></a>Restore</h3><p><code>Restore</code> 为 <code>NewStore</code> 和 <code>store.restore</code> 提供统一实现，即是创建一个新的 KV 实例和从已有的数据恢复成一个 KV 实例，提供了一个统一实现:</p><ul><li><p>恢复 compactMainRev 和 currentRev 版本号</p>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 如果先恢复 currentRev, 再恢复 compactMainRev:</span><br><span class="line">// 1. currentRev 可能小于 compactMainRev</span><br><span class="line">// 2. 导致数据不一致</span><br><span class="line">// 3. 可能触发错误的压缩操作</span><br><span class="line"></span><br><span class="line">// 正确的顺序确保：</span><br><span class="line">// 1. 压缩版本号先确定</span><br><span class="line">// 2. 键值对按版本顺序恢复</span><br><span class="line">// 3. 当前版本号最后确定，确保一致性</span><br></pre></td></tr></table></figure></li><li><p>并发恢复 treeIndex 中的索引数据</p></li><li><p>恢复 lease 租约信息</p></li><li><p>处理未完成的 compaction 任务</p></li></ul><p>完整实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> restore() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 设置监控报告器</span></span><br><span class="line">    s.setupMetricsReporter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 准备恢复范围</span></span><br><span class="line">    min, max := newRevBytes(), newRevBytes()</span><br><span class="line">    revToBytes(revision&#123;main: <span class="number">1</span>&#125;, min)                                  <span class="comment">// 从版本 1 开始</span></span><br><span class="line">    revToBytes(revision&#123;main: math.MaxInt64, sub: math.MaxInt64&#125;, max)  <span class="comment">// 到最大版本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 初始化租约映射</span></span><br><span class="line">    keyToLease := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]lease.LeaseID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 恢复压缩版本号</span></span><br><span class="line">    tx := s.b.ReadTx()</span><br><span class="line">    tx.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复已完成的压缩版本号: finishedCompact</span></span><br><span class="line">    finishedCompact, found := UnsafeReadFinishedCompact(tx)</span><br><span class="line">    <span class="keyword">if</span> found &#123;</span><br><span class="line">        s.revMu.Lock()</span><br><span class="line">        s.compactMainRev = finishedCompact</span><br><span class="line">        s.lg.Info(<span class="string">&quot;restored last compact revision&quot;</span>, </span><br><span class="line">            zap.Int64(<span class="string">&quot;restored-compact-revision&quot;</span>, s.compactMainRev))</span><br><span class="line">        s.revMu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取计划的压缩版本号</span></span><br><span class="line">    scheduledCompact, _ := UnsafeReadScheduledCompact(tx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 并发恢复 treeIndex 索引数据</span></span><br><span class="line">    keysGauge.Set(<span class="number">0</span>)</span><br><span class="line">    rkvc, revc := restoreIntoIndex(s.lg, s.kvindex)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 分块读取和恢复数据</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        keys, vals := tx.UnsafeRange(buckets.Key, min, max, <span class="type">int64</span>(restoreChunkKeys))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理当前块的数据</span></span><br><span class="line">        restoreChunk(s.lg, rkvc, keys, vals, keyToLease)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(keys) &lt; restoreChunkKeys &#123;</span><br><span class="line">            <span class="comment">// 部分集合意味着最终集合</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新下一个块的起始位置</span></span><br><span class="line">        newMin := bytesToRev(keys[<span class="built_in">len</span>(keys)<span class="number">-1</span>][:revBytesLen])</span><br><span class="line">        newMin.sub++</span><br><span class="line">        revToBytes(newMin, min)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(rkvc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 恢复当前版本号</span></span><br><span class="line">    &#123;</span><br><span class="line">        s.revMu.Lock()</span><br><span class="line">        s.currentRev = &lt;-revc</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理压缩后的版本号调整</span></span><br><span class="line">        <span class="keyword">if</span> s.currentRev &lt; s.compactMainRev &#123;</span><br><span class="line">            s.currentRev = s.compactMainRev</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理未完成压缩的情况</span></span><br><span class="line">        <span class="keyword">if</span> s.currentRev &lt; scheduledCompact &#123;</span><br><span class="line">            s.currentRev = scheduledCompact</span><br><span class="line">        &#125;</span><br><span class="line">        s.revMu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 处理未完成的压缩</span></span><br><span class="line">    <span class="keyword">if</span> scheduledCompact &lt;= s.compactMainRev &#123;</span><br><span class="line">        scheduledCompact = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. 恢复租约信息</span></span><br><span class="line">    <span class="keyword">for</span> key, lid := <span class="keyword">range</span> keyToLease &#123;</span><br><span class="line">        <span class="keyword">if</span> s.le == <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Unlock()</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;no lessor to attach lease&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        err := s.le.Attach(lid, []lease.LeaseItem&#123;&#123;Key: key&#125;&#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.lg.Error(<span class="string">&quot;failed to attach a lease&quot;</span>, zap.Error(err))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tx.Unlock()</span><br><span class="line"></span><br><span class="line">    s.lg.Info(<span class="string">&quot;kvstore restored&quot;</span>, zap.Int64(<span class="string">&quot;current-rev&quot;</span>, s.currentRev))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10. 处理未完成的压缩任务</span></span><br><span class="line">    <span class="keyword">if</span> scheduledCompact != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := s.compactLockfree(scheduledCompact); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.lg.Warn(<span class="string">&quot;compaction encountered error&quot;</span>, zap.Error(err))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="restoreIntoIndex"><a href="#restoreIntoIndex" class="headerlink" title="restoreIntoIndex"></a>restoreIntoIndex</h4><p><code>restoreIntoIndex</code> 是创建一个新的消费者 goroutine，来 restore treeIndex 与主线程 <code>restoreChunk</code> 一起并发 restore. </p><ul><li>生产者-消费者模式：使用通道进行数据传输</li><li>缓存优化：使用 LRU 风格的缓存策略</li><li>并发安全：在单独的 goroutine 中处理索引更新</li><li>内存控制：通过缓存大小限制内存使用</li></ul><p>完整实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> revKeyValue <span class="keyword">struct</span> &#123;</span><br><span class="line">key  []<span class="type">byte</span>          <span class="comment">// 版本化的键（包含 revision 信息）</span></span><br><span class="line">kv   mvccpb.KeyValue <span class="comment">// 键值对数据 (User&#x27;s Key Value)</span></span><br><span class="line">kstr <span class="type">string</span>          <span class="comment">// kv.Key 的字符串形式（用于缓存查找）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIntoIndex</span><span class="params">(lg *zap.Logger, idx index)</span></span> (<span class="keyword">chan</span>&lt;- revKeyValue, &lt;-<span class="keyword">chan</span> <span class="type">int64</span>) &#123;</span><br><span class="line">    rkvc, revc := <span class="built_in">make</span>(<span class="keyword">chan</span> revKeyValue, restoreChunkKeys), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int64</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        currentRev := <span class="type">int64</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; revc &lt;- currentRev &#125;()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建键索引缓存</span></span><br><span class="line">        kiCache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*keyIndex, restoreChunkKeys)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> rkv := <span class="keyword">range</span> rkvc &#123;</span><br><span class="line">            ki, ok := kiCache[rkv.kstr]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 缓存清理策略：当缓存满且未命中时，清理部分缓存</span></span><br><span class="line">            <span class="keyword">if</span> !ok &amp;&amp; <span class="built_in">len</span>(kiCache) &gt;= restoreChunkKeys &#123;</span><br><span class="line">                i := <span class="number">10</span></span><br><span class="line">                <span class="comment">// kiCache 是 unordered, range 是随机访问</span></span><br><span class="line">                <span class="comment">// 因此 delete 是随机删除</span></span><br><span class="line">                <span class="keyword">for</span> k := <span class="keyword">range</span> kiCache &#123;</span><br><span class="line">                    <span class="built_in">delete</span>(kiCache, k)</span><br><span class="line">                    <span class="keyword">if</span> i--; i == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 缓存未命中，从树索引中获取</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                ki = &amp;keyIndex&#123;key: rkv.kv.Key&#125;</span><br><span class="line">                <span class="keyword">if</span> idxKey := idx.KeyIndex(ki); idxKey != <span class="literal">nil</span> &#123;</span><br><span class="line">                    kiCache[rkv.kstr], ki = idxKey, idxKey</span><br><span class="line">                    ok = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            rev := bytesToRev(rkv.key) <span class="comment">// revision_byte to rev</span></span><br><span class="line">            currentRev = rev.main</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                <span class="comment">/// rkv.kv.Key 在 treeIndex 中已存在索引</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> isTombstone(rkv.key) &#123;</span><br><span class="line">                    <span class="comment">// 处理墓碑标记</span></span><br><span class="line">                    <span class="keyword">if</span> err := ki.tombstone(lg, rev.main, rev.sub); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        lg.Warn(<span class="string">&quot;tombstone encountered error&quot;</span>, zap.Error(err))</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 插入</span></span><br><span class="line">                ki.put(lg, rev.main, rev.sub)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 键索引不存在，创建新的</span></span><br><span class="line">                <span class="keyword">if</span> isTombstone(rkv.key) &#123;</span><br><span class="line">                    ki.restoreTombstone(lg, rev.main, rev.sub)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ki.restore(lg, revision&#123;rkv.kv.CreateRevision, <span class="number">0</span>&#125;, rev, rkv.kv.Version)</span><br><span class="line">                &#125;</span><br><span class="line">                idx.Insert(ki)</span><br><span class="line">                kiCache[rkv.kstr] = ki <span class="comment">// update cache</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rkvc, revc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="restoreChunk"><a href="#restoreChunk" class="headerlink" title="restoreChunk"></a>restoreChunk</h4><p><code>restoreChunk</code> 在 restore 主线程中处理，将从 backend 中获取到的数据进行租约 lease 信息处理，处理完将这个 batch 的数据集 <code>rkv</code> 通过 channel 传递给消费者 goroutine: restoreIntoIndex 去恢复 treeIndex。</p><p>restoreChunk:</p><ul><li>一次最多处理 <code>restoreChunkKeys</code> 个 {key value}</li><li>etcdServer.Restore 需要先恢复 leasor 信息</li></ul><p>store.restore 这部分关系如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// func restore</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">keys, vals := tx.UnsafeRange(buckets.Key, min, max, <span class="type">int64</span>(restoreChunkKeys))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// rkvc blocks if the total pending keys exceeds the restore</span></span><br><span class="line"><span class="comment">// chunk size to keep keys from consuming too much memory.</span></span><br><span class="line">restoreChunk(s.lg, rkvc, keys, vals, keyToLease)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(keys) &lt; restoreChunkKeys &#123;</span><br><span class="line"><span class="comment">// partial set implies final set</span></span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// next set begins after where this one ended</span></span><br><span class="line">newMin := bytesToRev(keys[<span class="built_in">len</span>(keys)<span class="number">-1</span>][:revBytesLen])</span><br><span class="line">newMin.sub++</span><br><span class="line">revToBytes(newMin, min)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreChunk</span><span class="params">(lg *zap.Logger, kvc <span class="keyword">chan</span>&lt;- revKeyValue, keys, vals [][]<span class="type">byte</span>, keyToLease <span class="keyword">map</span>[<span class="type">string</span>]lease.LeaseID)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        rkv := revKeyValue&#123;key: key&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反序列化键值对</span></span><br><span class="line">        <span class="keyword">if</span> err := rkv.kv.Unmarshal(vals[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            lg.Fatal(<span class="string">&quot;failed to unmarshal mvccpb.KeyValue&quot;</span>, zap.Error(err))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rkv.kstr = <span class="type">string</span>(rkv.kv.Key)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理租约信息</span></span><br><span class="line">        <span class="keyword">if</span> isTombstone(key) &#123;</span><br><span class="line">            <span class="comment">// 墓碑标记，删除租约关联</span></span><br><span class="line">            <span class="built_in">delete</span>(keyToLease, rkv.kstr)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> lid := lease.LeaseID(rkv.kv.Lease); lid != lease.NoLease &#123;</span><br><span class="line">            <span class="comment">// 有租约，记录租约关联</span></span><br><span class="line">            keyToLease[rkv.kstr] = lid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无租约，删除租约关联</span></span><br><span class="line">            <span class="built_in">delete</span>(keyToLease, rkv.kstr)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送到索引恢复通道</span></span><br><span class="line">        kvc &lt;- rkv</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="版本一致性"><a href="#版本一致性" class="headerlink" title="版本一致性"></a>版本一致性</h4><p>在完成上述操作后，即可获得最大 revision，但是仍需要调整下版本号:</p><ul><li>压缩后调整：确保 currentRev &gt;&#x3D; compactMainRev</li><li>未完成压缩：使用 scheduledCompact 调整版本号</li><li>墓碑版本处理：正确处理删除操作的版本号</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本号恢复逻辑</span></span><br><span class="line"></span><br><span class="line">finishedCompact, found := UnsafeReadFinishedCompact(tx)</span><br><span class="line"><span class="keyword">if</span> found &#123;</span><br><span class="line">    s.compactMainRev = finishedCompact</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//..</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    s.revMu.Lock()</span><br><span class="line">    s.currentRev = &lt;-revc  <span class="comment">// 从 treeIndex 索引恢复过程中获取最大版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1：处理压缩后的版本号调整</span></span><br><span class="line">    <span class="comment">// 在压缩过程中，某些版本可能被删除，需要确保当前版本号不小于压缩版本号</span></span><br><span class="line">    <span class="keyword">if</span> s.currentRev &lt; s.compactMainRev &#123;</span><br><span class="line">        s.currentRev = s.compactMainRev</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况2：处理未完成压缩的情况</span></span><br><span class="line">    <span class="comment">// 如果 etcd 在压缩过程中崩溃，可能导致版本号不一致</span></span><br><span class="line">    <span class="comment">// 使用计划的压缩版本号来调整当前版本号</span></span><br><span class="line">    <span class="keyword">if</span> s.currentRev &lt; scheduledCompact &#123;</span><br><span class="line">        s.currentRev = scheduledCompact</span><br><span class="line">    &#125;</span><br><span class="line">    s.revMu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lease"><a href="#lease" class="headerlink" title="lease"></a>lease</h4><p>调整完版本，再恢复租约：</p><ul><li>状态重建：重新建立键与租约的关联关系</li><li>错误容忍：租约恢复失败时记录错误但不终止恢复过程</li><li>完整性检查：确保租约管理器存在</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, lid := <span class="keyword">range</span> keyToLease &#123;</span><br><span class="line">    <span class="comment">// 需要 etcdServer 先恢复 leasor</span></span><br><span class="line">    <span class="keyword">if</span> s.le == <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.Unlock()</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;no lessor to attach lease&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新关联键和租约</span></span><br><span class="line">    err := s.le.Attach(lid, []lease.LeaseItem&#123;&#123;Key: key&#125;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.lg.Error(<span class="string">&quot;failed to attach a lease&quot;</span>, </span><br><span class="line">            zap.String(<span class="string">&quot;lease-id&quot;</span>, fmt.Sprintf(<span class="string">&quot;%016x&quot;</span>, lid)),</span><br><span class="line">            zap.Error(err))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="compactLockfree"><a href="#compactLockfree" class="headerlink" title="compactLockfree"></a>compactLockfree</h4><p>compaction 需要作为 restore 的最后一步，设计原因如下:</p><ol><li>数据完整性保证</li></ol><ul><li>所有数据都已恢复</li><li>索引结构已建立</li><li>租约关联已建立</li></ul><p>   如果 restore 提前 compaction，可能会导致 compactMainRev 变大，导致数据不一致，删除了部分数据。</p><ol start="2"><li>系统可用性</li></ol><ul><li>即使压缩失败，系统仍可运行</li><li>不会因为压缩问题导致启动失败</li></ul><ol start="3"><li>错误隔离<ul><li>压缩错误不会影响数据恢复（这点很重要）</li><li>可以独立处理压缩问题</li></ul></li></ol><p>从性能角度考虑: 先恢复核心功能, compaction 作为后台异步任务执行可以减少启动时间</p><p>完整实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 restore 过程中检测未完成的压缩</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> restore() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 首先读取已完成的压缩版本号</span></span><br><span class="line">    finishedCompact, found := UnsafeReadFinishedCompact(tx)</span><br><span class="line">    <span class="keyword">if</span> found &#123;</span><br><span class="line">        s.compactMainRev = finishedCompact</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 读取计划的压缩版本号</span></span><br><span class="line">    scheduledCompact, _ := UnsafeReadScheduledCompact(tx)</span><br><span class="line">    <span class="comment">// 3. 恢复上述所有数据...</span></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 最后处理未完成的压缩</span></span><br><span class="line">    <span class="keyword">if</span> scheduledCompact != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := s.compactLockfree(scheduledCompact); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.lg.Warn(<span class="string">&quot;compaction encountered error&quot;</span>, zap.Error(err))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.lg.Info(<span class="string">&quot;resume scheduled compaction&quot;</span>, </span><br><span class="line">                zap.Int64(<span class="string">&quot;scheduled-compact-revision&quot;</span>, scheduledCompact))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="EtcdServer-applySnapshot"><a href="#EtcdServer-applySnapshot" class="headerlink" title="EtcdServer.applySnapshot"></a>EtcdServer.applySnapshot</h5><p><code>EtcdServer.applySnapshot</code> 具有重要意义，分别应用于进程重启后的状态恢复，以及 follower 加入已有集群后的状态初始化等。实际应用价值如下:</p><ul><li>集群同步：确保 Follower 节点能够快速同步到 Leader 状态</li><li>故障恢复：系统重启后能够从快照快速恢复</li><li>性能优化：避免长时间的重放日志操作</li><li>数据一致性：保证分布式系统中的强一致性</li></ul><p>核心设计原则</p><ul><li>顺序重要性：ConsistentIndex → Lessor → MVCC → 其他组件的恢复顺序</li><li>原子性：后端切换和进度更新使用原子操作</li><li>资源管理：异步关闭旧资源，避免阻塞主流程</li><li>错误处理：关键错误使用 Panic，确保系统一致性</li></ul><p>执行程图如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    O[等待 Raft 节点持久化] --&gt;A[ConsistentIndex]</span><br><span class="line">    A[ConsistentIndex] --&gt; B[Lessor]</span><br><span class="line">    B --&gt; C[MVCC Store]</span><br><span class="line">    C --&gt; D[事务钩子]</span><br><span class="line">    D --&gt; E[后端切换]</span><br><span class="line">    E --&gt; F[Alarm Store]</span><br><span class="line">    F --&gt; G[Auth Store]</span><br><span class="line">    G --&gt; H[V2 Store]</span><br><span class="line">    H --&gt; I[集群配置]</span><br><span class="line">    I --&gt; J[网络配置]</span><br><span class="line">    </span><br><span class="line">    style A fill:#0f3460,stroke:#16213e,stroke-width:2px,color:#ffffff</span><br><span class="line">    style B fill:#0d7377,stroke:#14a085,stroke-width:2px,color:#ffffff</span><br><span class="line">    style C fill:#0d7377,stroke:#14a085,stroke-width:2px,color:#ffffff</span><br><span class="line">    style D fill:#0d7377,stroke:#14a085,stroke-width:2px,color:#ffffff</span><br><span class="line">    style E fill:#6a0572,stroke:#8b008b,stroke-width:2px,color:#ffffff</span><br><span class="line">    style J fill:#2d5016,stroke:#4a7c59,stroke-width:2px,color:#ffffff</span><br></pre></td></tr></table></figure><p>这里核心的 MVCC Restore 之前已经分析过，Lesssor 后续分析，另一个核心的设计就是 <code>ConsistentIndex</code>。</p><h2 id="ConsistentIndex"><a href="#ConsistentIndex" class="headerlink" title="ConsistentIndex"></a>ConsistentIndex</h2><p><code>consistIndex</code> 存在的必要性是 etcd 确保数据一致性的核心机制：</p><ul><li>核心就是防止重复 apply entry: 通过比较 log index, 确保每个 log entry 只 applied 一次</li><li>持久化保证: 只有真正持久化的数据才被标记为已应用</li><li>重启一致性: 重启后能够正确恢复到一致状态</li><li>异常处理: 在各种异常情况（重启、leader changed、网络分区等）下都能保证数据完整性</li></ul><p>这种设计使得 etcd 能够在复杂的分布式环境中提供强一致性保证，是 etcd 作为可靠分布式键值存储的重要基础。没有 consistIndex，etcd 就无法正确处理重启、快照恢复、网络分区等场景下的日志重放问题，会导致数据不一致或重复应用的问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// position：server/etcdserver/cindex/cindex.go:58-78</span></span><br><span class="line"><span class="keyword">type</span> consistentIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// consistentIndex 表示一致副本日志中条目的偏移量</span></span><br><span class="line">    <span class="comment">// 它缓存了 &quot;consistent_index&quot; 键的值</span></span><br><span class="line">    <span class="comment">// 通过原子操作访问，必须 64 位对齐</span></span><br><span class="line">    consistentIndex <span class="type">uint64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// term 表示一致副本日志中已提交条目的 RAFT term</span></span><br><span class="line">    <span class="comment">// 通过原子操作访问，必须 64 位对齐</span></span><br><span class="line">    <span class="comment">// 从 v3.5 开始持久化到后端</span></span><br><span class="line">    term <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// applyingIndex 和 applyingTerm 是 raftpb.Entry.Index 和 raftpb.Entry.Term 的临时缓存</span></span><br><span class="line">    <span class="comment">// 它们还没有准备好被持久化，将在 txPostLockInsideApplyHook 中保存到上面的 consistentIndex 和 term</span></span><br><span class="line">    applyingIndex <span class="type">uint64</span></span><br><span class="line">    applyingTerm  <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// be 用于初始读取 consistentIndex</span></span><br><span class="line">    be Backend</span><br><span class="line">    <span class="comment">// mutex 保护 be</span></span><br><span class="line">    mutex sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-apply-中的使用"><a href="#在-apply-中的使用" class="headerlink" title="在 apply 中的使用"></a>在 apply 中的使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShouldApplyV3 <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">ApplyBoth        = ShouldApplyV3(<span class="literal">true</span>)</span><br><span class="line">ApplyV2storeOnly = ShouldApplyV3(<span class="literal">false</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span></span> apply(es []raftpb.Entry, confState *raftpb.ConfState) (appliedt <span class="type">uint64</span>, appliedi <span class="type">uint64</span>, shouldStop <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> es &#123;</span><br><span class="line">        e := es[i]</span><br><span class="line">        <span class="keyword">switch</span> e.Type &#123;</span><br><span class="line">        <span class="keyword">case</span> raftpb.EntryNormal:</span><br><span class="line">            s.applyEntryNormal(&amp;e)</span><br><span class="line">            s.setAppliedIndex(e.Index)</span><br><span class="line">            s.setTerm(e.Term)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> raftpb.EntryConfChange:</span><br><span class="line">            <span class="comment">// 我们需要在 v2store 上应用所有 WAL 条目</span></span><br><span class="line">            <span class="comment">// 并且只在后端上应用 &#x27;unapplied&#x27; (e.Index&gt;backend.ConsistentIndex)</span></span><br><span class="line">            shouldApplyV3 := membership.ApplyV2storeOnly</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置当前执行条目的一致性索引</span></span><br><span class="line">            <span class="keyword">if</span> e.Index &gt; s.consistIndex.ConsistentIndex() &#123;</span><br><span class="line">                s.consistIndex.SetConsistentApplyingIndex(e.Index, e.Term)</span><br><span class="line">                shouldApplyV3 = membership.ApplyBoth</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... 处理配置变更</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关键逻辑</strong>：</p><ul><li>对于 <code>raftpb.EntryConfChange</code>，只有当 <code>e.Index &gt; s.consistIndex.ConsistentIndex()</code> 时才应用到 v3Store（即 BlotDB）</li><li>这确保了只有新的配置变更才会被处理</li></ul><h3 id="applyEntryNormal-方法中的使用"><a href="#applyEntryNormal-方法中的使用" class="headerlink" title="applyEntryNormal() 方法中的使用"></a>applyEntryNormal() 方法中的使用</h3><p><strong>关键逻辑</strong>：</p><ul><li>同样也只有当 <code>e.Index &gt; s.consistIndex.ConsistentIndex</code> 时才应用到 v3 存储</li><li>设置 <code>applyingIndex</code> 作为临时缓存</li><li>使用 <code>defer</code> 确保在异常情况下也能更新索引 (比如接收到空包等)</li></ul><p>只有当 index 更大，shouldApplyV3 的值是 <code>membership.ApplyBoth</code>，即为 true，才真正 apply 到 backend。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span></span> applyEntryNormal(e *raftpb.Entry) &#123;</span><br><span class="line">    shouldApplyV3 := membership.ApplyV2storeOnly</span><br><span class="line">    <span class="keyword">var</span> ar *applyResult</span><br><span class="line">    index := s.consistIndex.ConsistentIndex()</span><br><span class="line">    <span class="keyword">if</span> e.Index &gt; index &#123;</span><br><span class="line">        <span class="comment">// 设置当前执行条目的一致性索引</span></span><br><span class="line">        s.consistIndex.SetConsistentApplyingIndex(e.Index, e.Term)</span><br><span class="line">        shouldApplyV3 = membership.ApplyBoth</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 在某些情况下 txPostLockInsideApplyHook 不会被调用</span></span><br><span class="line">            <span class="comment">// 在这种情况下我们应该直接推进一致性索引</span></span><br><span class="line">            newIndex := s.consistIndex.ConsistentIndex()</span><br><span class="line">            <span class="keyword">if</span> newIndex &lt; e.Index &#123;</span><br><span class="line">                s.consistIndex.SetConsistentIndex(e.Index, e.Term)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 应用条目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事务钩子机制"><a href="#事务钩子机制" class="headerlink" title="事务钩子机制"></a>事务钩子机制</h4><h3 id="TxPostLockInsideApplyHook-方法"><a href="#TxPostLockInsideApplyHook-方法" class="headerlink" title="TxPostLockInsideApplyHook 方法"></a>TxPostLockInsideApplyHook 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">newbe.SetTxPostLockInsideApplyHook(s.getTxPostLockInsideApplyHook())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span></span> getTxPostLockInsideApplyHook() <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        applyingIdx, applyingTerm := s.consistIndex.ConsistentApplyingIndex()</span><br><span class="line">        <span class="keyword">if</span> applyingIdx &gt; s.consistIndex.UnsafeConsistentIndex() &#123;</span><br><span class="line">            s.consistIndex.SetConsistentIndex(applyingIdx, applyingTerm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ul><li>TxnApplyHook 在事务锁定时调用，因此内部调用的是 <code>Unsafe</code></li><li>将 <code>applyingIndex</code> 提升为 <code>consistentIndex</code></li><li>确保只有真正持久化的数据才被标记为已应用</li><li>在服务启动或者恢复存储后端时设置钩子</li><li>确保后续的事务操作都会在 <code>Unlock</code> 前调用这个钩子<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *backend)</span></span> SetTxPostLockInsideApplyHook(hook <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">b.batchTx.lock()</span><br><span class="line"><span class="keyword">defer</span> b.batchTx.Unlock() <span class="comment">// 智能 Commit</span></span><br><span class="line">b.txPostLockInsideApplyHook = hook</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTx)</span></span> LockInsideApply() &#123;</span><br><span class="line">t.lock()</span><br><span class="line"><span class="keyword">if</span> t.backend.txPostLockInsideApplyHook != <span class="literal">nil</span> &#123;</span><br><span class="line">ValidateCalledInsideApply(t.backend.lg)</span><br><span class="line">t.backend.txPostLockInsideApplyHook()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="applySnapshot-中的应用"><a href="#applySnapshot-中的应用" class="headerlink" title="applySnapshot 中的应用"></a>applySnapshot 中的应用</h3><p><strong>关键时机</strong>：</p><ul><li>必须在恢复 lessor 之前设置后端</li><li>避免旧的索引值覆盖新的快照值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置：server/etcdserver/server.go:1340-1345</span></span><br><span class="line"><span class="comment">// We need to set the backend to consistIndex before recovering the lessor,</span></span><br><span class="line"><span class="comment">// because lessor.Recover will commit the boltDB transaction, accordingly it</span></span><br><span class="line"><span class="comment">// will get the old consistent_index persisted into the db in OnPreCommitUnsafe.</span></span><br><span class="line"><span class="comment">// Eventually the new consistent_index value coming from snapshot is overwritten</span></span><br><span class="line"><span class="comment">// by the old value.</span></span><br><span class="line">s.consistIndex.SetBackend(newbe)</span><br></pre></td></tr></table></figure></li></ul><h3 id="在启动时一致性验证中的使用"><a href="#在启动时一致性验证中的使用" class="headerlink" title="在启动时一致性验证中的使用"></a>在启动时一致性验证中的使用</h3><p><strong>验证规则</strong>：</p><ul><li><code>consistIndex &lt;= hardstate.Commit</code></li><li><code>consistIndex &gt;= snapshot.Index</code></li><li>确保启动时状态的一致性</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置：server/verify/verify.go:110-131</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateConsistentIndex</span><span class="params">(cfg Config, hardstate *raftpb.HardState, snapshot *walpb.Snapshot, be backend.Backend)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    index, term := cindex.ReadConsistentIndex(be.ReadTx())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cfg.ExactIndex &amp;&amp; index != hardstate.Commit &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;backend.ConsistentIndex (%v) expected == WAL.HardState.commit (%v)&quot;</span>, index, hardstate.Commit)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> index &gt; hardstate.Commit &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;backend.ConsistentIndex (%v) must be &lt;= WAL.HardState.commit (%v)&quot;</span>, index, hardstate.Commit)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> index &lt; snapshot.Index &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;backend.ConsistentIndex (%v) must be &gt;= last snapshot index (%v)&quot;</span>, index, snapshot.Index)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>consistIndex 也是批量更新到 blotdb，和事物提交同步</p><h4 id="OnPreCommitUnsafe"><a href="#OnPreCommitUnsafe" class="headerlink" title="OnPreCommitUnsafe"></a>OnPreCommitUnsafe</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bh *backendHooks)</span></span> OnPreCommitUnsafe(tx backend.BatchTx) &#123;</span><br><span class="line">bh.indexer.UnsafeSave(tx)</span><br><span class="line">bh.confStateLock.Lock()</span><br><span class="line"><span class="keyword">defer</span> bh.confStateLock.Unlock()</span><br><span class="line"><span class="keyword">if</span> bh.confStateDirty &#123;</span><br><span class="line">membership.MustUnsafeSaveConfStateToBackend(bh.lg, tx, &amp;bh.confState)</span><br><span class="line"><span class="comment">// save bh.confState</span></span><br><span class="line">bh.confStateDirty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MVCC&quot;&gt;&lt;a href=&quot;#MVCC&quot; class=&quot;headerlink&quot; title=&quot;MVCC&quot;&gt;&lt;/a&gt;MVCC&lt;/h1&gt;&lt;p&gt;mvcc 的核心组件&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;</summary>
      
    
    
    
    
    <category term="ETCD" scheme="https://szza.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>剖析 ETCD.kvstore</title>
    <link href="https://szza.github.io/2024/08/19/ETCD/2_kv/"/>
    <id>https://szza.github.io/2024/08/19/ETCD/2_kv/</id>
    <published>2024-08-19T14:11:49.000Z</published>
    <updated>2025-10-23T13:03:48.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="KV"><a href="#KV" class="headerlink" title="KV"></a>KV</h1><p>etcd 采用双层存储架构：</p><ul><li><code>TreeIndex</code>: 内存中的 B-tree 索引，存储 <code>user_key</code> 到 <code>revision</code> 的映射， 管理 user_key 的所有历史生命周期</li><li><code>BoltDB</code>: 持久化存储，存储 <code>revision</code> 到 <code>KeyValue</code> 的映射</li></ul><p>传统设计: key → KeyValue 只能存储最新值， ETCD 的 ‘{revision, KeyValue}’ 映射支持历史版本存储,<code>revision</code> 作为全局单调递增的版本。</p><h3 id="View-设计"><a href="#View-设计" class="headerlink" title="View 设计"></a>View 设计</h3><p>先介绍下 KV 中的两个 VIEW Inteface: ReadView、WriteView 。这两个 VIEW 提供了基本的读写接口，既是 KV Store 需要实现的接口，也是应用层向 KV Store 写入数据的接口。因此，出于最小职责原理，将这公共接口抽象成 ReadView、WriteView。 <strong>上层无需要知道完整的 KV Store Interface</strong>，只需要使用 ReadView、WriteView Inteface 中提供的函数就行。</p><p>这里的 <code>VIEW</code> 是 <code>Store</code> 是一种”引用”、”指针” 的语义。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ReadView <span class="keyword">interface</span> &#123;</span><br><span class="line">FirstRev() <span class="type">int64</span></span><br><span class="line">Rev() <span class="type">int64</span></span><br><span class="line">    Range(ctx context.Context, key, end []<span class="type">byte</span>, ro RangeOptions) (r *RangeResult, err <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriteView <span class="keyword">interface</span> &#123;</span><br><span class="line">DeleteRange(key, end []<span class="type">byte</span>) (n, rev <span class="type">int64</span>)</span><br><span class="line">Put(key, value []<span class="type">byte</span>, lease lease.LeaseID) (rev <span class="type">int64</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此 ReadView、WriteView 的实现 <code>readView</code>、<code>writeVie</code> 也是 KV Stroe 的 wrapper。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> readView <span class="keyword">struct</span>&#123; kv KV &#125;</span><br><span class="line"><span class="keyword">type</span> writeView <span class="keyword">struct</span>&#123; kv KV &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> KV <span class="keyword">interface</span> &#123;</span><br><span class="line">    ReadView</span><br><span class="line">    WriteView</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Read creates a read transaction.</span></span><br><span class="line">    Read(mode ReadTxMode, trace *traceutil.Trace) TxnRead</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write creates a write transaction.</span></span><br><span class="line">    Write(trace *traceutil.Trace) TxnWrite</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashStorage returns HashStorage interface for KV storage.</span></span><br><span class="line">    HashStorage() HashStorage</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compact frees all superseded keys with revisions less than rev.</span></span><br><span class="line">    Compact(trace *traceutil.Trace, rev <span class="type">int64</span>) (&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="type">error</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Commit commits outstanding txns into the underlying backend.</span></span><br><span class="line">    Commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore restores the KV store from a backend.</span></span><br><span class="line">    Restore(b backend.Backend) <span class="type">error</span></span><br><span class="line">    Close() <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这么设计就能良好的隔离应用层和 KV Store，只暴露给应用层基本都读写接口。</p><h3 id="Txn"><a href="#Txn" class="headerlink" title="Txn"></a>Txn</h3><p>ETCD 中任何读写操作都需要先基于 KV Store 的 <code>Read</code> 、<code>Write</code> Interface 创建 Transaction，然后在 Transaction 中完成具体的操作。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TxnRead represents a read-only transaction with operations that will not</span></span><br><span class="line"><span class="comment">// block other read transactions.</span></span><br><span class="line"><span class="keyword">type</span> TxnRead <span class="keyword">interface</span> &#123;</span><br><span class="line">ReadView</span><br><span class="line"><span class="comment">// End marks the transaction is complete and ready to commit.</span></span><br><span class="line">End()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> TxnWrite <span class="keyword">interface</span> &#123;</span><br><span class="line">TxnRead</span><br><span class="line">WriteView</span><br><span class="line"><span class="comment">// Changes gets the changes made since opening the write txn.</span></span><br><span class="line">Changes() []mvccpb.KeyValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// txnReadWrite coerces a read txn to a write, panicking on any write operation.</span></span><br><span class="line"><span class="keyword">type</span> txnReadWrite <span class="keyword">struct</span>&#123; TxnRead &#125;</span><br></pre></td></tr></table></figure><h4 id="storeTxnRead"><a href="#storeTxnRead" class="headerlink" title="storeTxnRead"></a>storeTxnRead</h4><p>TxnRead 的生命周期</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    读事务生命周期                             │</span><br><span class="line">├─────────────────────────────────────────────────────────────┤</span><br><span class="line">│  1. kvstore.Read()                                            │</span><br><span class="line">│     ├─ s.mu.RLock()                                         │</span><br><span class="line">│     ├─ s.revMu.RLock()                                      │</span><br><span class="line">│     ├─ 选择ReadTx模式                                        │</span><br><span class="line">│     ├─ tx.RLock()                                           │</span><br><span class="line">│     └─ 返回storeTxnRead                                      │</span><br><span class="line">│                                                             │</span><br><span class="line">│  2. 执行读操作                                                │</span><br><span class="line">│     ├─ tr.Range()                                           │</span><br><span class="line">│     ├─ tr.Rev()                                             │</span><br><span class="line">│     └─ tr.FirstRev()                                        │</span><br><span class="line">│                                                             │</span><br><span class="line">│  3. tr.End()                                                │</span><br><span class="line">│     ├─ tr.tx.RUnlock()                                      │</span><br><span class="line">│     └─ tr.s.mu.RUnlock()                                    │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>step-1, step-3 具体实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> storeTxnRead <span class="keyword">struct</span> &#123;</span><br><span class="line">    s  *store</span><br><span class="line">    tx backend.ReadTx</span><br><span class="line">    </span><br><span class="line">    firstRev <span class="type">int64</span>  <span class="comment">// 第一个版本</span></span><br><span class="line">    rev      <span class="type">int64</span>  <span class="comment">// 当前版本</span></span><br><span class="line">    </span><br><span class="line">    trace *traceutil.Trace</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> Read(mode ReadTxMode, trace *traceutil.Trace) TxnRead &#123;</span><br><span class="line">    s.mu.RLock()</span><br><span class="line">    s.revMu.RLock()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> tx backend.ReadTx</span><br><span class="line">    <span class="keyword">if</span> mode == ConcurrentReadTxMode &#123;</span><br><span class="line">        tx = s.b.ConcurrentReadTx()  <span class="comment">// 并发读事务</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        tx = s.b.ReadTx()            <span class="comment">// 共享缓冲读事务</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    tx.RLock()</span><br><span class="line">    firstRev, rev := s.compactMainRev, s.currentRev</span><br><span class="line">    s.revMu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> newMetricsTxnRead(&amp;storeTxnRead&#123;s, tx, firstRev, rev, trace&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tr *storeTxnRead)</span></span> End() &#123;</span><br><span class="line">    tr.tx.RUnlock() <span class="comment">// RUnlock signals the end of concurrentReadTx.</span></span><br><span class="line">    tr.s.mu.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="storeTxnWrite"><a href="#storeTxnWrite" class="headerlink" title="storeTxnWrite"></a>storeTxnWrite</h4><p>TxnWrite 生命周期如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    写事务生命周期                             │</span><br><span class="line">├─────────────────────────────────────────────────────────────┤</span><br><span class="line">│  1. store.Write()                                           │</span><br><span class="line">│     ├─ s.mu.RLock()                                         │</span><br><span class="line">│     ├─ tx.LockInsideApply()                                 │</span><br><span class="line">│     └─ 返回storeTxnWrite                                     │</span><br><span class="line">│                                                             │</span><br><span class="line">│  2. 执行写操作                                                │</span><br><span class="line">│     ├─ tw.Put()                                             │</span><br><span class="line">│     ├─ tw.DeleteRange()                                     │</span><br><span class="line">│     ├─ tw.Range() (读操作)                                   │</span><br><span class="line">│     └─ 记录变更到changes                                      │</span><br><span class="line">│                                                             │</span><br><span class="line">│  3. tw.End()                                                │</span><br><span class="line">│     ├─ 如果有变更：                                           │</span><br><span class="line">│     │  ├─ tw.s.revMu.Lock()                                 │</span><br><span class="line">│     │  └─ tw.s.currentRev++                                 │</span><br><span class="line">│     ├─ tw.tx.Unlock()                                       │</span><br><span class="line">│     ├─ 如果有变更：tw.s.revMu.Unlock()                        │</span><br><span class="line">│     └─ tw.s.mu.RUnlock()                                    │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><p>step-1, step-3 具体实现如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> storeTxnWrite <span class="keyword">struct</span> &#123;</span><br><span class="line">    storeTxnRead</span><br><span class="line">    tx backend.BatchTx</span><br><span class="line">    <span class="comment">// beginRev is the revision where the txn begins; it will write to the next revision.</span></span><br><span class="line">    beginRev <span class="type">int64</span></span><br><span class="line">    changes  []mvccpb.KeyValue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> Write(trace *traceutil.Trace) TxnWrite &#123;</span><br><span class="line">    s.mu.RLock()</span><br><span class="line">    tx := s.b.BatchTx()</span><br><span class="line">    tx.LockInsideApply()</span><br><span class="line">    tw := &amp;storeTxnWrite&#123;</span><br><span class="line">        storeTxnRead: storeTxnRead&#123;s, tx, <span class="number">0</span>, <span class="number">0</span>, trace&#125;,</span><br><span class="line">        tx:           tx,</span><br><span class="line">        beginRev:     s.currentRev,</span><br><span class="line">        changes:      <span class="built_in">make</span>([]mvccpb.KeyValue, <span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newMetricsTxnWrite(tw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *storeTxnWrite)</span></span> End() &#123;</span><br><span class="line">    <span class="comment">// only update index if the txn modifies the mvcc state.</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tw.changes) != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// hold revMu lock to prevent new read txns from opening until writeback.</span></span><br><span class="line">        tw.s.revMu.Lock()</span><br><span class="line">        tw.s.currentRev++ <span class="comment">// 存在变更则 version++</span></span><br><span class="line">    &#125;</span><br><span class="line">    tw.tx.Unlock()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(tw.changes) != <span class="number">0</span> &#123;</span><br><span class="line">        tw.s.revMu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    tw.s.mu.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h4><p><code>store</code> 中新增了两个锁:<code>mu</code> 、<code>recvMu</code>:</p><ul><li><code>mu</code> 是个 RWMutex, 写锁是为了 stroe 的状态变更，读锁是用于事物<br>-<code>recvMu</code> 是为了版本控制线程安全。</li></ul><p>注意: <code>store.Read</code> 和 <code>store.Write</code> 在创建事物时，都是用的读锁 <code>s.mu.RLock()</code>, 配合 <code>recvMu</code> 进行细粒度的控制版本变更，使得 Transaction 的创建行为不会有相互堵塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> store <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// mu read locks for txns and write locks for non-txn store changes.</span></span><br><span class="line">    mu sync.RWMutex</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// revMuLock protects currentRev and compactMainRev.</span></span><br><span class="line">    <span class="comment">// Locked at end of write txn and released after write txn unlock lock.</span></span><br><span class="line">    <span class="comment">// Locked before locking read txn and released after locking.</span></span><br><span class="line">    revMu sync.RWMutex</span><br><span class="line">    </span><br><span class="line">    currentRev     <span class="type">int64</span>  <span class="comment">// 当前版本</span></span><br><span class="line">    compactMainRev <span class="type">int64</span>  <span class="comment">// 压缩版本</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Lock 层次如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    锁层次结构                                 │</span><br><span class="line">├─────────────────────────────────────────────────────────────┤</span><br><span class="line">│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │</span><br><span class="line">│  │   store.mu  │  │  store.revMu│  │   backend.tx        │ │</span><br><span class="line">│  │  (RWMutex)  │  │  (RWMutex)  │  │   (Mutex/RWMutex)   │ │</span><br><span class="line">│  │             │  │             │  │                     │ │</span><br><span class="line">│  │ • 保护store  │  │ • 保护版本   │  │ • 保护后端事务        │ │</span><br><span class="line">│  │ • 读写分离   │  │ • 版本控制    │  │ • 事务隔离           │ │</span><br><span class="line">│  │ • 全局状态   │  │ • 原子更新    │  │ • 数据一致性          │ │</span><br><span class="line">│  └─────────────┘  └─────────────┘  └─────────────────────┘ │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="Revision"><a href="#Revision" class="headerlink" title="Revision"></a>Revision</h3><p>etcd 的 Revision 设计基于 MVCC 模型，主要包含以下核心概念：</p><ul><li><code>Main Revision</code>: 全局递增的事务版本号，每次写事务都会递增</li><li><code>Sub Revision</code>: 同一事务内多个操作的子版本号，从 0 开始递增</li><li><code>Generation</code>: 键的生命周期，从创建到删除为一个 generation</li><li><code>Tombstone</code>: 删除标记，用于标记键的删除状态</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> revision <span class="keyword">struct</span> &#123;</span><br><span class="line">    main <span class="type">int64</span>  <span class="comment">// 主版本号，全局递增</span></span><br><span class="line">    sub  <span class="type">int64</span>  <span class="comment">// 子版本号，事务内递增</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编码格式：8字节 main + 1字节分隔符&#x27;_&#x27; + 8字节sub</span></span><br><span class="line"><span class="keyword">const</span> revBytesLen = <span class="number">8</span> + <span class="number">1</span> + <span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">revToBytes</span><span class="params">(rev revision, bytes []<span class="type">byte</span>)</span></span> &#123;</span><br><span class="line">    binary.BigEndian.PutUint64(bytes, <span class="type">uint64</span>(rev.main))</span><br><span class="line">    bytes[<span class="number">8</span>] = <span class="string">&#x27;_&#x27;</span></span><br><span class="line">    binary.BigEndian.PutUint64(bytes[<span class="number">9</span>:], <span class="type">uint64</span>(rev.sub))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a revision)</span></span> GreaterThan(b revision) <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a.main &gt; b.main &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a.main &lt; b.main &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a.sub &gt; b.sub  <span class="comment">// main相等时比较sub</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Store-中的-Revision-管理"><a href="#Store-中的-Revision-管理" class="headerlink" title="Store 中的 Revision 管理"></a>Store 中的 Revision 管理</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> store <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// 保护 currentRev 和 compactMainRev 的锁</span></span><br><span class="line">    revMu sync.RWMutex</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前最新的 revision (main部分)</span></span><br><span class="line">    currentRev <span class="type">int64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最后一次压缩的 revision (main部分) , FirstRev</span></span><br><span class="line">    compactMainRev <span class="type">int64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="读事务中的-Revision"><a href="#读事务中的-Revision" class="headerlink" title="读事务中的 Revision"></a>读事务中的 Revision</h5><p>读事务特点：</p><ul><li>使用 firstRev 和 rev 确定可读的版本范围</li><li><strong>不会修改 <code>currentRev</code></strong></li><li>支持历史版本查询</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> Read(mode ReadTxMode, trace *traceutil.Trace) TxnRead &#123;</span><br><span class="line">    s.mu.RLock()</span><br><span class="line">    s.revMu.RLock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前 revision 信息</span></span><br><span class="line">    firstRev, rev := s.compactMainRev, s.currentRev</span><br><span class="line">    </span><br><span class="line">    s.revMu.RUnlock()</span><br><span class="line">    <span class="keyword">return</span> &amp;storeTxnRead&#123;s, tx, firstRev, rev, trace&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="写事务中的-Revision"><a href="#写事务中的-Revision" class="headerlink" title="写事务中的 Revision"></a>写事务中的 Revision</h5><p>写事务开始: <code>beginRev</code> &#x3D; <code>currentRev</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> Write(trace *traceutil.Trace) TxnWrite &#123;</span><br><span class="line">    s.mu.RLock()</span><br><span class="line">    tx := s.b.BatchTx()</span><br><span class="line">    tx.LockInsideApply()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录事务开始时的 revision</span></span><br><span class="line">    tw := &amp;storeTxnWrite&#123;</span><br><span class="line">        beginRev: s.currentRev,  <span class="comment">// 事务开始时的 revision</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tw</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>操作执行: </p><ul><li>每个操作使得 <code>beginRev</code> + 1 作为 Main revision</li><li>Sub revision: 同一事务内从 0 开始递增</li><li>事务提交: currentRev++，更新全局版本号</li></ul><p> 在整个写事物生命周期内，Main revision 都是 <code>beginRev</code> + 1, <code>storeTxnWrite.Put</code> 会每次只会自增一次 Sub Revision。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *storeTxnWrite)</span></span> Put(key, value []<span class="type">byte</span>, lease lease.LeaseID) <span class="type">int64</span> &#123;</span><br><span class="line">tw.put(key, value, lease)</span><br><span class="line"><span class="keyword">return</span> tw.beginRev + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *storeTxnWrite)</span></span> DeleteRange(key, end []<span class="type">byte</span>) (<span class="type">int64</span>, <span class="type">int64</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> n := tw.deleteRange(key, end); n != <span class="number">0</span> || <span class="built_in">len</span>(tw.changes) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n, tw.beginRev + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>, tw.beginRev</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *storeTxnWrite)</span></span> End() &#123;</span><br><span class="line"><span class="comment">// only update index if the txn modifies the mvcc state.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tw.changes) != <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// hold revMu lock to prevent new read txns from opening until writeback.</span></span><br><span class="line">tw.s.revMu.Lock()</span><br><span class="line">tw.s.currentRev++ <span class="comment">// 更新全局 revision</span></span><br><span class="line">&#125;</span><br><span class="line">tw.tx.Unlock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(tw.changes) != <span class="number">0</span> &#123;</span><br><span class="line">tw.s.revMu.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">tw.s.mu.RUnlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="KeyIndex"><a href="#KeyIndex" class="headerlink" title="KeyIndex"></a>KeyIndex</h3><p>ETCD 中 <code>treeIndex</code> 是一个 B-Tree，存储着所有 Key 的历史版本信息，用于 MVCC. <code>keyIndex</code> 则存储着单个 key 的版本历史信息，他们的层次关系:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">┌────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    treeIndex (B-tree)                      │</span><br><span class="line">│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐         │</span><br><span class="line">│  │  keyIndex   │  │  keyIndex   │  │  keyIndex   │         │</span><br><span class="line">│  │   &quot;foo&quot;     │  │   &quot;bar&quot;     │  │   &quot;baz&quot;     │         │</span><br><span class="line">│  └─────────────┘  └─────────────┘  └─────────────┘         │</span><br><span class="line">└────────────────────────────────────────────────────────────┘</span><br><span class="line">                              │</span><br><span class="line">                              ▼</span><br><span class="line">┌────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    keyIndex &quot;foo&quot;                          │</span><br><span class="line">│  key: &quot;foo&quot;                                                │</span><br><span class="line">│  modified: 103.0                                           │</span><br><span class="line">│  generations: [gen0, gen1, gen2]                           │</span><br><span class="line">└────────────────────────────────────────────────────────────┘</span><br><span class="line">                              │</span><br><span class="line">                              ▼</span><br><span class="line">┌────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    generation                              │</span><br><span class="line">│  ver: 3                                                    │</span><br><span class="line">│  created: 100.0                                            │</span><br><span class="line">│  revs: [100.0, 101.0, 102.0]                               │</span><br><span class="line">└────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h4 id="Generation"><a href="#Generation" class="headerlink" title="Generation"></a>Generation</h4><p>Generation 表示一个 key 的生命周期，从 <strong>创建</strong> 到 <strong>删除</strong> 为一个完整的 generation。 <code>keyIndex</code> 与 <code>Generation</code> 关系如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> keyIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">    key         []<span class="type">byte</span>        <span class="comment">// 用户键</span></span><br><span class="line">    modified    revision      <span class="comment">// 最后修改的 revision</span></span><br><span class="line">    generations []generation  <span class="comment">// 该键的所有 generation</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> generation <span class="keyword">struct</span> &#123;</span><br><span class="line">    ver     <span class="type">int64</span>      <span class="comment">// key 在这个 generation 的修改次数</span></span><br><span class="line">    created revision   <span class="comment">// generation 创建时的 revision</span></span><br><span class="line">    revs    []revision <span class="comment">// 该 generation 中的所有 revision</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Generation 生命周期示例如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">键 &quot;foo&quot; 的操作序列:</span><br><span class="line">put(1.0) → put(2.0) → delete(3.0) → put(4.0) → delete(5.0)</span><br><span class="line"></span><br><span class="line">keyIndex 结构:</span><br><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│ key: &quot;foo&quot;                                                  │</span><br><span class="line">│ modified: 5.0                                               │</span><br><span class="line">│ generations:                                                │</span><br><span class="line">│   ┌───────────────────────────────────────────────────────┐ │</span><br><span class="line">│   │ Generation 0: &#123;empty&#125;                                 │ │</span><br><span class="line">│   │   ver: 0, created: &#123;&#125;, revs: []                       │ │</span><br><span class="line">│   └───────────────────────────────────────────────────────┘ │</span><br><span class="line">│   ┌───────────────────────────────────────────────────────┐ │</span><br><span class="line">│   │ Generation 1: &#123;4.0, 5.0(t)&#125;                           │ │</span><br><span class="line">│   │   ver: 2, created: 4.0, revs: [4.0, 5.0]              │ │</span><br><span class="line">│   └───────────────────────────────────────────────────────┘ │</span><br><span class="line">│   ┌───────────────────────────────────────────────────────┐ │</span><br><span class="line">│   │ Generation 2: &#123;1.0, 2.0, 3.0(t)&#125;                      │ │</span><br><span class="line">│   │   ver: 3, created: 1.0, revs: [1.0, 2.0, 3.0]         │ │</span><br><span class="line">│   └───────────────────────────────────────────────────────┘ │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p>在 keyIndex 中 put 一个 <code>key</code> 新的版本信息 <code>&#123;main, sub&#125;</code>，行为如下:</p><ul><li>通过 <code>ki.modified</code> 来确保 revision 的单调递增</li><li>无论这个 key 是首次 put，或者是 delete 之后又 put, generation 的第一个 revision 都会更新<code>generation.created</code> 字段</li><li>更新 <code>ki.modified</code> 为当前的 <code>rev</code>，用于保证后续 put 的单调性</li><li>g.ver 记录这个 generation 的 put 次数</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// put puts a revision to the keyIndex.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ki *keyIndex)</span></span> put(lg *zap.Logger, main <span class="type">int64</span>, sub <span class="type">int64</span>) &#123;</span><br><span class="line">rev := revision&#123;main: main, sub: sub&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !rev.GreaterThan(ki.modified) &#123;</span><br><span class="line"><span class="built_in">panic</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ki.generations) == <span class="number">0</span> &#123;</span><br><span class="line">ki.generations = <span class="built_in">append</span>(ki.generations, generation&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line">g := &amp;ki.generations[<span class="built_in">len</span>(ki.generations)<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(g.revs) == <span class="number">0</span> &#123; <span class="comment">// create a new key</span></span><br><span class="line">keysGauge.Inc()</span><br><span class="line">g.created = rev <span class="comment">// &#x27;new key&#x27; or &#x27;delete -&gt; put&#x27; 都会更新 g.created</span></span><br><span class="line">&#125;</span><br><span class="line">g.revs = <span class="built_in">append</span>(g.revs, rev) <span class="comment">// 所有历史信息</span></span><br><span class="line">g.ver++</span><br><span class="line">ki.modified = rev</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="tombstone"><a href="#tombstone" class="headerlink" title="tombstone"></a>tombstone</h4><p>删除一个 key, 在 keyIndex 中是先写入一个 <code>&#123;main,sub&#125;</code>，再紧跟着一个 marker(空 generation)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ki *keyIndex)</span></span> tombstone(lg *zap.Logger, main <span class="type">int64</span>, sub <span class="type">int64</span>) <span class="type">error</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ki.isEmpty() &#123;</span><br><span class="line">lg.Panic(</span><br><span class="line"><span class="string">&quot;&#x27;tombstone&#x27; got an unexpected empty keyIndex&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;key&quot;</span>, <span class="type">string</span>(ki.key)),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 不能 delete 之后再次 delete</span></span><br><span class="line"><span class="keyword">if</span> ki.generations[<span class="built_in">len</span>(ki.generations)<span class="number">-1</span>].isEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> ErrRevisionNotFound</span><br><span class="line">&#125;</span><br><span class="line">ki.put(lg, main, sub)</span><br><span class="line">ki.generations = <span class="built_in">append</span>(ki.generations, generation&#123;&#125;)</span><br><span class="line">keysGauge.Dec()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p><code>get</code> 是 ETCD 用于查询 key, value 历史版本的核心方法。算法设计:</p><ul><li><p><code>findGeneration</code>: 从最新 generation 开始向前搜索，找到包含指定 revision 的 generation</p></li><li><p><code>walk</code>: 在 generation 内从最新 revision 开始向前遍历，找到符合条件的 revision</p></li><li><p>版本号计算: 通过公式 <code>ver = g.ver - (len(g.revs) - n - 1)</code> 精确计算版本号</p><p> 这个公式可以简单理解为 <code>ver = n + 1</code>，表征 <code>generation</code> 第几次修改</p></li></ul><p>优势:</p><ul><li>具有高效性: O(g + r) 的时间复杂度，其中 g 和 r 通常都很小。 </li><li>一致性: 确保查询结果与指定 revision 时刻一致 </li><li>可扩展性: 支持大规模数据和高并发访问 </li><li>空间效率: 通过 generation 结构优化存储</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get gets the modified, created revision and version of the key that satisfies the given atRev.</span></span><br><span class="line"><span class="comment">// Rev must be higher than or equal to the given atRev.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ki *keyIndex)</span></span> get(lg *zap.Logger, atRev <span class="type">int64</span>) (modified, created revision, ver <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ki.isEmpty() &#123;</span><br><span class="line">lg.Panic(</span><br><span class="line"><span class="string">&quot;&#x27;get&#x27; got an unexpected empty keyIndex&quot;</span>,</span><br><span class="line">zap.String(<span class="string">&quot;key&quot;</span>, <span class="type">string</span>(ki.key)),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先找到 atRev 所在的 generation</span></span><br><span class="line">g := ki.findGeneration(atRev)</span><br><span class="line"><span class="keyword">if</span> g.isEmpty() &#123;</span><br><span class="line"><span class="keyword">return</span> revision&#123;&#125;, revision&#123;&#125;, <span class="number">0</span>, ErrRevisionNotFound</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n := g.walk(<span class="function"><span class="keyword">func</span><span class="params">(rev revision)</span></span> <span class="type">bool</span> &#123; <span class="keyword">return</span> rev.main &gt; atRev &#125;)</span><br><span class="line"><span class="keyword">if</span> n != <span class="number">-1</span> &#123;</span><br><span class="line"><span class="keyword">return</span> g.revs[n], g.created, g.ver - <span class="type">int64</span>(<span class="built_in">len</span>(g.revs)-n<span class="number">-1</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> revision&#123;&#125;, revision&#123;&#125;, <span class="number">0</span>, ErrRevisionNotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="findGeneration"><a href="#findGeneration" class="headerlink" title="findGeneration"></a>findGeneration</h5><p>利用时间局部性原理，从最新 generation 到最旧的 generation 的策略进行搜索，以此来支持历史版本查询。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ki *keyIndex)</span></span> findGeneration(rev <span class="type">int64</span>) *generation &#123;</span><br><span class="line">lastg := <span class="built_in">len</span>(ki.generations) - <span class="number">1</span></span><br><span class="line">cg := lastg</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cg &gt;= <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">//  跳过空的 generation</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ki.generations[cg].revs) == <span class="number">0</span> &#123;</span><br><span class="line">cg--</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">g := ki.generations[cg]</span><br><span class="line"><span class="keyword">if</span> cg != lastg &#123;</span><br><span class="line">            <span class="comment">// Tombstone 检查: 说明 rev 在两个 generation 的间隙</span></span><br><span class="line"><span class="keyword">if</span> tomb := g.revs[<span class="built_in">len</span>(g.revs)<span class="number">-1</span>].main; tomb &lt;= rev &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 找到所属的 generation</span></span><br><span class="line"><span class="keyword">if</span> g.revs[<span class="number">0</span>].main &lt;= rev &#123;</span><br><span class="line"><span class="keyword">return</span> &amp;ki.generations[cg]</span><br><span class="line">&#125;</span><br><span class="line">cg--</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="walk"><a href="#walk" class="headerlink" title="walk"></a>walk</h5><p><code>walk</code> 函数也是根据 <strong>时间局部性原理</strong> 进行遍历，返回符合条件的位置索引 <code>l-i-1</code>，那么上层 <code>keyIndex.get</code> 返回的 <code>ver = g.ver - (l - i - 1)</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(g *generation)</span></span> walk(f <span class="function"><span class="keyword">func</span><span class="params">(rev revision)</span></span> <span class="type">bool</span>) <span class="type">int</span> &#123;</span><br><span class="line">l := <span class="built_in">len</span>(g.revs)</span><br><span class="line"><span class="keyword">for</span> i := <span class="keyword">range</span> g.revs &#123;</span><br><span class="line">ok := f(g.revs[l-i<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="keyword">return</span> l - i - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="mvccpb-KeyValue"><a href="#mvccpb-KeyValue" class="headerlink" title="mvccpb.KeyValue"></a>mvccpb.KeyValue</h3><p>写入 BlotDB 的 value 是 <code>mvccpb.KeyValue</code>:</p><ul><li>CreateRevision：全局作用域，记录键的创建时间。只在键首次创建时设置，之后保持不变, 用于历史查询和键的生命周期管理</li><li>ModRevision：全局作用域，记录键的最后修改时间。每次修改都会更新为当前 revision, 用于版本比较、Watch 机制和压缩</li><li>Version：generation 作用域，记录键在 generation 内的修改次数。每次修改递增，删除后重置为 0, 用于版本一致性检查和压缩优化</li></ul><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">KeyValue</span> &#123;</span><br><span class="line">  <span class="comment">// key is the key in bytes. An empty key is not allowed.</span></span><br><span class="line">  <span class="type">bytes</span> key = <span class="number">1</span>;</span><br><span class="line">  <span class="comment">// create_revision is the revision of last creation on this key.</span></span><br><span class="line">  <span class="type">int64</span> create_revision = <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// mod_revision is the revision of last modification on this key.</span></span><br><span class="line">  <span class="type">int64</span> mod_revision = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// version is the version of the key. A deletion resets</span></span><br><span class="line">  <span class="comment">// the version to zero and any modification of the key</span></span><br><span class="line">  <span class="comment">// increases its version.</span></span><br><span class="line">  <span class="type">int64</span> version = <span class="number">4</span>;</span><br><span class="line">  <span class="comment">// value is the value held by the key, in bytes.</span></span><br><span class="line">  <span class="type">bytes</span> value = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">// lease is the ID of the lease that attached to key.</span></span><br><span class="line">  <span class="comment">// When the attached lease expires, the key will be deleted.</span></span><br><span class="line">  <span class="comment">// If lease is 0, then no lease is attached to the key.</span></span><br><span class="line">  <span class="type">int64</span> lease = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>storeTxnWrite.put 写入</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(tw *storeTxnWrite)</span></span> put(key, value []<span class="type">byte</span>, leaseID lease.LeaseID) &#123;</span><br><span class="line">rev := tw.beginRev + <span class="number">1</span></span><br><span class="line">c := rev</span><br><span class="line">oldLease := lease.NoLease</span><br><span class="line"></span><br><span class="line"><span class="comment">// if the key exists before, use its previous created and</span></span><br><span class="line"><span class="comment">// get its previous leaseID</span></span><br><span class="line">_, created, ver, err := tw.s.kvindex.Get(key, rev)</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">c = created.main</span><br><span class="line">oldLease = tw.s.le.GetLease(lease.LeaseItem&#123;Key: <span class="type">string</span>(key)&#125;)</span><br><span class="line">tw.trace.Step(<span class="string">&quot;get key&#x27;s previous created_revision and leaseID&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">ibytes := newRevBytes()</span><br><span class="line">idxRev := revision&#123;</span><br><span class="line">main: rev,</span><br><span class="line">sub:  <span class="type">int64</span>(<span class="built_in">len</span>(tw.changes)),</span><br><span class="line">&#125;</span><br><span class="line">revToBytes(idxRev, ibytes)</span><br><span class="line"></span><br><span class="line">kv := mvccpb.KeyValue&#123;</span><br><span class="line">Key:            key,</span><br><span class="line">Value:          value,</span><br><span class="line">CreateRevision: c,</span><br><span class="line">ModRevision:    rev,</span><br><span class="line">Version:        ver + <span class="number">1</span>,</span><br><span class="line">Lease:          <span class="type">int64</span>(leaseID),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">d, err := kv.Marshal()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tw.storeTxnRead.s.lg.Fatal(</span><br><span class="line"><span class="string">&quot;failed to marshal mvccpb.KeyValue&quot;</span>,</span><br><span class="line">zap.Error(err),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tw.trace.Step(<span class="string">&quot;marshal mvccpb.KeyValue&quot;</span>)</span><br><span class="line">tw.tx.UnsafeSeqPut(buckets.Key, ibytes, d)</span><br><span class="line">tw.s.kvindex.Put(key, idxRev)</span><br><span class="line">tw.changes = <span class="built_in">append</span>(tw.changes, kv)</span><br><span class="line">tw.trace.Step(<span class="string">&quot;store kv pair into bolt db&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> oldLease != lease.NoLease &#123;</span><br><span class="line"><span class="keyword">if</span> tw.s.le == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;no lessor to detach lease&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">err = tw.s.le.Detach(oldLease, []lease.LeaseItem&#123;&#123;Key: <span class="type">string</span>(key)&#125;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">tw.storeTxnRead.s.lg.Error(</span><br><span class="line"><span class="string">&quot;failed to detach old lease from a key&quot;</span>,</span><br><span class="line">zap.Error(err),</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> leaseID != lease.NoLease &#123;</span><br><span class="line"><span class="keyword">if</span> tw.s.le == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;no lessor to attach lease&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">err = tw.s.le.Attach(leaseID, []lease.LeaseItem&#123;&#123;Key: <span class="type">string</span>(key)&#125;&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;unexpected error from lease Attach&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">tw.trace.Step(<span class="string">&quot;attach lease to kv pair&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;KV&quot;&gt;&lt;a href=&quot;#KV&quot; class=&quot;headerlink&quot; title=&quot;KV&quot;&gt;&lt;/a&gt;KV&lt;/h1&gt;&lt;p&gt;etcd 采用双层存储架构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TreeIndex&lt;/code&gt;: 内存中的 B-tree 索引，存储 </summary>
      
    
    
    
    
    <category term="ETCD" scheme="https://szza.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>剖析 ETCD.backend</title>
    <link href="https://szza.github.io/2024/08/01/ETCD/1_backend/"/>
    <id>https://szza.github.io/2024/08/01/ETCD/1_backend/</id>
    <published>2024-08-01T01:38:49.000Z</published>
    <updated>2025-10-23T13:03:46.800Z</updated>
    
    <content type="html"><![CDATA[<h1 id="backend"><a href="#backend" class="headerlink" title="backend"></a>backend</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>backend 的接口定义如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Backend <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// ReadTx returns a read transaction. It is replaced by ConcurrentReadTx in the main data path, see #10523.</span></span><br><span class="line">ReadTx() ReadTx</span><br><span class="line">BatchTx() BatchTx</span><br><span class="line"><span class="comment">// ConcurrentReadTx returns a non-blocking read transaction.</span></span><br><span class="line">ConcurrentReadTx() ReadTx</span><br><span class="line"></span><br><span class="line">Snapshot() Snapshot</span><br><span class="line">Hash(ignores <span class="function"><span class="keyword">func</span><span class="params">(bucketName, keyName []<span class="type">byte</span>)</span></span> <span class="type">bool</span>) (<span class="type">uint32</span>, <span class="type">error</span>)</span><br><span class="line">Size() <span class="type">int64</span></span><br><span class="line">SizeInUse() <span class="type">int64</span></span><br><span class="line">OpenReadTxN() <span class="type">int64</span></span><br><span class="line">Defrag() <span class="type">error</span></span><br><span class="line">ForceCommit()</span><br><span class="line">Close() <span class="type">error</span></span><br><span class="line">SetTxPostLockInsideApplyHook(<span class="function"><span class="keyword">func</span><span class="params">()</span></span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的读写操作都需要通过 <code>func BatchTx</code>(for write) 和 <code>func ConcurrentReadTx</code> (for read) 来实现，这符合DB的读写操作：读写都需要在一个 transaction 中完成。</p><p>除了读写操作， backend 还需要提供一些 ForceCommit 、Close 等保证数据安全的操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                                Backend 架构                                      │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line"></span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                              Backend Interface                                  │</span><br><span class="line">│  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────────┐  ┌─────────────┐ │</span><br><span class="line">│  │   BatchTx()     │  │   ReadTx()      │  │ ConcurrentReadTx│  │  Snapshot() │ │</span><br><span class="line">│  │                 │  │                 │  │                 │  │             │ │</span><br><span class="line">│  └─────────────────┘  └─────────────────┘  └─────────────────┘  └─────────────┘ │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">                                        │</span><br><span class="line">                                        ▼</span><br><span class="line">┌─────────────────────────────────────────────────────────────────────────────────┐</span><br><span class="line">│                              Backend 实现层                                      │</span><br><span class="line">│                                                                                 │</span><br><span class="line">│  ┌─────────────────────────────────────────────────────────────────────────┐   │</span><br><span class="line">│  │                        backend struct                                  │   │</span><br><span class="line">│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │   │</span><br><span class="line">│  │  │   mu        │  │    db       │  │  batchTx    │  │   readTx    │   │   │</span><br><span class="line">│  │  │(RWMutex)    │  │(*bolt.DB)   │  │(*batchTxBuf)│  │(*readTx)    │   │   │</span><br><span class="line">│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │   │</span><br><span class="line">│  │                                                                       │   │</span><br><span class="line">│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │   │</span><br><span class="line">│  │  │txReadBuffer │  │   hooks     │  │   stopc     │  │     lg      │   │   │</span><br><span class="line">│  │  │   Cache     │  │   (Hooks)   │  │  (chan)     │  │(*zap.Logger)│   │   │</span><br><span class="line">│  │  └─────────────┘  └─────────────┘  └─────────────┘  └─────────────┘   │   │</span><br><span class="line">│  └─────────────────────────────────────────────────────────────────────────┘   │</span><br><span class="line">└─────────────────────────────────────────────────────────────────────────────────┘</span><br><span class="line">                                        │</span><br><span class="line">                    ┌───────────────────┼───────────────────┐</span><br><span class="line">                    ▼                   ▼                   ▼</span><br><span class="line">┌─────────────────────────┐  ┌─────────────────────────┐  ┌─────────────────────────┐</span><br><span class="line">│      BatchTx 系统        │  │     ReadTx 系统         │  │    其他核心操作          │</span><br><span class="line">│                         │  │                         │  │                         │</span><br><span class="line">│ ┌─────────────────────┐ │  │ ┌─────────────────────┐ │  │ ┌─────────────────────┐ │</span><br><span class="line">│ │   batchTxBuffered   │ │  │ │      readTx         │ │  │ │     Snapshot        │ │</span><br><span class="line">│ │                     │ │  │ │                     │ │  │ │                     │ │</span><br><span class="line">│ │ ┌─────────────────┐ │ │  │ │ ┌─────────────────┐ │ │  │ │ ┌─────────────────┐ │ │</span><br><span class="line">│ │ │   txWriteBuffer │ │ │  │ │ │  baseReadTx     │ │ │  │ │ │   bolt.Tx       │ │ │</span><br><span class="line">│ │ │                 │ │ │  │ │ │                 │ │ │  │ │ │   (read-only)   │ │ │</span><br><span class="line">│ │ │ ┌─────────────┐ │ │ │  │ │ │ ┌─────────────┐ │ │ │  │ │ └─────────────────┘ │ │</span><br><span class="line">│ │ │ │bucketBuffer │ │ │ │  │ │ │ │txReadBuffer │ │ │ │  │ └─────────────────────┘ │</span><br><span class="line">│ │ │ │   (sorted)  │ │ │ │  │ │ │ │             │ │ │ │  │                         │</span><br><span class="line">│ │ │ └─────────────┘ │ │ │  │ │ │ └─────────────┘ │ │ │  │ ┌─────────────────────┐ │</span><br><span class="line">│ │ └─────────────────┘ │ │  │ │ └─────────────────┘ │ │  │ │      Defrag         │ │</span><br><span class="line">│ └─────────────────────┘ │  │ └─────────────────────┘ │  │ │                     │ │</span><br><span class="line">│                         │  │                         │  │ │ ┌─────────────────┐ │ │</span><br><span class="line">│ ┌─────────────────────┐ │  │ ┌─────────────────────┐ │  │ │ │   Temp DB       │ │ │</span><br><span class="line">│ │   Lock 机制         │ │  │ │  concurrentReadTx   │ │  │ │ │   (defrag)      │ │ │</span><br><span class="line">│ │                     │ │  │ │                     │ │  │ │ └─────────────────┘ │ │</span><br><span class="line">│ │ ┌─────────────────┐ │ │  │ │ ┌─────────────────┐ │ │  │ └─────────────────────┘ │</span><br><span class="line">│ │ │LockInsideApply │ │ │  │ │ │   baseReadTx    │ │ │  │                         │</span><br><span class="line">│ │ │LockOutsideApply│ │ │  │ │ │   (no locks)    │ │ │  │ ┌─────────────────────┐ │</span><br><span class="line">│ │ │   + Hook       │ │ │  │ │ └─────────────────┘ │ │  │ │      Hash           │ │</span><br><span class="line">│ │ └─────────────────┘ │ │  │ └─────────────────────┘ │  │ │                     │ │</span><br><span class="line">│ └─────────────────────┘ │  └─────────────────────────┘  │ │ ┌─────────────────┐ │ │</span><br><span class="line">└─────────────────────────┘                              │ │ │   CRC32 Hash    │ │ │</span><br><span class="line">                                                         │ │ └─────────────────┘ │ │</span><br><span class="line">                                                         │ └─────────────────────┘ │</span><br><span class="line">                                                         └─────────────────────────┘</span><br></pre></td></tr></table></figure><h3 id="BatchTx"><a href="#BatchTx" class="headerlink" title="BatchTx"></a>BatchTx</h3><p>写入流程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Client Request</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│   BatchTx()     │ ──► batchTxBuffered</span><br><span class="line">│                 │</span><br><span class="line">│ LockInsideApply │ ──► 1. 获取锁</span><br><span class="line">│                 │     2. 执行 Hook (更新一致性索引)</span><br><span class="line">│                 │     3. 写入 txWriteBuffer</span><br><span class="line">│                 │     4. 批量提交到 BoltDB</span><br><span class="line">└─────────────────┘</span><br></pre></td></tr></table></figure><p>写缓冲区：批量写入，减少磁盘 I&#x2F;O</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> batchTxBuffered <span class="keyword">struct</span> &#123;</span><br><span class="line">batchTx</span><br><span class="line">buf                     txWriteBuffer</span><br><span class="line">pendingDeleteOperations <span class="type">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReadTx"><a href="#ReadTx" class="headerlink" title="ReadTx"></a>ReadTx</h3><p>读缓存：避免重复复制，支持并发读取</p><p>分离读写：读写事务独立，提高并发性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Client Request</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│   ReadTx()      │ ──► readTx (单线程)</span><br><span class="line">│                 │</span><br><span class="line">│ ConcurrentReadTx│ ──► concurrentReadTx (多线程)</span><br><span class="line">│                 │     1. 从 txReadBufferCache 获取数据</span><br><span class="line">│                 │     2. 如果缓存过期，从 readTx 复制</span><br><span class="line">│                 │     3. 无锁并发读取</span><br><span class="line">└─────────────────┘</span><br></pre></td></tr></table></figure><h3 id="缓冲区同步机制"><a href="#缓冲区同步机制" class="headerlink" title="缓冲区同步机制"></a>缓冲区同步机制</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────┐    writeback    ┌─────────────────┐</span><br><span class="line">│ txWriteBuffer   │ ──────────────► │ txReadBuffer    │</span><br><span class="line">│                 │                 │                 │</span><br><span class="line">│ ┌─────────────┐ │                 │ ┌─────────────┐ │</span><br><span class="line">│ │bucketBuffer │ │                 │ │bucketBuffer │ │</span><br><span class="line">│ │  (sorted)   │ │                 │ │  (sorted)   │ │</span><br><span class="line">│ └─────────────┘ │                 │ └─────────────┘ │</span><br><span class="line">└─────────────────┘                 └─────────────────┘</span><br><span class="line">        │                                   │</span><br><span class="line">        ▼                                   ▼</span><br><span class="line">┌─────────────────┐                 ┌─────────────────┐</span><br><span class="line">│    BoltDB       │                 │  Read Cache     │</span><br><span class="line">│   (持久化)       │                 │  (内存缓存)      │</span><br><span class="line">└─────────────────┘                 └─────────────────┘</span><br></pre></td></tr></table></figure><h3 id="Lock-流程"><a href="#Lock-流程" class="headerlink" title="Lock 流程"></a>Lock 流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│                    锁的获取顺序                          │</span><br><span class="line">├─────────────────────────────────────────────────────────┤</span><br><span class="line">│ 1. batchTx.LockInsideApply() / LockOutsideApply()       │</span><br><span class="line">│ 2. backend.mu.RLock() / Lock()                          │</span><br><span class="line">│ 3. readTx.Lock() / RLock()                              │</span><br><span class="line">└─────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure><h2 id="Detail"><a href="#Detail" class="headerlink" title="Detail"></a>Detail</h2><h3 id="batchTxBuffered"><a href="#batchTxBuffered" class="headerlink" title="batchTxBuffered"></a>batchTxBuffered</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> batchTxBuffered <span class="keyword">struct</span> &#123;</span><br><span class="line">    batchTx                               <span class="comment">// base</span></span><br><span class="line">    buf                     txWriteBuffer <span class="comment">// 写缓冲区</span></span><br><span class="line">    pendingDeleteOperations <span class="type">int</span>           <span class="comment">// 待删除操作计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>batchTxBuffered</code> 继承 batchTx， 进行双重写入（同时写入 BoltDB 和内存缓冲区）的核心设计:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Client Write Request</span><br><span class="line">        │</span><br><span class="line">        ▼</span><br><span class="line">┌─────────────────┐</span><br><span class="line">│ batchTxBuffered │</span><br><span class="line">│                 │</span><br><span class="line">│ ┌─────────────┐ │    ┌─────────────────┐</span><br><span class="line">│ │ batchTx     │ │───►│    BoltDB       │ (持久化)</span><br><span class="line">│ │ (直接写入)   │ │    │   (最终存储)    │</span><br><span class="line">│ └─────────────┘ │    └─────────────────┘</span><br><span class="line">│                 │</span><br><span class="line">│ ┌─────────────┐ │    ┌─────────────────┐</span><br><span class="line">│ │ buf         │ │───►│ txWriteBuffer   │ (内存缓冲)</span><br><span class="line">│ │ (缓冲写入)   │ │    │   (性能优化)    │</span><br><span class="line">│ └─────────────┘ │    └─────────────────┘</span><br><span class="line">└─────────────────┘</span><br></pre></td></tr></table></figure><h4 id="Unlock"><a href="#Unlock" class="headerlink" title="Unlock"></a>Unlock</h4><p><code>Unlock</code> 函数在 unlock 中进行智能commit，进行 commit 的条件是:</p><ul><li>批量限制: pending &gt;&#x3D; batchLimit（默认 10000）</li><li>删除操作: pendingDeleteOperations &gt; 0（立即提交）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTxBuffered)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> t.pending != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 同步缓冲区到读缓存</span></span><br><span class="line">        t.backend.readTx.Lock()</span><br><span class="line">        t.buf.writeback(&amp;t.backend.readTx.buf)</span><br><span class="line">        t.backend.readTx.Unlock()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 智能提交判断</span></span><br><span class="line">        <span class="keyword">if</span> t.pending &gt;= t.backend.batchLimit || t.pendingDeleteOperations &gt; <span class="number">0</span> &#123;</span><br><span class="line">            t.commit(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.batchTx.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么删除操作需要立即提交？线性一致性保证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">时间线: T1 ────── T2 ────── T3</span><br><span class="line">操作:   PUT A    DELETE A  READ A</span><br></pre></td></tr></table></figure><p>如果删除操作不立即提交：</p><ul><li>T2 删除操作在缓冲区中</li><li>T3 读取可能从 <code>BoltDB</code> 读到旧数据 </li><li>违反线性一致性</li></ul><h4 id="unsafeCommit"><a href="#unsafeCommit" class="headerlink" title="unsafeCommit"></a>unsafeCommit</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">1. 写操作完成，触发 commit</span><br><span class="line">   │</span><br><span class="line">   ▼</span><br><span class="line">2. 检查是否有旧的读事务</span><br><span class="line">   │</span><br><span class="line">   ▼</span><br><span class="line">3. 启动异步 goroutine 处理旧事务</span><br><span class="line">   │</span><br><span class="line">   ├─→ 等待所有读操作完成 (wg.Wait())</span><br><span class="line">   │</span><br><span class="line">   ├─→ 回滚旧读事务 (tx.Rollback())</span><br><span class="line">   │</span><br><span class="line">   └─→ 释放资源</span><br><span class="line">   │</span><br><span class="line">   ▼</span><br><span class="line">4. 立即重置 readTx 状态</span><br><span class="line">   │</span><br><span class="line">   ▼</span><br><span class="line">5. 提交写事务到 BoltDB</span><br><span class="line">   │</span><br><span class="line">   ▼</span><br><span class="line">6. 开始新的读事务</span><br></pre></td></tr></table></figure><p>unsafeCommit 中存在一个异步优化：</p><ul><li><p>非阻塞提交：读事务回滚在 goroutine 中异步进行</p><p>BlotDB 的 Read Transaction 有几个关键点:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BoltDB 读事务是只读的，不能提交</span></span><br><span class="line">tx, err := b.db.Begin(<span class="literal">false</span>)  <span class="comment">// false = 只读事务</span></span><br></pre></td></tr></table></figure><ul><li>只读事务：BoltDB 的读事务是只读的，不能调用 Commit()</li><li>必须关闭：读事务必须通过 Rollback() 来关闭</li><li>资源管理：未关闭的事务会占用数据库资源</li></ul></li><li><p>无缝切换：新读事务立即开始，不等待旧事务完成</p><p>  原因：</p><ul><li>数据一致性：新提交的数据需要对新读事务可见, 基于当前 snapshot 创建新的读事物</li><li>快照隔离：每个读事务看到的是特定时间点的数据快照</li><li>资源管理：避免长时间持有旧事务</li></ul></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTxBuffered)</span></span> unsafeCommit(stop <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 异步处理旧读事务</span></span><br><span class="line">    <span class="keyword">if</span> t.backend.readTx.tx != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(tx *bolt.Tx, wg *sync.WaitGroup)</span></span> &#123;</span><br><span class="line">            wg.Wait()  <span class="comment">// 异步等待所有读操作完成</span></span><br><span class="line">            tx.Rollback()</span><br><span class="line">        &#125;(t.backend.readTx.tx, t.backend.readTx.txWg)</span><br><span class="line"><span class="comment">// 立即重置读事物</span></span><br><span class="line">        t.backend.readTx.reset()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 提交写事务</span></span><br><span class="line">    t.batchTx.commit(stop)</span><br><span class="line">    t.pendingDeleteOperations = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 开始新读事务，保证新提交的数据对新读事务可见</span></span><br><span class="line">    <span class="keyword">if</span> !stop &#123;</span><br><span class="line">        t.backend.readTx.tx = t.backend.begin(<span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WaitGroup-的保护机制"><a href="#WaitGroup-的保护机制" class="headerlink" title="WaitGroup 的保护机制"></a>WaitGroup 的保护机制</h5><p>在 <code>ConcurrentReadTx</code> 中有个 txWg，在创建并发读事物时会增加一个引用计数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 ConcurrentReadTx 中</span></span><br><span class="line">b.readTx.txWg.Add(<span class="number">1</span>)  <span class="comment">// 增加计数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 concurrentReadTx.RUnlock() 中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *concurrentReadTx)</span></span> RUnlock() &#123; </span><br><span class="line">    rt.txWg.Done()  <span class="comment">// 减少计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WaitGroup 在 <code>unsafeCommit</code> 中的异步保护机制：</p><ul><li>引用计数：每个活跃的读操作增加计数         <code>b.readTx.txWg.Add(1)</code></li><li>安全关闭：只有当所有读操作完成后才回滚事务   <code>RUnlock: txWg.Done()</code></li><li>避免崩溃：防止在活跃读操作时关闭事务        <code>wg.Wait(); tx.Rollback()</code></li></ul><h4 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h4><p>流程如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">batchTxBuffered.commit()</span><br><span class="line">    │</span><br><span class="line">    ├─→ t.backend.readTx.Lock()  // 1. 锁定读事务</span><br><span class="line">    │</span><br><span class="line">    ├─→ t.unsafeCommit()         // 2. 执行提交逻辑</span><br><span class="line">    │   │</span><br><span class="line">    │   ├─→ 异步回滚旧读事务</span><br><span class="line">    │   ├─→ 提交写事务到 BoltDB</span><br><span class="line">    │   └─→ 创建新读事务</span><br><span class="line">    │</span><br><span class="line">    └─→ t.backend.readTx.Unlock() // 3. 释放读事务锁</span><br></pre></td></tr></table></figure><p><code>commit</code> 函数中先执行 <code>t.backend.readTx.Lock()</code> 的作用:</p><ul><li>阻止新读事务: 防止在提交期间启动新的读事务</li><li>等待活跃读事务: 等待所有正在进行的读事务完成</li><li>保护事务切换: 确保读事务的安全切换<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTxBuffered)</span></span> commit(stop <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// all read txs must be closed to acquire boltdb commit rwlock</span></span><br><span class="line">t.backend.readTx.Lock()</span><br><span class="line">t.unsafeCommit(stop)</span><br><span class="line">t.backend.readTx.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里的核心是 <code>t.backend.readTx.Lock() </code> 的作用。</p><p>首先，这里使用的 <code>Lock</code> 而不是 <code>RLOCK()</code>，由于写锁会阻塞所有的读锁，即阻塞 <code>ConcurrentReadTx</code> 函数创建新的 ReadTx, 需要等待当前所有活跃的 ReadTxs 完成，并确保写操作提交完成，再释放 Lock，才允许创建新的 ReadTx。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *backend)</span></span> ConcurrentReadTx() ReadTx &#123;</span><br><span class="line">    b.readTx.RLock()         <span class="comment">// 获取读锁</span></span><br><span class="line">    <span class="keyword">defer</span> b.readTx.RUnlock()</span><br><span class="line">    <span class="comment">// prevent boltdb read Tx from been rolled back until store read Tx is done. </span></span><br><span class="line">    <span class="comment">// Needs to be called when holding readTx.RLock().</span></span><br><span class="line">    b.readTx.txWg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>无写操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间线: T1 ────── T2 ────── T3</span><br><span class="line">操作:   读事务1   读事务2   读事务3</span><br><span class="line">锁状态: RLock()   RLock()   RLock()  (并发)</span><br></pre></td></tr></table></figure><p><strong>有写操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间线: T1 ────── T2 ────── T3 ────── T4</span><br><span class="line">操作:   读事务1   写提交    新读事务   写提交完成</span><br><span class="line">锁状态: RLock()   Lock()   阻塞       Unlock()</span><br></pre></td></tr></table></figure><p>如果没有 <code>readTx.Lock()</code> 的情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间线: T1 ────── T2 ────── T3 ────── T4</span><br><span class="line">操作:   写事务提交  新读事务开始  旧读事务回滚  新读事务读取</span><br><span class="line">状态:   准备提交    创建新事务    回滚旧事务    可能读到不一致数据</span><br></pre></td></tr></table></figure><p>问题：</p><ul><li>数据不一致：新读事务可能读到部分更新的数据</li><li>竞态条件：读事务创建和旧事务回滚的竞态</li><li>资源冲突：多个读事务同时访问 BoltDB</li></ul><p>存在 <code>readTx.Lock()</code> 的情况:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">时间线: T1 ────── T2 ────── T3 ────── T4</span><br><span class="line">操作:   获取读锁    等待读事务完成  提交写事务  释放锁</span><br><span class="line">状态:   阻塞新读    等待活跃读完成  原子提交   允许新读事务</span><br></pre></td></tr></table></figure><h4 id="Commit"><a href="#Commit" class="headerlink" title="Commit"></a>Commit</h4><p><code>Commit</code> 函数相比较 <code>commit</code> 函数多了一个 <code>lock()</code> 函数，这是继承自 <code>BatchTx</code> 的 <code>lock</code> 函数:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTxBuffered)</span></span> Commit() &#123;</span><br><span class="line">    t.lock()           <span class="comment">// 第一层：batchTx 的互斥锁</span></span><br><span class="line">    t.commit(<span class="literal">false</span>)    <span class="comment">// 内部调用</span></span><br><span class="line">    t.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> batchTx <span class="keyword">struct</span> &#123;</span><br><span class="line">    sync.Mutex        <span class="comment">// for lcok()</span></span><br><span class="line">    tx      *bolt.Tx  <span class="comment">// BoltDB 事务对象</span></span><br><span class="line">    backend *backend  <span class="comment">// 后端引用</span></span><br><span class="line">    pending <span class="type">int</span>       <span class="comment">// 待处理操作计数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lock</code> 主要是保护 <code>BatchTx</code> 的共享状态，与 <code>readTx.Lock()</code> 的协同作用:</p><ul><li><code>t.lock()</code>：保护 batchTx 内部状态，防止并发写操作</li><li><code>readTx.Lock()</code>：保护 BoltDB 事务提交，防止读事务干扰</li></ul><p>这么设计设计，优点是确保数据一致性和事务完整性， 缺点是在提交期间阻塞所有写操作，因此通过批量提交减少锁的持有时间来优化。</p><h4 id="UsafePut-UnsafeDelete"><a href="#UsafePut-UnsafeDelete" class="headerlink" title="UsafePut&#x2F;UnsafeDelete"></a>UsafePut&#x2F;UnsafeDelete</h4><p><code>batchTxBuffered</code> 有几个 Unsafe 函数，<code>Unsafe</code> 的意思这些函数都需要在 <code>t.lock()</code> 的保护下执行，分别由 <code>BatchTx</code> 接口中的 <code>LockInsideApply</code> 和 <code>LockOutsideApply</code> 封装。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTxBuffered)</span></span> UnsafePut(bucket Bucket, key []<span class="type">byte</span>, value []<span class="type">byte</span>) &#123;</span><br><span class="line">t.batchTx.UnsafePut(bucket, key, value)</span><br><span class="line">t.buf.put(bucket, key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTxBuffered)</span></span> UnsafeSeqPut(bucket Bucket, key []<span class="type">byte</span>, value []<span class="type">byte</span>) &#123;</span><br><span class="line">t.batchTx.UnsafeSeqPut(bucket, key, value)</span><br><span class="line">t.buf.putSeq(bucket, key, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTxBuffered)</span></span> UnsafeDelete(bucketType Bucket, key []<span class="type">byte</span>) &#123;</span><br><span class="line">t.batchTx.UnsafeDelete(bucketType, key)</span><br><span class="line">t.pendingDeleteOperations++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTxBuffered)</span></span> UnsafeDeleteBucket(bucket Bucket) &#123;</span><br><span class="line">t.batchTx.UnsafeDeleteBucket(bucket)</span><br><span class="line">t.pendingDeleteOperations++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BatchTx</code> 的 <code>LockOutsideApply</code> 和 <code>LockInsideApply</code> 区别就是在于是否在 Log Apply 的过程。</p><ul><li><p><code>LockInsideApply</code>：</p><ul><li>验证调用是否在 Apply 上下文中（即 Raft 日志应用过程中）</li><li>通过检查调用栈是否包含 .applyEntries 来判断</li><li>如果设置了 <code>txPostLockInsideApplyHook</code>，会额外验证调用栈</li></ul><p> 实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(t *batchTx)</span></span> LockInsideApply() &#123;</span><br><span class="line">       t.lock()</span><br><span class="line">       <span class="keyword">if</span> t.backend.txPostLockInsideApplyHook != <span class="literal">nil</span> &#123;</span><br><span class="line">           ValidateCalledInsideApply(t.backend.lg)</span><br><span class="line">           t.backend.txPostLockInsideApplyHook()  <span class="comment">// 执行钩子函数</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HOOK: 这个钩子确保在 Apply 过程中，consistIndex 能够正确更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span></span> getTxPostLockInsideApplyHook() <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">           applyingIdx, applyingTerm := s.consistIndex.ConsistentApplyingIndex()</span><br><span class="line">           <span class="keyword">if</span> applyingIdx &gt; s.consistIndex.UnsafeConsistentIndex() &#123;</span><br><span class="line">               s.consistIndex.SetConsistentIndex(applyingIdx, applyingTerm)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li><li><p>LockOutsideApply()：</p><ul><li>验证调用是否在 Apply 上下文之外</li><li>如果检测到在 Apply 上下文中调用，会触发 panic</li></ul><p>实现如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTx)</span></span> LockOutsideApply() &#123;</span><br><span class="line">    ValidateCalledOutSideApply(t.backend.lg)</span><br><span class="line">    t.lock()  <span class="comment">// 只获取锁，不执行钩子函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 主要用于系统初始化、恢复、维护操作等不需要更新一致性索引的操作 例如：存储初始化、数据清理、压缩等</p></li></ul><h4 id="Unlock-1"><a href="#Unlock-1" class="headerlink" title="Unlock"></a>Unlock</h4><p>到此，再重新审视下 <code>batchTxBuffered::Unlock</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTxBuffered)</span></span> Unlock() &#123;</span><br><span class="line">    <span class="keyword">if</span> t.pending != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="comment">// 1. 同步缓冲区到读缓存</span></span><br><span class="line">        t.backend.readTx.Lock()</span><br><span class="line">        t.buf.writeback(&amp;t.backend.readTx.buf)</span><br><span class="line">        t.backend.readTx.Unlock()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 智能提交判断</span></span><br><span class="line">        <span class="keyword">if</span> t.pending &gt;= t.backend.batchLimit || t.pendingDeleteOperations &gt; <span class="number">0</span> &#123;</span><br><span class="line">            t.commit(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    t.batchTx.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里核心是 <code>t.buf.writeback</code> 和 <code>t.batchTx.Unlock</code> 两个功能。后者是为了和 <code>t.lock()</code> 配对，释放锁资源。**<code>writeback</code> 的作用是将写缓冲区的数据同步到读缓冲区，来确保新写入的数据对后续读操作可见，进而保证 etcd 的线性一致性语义**</p><h3 id="ReadTx-1"><a href="#ReadTx-1" class="headerlink" title="ReadTx"></a>ReadTx</h3><p>上面阐述了写事物 <code>BatchTx</code> 如何进行写操作，下面来阐述读事物 <code>ConcurrentReadTx</code>。</p><h4 id="txReadBufferCache"><a href="#txReadBufferCache" class="headerlink" title="txReadBufferCache"></a>txReadBufferCache</h4><p>缓存策略</p><ul><li><code>bufVersion</code> 版本控制：通过版本号检测缓存有效性</li><li>延迟更新：只在必要时更新缓存</li><li>并发安全：使用锁保护缓存操作</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> txReadBufferCache <span class="keyword">struct</span> &#123;</span><br><span class="line">mu         sync.Mutex</span><br><span class="line">buf        *txReadBuffer</span><br><span class="line">bufVersion <span class="type">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TxReadBuffer"><a href="#TxReadBuffer" class="headerlink" title="TxReadBuffer"></a>TxReadBuffer</h4><p><code>txReadBufferCache.bufVersion</code> 缓存的是 <code>txReadBuffer.bufVersion</code> 的值: 只有当写事物提交时（BatchTx.commit）并在 writeback 函数中才会自增 <code>txReadBuffer.bufVersion++</code> 因此可以用两个 <code>bufVersion</code> 进行比较来确定缓存 <code>b.txReadBufferCache</code> 的有效性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// txReadBuffer accesses buffered updates.</span></span><br><span class="line"><span class="keyword">type</span> txReadBuffer <span class="keyword">struct</span> &#123;</span><br><span class="line">txBuffer</span><br><span class="line"><span class="comment">// bufVersion is used to check if the buffer is modified recently</span></span><br><span class="line">bufVersion <span class="type">uint64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(txw *txWriteBuffer)</span></span> writeback(txr *txReadBuffer) &#123;</span><br><span class="line">    <span class="comment">// ... 数据合并逻辑 ...</span></span><br><span class="line">    txw.reset()</span><br><span class="line">    <span class="comment">// increase the buffer version</span></span><br><span class="line">    txr.bufVersion++  <span class="comment">// 只有每次 writeback 后版本号 +1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图展示了一个 <code>txReadBufferCache.buf</code> demo: 如果在 <code>bufVersion</code> 有效期间创建 <code>ConcurrentReadTx</code>，则只会复制一次 <code>b.readTx.buf</code>，减少了多次 copy 行为，降低了集群压力。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> backend <span class="keyword">struct</span> &#123;</span><br><span class="line">readTx *readTx</span><br><span class="line"><span class="comment">// txReadBufferCache mirrors &quot;txReadBuffer&quot; within &quot;readTx&quot; -- readTx.baseReadTx.buf.</span></span><br><span class="line"><span class="comment">// When creating &quot;concurrentReadTx&quot;:</span></span><br><span class="line"><span class="comment">// - if the cache is up-to-date, &quot;readTx.baseReadTx.buf&quot; copy can be skipped</span></span><br><span class="line"><span class="comment">// - if the cache is empty or outdated, &quot;readTx.baseReadTx.buf&quot; copy is required</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Without Cache:</span></span><br><span class="line"><span class="comment">// readTx.baseReadTx.buf → copy → concurrentReadTx1</span></span><br><span class="line"><span class="comment">// readTx.baseReadTx.buf → copy → concurrentReadTx2</span></span><br><span class="line"><span class="comment">// readTx.baseReadTx.buf → copy → concurrentReadTx3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// With Cache:</span></span><br><span class="line"><span class="comment">// readTx.baseReadTx.buf → copy → cache → concurrentReadTx1</span></span><br><span class="line"><span class="comment">// .............................  cache → concurrentReadTx2</span></span><br><span class="line"><span class="comment">// .............................  cache → concurrentReadTx3</span></span><br><span class="line">txReadBufferCache txReadBufferCache</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConcurrentReadTx"><a href="#ConcurrentReadTx" class="headerlink" title="ConcurrentReadTx"></a>ConcurrentReadTx</h4><p><code>ConcurrentReadT</code> 的核心设计目标：</p><ul><li>非阻塞读操作<ul><li>并发安全：多个读操作可以同时进行</li><li>无锁设计：读操作不需要获取锁, 多个读操作可以并行执行</li><li>性能优化：避免读操作被写操作阻塞<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(rt *concurrentReadTx)</span></span> Lock()   &#123;&#125;  <span class="comment">// 空实现</span></span><br><span class="line">      <span class="function"><span class="keyword">func</span> <span class="params">(rt *concurrentReadTx)</span></span> RLock()  &#123;&#125;  <span class="comment">// 空实现</span></span><br><span class="line">      <span class="function"><span class="keyword">func</span> <span class="params">(rt *concurrentReadTx)</span></span> Unlock() &#123;&#125;  <span class="comment">// 空实现</span></span><br><span class="line"> <span class="comment">// 创建时：txWg.Add(1) 增加计数</span></span><br><span class="line">       <span class="comment">// 完成时：txWg.Done() 减少计数</span></span><br><span class="line">       <span class="comment">// 保护机制: 在 batchTx.commit 时，先等待所有并发读事物结束, 防止 BoltDB 事务过早回滚, </span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rt *concurrentReadTx)</span></span> RUnlock() &#123; rt.txWg.Done() &#125; <span class="comment">// 引用计数，管理多个读事物生命周期</span></span><br></pre></td></tr></table></figure></li></ul></li><li>数据一致性保证<ul><li>快照隔离：每个读事务看到特定时间点的数据</li><li>缓冲区同步：确保读操作能看到最新的写入数据</li></ul></li></ul><h4 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h4><p>第一阶段: 获取 <code>readTx</code> 读锁和事务保护。这里和 <code>batchTxBuffered.commit</code> 形成对比，当 BatchTx 在执行 <code>commit</code> 时会导致 <code>backend.ConcurrentReadTx</code> 函数中第一阶段 <code>readTx.RLock()</code> 阻塞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span> (b *backend) <span class="built_in">ConcurrentReadTx</span>() ReadTx &#123;</span><br><span class="line">    b.readTx.<span class="built_in">RLock</span>()                    <span class="comment">// 1. 获取读锁: 如果在 commit 则等待 readTx.UnLock</span></span><br><span class="line">    defer b.readTx.<span class="built_in">RUnlock</span>()            <span class="comment">// 2. 确保释放读锁</span></span><br><span class="line">    b.readTx.txWg.<span class="built_in">Add</span>(<span class="number">1</span>)                <span class="comment">// 3. 增加等待组计数，用于生命周期管理，跟踪活跃的读事务</span></span><br><span class="line">    <span class="comment">// ...below</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二阶段: 智能缓存管理</p><p>存策略： 通过 <code>bufVersion</code> 检测缓存是否过期。三种情况处理：空缓存、过期缓存、有效缓存。</p><p>由于 <code>commit</code> 中存在 <code>writeback</code> 策略，因此在 <code>commit</code> 结束使得 <code>b.readTx.RLock()</code> 解除阻塞后，<code>b.readTx.buf</code> 中总是缓存着当前最新的数据，那么 <code>ConcurrentReadTx</code> 得到 ReadTx 即基于最新的 snapshot， 保证了数据一致性。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(b *backend)</span></span> ConcurrentReadTx() ReadTx &#123;</span><br><span class="line"><span class="comment">//... above</span></span><br><span class="line"></span><br><span class="line">   b.txReadBufferCache.mu.Lock()       <span class="comment">// 4. 获取缓存锁</span></span><br><span class="line">       curCache := b.txReadBufferCache.buf</span><br><span class="line">       curCacheVer := b.txReadBufferCache.bufVersion</span><br><span class="line">       curBufVer := b.readTx.buf.bufVersion</span><br><span class="line"></span><br><span class="line">       isEmptyCache := curCache == <span class="literal">nil</span></span><br><span class="line">       isStaleCache := curCacheVer != curBufVer</span><br><span class="line"><span class="comment">//...below</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第三阶段:缓冲区复制优化策略</p><ul><li>延迟复制：只在必要时才复制缓冲区</li><li>并发优化：在复制时释放锁，提高并发性</li><li>版本检查：防止并发复制导致的数据不一致<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(b *backend)</span></span> ConcurrentReadTx() ReadTx &#123;</span><br><span class="line"><span class="comment">//... above</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> buf *txReadBuffer</span><br><span class="line">       <span class="keyword">switch</span> &#123;</span><br><span class="line">       <span class="keyword">case</span> isEmptyCache:</span><br><span class="line">           <span class="comment">// 首次创建缓存</span></span><br><span class="line">           curBuf := b.readTx.buf.unsafeCopy()</span><br><span class="line">           buf = &amp;curBuf</span><br><span class="line">           </span><br><span class="line">       <span class="keyword">case</span> isStaleCache:</span><br><span class="line">           <span class="comment">// 过期缓存，需要更新</span></span><br><span class="line">           b.txReadBufferCache.mu.Unlock()  <span class="comment">// 释放锁进行复制</span></span><br><span class="line">           curBuf := b.readTx.buf.unsafeCopy()</span><br><span class="line">           b.txReadBufferCache.mu.Lock()    <span class="comment">// 重新获取锁</span></span><br><span class="line">           buf = &amp;curBuf</span><br><span class="line">           </span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           <span class="comment">// 缓存有效，直接使用</span></span><br><span class="line">           buf = curCache</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...below</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>第四阶段: 缓存更新和版本控制机制</p><ul><li>原子性检查：确保缓存版本没有被其他线程修改</li><li>安全更新：只在版本一致时更新缓存</li><li>失败处理：版本不一致时跳过更新，下次调用会重新复制<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> isEmptyCache || curCacheVer == b.txReadBufferCache.bufVersion &#123;</span><br><span class="line">    <span class="comment">// 更新缓存</span></span><br><span class="line">    b.txReadBufferCache.buf = buf</span><br><span class="line">    b.txReadBufferCache.bufVersion = curBufVer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>第五阶段: 创建并发读事务</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &amp;concurrentReadTx&#123;</span><br><span class="line">    baseReadTx: baseReadTx&#123;</span><br><span class="line">        buf:     *buf,              <span class="comment">// 复制的缓冲区</span></span><br><span class="line">        txMu:    b.readTx.txMu,     <span class="comment">// 共享的事务锁</span></span><br><span class="line">        tx:      b.readTx.tx,       <span class="comment">// 共享的 BoltDB 事务</span></span><br><span class="line">        buckets: b.readTx.buckets,  <span class="comment">// 共享的桶缓存</span></span><br><span class="line">        txWg:    b.readTx.txWg,     <span class="comment">// 共享的等待组</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;backend&quot;&gt;&lt;a href=&quot;#backend&quot; class=&quot;headerlink&quot; title=&quot;backend&quot;&gt;&lt;/a&gt;backend&lt;/h1&gt;&lt;h2 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerli</summary>
      
    
    
    
    
    <category term="ETCD" scheme="https://szza.github.io/tags/ETCD/"/>
    
  </entry>
  
  <entry>
    <title>Conflict-free Replicated Data Types: An Overview</title>
    <link href="https://szza.github.io/2023/12/31/Paper/CRDT/"/>
    <id>https://szza.github.io/2023/12/31/Paper/CRDT/</id>
    <published>2023-12-31T02:20:00.000Z</published>
    <updated>2025-10-23T13:06:42.724Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Abstarct"><a href="#Abstarct" class="headerlink" title="Abstarct"></a>Abstarct</h2><p>强一致性需要的延迟高，无法应当网络分区（network partition）故障，很有可能导致无法执行操作，那么可选的方案就是弱一致性模型，比如最终一致性（eventual consistency），因果一致性（causal consistency），此时任何一个副本都能接受更新，并异步复制到其他副本。</p><p>采用弱一致性模型的系统，就允许副本短暂的和集群分离(比如因为网络问题等），并且需要一个机制来合并 (merge mechanism) 对同一个状态的并发更新。Conflict-free Replicated Data Types(CRDT) 就是这么一种算法。</p><h2 id="CRDTs-for-the-Application-Developer"><a href="#CRDTs-for-the-Application-Developer" class="headerlink" title="CRDTs for the Application Developer"></a>CRDTs for the Application Developer</h2><h3 id="Happend-before-relation"><a href="#Happend-before-relation" class="headerlink" title="Happend-before relation"></a>Happend-before relation</h3><p>happen-before relation 定义：event1 happend-before event2 （表述为 e1 ≺ e2）， 当且仅当满足条件以下三个条件之一：</p><ol><li>相同进程中，e1 在发生在 e2</li><li>e1 是 message m 的发送端，e2 是 message m 的接收端</li><li>已经存在一个 event e，满足 e1 ≺ e ≺ e2 条件</li></ol><p>在 CRDT 中，如果 update u1 happend-before update u2，u1 ≺ u2，当且仅当当u2开始执行时 u1 已经生效。</p><h3 id="Total-order-among-updates"><a href="#Total-order-among-updates" class="headerlink" title="Total order among updates"></a>Total order among updates</h3><p>定义全局序</p><h2 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h2><ol><li>fig7 的结果???</li></ol><h2 id="CRDTs-for-the-System-Developer"><a href="#CRDTs-for-the-System-Developer" class="headerlink" title="CRDTs for the System Developer"></a>CRDTs for the System Developer</h2><h3 id="3-1-Synchronization-model"><a href="#3-1-Synchronization-model" class="headerlink" title="3.1 Synchronization model"></a>3.1 Synchronization model</h3><h4 id="3-1-State-based-synchronization"><a href="#3-1-State-based-synchronization" class="headerlink" title="3.1 State-based synchronization"></a>3.1 State-based synchronization</h4><p>crdt 需要设计一个 merge 函数来合并remote rpelica 发送的状态，收敛条件有三个：</p><ol><li>基于的状态是可以形成一个偏序的:</li><li>产生的新状态要大于等于原始状态：对于更新 u, $s leq u(s)$，</li><li>merge 函数需要生成两个状态的最小上界：对于状态 states s1, s2 ， 能得到 $s1 \bigcup s2$.</li></ol><p>为了确保所有的更新最终都能到达所有的副本，我们只需要保证同步图是连通的。</p><blockquote><p>这里的”同步图”代表分布式系统中不同数据副本间的通信路径。如果图是连通的，那就意味着图中任意两个节点（副本）之间都存在路径。 这是保证所有更新最终到达所有副本的必要条件。如果图不连通，那么可能存在一些副本与其他副本隔离，无法接收到所有的更新。然而，需要注意的是，虽然连通的同步图是必要的，但在所有情况下，它可能并不足以确保最终的一致性。其他因素，如操作的顺序和网络延迟，也可能影响所有副本是否最终达到一致。例如，在一些分布式系统中，可能需要使用额外的机制，如向量时钟，来跟踪操作的因果顺序，或使用确保按照某种顺序将更新传播到所有副本的协议。</p></blockquote><h4 id="3-1-2-Operation-based-synchronization"><a href="#3-1-2-Operation-based-synchronization" class="headerlink" title="3.1.2 Operation-based synchronization"></a>3.1.2 Operation-based synchronization</h4><p>传递的是更新。除了要可靠地传递给 operations，一些 crdt 设计还需要按照某些顺序来传递 operation。</p><p>TODO….</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Abstarct&quot;&gt;&lt;a href=&quot;#Abstarct&quot; class=&quot;headerlink&quot; title=&quot;Abstarct&quot;&gt;&lt;/a&gt;Abstarct&lt;/h2&gt;&lt;p&gt;强一致性需要的延迟高，无法应当网络分区（network partition）故障，很有可能导</summary>
      
    
    
    
    <category term="CRDT" scheme="https://szza.github.io/categories/CRDT/"/>
    
    
    <category term="CRDT" scheme="https://szza.github.io/tags/CRDT/"/>
    
  </entry>
  
  <entry>
    <title>HashTable 设计: Seven Dimensional Analysis of Hashing Methods</title>
    <link href="https://szza.github.io/2023/11/05/Paper/HashTable-Desigin/"/>
    <id>https://szza.github.io/2023/11/05/Paper/HashTable-Desigin/</id>
    <published>2023-11-05T02:12:01.000Z</published>
    <updated>2023-11-12T03:10:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>针对 {key, value} 都是 64 bits 整型，论文从如下五个维度设计单线程 HashTable:</p><ol><li>数据分布</li><li>数据集大小</li><li>负载因子</li><li>读写率</li><li>查找成功率</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;针对 {key, value} 都是 64 bits 整型，论文从如下五个维度设计单线程 HashTable:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据分布&lt;/li&gt;
&lt;li&gt;数据集大小&lt;/li&gt;
&lt;li&gt;负载因子&lt;/li&gt;
&lt;li&gt;读写率&lt;/li&gt;
&lt;li&gt;查找成功率&lt;/li&gt;
&lt;</summary>
      
    
    
    
    
    <category term="Papers" scheme="https://szza.github.io/tags/Papers/"/>
    
  </entry>
  
  <entry>
    <title>SIMD: avx2_select_if 函数实现</title>
    <link href="https://szza.github.io/2023/10/29/SIMD/selector/"/>
    <id>https://szza.github.io/2023/10/29/SIMD/selector/</id>
    <published>2023-10-29T02:00:01.000Z</published>
    <updated>2023-11-04T02:31:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是讲述下 StarRocks 中如何利用 SIMD 指令来实现 select_if 的，其中关于 SIMD 的相关 API 含义直接参考 <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html"><strong>intel-intrinsics-guide</strong></a> 文档</p><h2 id="avx2-select-if-common-impl"><a href="#avx2-select-if-common-impl" class="headerlink" title="avx2_select_if_common_impl"></a>avx2_select_if_common_impl</h2><p>调用 avx2_select_if_common_impl 函数的前提是 sizeof(T) 是 {2,4,8} 中的一个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">bool</span> <span class="title">could_use_common_select_if</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">sizeof</span>(T) == <span class="number">2</span> || <span class="built_in">sizeof</span>(T) == <span class="number">4</span> || <span class="built_in">sizeof</span>(T) == <span class="number">8</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>select_if 的简单实现就是使用一个 for-loop 对 conditions 中每个条件进行判断：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> cond, a, <span class="function">b in <span class="title">zip</span><span class="params">(conditions, vector_a, vector_b)</span>:</span></span><br><span class="line"><span class="function">    dst.append(a if cond =</span>= True <span class="keyword">else</span> b)</span><br></pre></td></tr></table></figure><p>要用 SIMD 指令来实现 avx2_select_if, 思路就是将原本一次处理 8bit 转变为现在一次性处理 256 bit（假设支持 avx2 指令集）：<br><img src="https://github.com/szza/szza.github.io.images/blob/master/SIMD/avx2_select_if.drawio.svg?raw=true" alt="avx2_select_if-1"></p><h3 id="T1-load"><a href="#T1-load" class="headerlink" title="T1-load"></a>T1-load</h3><p>首先需要读取 selector、a、b 中的值，每次读取 256 bit，保存为 __m256i 类型。__m256i 实际上就是存储类型为 integer、大小为 256 bit 的数组。</p><ol><li><p>使用 <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm256_loadu_si256&techs=AVX_ALL">_mm256_loadu_si256</a> 函数将数据从内存读取到寄存器中，需要保证读取的内存确实有 256 bit 的连续内存，否则会触发 segment fault。</p></li><li><p>selector 转化为 __m256i 对象 loaded_mask 后，需要逐字节（bytewise）和 0x00 进行比较</p><p> 这里使用 <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm256_cmpeq_epi8&techs=AVX_ALL&ig_expand=895">_mm256_cmpeq_epi8</a> 函数逐字节将 loaded_mask 和 0x00 进行比较：相等的为 0x00 ，不等为 0xff。再对比较结果进行取反，相等的为 0xff，不等为 0x00。</p><p> 这一步作用：由于 selector 是 uint8_t[] 类型，每个元素的值要么是 0x00 要么是 0x01，通过 comp 和取反操作后，0x00 仍然是 0x00，而 0x01 变成 0xff，可以看做是『适配』SIMD API 的行为，因为很多 SIMD API 操作依赖 MEM[i*8+7] 的值来进行判断，后续比较方便。</p></li><li><p>使用 <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm256_movemask_epi8&techs=AVX_ALL&ig_expand=895,4635">_mm256_movemask_epi8</a> 函数将 loaded_mask 中每个字节的最高位组合起来，生成 32 bit &#x3D; 256 bit &#x2F; 8 整数 mask。</p><p>  至于这一步为啥怎么做，还不太清楚？后面还有个 data_mask 用来将 mask 扩充</p></li></ol><p>模板参数中的 left_const 和 right_const 表示比较的左侧和右侧是否是个常数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> .. <span class="keyword">where</span> a <span class="operator">&gt;</span> <span class="number">10</span>; <span class="comment">-- left_const = true, right_const = false</span></span><br><span class="line"><span class="keyword">select</span> .. <span class="keyword">where</span> a <span class="operator">&gt;</span> b;  <span class="comment">-- left_const = false, right_const = false</span></span><br></pre></td></tr></table></figure><p>读取 a、b 的数据至 vec_a、vec_b 的过程比较简单，这部分代码及注释如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> left_const = <span class="literal">false</span>, <span class="type">bool</span> right_const = <span class="literal">false</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="built_in">avx2_select_if_common_impl</span>(<span class="type">uint8_t</span>*&amp; selector, T*&amp; dst,</span><br><span class="line">                                            <span class="type">const</span> T*&amp; a, <span class="type">const</span> T*&amp; b, <span class="type">int</span> size) &#123;</span><br><span class="line">  <span class="type">const</span> T* dst_end = dst + size;</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="type">int</span> data_size = <span class="built_in">sizeof</span>(T);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 需要确保还剩余足够的内存</span></span><br><span class="line">  <span class="keyword">while</span> (dst + <span class="number">32</span> &lt; dst_end) &#123;</span><br><span class="line">    __m256i loaded_mask = _mm256_loadu_si256(<span class="built_in">reinterpret_cast</span>&lt;__m256i*&gt;(selector));</span><br><span class="line">    loaded_mask = _mm256_cmpeq_epi8(loaded_mask, _mm256_setzero_si256());</span><br><span class="line">    loaded_mask = ~loaded_mask;</span><br><span class="line">    <span class="type">uint32_t</span> mask = _mm256_movemask_epi8(loaded_mask);</span><br><span class="line"></span><br><span class="line">    __m256i vec_a[data_size];</span><br><span class="line">    __m256i vec_b[data_size];</span><br><span class="line">    __m256i vec_dst[data_size];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// load data from data vector</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data_size; ++i) &#123;</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!left_const)</span> </span>&#123;</span><br><span class="line">        vec_a[i] = _mm256_loadu_si256(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> __m256i*&gt;(a) + i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vec_a[i] = SIMDUtils::<span class="built_in">set_data</span>(*a);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!right_const)</span> </span>&#123;</span><br><span class="line">        vec_b[i] = _mm256_loadu_si256(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> __m256i*&gt;(b) + i);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vec_b[i] = SIMDUtils::<span class="built_in">set_data</span>(*b);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="T2-Blendv"><a href="#T2-Blendv" class="headerlink" title="T2-Blendv"></a>T2-Blendv</h3><p>由于已经基于 a, b 生成 __m256i 对象 vec_a, vec_b，向量化实现 avx2_select_if 的关键在于生成 __m256i 的 condition，最终调用 <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm256_blendv_epi8&techs=AVX_ALL&ig_expand=895,4635,506">_mm256_blendv_epi8</a> 函数来实现向量化三元表达式。</p><p>由于在 T1-load 中已经将 selector 转化为 uint32_t 类型的 mask，下面需要将 mask 恢复成 __m256i。</p><p>data_size 的值是 sizeof(T)（比如 uint16_t 的 data_size 是 2），for-loop 迭代 data_size 次，因此每次迭代处理 each_loop_handle_sz bit &#x3D; <strong>32</strong> &#x2F; data_size bit（其中 <strong>32</strong> 表征 mask 是 uint32_t 类型），即每次处理向量中的元素 vec_a[i]，vec_b[i] 的位数。</p><p>因此, uint16_t 就是每次迭代处理 16bit, uint32_t 每次处理 8 bit, 而 uint64_t 每次处理 4 bit，对应到 mask_table 中就是 0xFFFF、0xFF、0X0F，即通过 <code>select_mask = mask &amp; mask_table[data_size]</code> 来取出每次迭代操作的位。 </p><p>下面以 uint16 为例。</p><ol><li><p>在第一轮迭代中 select_mask 取的是 mask 的低 16 位，高 16 位为 0，即</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select_mask[<span class="number">15</span>:<span class="number">0</span>] = mask[<span class="number">15</span>:<span class="number">0</span>]</span><br><span class="line">select_mask[<span class="number">31</span>:<span class="number">16</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure><p>_mm256_set1_epi16(select_mask) 函数用 select_mask[15:0] 填充满 256 bit，即 select_vector 中连续存储了 16 个 select_mask[15:0]，效果就类似于 memset。</p><p>由于 select_mask[15:0] 中的每一个bit，对应着 loaded_mask 中 1 个字节最高位，因此这里为了取出该字节，使用 data_mask 恢复。比如 data_mask 前五个数据是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0001</span> <span class="comment">// 取的是第一个字节</span></span><br><span class="line"><span class="number">0x0002</span> <span class="comment">// 取的是第二个字节</span></span><br><span class="line"><span class="number">0x0004</span> <span class="comment">// 取的是第三个字节</span></span><br><span class="line"><span class="number">0x0008</span> <span class="comment">// 取的是第四个字节</span></span><br><span class="line"><span class="number">0x0010</span> <span class="comment">// 取的是第五个字节</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>再将 select_vector &#x3D; select_vector &amp; data_mask，得到就是每个字节的 mask。</p><p>由于 <a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm256_blendv_epi8&techs=AVX_ALL&ig_expand=895,4635,506">_mm256_blendv_epi8</a> 函数是按照 mask[i*8+7] 位置进行判断的，因此，需要将 select_vector 中 0x01 扩充成为 0xff，这就是 _mm256_cmpeq_epi16 函数和取反操作的目的。</p><p>到此，第一轮结束，<a href="https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html#text=_mm256_blendv_epi8&techs=AVX_ALL&ig_expand=895,4635,506">_mm256_blendv_epi8</a> 函数所需的 vec_a, vec_b, select_vector 都具备了，则可以一次性处理 256 bit，结构存于 vec_dst。</p></li><li><p>下一轮迭代即处理 mask 的高 16 位</p><p>此时只需要将 mask &gt;&gt; each_loop_handle_sz，即高 16 位变成低 16 位，重复上述逻辑。</p></li></ol><p>data_size 为 4、8的逻辑类似，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// 2.</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint32_t</span> mask_table[] = &#123;<span class="number">0</span>, <span class="number">0xFFFFFFFF</span>, <span class="number">0xFFFF</span>,</span><br><span class="line">                                   <span class="number">0</span>, <span class="number">0xFF</span>, </span><br><span class="line">                                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x0F</span>,</span><br><span class="line">                                   <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0x03</span>&#125;;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">uint8_t</span> each_loop_handle_sz = <span class="number">32</span> / data_size;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data_size; ++i) &#123;</span><br><span class="line">   <span class="type">uint32_t</span> select_mask = mask &amp; mask_table[data_size];</span><br><span class="line">   __m256i select_vector;</span><br><span class="line">   <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(data_size == <span class="number">2</span>)</span> </span>&#123;</span><br><span class="line">     select_vector = _mm256_set1_epi16(select_mask);</span><br><span class="line">     <span class="type">const</span> __m256i data_mask = _mm256_setr_epi16(</span><br><span class="line">       <span class="number">0x0001</span>, <span class="number">0x0002</span>, <span class="number">0x0004</span>, <span class="number">0x0008</span>, <span class="number">0x0010</span>, <span class="number">0x0020</span>, <span class="number">0x0040</span>, <span class="number">0x0080</span>, </span><br><span class="line">       <span class="number">0x0100</span>, <span class="number">0x0200</span>, <span class="number">0x0400</span>, <span class="number">0x0800</span>, <span class="number">0x1000</span>, <span class="number">0x2000</span>, <span class="number">0x4000</span>, <span class="number">0x8000</span>);</span><br><span class="line"></span><br><span class="line">     select_vector &amp;= data_mask;</span><br><span class="line">     select_vector = _mm256_cmpeq_epi16(select_vector, _mm256_setzero_si256());</span><br><span class="line">     select_vector = ~select_vector;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (data_size == <span class="number">4</span>) &#123;</span><br><span class="line">     select_vector = _mm256_set1_epi8(select_mask);</span><br><span class="line">     <span class="type">const</span> __m256i data_mask = _mm256_setr_epi8(</span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, </span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>, </span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, </span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>,</span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x10</span>, </span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x20</span>, </span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x40</span>, </span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x80</span>);</span><br><span class="line">     </span><br><span class="line">     select_vector &amp;= data_mask;</span><br><span class="line">     select_vector = _mm256_cmpeq_epi32(select_vector, _mm256_setzero_si256());</span><br><span class="line">     select_vector = ~select_vector;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (data_size == <span class="number">8</span>) &#123;</span><br><span class="line">     select_vector = _mm256_set1_epi8(select_mask);</span><br><span class="line">     <span class="type">const</span> __m256i data_mask = _mm256_setr_epi8(</span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x01</span>, </span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x02</span>,</span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x04</span>, </span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>,</span><br><span class="line">       <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x08</span>);</span><br><span class="line"></span><br><span class="line">     select_vector &amp;= data_mask;</span><br><span class="line">     select_vector = _mm256_cmpeq_epi64(select_vector, _mm256_setzero_si256());</span><br><span class="line">     select_vector = ~select_vector;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   vec_dst[i] = _mm256_blendv_epi8(vec_b[i], vec_a[i], select_vector);</span><br><span class="line">   mask &gt;&gt;= each_loop_handle_sz;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure><h3 id="T3-store"><a href="#T3-store" class="headerlink" title="T3-store"></a>T3-store</h3><p>T3-store 就是存储结果：将寄存器 vec_dst 中的数据存储到内存 dst 中，并继续迭代下一个 256bit。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="type">bool</span> left_const = <span class="literal">false</span>, <span class="type">bool</span> right_const = <span class="literal">false</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="built_in">avx2_select_if_common_impl</span>(<span class="type">uint8_t</span>*&amp; selector, T*&amp; dst,</span><br><span class="line">                                            <span class="type">const</span> T*&amp; a, <span class="type">const</span> T*&amp; b, <span class="type">int</span> size) &#123;</span><br><span class="line">   <span class="keyword">while</span> (dst + <span class="number">32</span> &lt; dst_end) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">       <span class="comment">// 3. 保存结果</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; data_size; ++i) &#123;</span><br><span class="line">         _mm256_storeu_si256(<span class="built_in">reinterpret_cast</span>&lt;__m256i*&gt;(dst) + i, vec_dst[i]);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 4. 迭代</span></span><br><span class="line">       dst += <span class="number">32</span>;</span><br><span class="line">       selector += <span class="number">32</span>;</span><br><span class="line">       <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!left_const)</span> </span>&#123;</span><br><span class="line">         a += <span class="number">32</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!right_const)</span> </span>&#123;</span><br><span class="line">         b += <span class="number">32</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avx2-select-if"><a href="#avx2-select-if" class="headerlink" title="avx2_select_if"></a>avx2_select_if</h2><p>这个版本的 avx2_select_if 是一个特化，只适用于 sizeof(T) 为 1 的情况，是 avx2_select_if_common_impl 的简略版，不需要 data_mask 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, </span><br><span class="line">          <span class="type">bool</span> left_const = <span class="literal">false</span>, <span class="type">bool</span> right_const = <span class="literal">false</span>,</span><br><span class="line">          std::<span class="type">enable_if_t</span>&lt;<span class="built_in">sizeof</span>(T) == <span class="number">1</span>, <span class="type">int</span>&gt; = <span class="number">1</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="built_in">avx2_select_if</span>(<span class="type">uint8_t</span>*&amp; selector, T*&amp; dst,</span><br><span class="line">                           <span class="type">const</span> T*&amp; a, <span class="type">const</span> T*&amp; b, <span class="type">int</span> size) &#123;</span><br><span class="line">  <span class="type">const</span> T* dst_end = dst + size;</span><br><span class="line">  <span class="keyword">while</span> (dst + <span class="number">32</span> &lt; dst_end) &#123;</span><br><span class="line">    <span class="keyword">auto</span> loaded_mask = _mm256_loadu_si256(<span class="built_in">reinterpret_cast</span>&lt;__m256i*&gt;(selector));</span><br><span class="line">    loaded_mask = _mm256_cmpeq_epi8(loaded_mask, _mm256_setzero_si256());</span><br><span class="line">    loaded_mask = ~loaded_mask;</span><br><span class="line">    __m256i vec_a;</span><br><span class="line">    __m256i vec_b;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!left_const)</span> </span>&#123;</span><br><span class="line">      vec_a = _mm256_loadu_si256(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> __m256i*&gt;(a));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vec_a = _mm256_set1_epi8(*a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!right_const)</span> </span>&#123;</span><br><span class="line">      vec_b = _mm256_loadu_si256(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> __m256i*&gt;(b));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vec_b = _mm256_set1_epi8(*b);</span><br><span class="line">    &#125;</span><br><span class="line">    __m256i res = _mm256_blendv_epi8(vec_b, vec_a, loaded_mask);</span><br><span class="line">    _mm256_storeu_si256(<span class="built_in">reinterpret_cast</span>&lt;__m256i*&gt;(dst), res);</span><br><span class="line">    dst += <span class="number">32</span>;</span><br><span class="line">    selector += <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">if</span> (!left_const) &#123;</span><br><span class="line">      a += <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!right_const) &#123;</span><br><span class="line">      b += <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="avx2-select-if-1"><a href="#avx2-select-if-1" class="headerlink" title="avx2_select_if"></a>avx2_select_if</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, std::<span class="type">enable_if_t</span>&lt;<span class="built_in">sizeof</span>(T) == <span class="number">4</span>, <span class="type">int</span>&gt; = <span class="number">4</span>&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">void</span> <span class="built_in">avx2_select_if</span>(<span class="type">uint8_t</span>*&amp; selector, T*&amp; dst,</span><br><span class="line">                           <span class="type">const</span> T*&amp; a, <span class="type">const</span> T*&amp; b, <span class="type">int</span> size) &#123;</span><br><span class="line">  <span class="type">const</span> T* dst_end = dst + size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (dst + <span class="number">8</span> &lt; dst_end) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> value = <span class="built_in">UNALIGNED_LOAD64</span>(selector);</span><br><span class="line">    __m128i v = _mm_set1_epi64x(value);</span><br><span class="line">    __m256i loaded_mask = _mm256_cvtepi8_epi32(v);</span><br><span class="line">    __m256i cond = _mm256_cmpeq_epi8(loaded_mask, _mm256_setzero_si256());</span><br><span class="line">    cond = ~cond;</span><br><span class="line"></span><br><span class="line">    __m256i mask = _mm256_set_epi8(</span><br><span class="line">        <span class="number">0x0c</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">        <span class="number">0x04</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">        <span class="number">0x0c</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">        <span class="number">0x08</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">        <span class="number">0x04</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>,</span><br><span class="line">        <span class="number">0x00</span>, <span class="number">0xff</span>, <span class="number">0xff</span>, <span class="number">0xff</span>);</span><br><span class="line">    cond = _mm256_shuffle_epi8(cond, mask);</span><br><span class="line"></span><br><span class="line">    __m256i vec_a = _mm256_loadu_si256(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> __m256i*&gt;(a));</span><br><span class="line">    __m256i vec_b = _mm256_loadu_si256(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> __m256i*&gt;(b));</span><br><span class="line">    __m256 res = _mm256_blendv_ps(_mm256_castsi256_ps(vec_b), </span><br><span class="line">                                  _mm256_castsi256_ps(vec_a),</span><br><span class="line">                                  _mm256_castsi256_ps(cond));</span><br><span class="line">    _mm256_storeu_si256(</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;__m256i*&gt;(dst), _mm256_castps_si256(res));</span><br><span class="line"></span><br><span class="line">    dst += <span class="number">8</span>;</span><br><span class="line">    selector += <span class="number">8</span>;</span><br><span class="line">    a += <span class="number">8</span>;</span><br><span class="line">    b += <span class="number">8</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SIMD-selector"><a href="#SIMD-selector" class="headerlink" title="SIMD_selector"></a>SIMD_selector</h2><p>SIMD_selector 其中的一个 select_if 函数封装上述三个函数，其他也类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;PrimitiveType TYPE&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SIMD_selector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="keyword">using</span> Container = <span class="keyword">typename</span> RunTimeColumnType&lt;TYPE&gt;::Container;</span><br><span class="line"> <span class="keyword">using</span> CppType = RunTimeCppType&lt;TYPE&gt;;</span><br><span class="line"> <span class="keyword">using</span> SelectVec = <span class="type">uint8_t</span>*;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// select if var var</span></span><br><span class="line"> <span class="comment">// dst[i] = select_vec[i] ? a[i] : b[i]</span></span><br><span class="line"> <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">select_if</span><span class="params">(SelectVec select_vec, Container&amp; dst,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> Container&amp; a, <span class="type">const</span> Container&amp; b)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> size = dst.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">auto</span>* start_dst = dst.<span class="built_in">data</span>();</span><br><span class="line">  <span class="keyword">auto</span>* end_dst = dst.<span class="built_in">data</span>() + size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span>* start_a = a.<span class="built_in">data</span>();</span><br><span class="line">  <span class="keyword">auto</span>* start_b = b.<span class="built_in">data</span>();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __AVX2__</span></span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>(CppType) == <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">avx2_select_if</span>(select_vec, start_dst, start_a, start_b, size);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (<span class="built_in">sizeof</span>(CppType) == <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="built_in">avx2_select_if</span>(select_vec, start_dst, start_a, start_b, size);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (<span class="built_in">could_use_common_select_if</span>&lt;CppType&gt;()) &#123;</span><br><span class="line">      <span class="built_in">avx2_select_if_common_impl</span>(select_vec, start_dst, start_a, start_b, size);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start_dst &lt; end_dst) &#123;</span><br><span class="line">   *start_dst = *select_vec ? *start_a : *start_b;</span><br><span class="line">   select_vec++;</span><br><span class="line">   start_dst++;</span><br><span class="line">   start_a++;</span><br><span class="line">   start_b++;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要是讲述下 StarRocks 中如何利用 SIMD 指令来实现 select_if 的，其中关于 SIMD 的相关 API 含义直接参考 &lt;a href=&quot;https://www.intel.com/content/www/us/en/docs/intrinsics</summary>
      
    
    
    
    <category term="SIMD" scheme="https://szza.github.io/categories/SIMD/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>Optimizer: 基于 OptimizerTask 实现 LogicalPlan 到 PhysicalPlan</title>
    <link href="https://szza.github.io/2023/10/07/StarRocks/CBO/Optimizer/"/>
    <id>https://szza.github.io/2023/10/07/StarRocks/CBO/Optimizer/</id>
    <published>2023-10-07T02:00:01.000Z</published>
    <updated>2023-11-03T13:09:18.000Z</updated>
    
    <content type="html"><![CDATA[<p>OptimizerTask 的继承关系如下图（还有个 RewriteTreeTask，由于和其他 Task 不一起使用，因此没画出来）。每个子 Task 都需要去实现 <strong>execute</strong> 函数来完成真正的操作。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/OptimizerTask-2.svg?raw=true" alt="OptimizerTask-2"></p><p>OptimizerTask 函数执行时采用后续遍历的顺序来执行任务，如下图。当前优化一个 Group 时，从 OptimizeGroupTask 函数开始，只有创建 OptimizeGroupTask 对象时才会创建一个新的 TaskContext，用 TaskContext 来记录当前 Group 的优化过程中产生最低成本的上界 upperBoundCost。</p><p>在执行过程中，每个 Task 会尽可能裁剪遍历分支，缩小搜索空间，降低优化器执行时间。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/OptimizerTask.svg?raw=true" alt="OptimizerTask"></p><p>这里主要讲解下 OptimizerTask 的搜索过程，每个 Task 的具体实现有空再说。</p><h2 id="SeriallyTaskScheduler"><a href="#SeriallyTaskScheduler" class="headerlink" title="SeriallyTaskScheduler"></a>SeriallyTaskScheduler</h2><p>SeriallyTaskScheduler 按照 <em>first in last out</em> 顺序执行 OptimizerTask：通过 SeriallyTaskScheduler.PushTask 和 OptimizerTask.PushTask 函数将待执行的 Task 入栈，在 SeriallyTaskScheduler.executeTasks 函数中将栈中元素 pop 出来执行。</p><p>executeTasks 函数限制了一次完整遍历的时间不能超过阈值 new_planner_optimize_timeout（默认值 3000ms），完整代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SeriallyTaskScheduler</span> <span class="keyword">implements</span> <span class="title class_">TaskScheduler</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Stack&lt;OptimizerTask&gt; tasks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SeriallyTaskScheduler</span><span class="params">()</span> &#123;</span><br><span class="line">        tasks = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pushTask</span><span class="params">(OptimizerTask task)</span> &#123;</span><br><span class="line">        tasks.push(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">executeTasks</span><span class="params">(TaskContext context)</span> &#123;</span><br><span class="line">        <span class="type">OptimizerContext</span> <span class="variable">optimizerContext</span> <span class="operator">=</span> context.getOptimizerContext();</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> </span><br><span class="line">            optimizerContext.getSessionVariable().getOptimizerExecuteTimeout();</span><br><span class="line">        <span class="type">Stopwatch</span> <span class="variable">watch</span> <span class="operator">=</span> optimizerContext.getTraceInfo().getStopwatch();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 stack 中的所有元素提取出来，全部执行完毕</span></span><br><span class="line">        <span class="keyword">while</span> (!tasks.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (watch.elapsed(TimeUnit.MILLISECONDS) &gt; timeout) &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">OptimizerTask</span> <span class="variable">task</span> <span class="operator">=</span> tasks.pop();</span><br><span class="line">            optimizerContext.setTaskContext(context);</span><br><span class="line">            task.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Memo"><a href="#Memo" class="headerlink" title="Memo"></a>Memo</h2><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/Memo.svg?raw=true" alt="Memo"></p><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>基于得到的逻辑表达式构建 Group Tree，初始化完成一个 OptExpression 对应一个 Group。核心是 Memo.copyIn 函数，后续 AppleRuleTask 中也会调用 Memo.copyIn 函数将应用规则得到的新 OptExpression 添加到 Group 的逻辑等价表达式集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GroupExpression <span class="title function_">init</span><span class="params">(OptExpression originExpression)</span> &#123;</span><br><span class="line">    <span class="comment">// 将 originExpressionTree --&gt; GroupTree</span></span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">rootGroupExpression</span> </span><br><span class="line">        <span class="operator">=</span> copyIn(<span class="literal">null</span>, originExpression).second;</span><br><span class="line">    rootGroup = rootGroupExpression.getGroup();</span><br><span class="line">    <span class="keyword">return</span> rootGroupExpression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optimizer-memoOptimize"><a href="#Optimizer-memoOptimize" class="headerlink" title="Optimizer.memoOptimize"></a>Optimizer.memoOptimize</h2><p>Optimizer.memoOptimize 函数可大致分为两个部分：</p><ol><li>添加一些规则，这些规则最终会被应用在 ApplyRuleTask 中</li><li>执行 OptimizeGroupTask</li></ol><p>memoOptimize 函数结束，优化器的主体工作就结束了。</p><p>代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">memoOptimize</span><span class="params">(ConnectContext connectContext, Memo memo, TaskContext rootTaskContext)</span> &#123;</span><br><span class="line">    <span class="type">OptExpression</span> <span class="variable">tree</span> <span class="operator">=</span> memo.getRootGroup().extractLogicalTree();</span><br><span class="line">    <span class="comment">// Join reorder</span></span><br><span class="line">    <span class="type">SessionVariable</span> <span class="variable">sessionVariable</span> <span class="operator">=</span> connectContext.getSessionVariable();</span><br><span class="line">    <span class="type">int</span> <span class="variable">innerCrossJoinNode</span> <span class="operator">=</span> Utils.countJoinNodeSize(tree, JoinOperator.innerCrossJoinSet());</span><br><span class="line">    <span class="keyword">if</span> (!sessionVariable.isDisableJoinReorder() </span><br><span class="line">        &amp;&amp; innerCrossJoinNode &lt; sessionVariable.getCboMaxReorderNode()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (innerCrossJoinNode &gt; sessionVariable.getCboMaxReorderNodeUseExhaustive()) &#123;</span><br><span class="line"></span><br><span class="line">            CTEUtils.collectForceCteStatistics(memo, context);</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ReorderJoinRule</span>().transform(tree, context);</span><br><span class="line">            context.getRuleSet().addJoinCommutativityWithOutInnerRule();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (Utils.countJoinNodeSize(tree, JoinOperator.semiAntiJoinSet())</span><br><span class="line">                 &lt; sessionVariable.getCboMaxReorderNodeUseExhaustive()) &#123;</span><br><span class="line">                context.getRuleSet().getTransformRules().add(</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">SemiReorderRule</span>());</span><br><span class="line">            &#125;</span><br><span class="line">            context.getRuleSet().addJoinTransformationRules();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//add join implementRule</span></span><br><span class="line">    context.getRuleSet().addAutoJoinImplementationRule();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isEnableMultiTableRewrite(connectContext, tree)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sessionVariable.isEnableMaterializedViewViewDeltaRewrite()</span><br><span class="line">             &amp;&amp; rootTaskContext.getOptimizerContext().getCandidateMvs()</span><br><span class="line">                   .stream().anyMatch(context -&gt; context.hasMultiTables())) &#123;</span><br><span class="line">            context.getRuleSet().addSingleTableMvRewriteRule();</span><br><span class="line">        &#125;</span><br><span class="line">        context.getRuleSet().addMultiTableMvRewriteRule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 函数探索入口</span></span><br><span class="line">    context.getTaskScheduler().pushTask(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">OptimizeGroupTask</span>(rootTaskContext, memo.getRootGroup()));</span><br><span class="line">    context.getTaskScheduler().executeTasks(rootTaskContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OptimizeGroupTask"><a href="#OptimizeGroupTask" class="headerlink" title="OptimizeGroupTask"></a>OptimizeGroupTask</h2><p>OptimizeGroupTask 是 Task 的执行入口：当开始优化一个 Group 时总是从 OptimizeGroupTask 开始。OptimizeGroupTask.execute 函数在执行前会先通过 Group.hasBestExpression 函数过滤已经优化过的 Group，防止重复搜索 or 死循环？</p><ul><li>OptimizeExpressionTask: 用于优化所有逻辑等价的 Operator Tree</li><li><a href="https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask">EnforceAndCostTask</a> 用于寻找每个 Group 的 cost 最低的 PhysicalGroupExpression。</li></ul><p>逻辑如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Group has optimized given the context</span></span><br><span class="line">    <span class="keyword">if</span> (group.hasBestExpression(context.getRequiredProperty())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序遍历，顺序执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> group.getLogicalExpressions().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        pushTask(<span class="keyword">new</span> <span class="title class_">OptimizeExpressionTask</span>(</span><br><span class="line">            context, group.getLogicalExpressions().get(i)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆序遍历，顺序执行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> group.getPhysicalExpressions().size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        pushTask((<span class="keyword">new</span> <span class="title class_">EnforceAndCostTask</span>(</span><br><span class="line">            context, group.getPhysicalExpressions().get(i))));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OptimizeExpressionTask"><a href="#OptimizeExpressionTask" class="headerlink" title="OptimizeExpressionTask"></a>OptimizeExpressionTask</h2><p>整体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Rule&gt; rules = getValidRules();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Rule rule : rules) &#123;</span><br><span class="line">        pushTask(<span class="keyword">new</span> <span class="title class_">ApplyRuleTask</span>(</span><br><span class="line">            context, groupExpression, rule, isExplore));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pushTask(<span class="keyword">new</span> <span class="title class_">DeriveStatsTask</span>(context, groupExpression));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> groupExpression.arity() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        pushTask(<span class="keyword">new</span> <span class="title class_">ExploreGroupTask</span>(</span><br><span class="line">            context, groupExpression.getInputs().get(i)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>任务执行的顺序是先入后出，因此执行 OptimizeExpressionTask 时，说明已经生成了一个初始化状态的最短路径。执行流程如下：</p><h3 id="1-ExploreGroupTask"><a href="#1-ExploreGroupTask" class="headerlink" title="1.ExploreGroupTask"></a>1.ExploreGroupTask</h3><p>OptimizeExpressionTask.execute 函数中依次用 groupExpression 的所有的输入 (sub-groups) 来构造 ExploreGroupTask 对象</p><p>而 ExploreGroupTask.execute 基于 childGroup 中所有逻辑等价的 Group.logicalExpression 又构造 OptimizeExpressionTask 对象。如此不断递归直到递归基（叶结点），即就是没有输入的 GroupExpression 对象，进入 DeriveStatsTask 开始为 GroupExpression 获取统计信息。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> ExploreGroupTask.execute() &#123;</span><br><span class="line">    <span class="keyword">if</span> (group.isExplored()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (GroupExpression logical : group.getLogicalExpressions()) &#123;</span><br><span class="line">        pushTask(<span class="keyword">new</span> <span class="title class_">OptimizeExpressionTask</span>(context, logical, <span class="literal">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    group.setExplored();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-DeriveStatsTask"><a href="#2-DeriveStatsTask" class="headerlink" title="2.DeriveStatsTask"></a>2.DeriveStatsTask</h3><p>顾名思义，DeriverStatsTask 是为 groupExpression.group.statistics 获取统计信息的，如果是物化视图则为 groupExpression.group.mvStatistics 获取统计信息。</p><p>核心功能由 StatisticsCalculator 实现。 关于 StatisticsCalculator，可以参考官方博客 <a href="https://zhuanlan.zhihu.com/p/582214743">StarRocks 统计信息和 Cost 估算</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 裁剪</span></span><br><span class="line">  <span class="keyword">if</span> (groupExpression.isStatsDerived() || groupExpression.isUnused()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">ExpressionContext</span> <span class="variable">expressionContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExpressionContext</span>(groupExpression);</span><br><span class="line">  <span class="type">StatisticsCalculator</span> <span class="variable">statisticsCalculator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StatisticsCalculator</span>(</span><br><span class="line">      expressionContext,</span><br><span class="line">      context.getOptimizerContext().getColumnRefFactory(),</span><br><span class="line">      context.getOptimizerContext());</span><br><span class="line">  statisticsCalculator.estimatorStats(); <span class="comment">// 获取统计信息</span></span><br><span class="line"></span><br><span class="line">  <span class="type">Statistics</span> <span class="variable">currentStatistics</span> </span><br><span class="line">      <span class="operator">=</span> groupExpression.getGroup().getStatistics();</span><br><span class="line">  <span class="type">Statistics</span> <span class="variable">statistics</span> <span class="operator">=</span> expressionContext.getStatistics();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 更新统计</span></span><br><span class="line">  <span class="keyword">if</span> (currentStatistics == <span class="literal">null</span> ||</span><br><span class="line">      (statistics.getOutputRowCount() &lt; currentStatistics.getOutputRowCount() </span><br><span class="line">      <span class="comment">// currentStatistics != null 可能是 merge 的</span></span><br><span class="line">       &amp;&amp; !isMaterializedView())) &#123;</span><br><span class="line">      groupExpression.getGroup().setStatistics(statistics);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (currentStatistics != <span class="literal">null</span> &amp;&amp; !currentStatistics.equals(statistics)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isMaterializedView()) &#123;</span><br><span class="line">          <span class="type">LogicalOlapScanOperator</span> <span class="variable">scan</span> <span class="operator">=</span> groupExpression.getOp().cast();</span><br><span class="line">          <span class="type">MaterializedView</span> <span class="variable">mv</span> <span class="operator">=</span> (MaterializedView) scan.getTable();</span><br><span class="line">          groupExpression.getGroup().setMvStatistics(mv.getId(), statistics);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 标记，防止重复统计</span></span><br><span class="line">  groupExpression.setStatsDerived();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-ApplyRuleTask"><a href="#3-ApplyRuleTask" class="headerlink" title="3.ApplyRuleTask"></a>3.ApplyRuleTask</h3><p>按照规则生成新的逻辑表达式、物理表达式</p><h4 id="OptimizeExpressionTask-getValidRules"><a href="#OptimizeExpressionTask-getValidRules" class="headerlink" title="OptimizeExpressionTask.getValidRules"></a>OptimizeExpressionTask.getValidRules</h4><p>首先要获取有有效的规则：logicalRules、physicalRules 是 Optimizer.memoOptimize 函数中在执行 OptimizeGroupTask 之前添加的。filterInValidRules 函数再将 groupExpression 和 logicalRules、physicalRules 进行匹配。 能匹配得上的即 validRules，最终将 validRules 基于 <code>Rule::promise</code> 值进行排序。</p><p>这里有个概念需要注意下:</p><ul><li><strong>Transform Rule</strong>: 基于规则，生成等价的逻辑计划，扩充搜索空间</li><li><strong>Implement Rule</strong>: 将逻辑节点 LogicalOperator 转换为物理节点 PhysicalOperator</li></ul><p>因此，难点是 <em>Transform Rule</em>，其中 Rule 细节后续有机会再深入分析咯。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/Rule.svg?raw=true" alt="Rule"></p><p>代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;Rule&gt; <span class="title function_">getValidRules</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Rule&gt; validRules = </span><br><span class="line">        Lists.newArrayListWithCapacity(RuleType.NUM_RULES.id());</span><br><span class="line">    List&lt;Rule&gt; logicalRules = </span><br><span class="line">        context.getOptimizerContext().getRuleSet().getTransformRules();</span><br><span class="line">    <span class="comment">// 根据匹配规则，获取能应用到 groupExpression 的有效规则 </span></span><br><span class="line">    filterInValidRules(groupExpression, logicalRules, validRules);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isExplore) &#123;</span><br><span class="line">        List&lt;Rule&gt; physicalRules = </span><br><span class="line">            context.getOptimizerContext().getRuleSet().getImplementRules();</span><br><span class="line">        filterInValidRules(groupExpression, physicalRules, validRules);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序: logical rule 前, physical rule 在后</span></span><br><span class="line">    validRules.sort(Comparator.comparingInt(Rule::promise));</span><br><span class="line">    <span class="keyword">return</span> validRules;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="OptimizerTask-filterInValidRules"><a href="#OptimizerTask-filterInValidRules" class="headerlink" title="OptimizerTask.filterInValidRules"></a>OptimizerTask.filterInValidRules</h4><p>每个 Rule 都有一个 Pattern，只有 Rule 和 Pattern 匹配时才算一个有效规则。<br>解释如代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">filterInValidRules</span><span class="params">(GroupExpression groupExpression,</span></span><br><span class="line"><span class="params">                        List&lt;Rule&gt; candidateRules,</span></span><br><span class="line"><span class="params">                        List&lt;Rule&gt; validRules)</span> &#123;</span><br><span class="line">    <span class="type">OptimizerConfig</span> <span class="variable">optimizerConfig</span> <span class="operator">=</span> </span><br><span class="line">        context.getOptimizerContext().getOptimizerConfig();</span><br><span class="line">    <span class="keyword">for</span> (Rule rule : candidateRules) &#123;</span><br><span class="line">        <span class="comment">//CHECK-1: groupExpression 已经应用过这个规则</span></span><br><span class="line">        <span class="keyword">if</span> (groupExpression.hasRuleExplored(rule)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// CHECK-2: operator + child 是否能匹配上</span></span><br><span class="line">        <span class="keyword">if</span> (!rule.getPattern().matchWithoutChild(groupExpression)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// CHECK-3: 这个规则没有 disable</span></span><br><span class="line">        <span class="keyword">if</span> (optimizerConfig.isRuleDisable(rule.type())) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 有效</span></span><br><span class="line">        validRules.add(rule);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Pattern-matchWithoutChild"><a href="#Pattern-matchWithoutChild" class="headerlink" title="Pattern.matchWithoutChild"></a>Pattern.matchWithoutChild</h4><p>Pattern 主要用于描述 Rule 的匹配规则，用户可以按照想要匹配的 Operator 类型创建 Pattern。除了常规的 Operator 类型以外，StarRocks 还提供两种特殊的 Operator：</p><ul><li><strong>PATTERN_LEAF</strong>：用于匹配任意单个节点，几乎每个 Rule 里都会以 PATTERN_LEFF 作为叶子节点；</li><li><strong>PATTERN_MULTI_LEAF</strong>：用于匹配 N个（&gt;&#x3D;0）任意节点，在 UNION、INTERSECT、EXCEPT 这类多输入节点相关的Rule中比较常见。</li></ul><p>matchWithoutChild 解释如代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">matchWithoutChild</span><span class="params">(GroupExpression expression, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (expression == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CHECK-1: 子节点个数是否能匹配上</span></span><br><span class="line">    <span class="keyword">if</span> (expression.getInputs().size() &lt; <span class="built_in">this</span>.children().size()</span><br><span class="line">         &amp;&amp; children.stream().noneMatch(</span><br><span class="line">            p -&gt; OperatorType.PATTERN_MULTI_LEAF.equals(p.getOpType()))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CHECK-2: Pattern 是否能匹配任意 Operator</span></span><br><span class="line">    <span class="keyword">if</span> (OperatorType.PATTERN_LEAF.equals(getOpType()) </span><br><span class="line">        || OperatorType.PATTERN_MULTI_LEAF.equals(getOpType())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">OperatorType</span> <span class="variable">givenOpType</span> <span class="operator">=</span>  expression.getOp().getOpType();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CHECK-3: Pattern 只能匹配 SCAN Operator</span></span><br><span class="line">    <span class="keyword">if</span> (isPatternScan() &amp;&amp; scanTypes.contains(givenOpType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CHECK-4: Pattern 只能匹配 JOIN Operator</span></span><br><span class="line">    <span class="keyword">if</span> (isPatternMultiJoin() &amp;&amp; isMultiJoin(givenOpType, level)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// CHECK-5: 直接判断</span></span><br><span class="line">    <span class="keyword">return</span> getOpType().equals(givenOpType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ApplyRuleTask-execute"><a href="#ApplyRuleTask-execute" class="headerlink" title="ApplyRuleTask.execute"></a>ApplyRuleTask.execute</h4><p>匹配的核心是 Binder，能找到 GroupExpression 中符合 rule 的部分。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//裁剪: 这个规则已经匹配过 or 这个group 不需要优化</span></span><br><span class="line">    <span class="keyword">if</span> (groupExpression.hasRuleExplored(rule) ||</span><br><span class="line">        groupExpression.isUnused()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">OptimizerContext</span> <span class="variable">optimizerContext</span> <span class="operator">=</span> context.getOptimizerContext();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 对 groupExpression 应用规则，生成新的表达式</span></span><br><span class="line">    <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> rule.getPattern();</span><br><span class="line">    <span class="type">Binder</span> <span class="variable">binder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Binder</span>(pattern, groupExpression);</span><br><span class="line">    <span class="type">OptExpression</span> <span class="variable">extractExpr</span> <span class="operator">=</span> binder.next();</span><br><span class="line">    List&lt;OptExpression&gt; newExpressions = Lists.newArrayList();</span><br><span class="line">    <span class="keyword">while</span> (extractExpr != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 每个具体的规则会重载 Rule.check 函数</span></span><br><span class="line">        <span class="comment">// 更加细致的判断是否符合 extractExpr 与 rule 能否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (!rule.check(extractExpr, optimizerContext)) &#123;</span><br><span class="line">            extractExpr = binder.next();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 生成新的 expression</span></span><br><span class="line">        newExpressions.addAll(</span><br><span class="line">            rule.transform(extractExpr, optimizerContext));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 迭代</span></span><br><span class="line">        extractExpr = binder.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 针对新生成的表达式进行递归优化</span></span><br><span class="line">    <span class="keyword">for</span> (OptExpression expression : newExpressions) &#123;</span><br><span class="line">        <span class="comment">// Insert new OptExpression to memo</span></span><br><span class="line">        Pair&lt;Boolean, GroupExpression&gt; result </span><br><span class="line">            = optimizerContext.getMemo().</span><br><span class="line">                copyIn(groupExpression.getGroup(), expression);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The group has been merged</span></span><br><span class="line">        <span class="keyword">if</span> (groupExpression.hasEmptyRootGroup()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">GroupExpression</span> <span class="variable">newGroupExpression</span> <span class="operator">=</span> result.second;</span><br><span class="line">        <span class="keyword">if</span> (newGroupExpression.getOp().isLogical()) &#123;</span><br><span class="line">            <span class="comment">// For logic newGroupExpression, optimize it</span></span><br><span class="line">            pushTask(<span class="keyword">new</span> <span class="title class_">OptimizeExpressionTask</span>(</span><br><span class="line">                context, newGroupExpression, isExplore));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// For physical newGroupExpression, enforce and cost it,</span></span><br><span class="line">            <span class="comment">// Optimize its inputs if needed</span></span><br><span class="line">            pushTask(<span class="keyword">new</span> <span class="title class_">EnforceAndCostTask</span>(</span><br><span class="line">                context, newGroupExpression));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    groupExpression.setRuleExplored(rule);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h2><p>Binder 的作用是从 GroupExpression 搜索出符合 Pattern 的所有等价表达式，并通过 Binder.next 函数返回所有符合 Pattern 的表达式子树。</p><p>如图，左侧的 Pattern 在右侧的匹配结果就是虚线框中的部分。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/Rule-Pattern.svg?raw=true" alt="Rule-Pattern"></p><p>如图，左侧的 Pattern 匹配的结果，Binder.next 返回的结果顺序：</p><ul><li>JOIN-OLAP_SCAN_1-OLAP_SCAN_2</li><li>JOIN-OLAP_SCAN_1-OLAP_SCAN_4 </li><li>JOIN-OLAP_SCAN_3-OLAP_SCAN_3 </li><li>JOIN-OLAP_SCAN_3-OLAP_SCAN_4</li></ul><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/Rule-Pattern-2.svg?raw=true" alt="Rule-Pattern-2"></p><p>因此，为了能 Binder.next 函数能返回不重复的所有匹配结果，Binder 需要具有存储状态。</p><ul><li><p>groupTraceKey: 表示当前正在访问哪个 Group</p></li><li><p>groupExpressionIndex[groupTraceKey]: 表示访问 Group 的第几个等价表达式，在每次遍历时 groupExpressionIndex 最终的长度都是和 和 Group 的个数一致。</p><p>  groupExpressionIndex[0] 是当前 GroupExpression 所属的 Group，groupExpressionIndex[1:-1] 是 ChildernGroup</p></li></ul><p>Binder.next 本质是个多叉树搜索算法，下面顺着代码顺序来看。</p><h3 id="next"><a href="#next" class="headerlink" title="next"></a>next</h3><p>next 函数用于从 groupExpression 中找到匹配 Pattern 的 OptExpression。 </p><ol><li><p>每次进入 next 函数都需要把 groupTraceKey 赋值为0，表示重头从第一个 group 进行遍历，</p></li><li><p>将上次 next 函数访问的最后一个 group 中的等价表达式的下标 + 1</p><p> 每个 Group 中的逻辑等价的表达式的数量是 Group.getLogicalExpressions().size()，会依次访问</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> OptExpression <span class="title function_">next</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// For logic scan to physical scan, we only need to match once</span></span><br><span class="line">    <span class="keyword">if</span> (pattern.children().size() == <span class="number">0</span> &amp;&amp; groupExpressionIndex.get(<span class="number">0</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    OptExpression expression;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.groupTraceKey = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Match with the next groupExpression of the last group node</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lastNode</span> <span class="operator">=</span> <span class="built_in">this</span>.groupExpressionIndex.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">lastNodeIndex</span> <span class="operator">=</span> <span class="built_in">this</span>.groupExpressionIndex.get(lastNode);</span><br><span class="line">        <span class="comment">// 增加上次访问到 Group 的逻辑等价表达式的下标，实现依次访问</span></span><br><span class="line">        <span class="built_in">this</span>.groupExpressionIndex.set(lastNode, lastNodeIndex + <span class="number">1</span>); </span><br><span class="line"></span><br><span class="line">        expression = match(pattern, groupExpression, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// while 中的判断条件是为了回溯</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (expression == <span class="literal">null</span> &amp;&amp; <span class="built_in">this</span>.groupExpressionIndex.size() != <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="match"><a href="#match" class="headerlink" title="match"></a>match</h3><p>Binder.match 函数目的是找出 groupExpression 中匹配 Pattern 的 OptExpression 子树。实际上就是 Pattern-Tree 能否在 GroupExpression-Tree 中能否找到结构和自己一样的子树，因此需要同时遍历 Pattern、GroupExpression 两棵树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> OptExpression <span class="title function_">match</span><span class="params">(Pattern pattern, GroupExpression groupExpression,</span></span><br><span class="line"><span class="params">                            <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="comment">// CHECK-1: 先匹配 groupExpression 自己是否符合 Pattern 结构</span></span><br><span class="line">    <span class="keyword">if</span> (!pattern.matchWithoutChild(groupExpression, level)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// recursion match children</span></span><br><span class="line">    List&lt;OptExpression&gt; resultInputs = Lists.newArrayList();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 记录两棵树遍历的位置</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">patternIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gEI</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Pattern&gt; childernPatternSize = pattern.children().size();</span><br><span class="line">    List&lt;Group&gt; childernGroup = groupExpression.getInputs();</span><br><span class="line">    <span class="comment">// 遍历所有的 childernGroup</span></span><br><span class="line">    <span class="keyword">while</span> ((patternIndex &lt; childernPatternSize) &amp;&amp; gEI &lt; childernGroup.size()) &#123;</span><br><span class="line">        trace();</span><br><span class="line">        <span class="type">Group</span> <span class="variable">childGroup</span> <span class="operator">=</span> childernGroup.get(gEI);</span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">childPattern</span> <span class="operator">=</span> pattern.childAt(patternIndex);</span><br><span class="line">        <span class="comment">// 先递归子 group</span></span><br><span class="line">        <span class="type">OptExpression</span> <span class="variable">opt</span> <span class="operator">=</span> </span><br><span class="line">            match(childPattern,</span><br><span class="line">                  extractGroupExpression(childPattern, childGroup),</span><br><span class="line">                  level);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (opt == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        resultInputs.add(opt);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时为 true 才不更新 patternIndex</span></span><br><span class="line">        <span class="keyword">if</span> (!(childPattern.isPatternMultiLeaf() &amp;&amp; </span><br><span class="line">             (childernGroup.size() - gEI) &gt; (childernPatternSize - patternIndex))) &#123;</span><br><span class="line">            patternIndex++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        gEI++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">OptExpression</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OptExpression</span>(groupExpression);</span><br><span class="line">    result.getInputs().addAll(resultInputs);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="trace"><a href="#trace" class="headerlink" title="trace"></a>trace</h4><p>准备下一个要访问的 Group。groupExpressionIndex.add(0) 表示第一次访问下一个Group。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">trace</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.groupTraceKey++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="built_in">this</span>.groupExpressionIndex.size(); i &lt; <span class="built_in">this</span>.groupTraceKey + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">this</span>.groupExpressionIndex.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="extractGroupExpression"><a href="#extractGroupExpression" class="headerlink" title="extractGroupExpression"></a>extractGroupExpression</h4><p>groupExpressionIndex 用于存储状态，在 extractGroupExpression 函数中提取 Group 的 groupExpressionIndex[groupTraceKey] 个逻辑等价的表达式。当 ChildernGroup[i] 的所有等价表达式访问完毕，则将 groupTraceKey 从 groupExpressionIndex 中删除，回溯到到前一个 ChildernGroup[i-1]。</p><p>本质上就是个<strong>后序遍历多叉树</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> GroupExpression <span class="title function_">extractGroupExpression</span><span class="params">(Pattern pattern, Group group)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (pattern.isPatternLeaf() || pattern.isPatternMultiLeaf()) &#123;</span><br><span class="line">        <span class="comment">// 这种只有一个表达式</span></span><br><span class="line">        <span class="keyword">if</span> (groupExpressionIndex.get(groupTraceKey) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            groupExpressionIndex.remove(groupTraceKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> group.getFirstLogicalExpression();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 多个逻辑等价的表达式，依次遍历</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">valueIndex</span> <span class="operator">=</span> groupExpressionIndex.get(groupTraceKey);</span><br><span class="line">        <span class="keyword">if</span> (valueIndex &gt;= group.getLogicalExpressions().size()) &#123;</span><br><span class="line">            <span class="comment">// 本group遍历结束，删除节点进行回溯</span></span><br><span class="line">            groupExpressionIndex.remove(groupTraceKey);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> group.getLogicalExpressions().get(valueIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/577956480">StarRocks 优化器代码导读</a></li><li><a href="https://szza.github.io/2023/06/15/Paper/Columbia-Query-Optimizer-1">COLUMBIA 查询优化器如何提升性能(上)</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OptimizerTask 的继承关系如下图（还有个 RewriteTreeTask，由于和其他 Task 不一起使用，因此没画出来）。每个子 Task 都需要去实现 &lt;strong&gt;execute&lt;/strong&gt; 函数来完成真正的操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=</summary>
      
    
    
    
    <category term="CBO" scheme="https://szza.github.io/categories/CBO/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>EnforceAndCostTask: 搜索代价最低的 PhysicalPlan</title>
    <link href="https://szza.github.io/2023/10/05/StarRocks/CBO/EnforceAndCostTask/"/>
    <id>https://szza.github.io/2023/10/05/StarRocks/CBO/EnforceAndCostTask/</id>
    <published>2023-10-05T02:00:01.000Z</published>
    <updated>2023-11-03T13:09:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="PhysicalProperty"><a href="#PhysicalProperty" class="headerlink" title="PhysicalProperty"></a>PhysicalProperty</h2><p>PhysicalProperty 是个接口的，实现接口的类中比较重要是 DistributionProperty </p><ul><li>DistributionSpec.DistributionType 表示 Operator 的输出数据分布</li><li>HashDistributionDesc.sourceType 表示 Operator 的数据来源</li></ul><p>继承逻辑如下:<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/DistributionSpec.svg?raw=true" alt="DistributionSpec-1"><br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/PropertyDeriver.svg?raw=true" alt="PropertyDeriver"></p><h2 id="TaskContext"><a href="#TaskContext" class="headerlink" title="TaskContext"></a>TaskContext</h2><p>TaskContext 作为优化一个 Group 时的上下文信息，主要有以下五个成员变量</p><ul><li>requiredProperty: 即父节点对当前 Grouo 所有 GroupExpressions 的输出必须满足的属性</li><li>requiredColumns: 父节点的输出要求当前 Group 输出的列</li></ul><p>比如，</p><ol><li><p>在 optimizeByCost 函数首次构造 TaskContext 对象，</p><ul><li>requiredProperty 是空的</li><li>requiredColumns 是最终输出的列</li></ul></li><li><p>在 <a href="https://szza.github.io/2023/10/07/Pipeline/EnforceAndCostTask/#optimizeChildGroup">EnforceAndCostTask.optimizeChildGroup</a> 中对 ChildGroup 进行递归初始化时:</p><ul><li><p>requiredProperty</p><p>当前节点 Group 先通过 RequiredPropertyDeriver.getRequiredProps 函数先计算出自己子节点 ChildernGroup 输出所需的属性，再将子节点输出所需满足的属性 inputProperty 用于构造 TaskContext，递归优化子节点 ChildGroup</p></li><li><p>requiredColumns 也是所需输出的列</p></li></ul></li></ol><p>先简略看下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">TaskContext</span><span class="params">(OptimizerContext context,</span></span><br><span class="line"><span class="params">                   PhysicalPropertySet physicalPropertySet,</span></span><br><span class="line"><span class="params">                   ColumnRefSet requiredColumns,</span></span><br><span class="line"><span class="params">                   <span class="type">double</span> cost)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.optimizerContext = context;</span><br><span class="line">    <span class="built_in">this</span>.requiredProperty = physicalPropertySet;</span><br><span class="line">    <span class="built_in">this</span>.requiredColumns = requiredColumns;</span><br><span class="line">    <span class="built_in">this</span>.upperBoundCost = cost;</span><br><span class="line">    <span class="built_in">this</span>.allScanOperators = Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> OptExpression <span class="title function_">optimizeByCost</span><span class="params">(ConnectContext connectContext,</span></span><br><span class="line"><span class="params">                                     OptExpression logicOperatorTree,</span></span><br><span class="line"><span class="params">                                     PhysicalPropertySet requiredProperty,</span></span><br><span class="line"><span class="params">                                     ColumnRefSet requiredColumns)</span> &#123;</span><br><span class="line">    <span class="type">TaskContext</span> <span class="variable">rootTaskContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskContext</span>(</span><br><span class="line">        context, requiredProperty, requiredColumns.clone(), Double.MAX_VALUE);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RequiredPropertyDeriver"><a href="#RequiredPropertyDeriver" class="headerlink" title="RequiredPropertyDeriver"></a>RequiredPropertyDeriver</h2><p>RequiredPropertyDeriver 是用于计算每个 Operator 对子节点输出需要满足的属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;PhysicalPropertySet&gt;&gt; <span class="title function_">getRequiredProps</span><span class="params">(GroupExpression groupExpression)</span> &#123;</span><br><span class="line">    requiredProperties = Lists.newArrayList();</span><br><span class="line">    groupExpression.getOp().accept(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">ExpressionContext</span>(groupExpression));</span><br><span class="line">    deriveChildCTEProperty(groupExpression);</span><br><span class="line">    <span class="keyword">return</span> requiredProperties;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="visitOperator"><a href="#visitOperator" class="headerlink" title="visitOperator"></a>visitOperator</h3><p>没有实现 visitPhysicalxxx 函数的 Operator，就会进入 visitOperator 函数，即根据节点的入度(arity) 生成包含 arity 个 PhysicalPropertySet.EMPTY 的 PhysicalPropertySet，也就是对每个子节点输出属性都没有要求。</p><p>比如，PhysicalHashJoinOperator 实现了 visitPhysicalHashJoin 函数，则会进入下文流程来获取属性，而 OlapScanNodeOperator 没有实现 visitOlapScanNodeOperator 函数则进入 visitOperator 函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visitOperator</span><span class="params">(Operator node, ExpressionContext context)</span> &#123;</span><br><span class="line">  List&lt;PhysicalPropertySet&gt; requiredProps = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">childIndex</span> <span class="operator">=</span> <span class="number">0</span>; childIndex &lt; context.arity(); ++childIndex) &#123;</span><br><span class="line">      requiredProps.add(PhysicalPropertySet.EMPTY);</span><br><span class="line">  &#125;</span><br><span class="line">  requiredProperties.add(requiredProps);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="visitPhysicalHashJoin"><a href="#visitPhysicalHashJoin" class="headerlink" title="visitPhysicalHashJoin"></a>visitPhysicalHashJoin</h3><p>当遇到一个 PhysicalHashJoinOperator，则会进入 visitPhysicalHashJoin 函数，生成对左右子节点输出所需的属性。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/DistributionSpec-4.svg?raw=true" alt="DistributionSpec-4"></p><p>JOIN 的实现主要有两种：</p><ol><li>BroadcastJOIN<br> 将右子节点数据（Build-TABLE）的数据全部发送到左子节点（Probe-TABLE），在左子节点很丧构建 HashMap。这种实现对右表的行数有大小限制。</li><li>ShuffleJOIN<br>需要对子节点的数据进行Shuffle，根据 Shuffle 规则又可以细分。</li></ol><p>最终选择哪种作为物理计划，根据右表的大小、以及生成的物理计划的代价进行抉择。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visitPhysicalHashJoin</span><span class="params">(PhysicalHashJoinOperator node, ExpressionContext context)</span> &#123;</span><br><span class="line">    <span class="comment">// 1 For broadcast join</span></span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">rightBroadcastProperty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PhysicalPropertySet</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DistributionProperty</span>(DistributionSpec.createReplicatedDistributionSpec()));</span><br><span class="line">    requiredProperties.add(Lists.newArrayList(</span><br><span class="line">        PhysicalPropertySet.EMPTY,  <span class="comment">// 对左子节点输出无要求</span></span><br><span class="line">        rightBroadcastProperty));   <span class="comment">// 对右子节点输出属性有分布要求</span></span><br><span class="line"></span><br><span class="line">    <span class="type">JoinHelper</span> <span class="variable">joinHelper</span> <span class="operator">=</span> JoinHelper.of(node, </span><br><span class="line">            context.getChildOutputColumns(<span class="number">0</span>),  <span class="comment">// 左子节点的输出列</span></span><br><span class="line">            context.getChildOutputColumns(<span class="number">1</span>)); <span class="comment">// 右子节点的输出列</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当前 Operator 仅能通过 BroadcastJoin 来实现</span></span><br><span class="line">    <span class="keyword">if</span> (joinHelper.onlyBroadcast()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 Operator 仅能通过 ShuffleJoin 来实现</span></span><br><span class="line">    <span class="keyword">if</span> (joinHelper.onlyShuffle()) &#123;</span><br><span class="line">        requiredProperties.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 For shuffle join</span></span><br><span class="line">    List&lt;Integer&gt; leftOnPredicateColumns = joinHelper.getLeftOnColumns();</span><br><span class="line">    List&lt;Integer&gt; rightOnPredicateColumns = joinHelper.getRightOnColumns();</span><br><span class="line">    <span class="keyword">if</span> (leftOnPredicateColumns.isEmpty() || rightOnPredicateColumns.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将父节点对自己的输出要求 requirementsFromParent 传递给对子节点</span></span><br><span class="line">    <span class="comment">// 生成 ShuffleJoin 属性</span></span><br><span class="line">    requiredProperties.add(computeShuffleJoinRequiredProperties(</span><br><span class="line">        requirementsFromParent, leftOnPredicateColumns, rightOnPredicateColumns));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PropertyDeriverBase-computeShuffleJoinRequiredProperties"><a href="#PropertyDeriverBase-computeShuffleJoinRequiredProperties" class="headerlink" title="PropertyDeriverBase.computeShuffleJoinRequiredProperties"></a>PropertyDeriverBase.computeShuffleJoinRequiredProperties</h4><p>requiredFromParent 是 PhysicalHashJoinOperator 父节点对其输出需要满足的属性，leftShuffleColumns、rightShuffleColumns 是 JoinOperator 的两个子节点的 shuffle 列。 JoinOperator 需要在满足 requiredFromParent 的前提下，调整 shuffle 列的顺序，生成自己左右子节点的输出属性。</p><p>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> List&lt;PhysicalPropertySet&gt; </span><br><span class="line"><span class="title function_">computeShuffleJoinRequiredProperties</span><span class="params">(PhysicalPropertySet requiredFromParent, </span></span><br><span class="line"><span class="params">                                     List&lt;Integer&gt; leftShuffleColumns,</span></span><br><span class="line"><span class="params">                                     List&lt;Integer&gt; rightShuffleColumns)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 获得父节点的 ShuffleJoin 分布要求</span></span><br><span class="line">    Optional&lt;HashDistributionDesc&gt; requiredShuffleDescOptional =</span><br><span class="line">            getShuffleJoinHashDistributionDesc(requiredFromParent);</span><br><span class="line">    <span class="keyword">if</span> (!requiredShuffleDescOptional.isPresent()) &#123;</span><br><span class="line">        <span class="comment">// 2. requiredFromParent 不要求子节点是 ShufffleJOIN</span></span><br><span class="line">        <span class="keyword">return</span> createShuffleJoinRequiredProperties(</span><br><span class="line">            leftShuffleColumns, rightShuffleColumns);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 是否需要调整列的顺序</span></span><br><span class="line">        List&lt;Integer&gt; requiredColumns </span><br><span class="line">                = requiredShuffleDescOptional.get().getColumns();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">adjustBasedOnLeft</span></span><br><span class="line">                <span class="operator">=</span> leftShuffleColumns.size() == requiredColumns.size()</span><br><span class="line">                &amp;&amp; leftShuffleColumns.containsAll(requiredColumns)</span><br><span class="line">                &amp;&amp; requiredColumns.containsAll(leftShuffleColumns);</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">adjustBasedOnRight</span> </span><br><span class="line">                <span class="operator">=</span> rightShuffleColumns.size() == requiredColumns.size()</span><br><span class="line">                &amp;&amp; rightShuffleColumns.containsAll(requiredColumns)</span><br><span class="line">                &amp;&amp; requiredColumns.containsAll(rightShuffleColumns);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基于和 requiredColumns 完全相同的列进行选择</span></span><br><span class="line">        <span class="keyword">if</span> (adjustBasedOnLeft || adjustBasedOnRight) &#123;</span><br><span class="line">            List&lt;Integer&gt; requiredLeft = Lists.newArrayList();</span><br><span class="line">            List&lt;Integer&gt; requiredRight = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Integer cid : requiredColumns) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> adjustBasedOnLeft </span><br><span class="line">                        ? leftShuffleColumns.indexOf(cid) </span><br><span class="line">                        : rightShuffleColumns.indexOf(cid);</span><br><span class="line">                requiredLeft.add(leftShuffleColumns.get(idx));</span><br><span class="line">                requiredRight.add(rightShuffleColumns.get(idx));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> createShuffleJoinRequiredProperties(</span><br><span class="line">                requiredLeft, requiredRight);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> createShuffleJoinRequiredProperties(</span><br><span class="line">                leftShuffleColumns, rightShuffleColumns);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PropertyDeriverBase-getShuffleJoinHashDistributionDesc"><a href="#PropertyDeriverBase-getShuffleJoinHashDistributionDesc" class="headerlink" title="PropertyDeriverBase.getShuffleJoinHashDistributionDesc"></a>PropertyDeriverBase.getShuffleJoinHashDistributionDesc</h4><p>getShuffleJoinHashDistributionDesc 函数有两个作用：</p><ol><li>检测父节点是否要子节点输出为 SHUFFLE 方式。如果不是，则返回 Optional.empty()，即不强求子节点也必须有这个分布</li><li>否则，则返回父节点要求子节点满足的输出属性 requiredPropertySet</li></ol><p>代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">static</span> Optional&lt;HashDistributionDesc&gt; </span><br><span class="line"><span class="title function_">getShuffleJoinHashDistributionDesc</span><span class="params">(PhysicalPropertySet requiredPropertySet)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 子节点输出方式 shuffle</span></span><br><span class="line">    <span class="keyword">if</span> (!requiredPropertySet.getDistributionProperty().isShuffle()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">HashDistributionDesc</span> <span class="variable">requireDistributionDesc</span> <span class="operator">=</span></span><br><span class="line">        ((HashDistributionSpec) requiredPropertySet.getDistributionProperty()</span><br><span class="line">            .getSpec()).getHashDistributionDesc();</span><br><span class="line">      <span class="comment">// 2. 子节点输入源是 SHUFFLE_JOIN</span></span><br><span class="line">    <span class="keyword">if</span> (!HashDistributionDesc.SourceType.SHUFFLE_JOIN</span><br><span class="line">        .equals(requireDistributionDesc.getSourceType())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Optional.of(requireDistributionDesc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PropertyDeriverBase-createShuffleJoinRequiredProperties"><a href="#PropertyDeriverBase-createShuffleJoinRequiredProperties" class="headerlink" title="PropertyDeriverBase.createShuffleJoinRequiredProperties"></a>PropertyDeriverBase.createShuffleJoinRequiredProperties</h4><p>基于输入参数 &lt;leftColumns, rightColumns&gt; 生成 List&lt;PhysicalPropertySet&gt;。这里的 HashDistributionDesc.SourceType.SHUFFLE_JOIN 表示这个 hash 分布来源是 JOIN。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;PhysicalPropertySet&gt;</span><br><span class="line"><span class="title function_">createShuffleJoinRequiredProperties</span><span class="params">(List&lt;Integer&gt; leftColumns, List&lt;Integer&gt; rightColumns)</span> &#123;</span><br><span class="line">    <span class="type">HashDistributionSpec</span> <span class="variable">leftDistribution</span> <span class="operator">=</span> </span><br><span class="line">        DistributionSpec.createHashDistributionSpec(<span class="keyword">new</span> <span class="title class_">HashDistributionDesc</span>(</span><br><span class="line">        leftColumns,</span><br><span class="line">        HashDistributionDesc.SourceType.SHUFFLE_JOIN));</span><br><span class="line">    <span class="type">HashDistributionSpec</span> <span class="variable">rightDistribution</span> <span class="operator">=</span> </span><br><span class="line">        DistributionSpec.createHashDistributionSpec(<span class="keyword">new</span> <span class="title class_">HashDistributionDesc</span>(</span><br><span class="line">        rightColumns,</span><br><span class="line">        HashDistributionDesc.SourceType.SHUFFLE_JOIN));</span><br><span class="line"></span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">leftRequiredPropertySet</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">PhysicalPropertySet</span>(<span class="keyword">new</span> <span class="title class_">DistributionProperty</span>(leftDistribution));</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">rightRequiredPropertySet</span> <span class="operator">=</span></span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">PhysicalPropertySet</span>(<span class="keyword">new</span> <span class="title class_">DistributionProperty</span>(rightDistribution));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Lists.newArrayList(leftRequiredPropertySet, rightRequiredPropertySet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="EnforceAndCostTask"><a href="#EnforceAndCostTask" class="headerlink" title="EnforceAndCostTask"></a>EnforceAndCostTask</h2><p>EnforceAndCostTask 是用于优化一个 groupExpression 所属 Group 及其输入：从叶结点向根节点方向优化，bottom-up。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EnforceAndCostTask(TaskContext context, GroupExpression expression) &#123;</span><br><span class="line">  <span class="built_in">super</span>(context);</span><br><span class="line">  <span class="built_in">this</span>.groupExpression = expression;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="initRequiredProperties"><a href="#initRequiredProperties" class="headerlink" title="initRequiredProperties"></a>initRequiredProperties</h3><p>initRequiredProperties 函数中通过调用 RequiredPropertyDeriver.getRequiredProps 函数来获得 GroupExpression.op 要求子节点需要满足的输出属性，记录记录在 childrenRequiredPropertiesList。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initRequiredProperties</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (curChildIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  localCost = <span class="number">0</span>;</span><br><span class="line">  curTotalCost = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 子节点所需满足的输出属性</span></span><br><span class="line">  childrenRequiredPropertiesList = </span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">RequiredPropertyDeriver</span>(context).getRequiredProps(groupExpression);</span><br><span class="line">  curChildIndex = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="optimizeChildGroup"><a href="#optimizeChildGroup" class="headerlink" title="optimizeChildGroup"></a>optimizeChildGroup</h3><p>optimizeChildGroup 函数对当前 groupExpression 的所有输入（即 ChildernGroup） 先优化，等输入都优化完毕，就能统计出从叶结点到当前 Group 的最佳路径了。</p><ul><li>inputProperty 是对当前 group 对 childGroup 输出属性的要求</li><li>newUpperBound 是以 childGroup 为根节点的子树中，cost 上界</li></ul><p>借助 pushTask 函数实现保护现场、现场恢复。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">optimizeChildGroup</span><span class="params">(PhysicalPropertySet inputProperty,</span></span><br><span class="line"><span class="params">                                Group childGroup)</span> &#123;</span><br><span class="line">  <span class="comment">// clone 函数实现保留现场</span></span><br><span class="line">  pushTask((EnforceAndCostTask) clone()); </span><br><span class="line">  <span class="type">double</span> <span class="variable">newUpperBound</span> <span class="operator">=</span> context.getUpperBoundCost() - curTotalCost;</span><br><span class="line">  <span class="type">TaskContext</span> <span class="variable">taskContext</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskContext</span>(</span><br><span class="line">        context.getOptimizerContext(), </span><br><span class="line">        inputProperty,</span><br><span class="line">        context.getRequiredColumns(),</span><br><span class="line">        newUpperBound);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本次执行的 ChildGroup</span></span><br><span class="line">  pushTask(<span class="keyword">new</span> <span class="title class_">OptimizeGroupTask</span>(taskContext, childGroup)); </span><br><span class="line">  <span class="comment">// 执行完再返回现场</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OutputPropertyDeriver"><a href="#OutputPropertyDeriver" class="headerlink" title="OutputPropertyDeriver"></a>OutputPropertyDeriver</h2><p>OutputPropertyDeriver 类用于生成当前节点的输出属性，ChildOutputPropertyGuarantor 用于生成子节点的输出属性</p><p>先来看没有输入的节点，比如 OlapScanNodeOperator，在执行 EnforceAndCostTask.execute 函数时会跳过 optimizeChildGroup 函数和 ChildOutputPropertyGuarantor，进入 OutputPropertyDeriver 中，来满足父节点的输出属性要求。</p><ul><li>context.getRequiredProperty() 是父节点所需要的属性</li><li>outputProperty 是本节点输出的属性</li><li>childrenOutputProperties 是子节点属性的属性</li></ul><p>这部分代码注释如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in EnforceAndCostTask.execute</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计完 ChildernGroup 的 cost 之后，再统计当前 groupExpression 的 cost</span></span><br><span class="line"><span class="keyword">if</span> (curChildIndex == <span class="number">0</span> &amp;&amp; prevChildIndex == -<span class="number">1</span>) &#123;</span><br><span class="line">    localCost = CostModel.calculateCost(groupExpression);</span><br><span class="line">    curTotalCost += localCost;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ChildernGroup 优化完毕，再考虑自己</span></span><br><span class="line"><span class="keyword">if</span> (curChildIndex == groupExpression.getInputs().size()) &#123;</span><br><span class="line">    <span class="type">ChildOutputPropertyGuarantor</span> <span class="variable">childOutputPropertyGuarantor</span> </span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChildOutputPropertyGuarantor</span>(</span><br><span class="line">            context,</span><br><span class="line">            groupExpression,</span><br><span class="line">            context.getRequiredProperty(),</span><br><span class="line">            childrenBestExprList,</span><br><span class="line">            childrenRequiredProperties,</span><br><span class="line">            childrenOutputProperties,</span><br><span class="line">            curTotalCost);</span><br><span class="line">    <span class="comment">// 校验子节点输出属性是否满足当前节点对其输出属性要求</span></span><br><span class="line">    curTotalCost = childOutputPropertyGuarantor.enforceLegalChildOutputProperty();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 裁剪: 当前 groupExpression 优化的代价已经高于 Group 中其他等价 GroupExpression</span></span><br><span class="line">    <span class="keyword">if</span> (curTotalCost &gt; context.getUpperBoundCost()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update current group statistics and re-compute costs</span></span><br><span class="line">    <span class="keyword">if</span> (!computeCurrentGroupStatistics()) &#123;</span><br><span class="line">        <span class="comment">// child group has been pruned</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compute the output property</span></span><br><span class="line">    <span class="comment">// 计算当前 GroupExpression 的输出属性，并满足父节点输出属性要求</span></span><br><span class="line">    <span class="type">OutputPropertyDeriver</span> <span class="variable">outputPropertyDeriver</span> </span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputPropertyDeriver</span>(groupExpression,</span><br><span class="line">                                    context.getRequiredProperty(),</span><br><span class="line">                                    childrenOutputProperties);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">outputProperty</span> <span class="operator">=</span> outputPropertyDeriver.getOutputProperty();</span><br><span class="line">    recordCostsAndEnforce(outputProperty, childrenRequiredProperties);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OutputPropertyDeriver-visitPhysicalOlapScan"><a href="#OutputPropertyDeriver-visitPhysicalOlapScan" class="headerlink" title="OutputPropertyDeriver.visitPhysicalOlapScan"></a>OutputPropertyDeriver.visitPhysicalOlapScan</h3><p>PhysicalOlapScanOperator 是个递归基，没有输入属性、只有输出属性，输出属性集中只有个分布属性 HashDistributionSpec，其中 <strong>HashDistributionDesc.SourceType.LOCAL</strong> 表示数据来源于本地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PhysicalPropertySet <span class="title function_">visitPhysicalOlapScan</span><span class="params">(PhysicalOlapScanOperator node, </span></span><br><span class="line"><span class="params">                                                 ExpressionContext context)</span> &#123;</span><br><span class="line">    <span class="type">HashDistributionSpec</span> <span class="variable">olapDistributionSpec</span> <span class="operator">=</span> node.getDistributionSpec();</span><br><span class="line"></span><br><span class="line">    DistributionSpec.<span class="type">PropertyInfo</span> <span class="variable">physicalPropertyInfo</span> </span><br><span class="line">        <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributionSpec</span>.PropertyInfo();</span><br><span class="line"></span><br><span class="line">    physicalPropertyInfo.tableId = node.getTable().getId();</span><br><span class="line">    physicalPropertyInfo.partitionIds = node.getSelectedPartitionId();</span><br><span class="line">    <span class="keyword">return</span> createPropertySetByDistribution(<span class="keyword">new</span> <span class="title class_">HashDistributionSpec</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HashDistributionDesc</span>(</span><br><span class="line">            olapDistributionSpec.getShuffleColumns(),</span><br><span class="line">            HashDistributionDesc.SourceType.LOCAL),</span><br><span class="line">        physicalPropertyInfo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnforceAndCostTask-recordCostsAndEnforce"><a href="#EnforceAndCostTask-recordCostsAndEnforce" class="headerlink" title="EnforceAndCostTask.recordCostsAndEnforce"></a>EnforceAndCostTask.recordCostsAndEnforce</h3><p>outputProperty 是当前节点输出属性，context.getRequiredPropert() 是父节点对当前节点的输出属性要求，此时需要进一步校验 outputProperty –&gt; requiredPropert 链路是否满足，如果不满足则施加一个 enforcer: <strong>outputProperty –&gt; enforcer –&gt; requiredPropert</strong>。</p><p>recordCostsAndEnforce 函数的输入是当前节点输出属性 outputProperty、和子节点输入属性 childrenOutputProperties，函数执行完，一个 Group 的及其子 Group 的优化就结束了，并将最低成本记录在 <strong>curTotalCost</strong> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> </span><br><span class="line"><span class="title function_">recordCostsAndEnforce</span><span class="params">(PhysicalPropertySet outputProperty,</span></span><br><span class="line"><span class="params">                      List&lt;PhysicalPropertySet&gt; childrenOutputProperties)</span> &#123;</span><br><span class="line">    <span class="comment">//1. 重新计算 cost，并更新当前 groupExpression 的 totoal cost</span></span><br><span class="line">    curTotalCost -= localCost;</span><br><span class="line">    localCost = CostModel.calculateCostWithChildrenOutProperty(</span><br><span class="line">            groupExpression, childrenOutputProperties);</span><br><span class="line">    curTotalCost += localCost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 先假设满足本节点的输出属性 outputProperty 能满足父节点所需属性 requiredProperty</span></span><br><span class="line">    setSatisfiedPropertyWithCost(outputProperty, childrenOutputProperties);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">requiredProperty</span> <span class="operator">=</span> context.getRequiredProperty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!outputProperty.isSatisfy(requiredProperty)) &#123;</span><br><span class="line">        <span class="comment">// 2. 如果不满足，则添加 Enforcer</span></span><br><span class="line">        <span class="comment">// outputProperty --&gt; enforcedProperty --&gt; requiredProperty</span></span><br><span class="line">        <span class="type">PhysicalPropertySet</span> <span class="variable">enforcedProperty</span> </span><br><span class="line">            <span class="operator">=</span> enforceProperty(outputProperty, requiredProperty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// enforcedProperty is superset of requiredProperty</span></span><br><span class="line">        <span class="keyword">if</span> (!enforcedProperty.equals(requiredProperty)) &#123;</span><br><span class="line">            <span class="comment">// 在 &#123;enforcedProperty, requiredProperty&#125; 之间映射</span></span><br><span class="line">            setPropertyWithCost(</span><br><span class="line">                <span class="comment">// enforcer</span></span><br><span class="line">                groupExpression.getGroup().getBestExpression(enforcedProperty), </span><br><span class="line">                enforcedProperty,</span><br><span class="line">                requiredProperty,</span><br><span class="line">                Lists.newArrayList(outputProperty));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 如果满足，且 outputProperty != requiredProperty</span></span><br><span class="line">        <span class="comment">//    outputProperty 是 requiredProperty 的子集，则更新记录</span></span><br><span class="line">        <span class="keyword">if</span> (!outputProperty.equals(requiredProperty)) &#123;</span><br><span class="line">            setPropertyWithCost(</span><br><span class="line">                groupExpression,</span><br><span class="line">                outputProperty,</span><br><span class="line">                requiredProperty,</span><br><span class="line">                childrenOutputProperties);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 更新当前 groupExpression 所属的 Group 的 cost 上界</span></span><br><span class="line">    <span class="keyword">if</span> (curTotalCost &lt; context.getUpperBoundCost()) &#123;</span><br><span class="line">        context.setUpperBoundCost(curTotalCost);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EnforceAndCostTask-setSatisfiedPropertyWithCost"><a href="#EnforceAndCostTask-setSatisfiedPropertyWithCost" class="headerlink" title="EnforceAndCostTask.setSatisfiedPropertyWithCost"></a>EnforceAndCostTask.setSatisfiedPropertyWithCost</h4><p>setSatisfiedPropertyWithCost 函数表示当前 groupExpression 的输出属性 outputProperty 父节点要求的属性 requiredProperty 完全一样了。因此，调用 setPropertyWithCost 函数时，直接使用 outputProperty 代替 requiredProperty。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setSatisfiedPropertyWithCost</span><span class="params">(</span></span><br><span class="line"><span class="params">                        PhysicalPropertySet outputProperty, </span></span><br><span class="line"><span class="params">                        List&lt;PhysicalPropertySet&gt; childrenOutputProperties)</span> &#123;</span><br><span class="line">    setPropertyWithCost(</span><br><span class="line">        groupExpression, outputProperty, childrenOutputProperties);</span><br><span class="line">    <span class="keyword">if</span> (outputProperty.getCteProperty().isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// groupExpression can satisfy the ANY type output property</span></span><br><span class="line">        setPropertyWithCost(groupExpression,</span><br><span class="line">                            outputProperty,</span><br><span class="line">                            PhysicalPropertySet.EMPTY,</span><br><span class="line">                            childrenOutputProperties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EnforceAndCostTask-setPropertyWithCost"><a href="#EnforceAndCostTask-setPropertyWithCost" class="headerlink" title="EnforceAndCostTask.setPropertyWithCost"></a>EnforceAndCostTask.setPropertyWithCost</h4><p>Group 与 GroupExpression：一个 Group 中包含了所有逻辑上等价的 GroupExpression（即输出一样），并记录了 lowestCost 的 GroupExpression，而 GroupExpression 输入输出都是 Group </p><ul><li><p>GroupExpression.lowestCostTable: 记录是得到 outputProperty 所需的成小成本 curTotalCost 以及对应的输入属性 childrenOutputProperties</p><p>  因此，如果本次更新 childrenOutputProperties –&gt; outputProperty 所需的成本 curTotalCost 更低，则更新 GroupExpression.lowestCostTable 中的记录（如果原本没有则插入）</p><blockquote><p>GroupExpression.updatePropertyWithCost 函数更新。</p></blockquote></li><li><p>GroupExpression.outputPropertyMap: 记录的是得到最佳路径时，满足 requiredPropertySet 的输出属性 outputProperty</p><p>  由于 updatePropertyWithCost 返回 true 时，才会更新 GroupExpression.outputPropertyMap，因此两个函数联动起来就是<u><strong>输入到输出的最佳路径信息</strong></u>：</p><ul><li>Group 中最佳表达式：this.groupExpression</li><li>最低的成本：curTotalCost</li><li>此时的输入属性：childrenOutputProperties</li><li>此时的输出属性：outputProperty</li><li>父节点要求属性：requiredProperty</li></ul><blockquote><p>GroupExpression.setOutputPropertySatisfyRequiredProperty 更新。</p></blockquote></li><li><p>Group.lowestCostExpressions: 记录的是 Group 所有等价的 GroupExpression 中，在满足 requiredProperty 属性要求的前提下，代价最低的 GroupExprssion 是哪个</p><ul><li>key: requiredProperty</li><li>value: &lt;cost, expression&gt; 最低的代价与对应的 GroupExpression</li></ul><blockquote><p>Group.setBestExpression 函数更新</p></blockquote></li></ul><p>因此，当优化结束，父节点可以通过 GroupExpression.getOutputProperty(requiredProperty) 函数得到最佳输入属性 outputProperty，再递归到 childrenOutputProperties，… 即可遍历所有最佳表达式。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/groupExpression-1.svg?raw=true" alt="groupExpression-1"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setPropertyWithCost</span><span class="params">(GroupExpression groupExpression,</span></span><br><span class="line"><span class="params">                                 PhysicalPropertySet outputProperty,</span></span><br><span class="line"><span class="params">                                 PhysicalPropertySet requiredProperty,</span></span><br><span class="line"><span class="params">                                 List&lt;PhysicalPropertySet&gt; childrenOutputProperties)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (groupExpression.updatePropertyWithCost(</span><br><span class="line">            requiredProperty, childrenOutputProperties, curTotalCost)) &#123;</span><br><span class="line">        groupExpression.setOutputPropertySatisfyRequiredProperty(</span><br><span class="line">            outputProperty, requiredProperty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.groupExpression.getGroup().setBestExpression(</span><br><span class="line">        groupExpression, curTotalCost, requiredProperty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GroupExpression-updatePropertyWithCost"><a href="#GroupExpression-updatePropertyWithCost" class="headerlink" title="GroupExpression.updatePropertyWithCost"></a>GroupExpression.updatePropertyWithCost</h4><p>当发现一个满足条件的 outputProperties，并且本次 new_cost 比之前的 old_cost 更小则更新 GroupExpression.lowestCostTable 记录（如果没有则插入），它是在 {outputProperties, &lt;cost, inputProperties&gt;} 之间建立映射关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updatePropertyWithCost</span><span class="params">(PhysicalPropertySet outputProperties,</span></span><br><span class="line"><span class="params">                                      List&lt;PhysicalPropertySet&gt; inputProperties,</span></span><br><span class="line"><span class="params">                                      <span class="type">double</span> cost)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lowestCostTable.containsKey(outputProperties)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lowestCostTable.get(outputProperties).first &gt; cost) &#123;</span><br><span class="line">            lowestCostTable.put(</span><br><span class="line">                outputProperties, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(cost, inputProperties));</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lowestCostTable.put(</span><br><span class="line">            outputProperties, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(cost, inputProperties));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GroupExpression-setOutputPropertySatisfyRequiredProperty"><a href="#GroupExpression-setOutputPropertySatisfyRequiredProperty" class="headerlink" title="GroupExpression.setOutputPropertySatisfyRequiredProperty"></a>GroupExpression.setOutputPropertySatisfyRequiredProperty</h4><p>setOutputPropertySatisfyRequiredProperty 是为了记录在父节点 parent 所需属性 requiredPropertySet 和本节点输出属性之间 outputPropertySet 的映射关系。</p><p>当 parent 执行 EnforceAndCostTask 函数时，会通过 GroupExpression.getOutputProperty 函数来获取子节点的输出属性，后面会仔细讲解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setOutputPropertySatisfyRequiredProperty</span><span class="params">(PhysicalPropertySet outputPropertySet,</span></span><br><span class="line"><span class="params">                                                     PhysicalPropertySet requiredPropertySet)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.outputPropertyMap.put(requiredPropertySet, outputPropertySet);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> PhysicalPropertySet <span class="title function_">getOutputProperty</span><span class="params">(PhysicalPropertySet requiredPropertySet)</span> &#123;</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">outputProperty</span> <span class="operator">=</span> outputPropertyMap.get(requiredPropertySet);</span><br><span class="line">    Preconditions.checkState(outputProperty != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> outputProperty;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Group-setBestExpression"><a href="#Group-setBestExpression" class="headerlink" title="Group.setBestExpression"></a>Group.setBestExpression</h4><p>Group.lowestCostExpressions 的映射关系是 {RequeiredProperty, {cost, groupExpression}}，即 key 是父节点所需的属性，value 是代价最低的 groupExpression 及其 cost。Group.setBestExpression 函数实时更新代价最低的 Group.lowestCostExpressions</p><p>那么最终根节点的 group 获取代价最低的 groupExpression 时就可以通过 Group.getBestExpression 函数获得。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBestExpression</span><span class="params">(GroupExpression expression,</span></span><br><span class="line"><span class="params">                              <span class="type">double</span> cost,</span></span><br><span class="line"><span class="params">                              PhysicalPropertySet physicalPropertySet)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lowestCostExpressions.containsKey(physicalPropertySet)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (lowestCostExpressions.get(physicalPropertySet).first &gt; cost) &#123;</span><br><span class="line">            lowestCostExpressions.put(</span><br><span class="line">                physicalPropertySet, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(cost, expression));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lowestCostExpressions.put(</span><br><span class="line">            physicalPropertySet, <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(cost, expression));</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> GroupExpression <span class="title function_">getBestExpression</span><span class="params">(PhysicalPropertySet physicalPropertySet)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (hasBestExpression(physicalPropertySet)) &#123;</span><br><span class="line">        <span class="keyword">return</span> lowestCostExpressions.get(physicalPropertySet).second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnforceAndCostTask-enforceDistribute"><a href="#EnforceAndCostTask-enforceDistribute" class="headerlink" title="EnforceAndCostTask.enforceDistribute"></a>EnforceAndCostTask.enforceDistribute</h3><p>enforceProperty 函数会检测 outputPropertySet 中的 DistributionProperty、SortProperty 是否满足 requiredPropertySet。这里以 DistributionProperty 为例阐述 enforceDistribute 函数怎么添加 Enforcer。</p><ol><li>PhysicalPropertySet.setDistributionProperty 函数表示只更改 DistributionProperty，其他属性仍然保持不变，如此 newOutputProperty 的分布属性就和父节点的一致。</li><li>然后 DistributionProperty.appendEnforcers 函数将当前 group（即 groupExpression.getGroup()）作为输入生成一个新的 GroupExpression 对象 enforcer，enforcer 类似转换器，实现 oldOutputProperty -&gt;  newOutputProperty -&gt; requiredProperty 的转变。</li><li>最后，由于新生成的 enforcer 还没有所属的 Group，updateCostWithEnforcer 函数中将 enforcer 的所属 group 也设置为 groupExpression.getGroup()</li></ol><p>整体逻辑如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PhysicalPropertySet <span class="title function_">enforceDistribute</span><span class="params">(PhysicalPropertySet oldOutputProperty)</span> &#123;</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">newOutputProperty</span> <span class="operator">=</span> oldOutputProperty.copy();</span><br><span class="line">    <span class="comment">// 设置目标分布属性</span></span><br><span class="line">    newOutputProperty.setDistributionProperty(</span><br><span class="line">        context.getRequiredProperty().getDistributionProperty());</span><br><span class="line">    <span class="comment">// 增加一个 groupExpression</span></span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">enforcer</span> <span class="operator">=</span> context.getRequiredProperty()</span><br><span class="line">                               .getDistributionProperty()</span><br><span class="line">                               .appendEnforcers(groupExpression.getGroup());</span><br><span class="line">    <span class="comment">// 将 newOutputProperty --&gt; enforcer</span></span><br><span class="line">    updateCostWithEnforcer(enforcer, oldOutputProperty, newOutputProperty);</span><br><span class="line">    <span class="keyword">return</span> newOutputProperty;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="DistributionProperty-appendEnforcers"><a href="#DistributionProperty-appendEnforcers" class="headerlink" title="DistributionProperty.appendEnforcers"></a>DistributionProperty.appendEnforcers</h4><p>生成新的 GroupExpression 对象 enforer，其中包含的 Operator 是 PhysicalDistributionOperator 实现所需的数据分布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> GroupExpression <span class="title function_">appendEnforcers</span><span class="params">(Group child)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">GroupExpression</span>(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PhysicalDistributionOperator</span>(spec), Lists.newArrayList(child));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EnforceAndCostTask-updateCostWithEnforcer"><a href="#EnforceAndCostTask-updateCostWithEnforcer" class="headerlink" title="EnforceAndCostTask.updateCostWithEnforcer"></a>EnforceAndCostTask.updateCostWithEnforcer</h4><p>updateCostWithEnforcer 函数设置 enforcer 所属的 Group，串联起 {oldOutputProperty, newOutputProperty} 之间的联系，并重新计算 enforcer 之后的代价。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateCostWithEnforcer</span><span class="params">(GroupExpression enforcer,</span></span><br><span class="line"><span class="params">                                    PhysicalPropertySet oldOutputProperty,</span></span><br><span class="line"><span class="params">                                    PhysicalPropertySet newOutputProperty)</span> &#123;</span><br><span class="line">    context.getOptimizerContext().getMemo().</span><br><span class="line">        insertEnforceExpression(enforcer, groupExpression.getGroup());</span><br><span class="line">    <span class="comment">// 记录增加的 enforcer 代价</span></span><br><span class="line">    curTotalCost += CostModel.calculateCost(enforcer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enforcer.updatePropertyWithCost(</span><br><span class="line">            newOutputProperty,</span><br><span class="line">            Lists.newArrayList(oldOutputProperty),</span><br><span class="line">            curTotalCost)) &#123;</span><br><span class="line">        enforcer.setOutputPropertySatisfyRequiredProperty(</span><br><span class="line">            newOutputProperty, newOutputProperty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    groupExpression.getGroup().setBestExpression(</span><br><span class="line">        enforcer, curTotalCost, newOutputProperty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Memo-insertEnforceExpression"><a href="#Memo-insertEnforceExpression" class="headerlink" title="Memo.insertEnforceExpression"></a>Memo.insertEnforceExpression</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertEnforceExpression</span><span class="params">(GroupExpression groupExpression, Group targetGroup)</span> &#123;</span><br><span class="line">    groupExpression.setGroup(targetGroup);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ChildOutputPropertyGuarantor"><a href="#ChildOutputPropertyGuarantor" class="headerlink" title="ChildOutputPropertyGuarantor"></a>ChildOutputPropertyGuarantor</h2><h3 id="EnforceAndCostTask-execute"><a href="#EnforceAndCostTask-execute" class="headerlink" title="EnforceAndCostTask.execute"></a>EnforceAndCostTask.execute</h3><p>上面的视角是以 PhysicalOlapScanOperator 为例讲解了优化一个 Group 的过程，因为 OlapScanNode 作为物理计划树中的叶结点，没有输入，因此是 EnforceAndCostTask.execute 函数的递归基，下面以 PhysicalHashJoinOperator 为例讲解一个子树优化的过程。</p><p>HashJoinNode 的左右子节点是 PhysicalOlapScanOperator or PhysicalDistributionOperator，并且 optimizeChildGroup 函数已递归两次将左右子节点都优化完，因此</p><ul><li>childGroup.getBestExpression() 获得的 childBestExpr 是在上面的 Group.setBestExpression 函数中设置的<br>如果 childBestExpr &#x3D;&#x3D; null 表示当前 childGroup 要么已经被裁剪了，要么还没优化，具体哪种取决于 prevChildIndex: prevChildIndex 记录正在优化的子节点索引，如果 prevChildIndex &lt; curChildIndex 则表示 childGroup 还没优化，则进入 optimizeChildGroup 函数递归完</li><li>childBestExpr.getOutputProperty() 获得的是也是上面 setOutputPropertySatisfyRequiredProperty 函数设置的最佳 GroupExpression 对象</li></ul><p>这部分代码逻辑及其解释如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (; curChildIndex &lt; groupExpression.getInputs().size(); curChildIndex++) &#123;</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">childRequiredProperty</span> </span><br><span class="line">        <span class="operator">=</span> childrenRequiredProperties.get(curChildIndex);</span><br><span class="line">    <span class="type">Group</span> <span class="variable">childGroup</span> <span class="operator">=</span> groupExpression.getInputs().get(curChildIndex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check whether the child group is already optimized for the property</span></span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">childBestExpr</span> <span class="operator">=</span> </span><br><span class="line">        childGroup.getBestExpression(childRequiredProperty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pruned</span></span><br><span class="line">    <span class="keyword">if</span> (childBestExpr == <span class="literal">null</span> &amp;&amp; prevChildIndex &gt;= curChildIndex) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尚未优化</span></span><br><span class="line">    <span class="keyword">if</span> (childBestExpr == <span class="literal">null</span>) &#123;</span><br><span class="line">        prevChildIndex = curChildIndex;</span><br><span class="line">        optimizeChildGroup(childRequiredProperty, childGroup);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// childOutputProperty 就是 childBestExpr 输出的</span></span><br><span class="line">    childrenBestExprList.add(childBestExpr);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">childOutputProperty</span> <span class="operator">=</span> </span><br><span class="line">        childBestExpr.getOutputProperty(childRequiredProperty);</span><br><span class="line">    childrenOutputProperties.add(childOutputProperty);</span><br><span class="line">    childrenRequiredProperties.set(curChildIndex, childOutputProperty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 裁剪: agg operator 不能生成一阶段聚合</span></span><br><span class="line">    <span class="keyword">if</span> (!canGenerateOneStageAgg(childBestExpr)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 裁剪: join operator 不能使用 brocast join</span></span><br><span class="line">    <span class="keyword">if</span> (!checkBroadcastRowCountLimit(childRequiredProperty, childBestExpr)) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 裁剪: 当前成本已超过 group 中其他逻辑等价的 GroupExpression 成本的上界</span></span><br><span class="line">    curTotalCost += childBestExpr.getCost(childRequiredProperty);</span><br><span class="line">    <span class="keyword">if</span> (curTotalCost &gt; context.getUpperBoundCost()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="enforceLegalChildOutputProperty"><a href="#enforceLegalChildOutputProperty" class="headerlink" title="enforceLegalChildOutputProperty"></a>enforceLegalChildOutputProperty</h3><p>获得 ChildernGroup 信息后，就通过 ChildOutputPropertyGuarantor 来校验属性是否符合要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in EnforceAndCostTask.execute</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (curChildIndex == groupExpression.getInputs().size()) &#123;</span><br><span class="line">    <span class="comment">// before we compute the property, here need to make sure that the plan is legal</span></span><br><span class="line">    <span class="type">ChildOutputPropertyGuarantor</span> <span class="variable">childOutputPropertyGuarantor</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ChildOutputPropertyGuarantor</span>(</span><br><span class="line">            context,</span><br><span class="line">            groupExpression,</span><br><span class="line">            context.getRequiredProperty(),</span><br><span class="line">            childrenBestExprList,</span><br><span class="line">            childrenRequiredProperties,</span><br><span class="line">            childrenOutputProperties,</span><br><span class="line">            curTotalCost);</span><br><span class="line">    curTotalCost = </span><br><span class="line">        childOutputPropertyGuarantor.enforceLegalChildOutputProperty();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">enforceLegalChildOutputProperty</span><span class="params">()</span> &#123;</span><br><span class="line">    groupExpression.getOp().accept(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">ExpressionContext</span>(groupExpression));</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.curTotalCost;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="visitPhysicalJoin"><a href="#visitPhysicalJoin" class="headerlink" title="visitPhysicalJoin"></a>visitPhysicalJoin</h3><p><a href="https://github.com/StarRocks/starrocks/blob/669d53928ab88a946263fe7eaafdc9447ddd7903/fe/fe-core/src/main/java/com/starrocks/sql/optimizer/ChildOutputPropertyGuarantor.java#L300">visitPhysicalJoin</a> 函数完整的代码很长不全贴了，分段进行讲解。</p><h4 id="BRANCH-0-BroadcastJoin"><a href="#BRANCH-0-BroadcastJoin" class="headerlink" title="BRANCH-0: BroadcastJoin"></a>BRANCH-0: BroadcastJoin</h4><p>如果在 checkBroadcastRowCountLimit 函数中，BroadcastJoin 没有被裁剪，那么也会生成一个 BroadcastJoin PropertySet，至于最终是否被选择，就得看 BroadcastJoin 和 ShuffleJOIN 的 cost 谁更低。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visitPhysicalJoin</span><span class="params">(PhysicalJoinOperator node, ExpressionContext context)</span> &#123;</span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">leftChild</span> <span class="operator">=</span> childrenBestExprList.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">rightChild</span> <span class="operator">=</span> childrenBestExprList.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">leftChildOutputProperty</span> <span class="operator">=</span> childrenOutputProperties.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">rightChildOutputProperty</span> <span class="operator">=</span> childrenOutputProperties.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Distribution is broadcast</span></span><br><span class="line">    <span class="type">DistributionProperty</span> <span class="variable">rightDistribute</span> <span class="operator">=</span> rightChildOutputProperty.getDistributionProperty();</span><br><span class="line">    <span class="keyword">if</span> (rightDistribute.isBroadcast() || rightDistribute.isGather()) &#123;</span><br><span class="line">        <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>ShuffleJoin</strong><br>此时，左右两个子节点的 <strong>输出分布属性</strong> 都需要是 <strong>DistributionType.SHUFFLE</strong>，如果不是则报错。</p><p>确定了输出分布属性之后，再根据子节点的 DistributionType.SourceType 来优化分布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Void <span class="title function_">visitPhysicalJoin</span><span class="params">(PhysicalJoinOperator node, ExpressionContext context)</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 2. Distribution is shuffle</span></span><br><span class="line">    <span class="type">JoinHelper</span> <span class="variable">joinHelper</span> <span class="operator">=</span> JoinHelper.of(</span><br><span class="line">        node, context.getChildOutputColumns(<span class="number">0</span>), context.getChildOutputColumns(<span class="number">1</span>));</span><br><span class="line">    List&lt;Integer&gt; leftOnPredicateColumns = joinHelper.getLeftOnColumns();</span><br><span class="line">    List&lt;Integer&gt; rightOnPredicateColumns = joinHelper.getRightOnColumns();</span><br><span class="line">    <span class="comment">// Get required properties for children.</span></span><br><span class="line">    List&lt;PhysicalPropertySet&gt; requiredProperties =</span><br><span class="line">        computeShuffleJoinRequiredProperties( </span><br><span class="line">            requirements, leftOnPredicateColumns, rightOnPredicateColumns);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; leftShuffleColumns =</span><br><span class="line">        ((HashDistributionSpec) requiredProperties.get(<span class="number">0</span>)</span><br><span class="line">        .getDistributionProperty().getSpec()).getShuffleColumns();</span><br><span class="line">    List&lt;Integer&gt; rightShuffleColumns = </span><br><span class="line">        ((HashDistributionSpec) requiredProperties.get(<span class="number">1</span>)</span><br><span class="line">        .getDistributionProperty().getSpec()).getShuffleColumns();</span><br><span class="line"></span><br><span class="line">    <span class="type">DistributionProperty</span> <span class="variable">leftChildDistributionProperty</span> <span class="operator">=</span> </span><br><span class="line">            leftChildOutputProperty.getDistributionProperty();</span><br><span class="line">    <span class="type">DistributionProperty</span> <span class="variable">rightChildDistributionProperty</span> <span class="operator">=</span> </span><br><span class="line">            rightChildOutputProperty.getDistributionProperty();</span><br><span class="line">    <span class="comment">// CHECK: 只有 broadcast 不需要 shuffle</span></span><br><span class="line">    <span class="keyword">if</span> (!leftChildDistributionProperty.isShuffle() </span><br><span class="line">        || !rightChildDistributionProperty.isShuffle()) &#123;</span><br><span class="line">        Preconditions.checkState(</span><br><span class="line">            <span class="literal">false</span>, <span class="string">&quot;Children output property distribution error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BRANCH-1-ColocateJoin"><a href="#BRANCH-1-ColocateJoin" class="headerlink" title="BRANCH-1: ColocateJoin"></a>BRANCH-1: ColocateJoin</h4><p>如果 JOIN 的左右子节点都是来自于 OlapScan，会再检测 ColocateJoin 函数来检测是否真的能通过 ColocateJoin 来完成。不能则通过 transToBucketShuffleJoin 函数转为 BucketShuffleJoin。</p><p>要转换为 BucketShuffleJoin 一般是 join-key 包含了 value-column。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftDistributionDesc.isLocal() &amp;&amp; rightDistributionDesc.isLocal()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (JoinOperator.HINT_BUCKET.equals(hint) || </span><br><span class="line">        !canColocateJoin(</span><br><span class="line">            leftDistributionSpec, rightDistributionSpec,</span><br><span class="line">            leftShuffleColumns, rightShuffleColumns)) &#123;</span><br><span class="line">        transToBucketShuffleJoin(</span><br><span class="line">            leftDistributionSpec, leftShuffleColumns, rightShuffleColumns);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BRANCH-2-BucketShuffleJoin"><a href="#BRANCH-2-BucketShuffleJoin" class="headerlink" title="BRANCH-2: BucketShuffleJoin"></a>BRANCH-2: BucketShuffleJoin</h4><p>一般是左表（大表）的 bucket-key 命中了 join-key</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftDistributionDesc.isLocal() &amp;&amp; rightDistributionDesc.isShuffle()) &#123;</span><br><span class="line">    <span class="comment">// bucket join</span></span><br><span class="line">    transToBucketShuffleJoin(leftDistributionSpec, leftShuffleColumns, rightShuffleColumns);</span><br><span class="line">    <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="transToBucketShuffleJoin"><a href="#transToBucketShuffleJoin" class="headerlink" title="transToBucketShuffleJoin"></a>transToBucketShuffleJoin</h5><p>和 enforceChildSatisfyShuffleJoin 逻辑类似</p><h4 id="BRANCH-3-ShuffleJoin"><a href="#BRANCH-3-ShuffleJoin" class="headerlink" title="BRANCH-3: ShuffleJoin"></a>BRANCH-3: ShuffleJoin</h4><p>如果左侧是 Shuffle，而右侧是 Local，需要调整为 {Shuffle, Shuffle_Enforcer}，如果左右两侧都是 Shuffle，则需要检测是否满足 shffleJoin</p><p>如果左表的 join-key 不是 bucket-key，一般都是 shuffle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftDistributionDesc.isShuffle() &amp;&amp; rightDistributionDesc.isLocal()) &#123;</span><br><span class="line">    <span class="comment">// coordinator can not bucket shuffle data from left to right, so we need to adjust to shuffle join</span></span><br><span class="line">    enforceChildSatisfyShuffleJoin(leftDistributionSpec, leftShuffleColumns, rightShuffleColumns,</span><br><span class="line">            rightChild, rightChildOutputProperty);</span><br><span class="line">    <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (leftDistributionDesc.isShuffle() &amp;&amp; rightDistributionDesc.isShuffle()) &#123;</span><br><span class="line">    <span class="comment">// 如果不满足 shuffle join</span></span><br><span class="line">    <span class="keyword">if</span> (!checkChildDistributionSatisfyShuffle(leftDistributionSpec, rightDistributionSpec,</span><br><span class="line">            leftShuffleColumns,</span><br><span class="line">            rightShuffleColumns)) &#123;</span><br><span class="line">        enforceChildSatisfyShuffleJoin(leftDistributionSpec, leftShuffleColumns, rightShuffleColumns,</span><br><span class="line">                rightChild, rightChildOutputProperty);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> visitOperator(node, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enforceChildSatisfyShuffleJoin"><a href="#enforceChildSatisfyShuffleJoin" class="headerlink" title="enforceChildSatisfyShuffleJoin"></a>enforceChildSatisfyShuffleJoin</h4><p>transToBucketShuffleJoin 和 enforceChildSatisfyShuffleJoin 核心逻辑都一样，都是先需要生产 shuffle columns，再重新分布。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">enforceChildSatisfyShuffleJoin</span><span class="params">(HashDistributionSpec leftDistributionSpec,</span></span><br><span class="line"><span class="params">                                            List&lt;Integer&gt; leftShuffleColumns,</span></span><br><span class="line"><span class="params">                                            List&lt;Integer&gt; rightShuffleColumns,</span></span><br><span class="line"><span class="params">                                            GroupExpression child,</span></span><br><span class="line"><span class="params">                                            PhysicalPropertySet childOutputProperty)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; newRightShuffleColumns = Lists.newArrayList();</span><br><span class="line">    <span class="type">HashDistributionDesc</span> <span class="variable">leftDistributionDesc</span> <span class="operator">=</span> leftDistributionSpec.getHashDistributionDesc();</span><br><span class="line">    DistributionSpec.<span class="type">PropertyInfo</span> <span class="variable">leftDistributionPropertyInfo</span> <span class="operator">=</span> leftDistributionSpec.getPropertyInfo();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cid : leftDistributionDesc.getColumns()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftShuffleColumns.contains(cid)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> leftShuffleColumns.indexOf(cid);</span><br><span class="line">            newRightShuffleColumns.add(rightShuffleColumns.get(index));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// find equivalent columns for the hash distribution columns</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">equivalentColumn</span> <span class="operator">=</span></span><br><span class="line">                    Arrays.stream(leftDistributionPropertyInfo.getEquivalentColumns(cid).getColumnIds()).</span><br><span class="line">                            filter(leftShuffleColumns::contains).findAny().orElse(cid);</span><br><span class="line">            Preconditions.checkState(leftShuffleColumns.contains(equivalentColumn));</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> leftShuffleColumns.indexOf(equivalentColumn);</span><br><span class="line">            newRightShuffleColumns.add(rightShuffleColumns.get(index));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 都是更改啊右子节点的分布属性</span></span><br><span class="line">    enforceChildShuffleDistribution(newRightShuffleColumns, child, childOutputProperty, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enforceChildShuffleDistribution"><a href="#enforceChildShuffleDistribution" class="headerlink" title="enforceChildShuffleDistribution"></a>enforceChildShuffleDistribution</h4><p>构造 HashDistributionSpec 对象主要是需要构造 HashDistributionDesc.columns，上层函数传递 HashDistributionDesc.columns 后就可以得到所需的分布 enforceDistributionSpec。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> GroupExpression <span class="title function_">enforceChildShuffleDistribution</span><span class="params">(List&lt;Integer&gt; shuffleColumns, GroupExpression child,</span></span><br><span class="line"><span class="params">                                                        PhysicalPropertySet childOutputProperty,</span></span><br><span class="line"><span class="params">                                                        <span class="type">int</span> childIndex)</span> &#123;</span><br><span class="line">    <span class="type">DistributionSpec</span> <span class="variable">enforceDistributionSpec</span> <span class="operator">=</span></span><br><span class="line">            DistributionSpec.createHashDistributionSpec(<span class="keyword">new</span> <span class="title class_">HashDistributionDesc</span>(shuffleColumns,</span><br><span class="line">                    HashDistributionDesc.SourceType.SHUFFLE_ENFORCE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 enforceDistributionSpec 和 child 连接起来，</span></span><br><span class="line">    <span class="comment">// 并更新 cost 信息</span></span><br><span class="line">    Pair&lt;GroupExpression, PhysicalPropertySet&gt; pair =</span><br><span class="line">            enforceChildDistribution(enforceDistributionSpec, child, childOutputProperty);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">newChildInputProperty</span> <span class="operator">=</span> pair.second;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新结果</span></span><br><span class="line">    requiredChildrenProperties.set(childIndex, newChildInputProperty);</span><br><span class="line">    childrenOutputProperties.set(childIndex, newChildInputProperty);</span><br><span class="line">    <span class="keyword">return</span> pair.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enforceChildDistribution"><a href="#enforceChildDistribution" class="headerlink" title="enforceChildDistribution"></a>enforceChildDistribution</h4><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/DistributionSpec-2.svg?raw=true" alt="DistributionSpec-2"></p><p>enforceChildDistribution 函数也比较重要，是为了让子节点 child 的输出分布属性中满足父节点要求的 <em>distributionSpec</em> 的要求，。因此需要在输入和输出之间再增加个 enforcer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Pair&lt;GroupExpression, PhysicalPropertySet&gt; <span class="title function_">enforceChildDistribution</span><span class="params">(DistributionSpec distributionSpec,</span></span><br><span class="line"><span class="params">                                                                            GroupExpression child,</span></span><br><span class="line"><span class="params">                                                                            PhysicalPropertySet childOutputProperty)</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">childCosts</span> <span class="operator">=</span> child.getCost(childOutputProperty);</span><br><span class="line">    <span class="type">Group</span> <span class="variable">childGroup</span> <span class="operator">=</span> child.getGroup();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 基于新的分布要求，生成新的分布属性</span></span><br><span class="line">    <span class="type">DistributionProperty</span> <span class="variable">newDistributionProperty</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DistributionProperty</span>(distributionSpec);</span><br><span class="line">    <span class="comment">// 2. 基于旧的输出属性集，复制构造一个新的 PhysicalPropertySet 对象</span></span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">newOutputProperty</span> <span class="operator">=</span> childOutputProperty.copy();</span><br><span class="line">    <span class="comment">// 3. 仅更改分布属性</span></span><br><span class="line">    newOutputProperty.setDistributionProperty(newDistributionProperty);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 如果子节点对应 Operator 是 PhysicalDistributionOperator</span></span><br><span class="line">    <span class="keyword">if</span> (child.getOp() <span class="keyword">instanceof</span> PhysicalDistributionOperator) &#123;</span><br><span class="line">        <span class="type">GroupExpression</span> <span class="variable">enforcer</span> <span class="operator">=</span> newDistributionProperty.appendEnforcers(childGroup);</span><br><span class="line">        <span class="comment">// 记录映射关系</span></span><br><span class="line">        enforcer.setOutputPropertySatisfyRequiredProperty(newOutputProperty, newOutputProperty);</span><br><span class="line">        <span class="comment">// 设置 enforcer 所属的 Group</span></span><br><span class="line">        context.getMemo().insertEnforceExpression(enforcer, childGroup);</span><br><span class="line">        <span class="comment">// 记录本节点的输出属性 与 输入分布属性之间的映射</span></span><br><span class="line">        enforcer.updatePropertyWithCost(newOutputProperty,</span><br><span class="line">                child.getInputProperties(childOutputProperty),</span><br><span class="line">                childCosts);</span><br><span class="line">        <span class="comment">// 更新最佳路径</span></span><br><span class="line">        childGroup.setBestExpression(enforcer, childCosts, newOutputProperty);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(enforcer, newOutputProperty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5.1 如果不是 PhysicalDistributionOperator </span></span><br><span class="line">    <span class="type">GroupExpression</span> <span class="variable">enforcer</span> <span class="operator">=</span> newDistributionProperty.appendEnforcers(childGroup);</span><br><span class="line">    enforcer.setOutputPropertySatisfyRequiredProperty(</span><br><span class="line">        newOutputProperty, newOutputProperty);</span><br><span class="line">    updateChildCostWithEnforcer(</span><br><span class="line">        enforcer, childOutputProperty, newOutputProperty, childCosts, childGroup);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Pair</span>&lt;&gt;(enforcer, newOutputProperty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="updateChildCostWithEnforcer"><a href="#updateChildCostWithEnforcer" class="headerlink" title="updateChildCostWithEnforcer"></a>updateChildCostWithEnforcer</h4><p>当 child.getOp() 不是 PhysicalDistributionOperator 对象时，则进入 updateChildCostWithEnforcer 函数中，区别就是此函数会计算新增的 enforcer 的cost。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">updateChildCostWithEnforcer</span><span class="params">(GroupExpression enforcer,</span></span><br><span class="line"><span class="params">                                         PhysicalPropertySet oldOutputProperty,</span></span><br><span class="line"><span class="params">                                         PhysicalPropertySet newOutputProperty,</span></span><br><span class="line"><span class="params">                                         <span class="type">double</span> childCost, </span></span><br><span class="line"><span class="params">                                         Group childGroup)</span> &#123;</span><br><span class="line">    context.getMemo().insertEnforceExpression(enforcer, childGroup);</span><br><span class="line">    <span class="comment">// update current total cost</span></span><br><span class="line">    curTotalCost -= childCost;</span><br><span class="line">    <span class="comment">// add enforcer cost</span></span><br><span class="line">    childCost += CostModel.calculateCost(enforcer);</span><br><span class="line">    curTotalCost += childCost;</span><br><span class="line"></span><br><span class="line">    enforcer.updatePropertyWithCost(</span><br><span class="line">        newOutputProperty, </span><br><span class="line">        Lists.newArrayList(oldOutputProperty),</span><br><span class="line">        childCost);</span><br><span class="line">    childGroup.setBestExpression(enforcer, childCost, newOutputProperty);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OutputPropertyDeriver-visitPhysicalJoin"><a href="#OutputPropertyDeriver-visitPhysicalJoin" class="headerlink" title="OutputPropertyDeriver.visitPhysicalJoin"></a><a href="https://github.com/StarRocks/starrocks/blob/4a2c85a904ea7e32707e926f96b4fa9b45b59d00/fe/fe-core/src/main/java/com/starrocks/sql/optimizer/OutputPropertyDeriver.java#L212">OutputPropertyDeriver.visitPhysicalJoin</a></h2><p>在前文 ChildOutputPropertyGuarantor.visitPhysicalJoin 中已经设置好右子节的输出属性，在 OutputPropertyDeriver.visitPhysicalJoin 中则根据左右子节点的输出属性，生成 PhysicalJoinOperator 自己的输出属性。</p><h3 id="computeHashJoinDistributionPropertyInfo"><a href="#computeHashJoinDistributionPropertyInfo" class="headerlink" title="computeHashJoinDistributionPropertyInfo"></a><a href="https://github.com/StarRocks/starrocks/blob/4a2c85a904ea7e32707e926f96b4fa9b45b59d00/fe/fe-core/src/main/java/com/starrocks/sql/optimizer/OutputPropertyDeriver.java#L165">computeHashJoinDistributionPropertyInfo</a></h3><p>此函数设置 physicalPropertySet 的 DistributionSpec.PropertyInfo，再返回 physicalPropertySet。因此 Join 输出的属性即传入的 physicalPropertySet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PhysicalPropertySet <span class="title function_">computeHashJoinDistributionPropertyInfo</span><span class="params">(PhysicalJoinOperator node,</span></span><br><span class="line"><span class="params">                                                                    PhysicalPropertySet physicalPropertySet,</span></span><br><span class="line"><span class="params">                                                                    List&lt;Integer&gt; leftOnPredicateColumns,</span></span><br><span class="line"><span class="params">                                                                    List&lt;Integer&gt; rightOnPredicateColumns,</span></span><br><span class="line"><span class="params">                                                                    ExpressionContext context)</span> &#123;</span><br><span class="line">    DistributionSpec.<span class="type">PropertyInfo</span> <span class="variable">propertyInfo</span> <span class="operator">=</span></span><br><span class="line">            physicalPropertySet.getDistributionProperty().getSpec().getPropertyInfo();</span><br><span class="line"></span><br><span class="line">    <span class="type">ColumnRefSet</span> <span class="variable">leftChildColumns</span> <span class="operator">=</span> context.getChildOutputColumns(<span class="number">0</span>);</span><br><span class="line">    <span class="type">ColumnRefSet</span> <span class="variable">rightChildColumns</span> <span class="operator">=</span> context.getChildOutputColumns(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (node.getJoinType().isLeftOuterJoin()) &#123;</span><br><span class="line">        propertyInfo.nullableColumns.union(rightChildColumns);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getJoinType().isRightOuterJoin()) &#123;</span><br><span class="line">        propertyInfo.nullableColumns.union(leftChildColumns);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getJoinType().isFullOuterJoin()) &#123;</span><br><span class="line">        propertyInfo.nullableColumns.union(leftChildColumns);</span><br><span class="line">        propertyInfo.nullableColumns.union(rightChildColumns);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.getJoinType().isInnerJoin()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; leftOnPredicateColumns.size(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftColumn</span> <span class="operator">=</span> leftOnPredicateColumns.get(i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightColumn</span> <span class="operator">=</span> rightOnPredicateColumns.get(i);</span><br><span class="line">            propertyInfo.addJoinEquivalentPair(leftColumn, rightColumn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> physicalPropertySet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BRANCH-0-BROADCAST"><a href="#BRANCH-0-BROADCAST" class="headerlink" title="BRANCH-0: BROADCAST"></a>BRANCH-0: BROADCAST</h3><p>TODO: computeHashJoinDistributionPropertyInfo 函数左右传入的都是空集？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PhysicalPropertySet <span class="title function_">visitPhysicalJoin</span><span class="params">(PhysicalJoinOperator node, ExpressionContext context)</span> &#123;</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">leftChildOutputProperty</span> <span class="operator">=</span> childrenOutputProperties.get(<span class="number">0</span>);</span><br><span class="line">    <span class="type">PhysicalPropertySet</span> <span class="variable">rightChildOutputProperty</span> <span class="operator">=</span> childrenOutputProperties.get(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. Distribution is broadcast</span></span><br><span class="line">    <span class="keyword">if</span> (rightChildOutputProperty.getDistributionProperty().isBroadcast()) &#123;</span><br><span class="line">        <span class="keyword">return</span> computeHashJoinDistributionPropertyInfo(</span><br><span class="line">            node,</span><br><span class="line">            leftChildOutputProperty,</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            Collections.emptyList(),</span><br><span class="line">            context);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BRANCH-1-ColocateJoin-1"><a href="#BRANCH-1-ColocateJoin-1" class="headerlink" title="BRANCH-1:ColocateJoin"></a>BRANCH-1:ColocateJoin</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftDistributionDesc.isLocal() &amp;&amp; rightDistributionDesc.isLocal()) &#123;</span><br><span class="line">    <span class="comment">// colocate join</span></span><br><span class="line">    <span class="keyword">return</span> computeHashJoinDistributionPropertyInfo(node,</span><br><span class="line">            computeColocateJoinOutputProperty(leftDistributionSpec, rightDistributionSpec),</span><br><span class="line">            leftOnPredicateColumns,</span><br><span class="line">            rightOnPredicateColumns, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BRNACH-2-BucketShuffleJoin"><a href="#BRNACH-2-BucketShuffleJoin" class="headerlink" title="BRNACH-2: BucketShuffleJoin"></a>BRNACH-2: BucketShuffleJoin</h3><p>leftChildOutputProperty 直接设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftDistributionDesc.isLocal() &amp;&amp; rightDistributionDesc.isBucketJoin()) &#123;</span><br><span class="line">    <span class="comment">// bucket join</span></span><br><span class="line">    <span class="keyword">return</span> computeHashJoinDistributionPropertyInfo(node,</span><br><span class="line">            leftChildOutputProperty,</span><br><span class="line">            leftOnPredicateColumns,</span><br><span class="line">            rightOnPredicateColumns,</span><br><span class="line">            context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BRNACH-3-Shufflejoin"><a href="#BRNACH-3-Shufflejoin" class="headerlink" title="BRNACH-3: Shufflejoin"></a>BRNACH-3: Shufflejoin</h3><p>左右输入数据源都是 Shuffle（SourceType.SHUFFLE_AGG、SourceType.SHUFFLE_JOIN）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((leftDistributionDesc.isShuffle() || leftDistributionDesc.isShuffleEnforce()) &amp;&amp;</span><br><span class="line">    (rightDistributionDesc.isShuffle()) || rightDistributionDesc.isShuffleEnforce()) &#123;</span><br><span class="line">    <span class="comment">// shuffle join</span></span><br><span class="line">    <span class="keyword">return</span> computeHashJoinDistributionPropertyInfo(node,</span><br><span class="line">            computeShuffleJoinOutputProperty(leftDistributionDesc.getColumns()),</span><br><span class="line">            leftOnPredicateColumns,</span><br><span class="line">            rightOnPredicateColumns, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="computeShuffleJoinOutputProperty"><a href="#computeShuffleJoinOutputProperty" class="headerlink" title="computeShuffleJoinOutputProperty"></a>computeShuffleJoinOutputProperty</h4><p>基于左侧的 shuffle 列创建输出属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PhysicalPropertySet <span class="title function_">computeShuffleJoinOutputProperty</span><span class="params">(List&lt;Integer&gt; leftShuffleColumns)</span> &#123;</span><br><span class="line">    Optional&lt;HashDistributionDesc&gt; requiredShuffleDesc = getRequiredShuffleDesc();</span><br><span class="line">    <span class="keyword">if</span> (!requiredShuffleDesc.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> PhysicalPropertySet.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">HashDistributionSpec</span> <span class="variable">leftShuffleDistribution</span> <span class="operator">=</span> DistributionSpec.createHashDistributionSpec(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">HashDistributionDesc</span>(leftShuffleColumns, HashDistributionDesc.SourceType.SHUFFLE_JOIN));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> createPropertySetByDistribution(leftShuffleDistribution);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="getRequiredShuffleDesc"><a href="#getRequiredShuffleDesc" class="headerlink" title="getRequiredShuffleDesc"></a>getRequiredShuffleDesc</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Optional&lt;HashDistributionDesc&gt; <span class="title function_">getRequiredShuffleDesc</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!requirements.getDistributionProperty().isShuffle()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">HashDistributionDesc</span> <span class="variable">requireDistributionDesc</span> <span class="operator">=</span> ((HashDistributionSpec)</span><br><span class="line">         requirements.getDistributionProperty().getSpec()).getHashDistributionDesc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (HashDistributionDesc.SourceType.SHUFFLE_JOIN.equals(requireDistributionDesc.getSourceType()) ||</span><br><span class="line">        HashDistributionDesc.SourceType.SHUFFLE_AGG.equals(requireDistributionDesc.getSourceType())) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.of(requireDistributionDesc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;PhysicalProperty&quot;&gt;&lt;a href=&quot;#PhysicalProperty&quot; class=&quot;headerlink&quot; title=&quot;PhysicalProperty&quot;&gt;&lt;/a&gt;PhysicalProperty&lt;/h2&gt;&lt;p&gt;PhysicalProper</summary>
      
    
    
    
    <category term="CBO" scheme="https://szza.github.io/categories/CBO/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>PlanFragmentBuilder: 从 PhysicalPlan 到 ExecPlan</title>
    <link href="https://szza.github.io/2023/10/03/StarRocks/CBO/PlanFragment/"/>
    <id>https://szza.github.io/2023/10/03/StarRocks/CBO/PlanFragment/</id>
    <published>2023-10-03T02:00:01.000Z</published>
    <updated>2023-10-29T02:12:10.000Z</updated>
    
    <content type="html"><![CDATA[<p>输入的 SQL 经过 Parser 后生成 AST 并最终转化为 Relation Tree， 基于 Relation 生成逻辑计划 logicalPlan，逻辑计划再经过优化器生成物理计划 PhysicalPlan，最终生成执行计划 ExecPlan。从 LogicalPlan 到 ExecPlan 的三个步骤如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecPlan <span class="title function_">createQueryPlan</span><span class="params">(Relation relation, ConnectContext session,</span></span><br><span class="line"><span class="params">                                       TResultSinkType resultSinkType)</span> &#123;</span><br><span class="line">    <span class="type">QueryRelation</span> <span class="variable">query</span> <span class="operator">=</span> (QueryRelation) relation;</span><br><span class="line">    List&lt;String&gt; colNames = query.getColumnOutputNames();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. Build Logical plan</span></span><br><span class="line">    <span class="type">ColumnRefFactory</span> <span class="variable">columnRefFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ColumnRefFactory</span>();</span><br><span class="line">    <span class="type">LogicalPlan</span> <span class="variable">logicalPlan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RelationTransformer</span>(</span><br><span class="line">            columnRefFactory, session).transformWithSelectLimit(query);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. Optimize logical plan and build physical plan</span></span><br><span class="line">    <span class="type">OptExpression</span> <span class="variable">optimizedPlan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Optimizer</span>().optimize(</span><br><span class="line">            session,</span><br><span class="line">            logicalPlan.getRoot(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">PhysicalPropertySet</span>(),</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ColumnRefSet</span>(logicalPlan.getOutputColumn()),</span><br><span class="line">            columnRefFactory);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. Build fragment exec plan</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">PlanFragmentBuilder</span>().createPhysicalPlan(</span><br><span class="line">            optimizedPlan, session, </span><br><span class="line">            logicalPlan.getOutputColumn(), </span><br><span class="line">            columnRefFactory, colNames,</span><br><span class="line">            resultSinkType,</span><br><span class="line">            !session.getSessionVariable().isSingleNodeExecPlan());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本节主要讲解 PlanFragmentBuilder 是何将物理计划 optimizedPlan 转化成执行计划 ExecPlan。</p><h2 id="createPhysicalPlan"><a href="#createPhysicalPlan" class="headerlink" title="createPhysicalPlan"></a>createPhysicalPlan</h2><p>经过优化器后生成的物理计划 optimizedPlan 是由 OptExpression 构成的树。createPhysicalPlan 函数主要有两步：</p><ol><li><p>createOutputFragment 函数将 OptExpression 转化为 PlanNode</p><p>一个 Fragment 包含由 PlanNode 组成的子树，每个 Fragment.PlanNode Tree 的叶结点是 ScanNode 或者 ExchangeNode：ScanNode 用于从 BE 节点存储层读取数据，ExchangeNode 用于接受其他的 Fragments 的输出。 生成的 Fragments 保存在 ExecPlan.fragments 中</p></li><li><p>finalizeFragments 函数为生成的 ExecPlan.fragments 中的每个 Fragment 都分配一个 DataSink，</p><p>DataSink 和 ExchangeNode 配对，即 DataSink 是数据发送端，ExchangeNode 是数据接收端，这样 Fragments 才串成完整的 tree，形成 MPP 架构。</p></li></ol><p>createPhysicalPlan 函数逻辑如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecPlan <span class="title function_">createPhysicalPlan</span><span class="params">(OptExpression plan, </span></span><br><span class="line"><span class="params">                                          ConnectContext connectContext,</span></span><br><span class="line"><span class="params">                                          List&lt;ColumnRefOperator&gt; outputColumns,</span></span><br><span class="line"><span class="params">                                          ColumnRefFactory columnRefFactory,</span></span><br><span class="line"><span class="params">                                          List&lt;String&gt; colNames,</span></span><br><span class="line"><span class="params">                                          TResultSinkType resultSinkType,</span></span><br><span class="line"><span class="params">                                          <span class="type">boolean</span> hasOutputFragment)</span> &#123;</span><br><span class="line">    <span class="type">ExecPlan</span> <span class="variable">execPlan</span> <span class="operator">=</span> </span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ExecPlan</span>(connectContext, colNames, plan, outputColumns);</span><br><span class="line">    createOutputFragment(</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">PhysicalPlanTranslator</span>(columnRefFactory).visit(plan, execPlan),</span><br><span class="line">        execPlan, outputColumns, hasOutputFragment);</span><br><span class="line">    execPlan.setPlanCount(plan.getPlanCount());</span><br><span class="line">    <span class="keyword">return</span> finalizeFragments(execPlan, resultSinkType);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面以 OlapScanNode、JoinNode 为例进行说明如何生成 Fragments。</p><h2 id="visitPhysicalOlapScan"><a href="#visitPhysicalOlapScan" class="headerlink" title="visitPhysicalOlapScan"></a>visitPhysicalOlapScan</h2><p>OptExpression Tree 采用的是后序递归遍历，因为会先遍历到叶节点，比如 OlapScanNode。</p><p>下面就需要根据 PhysicalOlapScanOperator 中的信息生成 OlapScanNode，并生成 ExecPlan.fragments 中的第一个 Fragment, 而 OlapScanNode 即该 Fragment 的 root node。</p><p>因为 OlapScanNode 最终是要在BE上执行的，因此要包含具体的存储信息的，比如要访问的列（tupleDescriptor）、要访问的 Tablets 位于哪些BE节点上，以及一些能下推到存储层的谓词等。</p><p>下面代码重点关注设置 tablet 信息部分，其余部分略去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PlanFragment <span class="title function_">visitPhysicalOlapScan</span><span class="params">(OptExpression optExpr, ExecPlan context)</span> &#123;</span><br><span class="line">    <span class="type">PhysicalOlapScanOperator</span> <span class="variable">node</span> <span class="operator">=</span> (PhysicalOlapScanOperator) optExpr.getOp();</span><br><span class="line"></span><br><span class="line">   <span class="type">OlapTable</span> <span class="variable">referenceTable</span> <span class="operator">=</span> (OlapTable) node.getTable();</span><br><span class="line">   context.getDescTbl().addReferencedTable(referenceTable);</span><br><span class="line">   <span class="comment">// 构造 tupleDescriptor，后面填充要访问的列信息</span></span><br><span class="line">   <span class="type">TupleDescriptor</span> <span class="variable">tupleDescriptor</span> <span class="operator">=</span> context.getDescTbl().createTupleDescriptor();</span><br><span class="line">   tupleDescriptor.setTable(referenceTable);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造 ScanNode 对象</span></span><br><span class="line">   <span class="type">OlapScanNode</span> <span class="variable">scanNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OlapScanNode</span>(context.getNextNodeId(),</span><br><span class="line">                                            tupleDescriptor,</span><br><span class="line">                                             <span class="string">&quot;OlapScanNode&quot;</span>);</span><br><span class="line">   scanNode.setLimit(node.getLimit());</span><br><span class="line">   scanNode.computeStatistics(optExpr.getStatistics());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 1. set tablet</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// &#123;index_id, partition_ids, tablet_ids&#125;</span></span><br><span class="line">       scanNode.updateScanInfo(node.getSelectedPartitionId(),</span><br><span class="line">               node.getSelectedTabletId(),</span><br><span class="line">               node.getSelectedIndexId());</span><br><span class="line">       <span class="type">long</span> <span class="variable">selectedIndexId</span> <span class="operator">=</span> node.getSelectedIndexId();</span><br><span class="line">       <span class="type">long</span> <span class="variable">totalTabletsNum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="type">long</span> <span class="variable">localBeId</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">       <span class="comment">// 1.1. 筛选出非空分区</span></span><br><span class="line">       List&lt;Long&gt; selectedNonEmptyPartitionIds = </span><br><span class="line">            node.getSelectedPartitionId().stream().filter(p -&gt; &#123;</span><br><span class="line">                List&lt;Long&gt; selectTabletIds = scanNode.getPartitionToScanTabletMap().get(p);</span><br><span class="line">                <span class="keyword">return</span> selectTabletIds != <span class="literal">null</span> &amp;&amp; !selectTabletIds.isEmpty();</span><br><span class="line">            &#125;).collect(Collectors.toList());</span><br><span class="line">       scanNode.setSelectedPartitionIds(selectedNonEmptyPartitionIds);</span><br><span class="line">       <span class="comment">// 1.2 设置要访问的 tablet</span></span><br><span class="line">       <span class="keyword">for</span> (Long partitionId : selectedNonEmptyPartitionIds) &#123;</span><br><span class="line">           List&lt;Long&gt; selectTabletIds = scanNode.getPartitionToScanTabletMap().get(partitionId);</span><br><span class="line">           <span class="keyword">final</span> <span class="type">Partition</span> <span class="variable">partition</span> <span class="operator">=</span> referenceTable.getPartition(partitionId);</span><br><span class="line">           <span class="keyword">final</span> <span class="type">MaterializedIndex</span> <span class="variable">selectedTable</span> <span class="operator">=</span> partition.getIndex(selectedIndexId);</span><br><span class="line">           Map&lt;Long, Integer&gt; tabletId2BucketSeq = Maps.newHashMap();</span><br><span class="line">           List&lt;Long&gt; allTabletIds = selectedTable.getTabletIdsInOrder();</span><br><span class="line">           <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; allTabletIds.size(); i++) &#123;</span><br><span class="line">               tabletId2BucketSeq.put(allTabletIds.get(i), i);</span><br><span class="line">           &#125;</span><br><span class="line">           scanNode.setTabletId2BucketSeq(tabletId2BucketSeq);</span><br><span class="line">           <span class="comment">// ScanNode 本次要访问的所有 tablets</span></span><br><span class="line">           List&lt;Tablet&gt; tablets = selectTabletIds.stream().map(</span><br><span class="line">                selectedTable::getTablet).collect(Collectors.toList());</span><br><span class="line">           <span class="comment">// &#123;table, partition, tablets&#125; 确定了本次访问的 tablets</span></span><br><span class="line">           scanNode.addScanRangeLocations(partition,</span><br><span class="line">                                          selectedTable, </span><br><span class="line">                                          tablets,</span><br><span class="line">                                          localBeId);</span><br><span class="line">           <span class="comment">// totalTabletsNum 用于 explain 显示</span></span><br><span class="line">           totalTabletsNum += selectedTable.getTablets().size();</span><br><span class="line">       &#125;</span><br><span class="line">       scanNode.setTotalTabletsNum(totalTabletsNum);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (UserException e) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StarRocksPlannerException</span>(</span><br><span class="line">            <span class="string">&quot;Build Exec OlapScanNode fail, scan info is invalid,&quot;</span> + e.getMessage(),</span><br><span class="line">            INTERNAL_ERROR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   context.getScanNodes().add(scanNode);</span><br><span class="line">   <span class="comment">// 5. 生成新的 Fragment</span></span><br><span class="line">   <span class="type">PlanFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlanFragment</span>(</span><br><span class="line">        context.getNextFragmentId(), </span><br><span class="line">        scanNode,  <span class="comment">// 根节点</span></span><br><span class="line">        DataPartition.RANDOM);</span><br><span class="line">   fragment.setQueryGlobalDicts(node.getGlobalDicts());</span><br><span class="line">   context.getFragments().add(fragment);</span><br><span class="line">   <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="addScanRangeLocationsp"><a href="#addScanRangeLocationsp" class="headerlink" title="addScanRangeLocationsp"></a>addScanRangeLocationsp</h3><p>addScanRangeLocationsp 函数是为了记录 tablets 的所有可用副本在 BE 节点上的位置，为后续下发计算任务准备。</p><h4 id="TScanRangeLocations"><a href="#TScanRangeLocations" class="headerlink" title="TScanRangeLocations"></a>TScanRangeLocations</h4><p>这里是用的 thrift protoc 定义的 TScanRangeLocations，</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TScanRangeLocations</span> </span>&#123;</span><br><span class="line">  <span class="number">1</span>: <span class="keyword">required</span> PlanNodes.TScanRange scan_range</span><br><span class="line">  <span class="number">2</span>: <span class="type">list</span>&lt;TScanRangeLocation&gt; locations  <span class="comment">// non-empty list</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TScanRange</span> </span>&#123;</span><br><span class="line">  <span class="number">4</span>: <span class="keyword">optional</span> TInternalScanRange internal_scan_range</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>TScanRangeLocations.scan_range 记录的本次 scan_range 的元信息，在 BE 中会根据这些元信息找到每个 tablet 中要访问的 rowsets。  <figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TInternalScanRange</span> </span>&#123;</span><br><span class="line">  <span class="number">1</span>: <span class="keyword">required</span> <span class="type">list</span>&lt;Types.TNetworkAddress&gt; hosts</span><br><span class="line">  <span class="number">2</span>: <span class="keyword">required</span> <span class="type">string</span> schema_hash</span><br><span class="line">  <span class="number">3</span>: <span class="keyword">required</span> <span class="type">string</span> version</span><br><span class="line">  <span class="number">4</span>: <span class="keyword">required</span> <span class="type">string</span> version_hash <span class="comment">// Deprecated</span></span><br><span class="line">  <span class="number">5</span>: <span class="keyword">required</span> Types.TTabletId tablet_id</span><br><span class="line">  <span class="number">6</span>: <span class="keyword">required</span> <span class="type">string</span> db_name</span><br><span class="line">  <span class="number">7</span>: <span class="keyword">optional</span> <span class="type">list</span>&lt;TKeyRange&gt; partition_column_ranges</span><br><span class="line">  <span class="number">8</span>: <span class="keyword">optional</span> <span class="type">string</span> index_name</span><br><span class="line">  <span class="number">9</span>: <span class="keyword">optional</span> <span class="type">string</span> table_name </span><br><span class="line">  <span class="number">10</span>: <span class="keyword">optional</span> <span class="type">i64</span> partition_id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>TScanRangeLocations.locations 则记录的的是该 tablet 所有副本在BE上的位置  <figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TScanRangeLocation</span> </span>&#123;</span><br><span class="line">  <span class="number">1</span>: <span class="keyword">required</span> Types.TNetworkAddress server</span><br><span class="line">  <span class="number">2</span>: <span class="keyword">optional</span> <span class="type">i32</span> volume_id = -<span class="number">1</span> <span class="comment">// Just used for hdfs</span></span><br><span class="line">  <span class="number">3</span>: <span class="keyword">optional</span> <span class="type">i64</span> backend_id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>addScanRangeLocations 函数就是填充 TScanRangeLocations 对象，然后所有 tablets 的 scanRangeLocations 结构都保存到 result 中。这一步主要是为后面 Coordinator 中调度准备，完整代码详见 <a href="https://github.com/StarRocks/starrocks/blob/a4c842cc3d5b506ae1d9f40f2acac85e5f2e78c3/fe/fe-core/src/main/java/com/starrocks/planner/OlapScanNode.java#L441">addScanRangeLocations</a> 。</p><h2 id="visitPhysicalHashJoin"><a href="#visitPhysicalHashJoin" class="headerlink" title="visitPhysicalHashJoin"></a>visitPhysicalHashJoin</h2><p>HashJoin 先生成左右两个子节点的 Fragment 作为输入，再来生成执行 HashJoin 的 Fragment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PlanFragment <span class="title function_">visitPhysicalHashJoin</span><span class="params">(OptExpression optExpr, ExecPlan context)</span> &#123;</span><br><span class="line">    <span class="type">PlanFragment</span> <span class="variable">leftFragment</span> <span class="operator">=</span> visit(optExpr.inputAt(<span class="number">0</span>), context);</span><br><span class="line">    <span class="type">PlanFragment</span> <span class="variable">rightFragment</span> <span class="operator">=</span> visit(optExpr.inputAt(<span class="number">1</span>), context);</span><br><span class="line">    <span class="keyword">return</span> visitPhysicalJoin(leftFragment, rightFragment, optExpr, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="visitPhysicalJoin"><a href="#visitPhysicalJoin" class="headerlink" title="visitPhysicalJoin"></a>visitPhysicalJoin</h2><p>主要分为一下三个部分</p><h3 id="1-DistributionMode"><a href="#1-DistributionMode" class="headerlink" title="1. DistributionMode"></a>1. DistributionMode</h3><p>获取 PhysicalJoinOperator 中的信息，并传递给 HashJoinNode。 PhysicalJoinOperator 和它的两个子节点可能组合方式如下：<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/PlanFragmentBuilder-2.svg?raw=true" alt="PlanFragmentBuilder-2"><br>出于简洁目的，使用 PhysicalOlapScanOp （OlapScanNode）表征该子节点数据来自于本地，用 PhysicalOlapScanOp（ExchangeNode）表示数据来自于其他Fragment 的输出。</p><ol><li><p>左右子节点都是 ExchangeNode，并且数据分布属性都是 DistributionSpec.DistributionType.SHUFFLE </p></li><li><p>左右子节点都不是 ExchangeNode，则数据可以直接通过 OlapScanNode 从本地获取</p><p> 如果 isColocateJoin 函数为 true，即数据源分布属性是 <strong>HashDistributionDesc.SourceType.LOCAL</strong>，则是不需要 shuffle，因为在 Coordinator 中已经完成了 Shuffle，BE 中计算时能直接在 bucket 层次进行 join。</p><p> 这个场景一般是 join-key 就是 table 的 key-column，这样构建 hashmap 的数据本身就是正交的，无需 shuffle 来达到正交的目标。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isColocateJoin</span><span class="params">(OptExpression optExpression)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> optExpression.getRequiredProperties().stream().allMatch(</span><br><span class="line">   physicalPropertySet -&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span> (!physicalPropertySet.getDistributionProperty().isShuffle()) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       HashDistributionDesc.<span class="type">SourceType</span> <span class="variable">hashSourceType</span> <span class="operator">=</span> ((HashDistributionSpec) </span><br><span class="line">          (physicalPropertySet.getDistributionProperty().getSpec()))</span><br><span class="line">            .getHashDistributionDesc().getSourceType();</span><br><span class="line">       <span class="keyword">return</span> hashSourceType.equals(HashDistributionDesc.SourceType.LOCAL);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 如果 isColocateJoin 函数为 false, 判断 isShuffleJoin 函数是否为 true。判断 PhysicalJoinOperator 的数据源分布是否需要 shuffle。这个场景一般是 join-key 包含了 value-column，需要在 BE 节点上对 value-column 进行 shuffle 得到正交的 join-key 数据。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isShuffleJoin</span><span class="params">(OptExpression optExpression)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> optExpression.getRequiredProperties().stream().allMatch(</span><br><span class="line">      physicalPropertySet -&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span> (!physicalPropertySet.getDistributionProperty().isShuffle()) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       HashDistributionDesc.<span class="type">SourceType</span> <span class="variable">hashSourceType</span> <span class="operator">=</span> ((HashDistributionSpec) </span><br><span class="line">          (physicalPropertySet.getDistributionProperty().getSpec()))</span><br><span class="line">                       .getHashDistributionDesc().getSourceType();</span><br><span class="line">       <span class="keyword">return</span> hashSourceType.equals(HashDistributionDesc.SourceType.SHUFFLE_JOIN) ||</span><br><span class="line">              hashSourceType.equals(HashDistributionDesc.SourceType.SHUFFLE_ENFORCE) ||</span><br><span class="line">              hashSourceType.equals(HashDistributionDesc.SourceType.SHUFFLE_AGG);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>右子节点是 ExchangeNode 且数据源分布是 DistributionSpec.DistributionType.BROADCAST</p><p> 此时不关注左子节点是 OlapScanNode or ExchangeNode 以及是啥数据源分布，因为 BE 在执行时是将右表的数据全部发送到左表。</p></li><li><p>other</p></li></ol><blockquote><p><strong>TODO</strong>: 优化器何时会使得 isShuffleJoin 为 true</p></blockquote><p>这部分代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> PlanFragment <span class="title function_">visitPhysicalJoin</span><span class="params">(PlanFragment leftFragment, </span></span><br><span class="line"><span class="params">                                      PlanFragment rightFragment,</span></span><br><span class="line"><span class="params">                                      OptExpression optExpr,</span></span><br><span class="line"><span class="params">                                      ExecPlan context)</span> &#123;</span><br><span class="line">   <span class="type">PhysicalJoinOperator</span> <span class="variable">node</span> <span class="operator">=</span> (PhysicalJoinOperator) optExpr.getOp();</span><br><span class="line"></span><br><span class="line">   <span class="type">ColumnRefSet</span> <span class="variable">leftChildColumns</span> <span class="operator">=</span></span><br><span class="line">       optExpr.inputAt(<span class="number">0</span>).getLogicalProperty().getOutputColumns();</span><br><span class="line">   <span class="type">ColumnRefSet</span> <span class="variable">rightChildColumns</span> <span class="operator">=</span> </span><br><span class="line">       optExpr.inputAt(<span class="number">1</span>).getLogicalProperty().getOutputColumns();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   JoinNode.DistributionMode distributionMode;</span><br><span class="line">   <span class="keyword">if</span> (isExchangeWithDistributionType(</span><br><span class="line">               leftFragmentPlanRoot, DistributionSpec.DistributionType.SHUFFLE)</span><br><span class="line">       &amp;&amp; isExchangeWithDistributionType(</span><br><span class="line">               rightFragmentPlanRoot, DistributionSpec.DistributionType.SHUFFLE)) &#123;</span><br><span class="line">       distributionMode = JoinNode.DistributionMode.PARTITIONED;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isExchangeWithDistributionType(</span><br><span class="line">               rightFragmentPlanRoot, DistributionSpec.DistributionType.BROADCAST)) &#123;</span><br><span class="line">       distributionMode = JoinNode.DistributionMode.BROADCAST;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(leftFragmentPlanRoot <span class="keyword">instanceof</span> ExchangeNode)</span><br><span class="line">           &amp;&amp; !(rightFragmentPlanRoot <span class="keyword">instanceof</span> ExchangeNode)) &#123;</span><br><span class="line">       <span class="keyword">if</span> (isColocateJoin(optExpr)) &#123;</span><br><span class="line">           distributionMode = HashJoinNode.DistributionMode.COLOCATE;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isShuffleJoin(optExpr)) &#123;</span><br><span class="line">           distributionMode = JoinNode.DistributionMode.SHUFFLE_HASH_BUCKET;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           distributionMode = JoinNode.DistributionMode.COLOCATE;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isShuffleJoin(optExpr)) &#123;</span><br><span class="line">       distributionMode = JoinNode.DistributionMode.SHUFFLE_HASH_BUCKET;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       distributionMode = JoinNode.DistributionMode.LOCAL_HASH_BUCKET;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-JoinNode"><a href="#2-JoinNode" class="headerlink" title="2. JoinNode"></a>2. JoinNode</h3><p>根据 PhysicalHashJoinOperator 信息生生成 JoinNode</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">JoinNode joinNode;</span><br><span class="line"><span class="keyword">if</span> (node <span class="keyword">instanceof</span> PhysicalHashJoinOperator) &#123;</span><br><span class="line">    joinNode = <span class="keyword">new</span> <span class="title class_">HashJoinNode</span>(</span><br><span class="line">            context.getNextNodeId(),</span><br><span class="line">            leftFragment.getPlanRoot(), rightFragment.getPlanRoot(),</span><br><span class="line">            joinOperator, eqJoinConjuncts, otherJoinConjuncts);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (node <span class="keyword">instanceof</span> PhysicalMergeJoinOperator) &#123;</span><br><span class="line">    joinNode = <span class="keyword">new</span> <span class="title class_">MergeJoinNode</span>(</span><br><span class="line">            context.getNextNodeId(),</span><br><span class="line">            leftFragment.getPlanRoot(), rightFragment.getPlanRoot(),</span><br><span class="line">            joinOperator, eqJoinConjuncts, otherJoinConjuncts);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StarRocksPlannerException</span>(<span class="string">&quot;unknown join operator: &quot;</span> + node, INTERNAL_ERROR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-JoinFragmentBuilder"><a href="#3-JoinFragmentBuilder" class="headerlink" title="3. JoinFragmentBuilder"></a>3. JoinFragmentBuilder</h3><p>下面就是要根据不同 JoinNode.DistributionMode 将 JoinNode 转化为 PlanFragment。</p><h4 id="JoinNode-DistributionMode-BROADCAST"><a href="#JoinNode-DistributionMode-BROADCAST" class="headerlink" title="JoinNode.DistributionMode.BROADCAST"></a>JoinNode.DistributionMode.BROADCAST</h4><p>此时 rightFragment 的根节点是 ExchangeNode，并且数据源分布是 JoinNode.DistributionMode.BROADCAST。</p><p>在BE端生成 Pipeline 时，只会产生一个 HashJoinBuildOperator，即所有的 PipeleDrivers 共享一个 HashJoinBuildOperator。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HashJoinerPtr <span class="title">create_builder</span><span class="params">(<span class="type">int</span> driver_sequence)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_is_broadcast()) &#123;</span><br><span class="line">        driver_sequence = BROADCAST_BUILD_DRIVER_SEQUENCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!_builder_map[driver_sequence]) &#123;</span><br><span class="line">        _builder_map[driver_sequence] = </span><br><span class="line">            std::<span class="built_in">make_shared</span>&lt;HashJoiner&gt;(_param, _read_only_probers);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _builder_map[driver_sequence];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在BE端执行时，HashJoinBuildOperator 中的数据全部发送给左表。因此 <strong>右表的变成左表的依赖</strong>，因此需要将右表变成左表的子节点，将左表的 fragment 作为输出返回。</p><p><strong>注意</strong>：context.getFragments() 中包含的是所有独立的 Fragment 子树，而 rightFragment 的根节点是 ExchangeNode，说明 rightFragment 对应生产者 Fragment 已经是一个独立的 Fragment subtree，因此需要将 leftFragment、rightFragment 从 context.getFragments() 中移除，再将 leftFragment 作为一个新的 Fragment 子树加入 context.getFragments()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (distributionMode.equals(JoinNode.DistributionMode.BROADCAST)) &#123;</span><br><span class="line">   setJoinPushDown(joinNode);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Connect parent and child fragment</span></span><br><span class="line">   rightFragment.getPlanRoot().setFragment(leftFragment);</span><br><span class="line"></span><br><span class="line">   context.getFragments().remove(rightFragment);</span><br><span class="line">   context.getFragments().remove(leftFragment);</span><br><span class="line"></span><br><span class="line">   context.getFragments().add(leftFragment);</span><br><span class="line">   leftFragment.setPlanRoot(joinNode);</span><br><span class="line">   <span class="comment">// 构建依赖关系</span></span><br><span class="line">   leftFragment.addChild(rightFragment.getChild(<span class="number">0</span>));</span><br><span class="line">   leftFragment.mergeQueryGlobalDicts(rightFragment.getQueryGlobalDicts());</span><br><span class="line">   <span class="comment">// 返回左表的fragment</span></span><br><span class="line">   <span class="keyword">return</span> leftFragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JoinNode-DistributionMode-PARTITIONED"><a href="#JoinNode-DistributionMode-PARTITIONED" class="headerlink" title="JoinNode.DistributionMode.PARTITIONED"></a>JoinNode.DistributionMode.PARTITIONED</h4><p>此时，左右fragments的根节点都是 ExchangeNode，且都需要进行 Shuffle。那么就需新建个 joinFragment，并将 rightFragment 和 rightFragment 作为子节点。在 BE 端执行时，leftFragment、rightFragment 通过 ExchangeSink 将数据发送到啊 ExchangeNode，在 JoinFragment 中进行 join 操作。</p><p>此时的数据数据分区方式是 TPartitionType.HASH_PARTITIONED，BE 端会根据分区方式选择计算hash值的函数，主要是区分于 TPartitionType.BUCKET_SHUFFLE_HASH_PARTITIONED。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (distributionMode.equals(JoinNode.DistributionMode.PARTITIONED)) &#123;</span><br><span class="line">   <span class="type">DataPartition</span> <span class="variable">lhsJoinPartition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataPartition</span>(TPartitionType.HASH_PARTITIONED,</span><br><span class="line">         leftFragment.getDataPartition().getPartitionExprs());</span><br><span class="line">   <span class="type">DataPartition</span> <span class="variable">rhsJoinPartition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataPartition</span>(TPartitionType.HASH_PARTITIONED,</span><br><span class="line">         rightFragment.getDataPartition().getPartitionExprs());</span><br><span class="line"></span><br><span class="line">   leftFragment.getChild(<span class="number">0</span>).setOutputPartition(lhsJoinPartition);</span><br><span class="line">   rightFragment.getChild(<span class="number">0</span>).setOutputPartition(rhsJoinPartition);</span><br><span class="line"></span><br><span class="line">   context.getFragments().remove(leftFragment);</span><br><span class="line">   context.getFragments().remove(rightFragment);</span><br><span class="line"></span><br><span class="line">   <span class="type">PlanFragment</span> <span class="variable">joinFragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlanFragment</span>(context.getNextFragmentId(),</span><br><span class="line">         joinNode, lhsJoinPartition);</span><br><span class="line">   joinFragment.addChild(leftFragment.getChild(<span class="number">0</span>));</span><br><span class="line">   joinFragment.addChild(rightFragment.getChild(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">   joinFragment.mergeQueryGlobalDicts(leftFragment.getQueryGlobalDicts());</span><br><span class="line">   joinFragment.mergeQueryGlobalDicts(rightFragment.getQueryGlobalDicts());</span><br><span class="line">   context.getFragments().add(joinFragment);</span><br><span class="line">   <span class="keyword">return</span> joinFragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JoinNode-DistributionMode-COLOCATE"><a href="#JoinNode-DistributionMode-COLOCATE" class="headerlink" title="JoinNode.DistributionMode.COLOCATE"></a>JoinNode.DistributionMode.COLOCATE</h4><p>这时 leftFragment、rightFragment 的子节点数据源都是来自 OlapScanNode 而不是 ExchangeNode。</p><p>BE 端在执行时，就是能够在一个 Fragment 中从本地读取 build-table 和 probe-table 的数据直接进行 join 操作，而不是从 ExchangeNode 读取。此外 COLOCATE-Join 是直接按照 join-key 分布，那么就可以直接 bucket-join。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (distributionMode.equals(JoinNode.DistributionMode.COLOCATE)) &#123;</span><br><span class="line">   joinNode.setColocate(<span class="literal">true</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">   setJoinPushDown(joinNode);</span><br><span class="line"></span><br><span class="line">   joinNode.setChild(<span class="number">0</span>, leftFragment.getPlanRoot());</span><br><span class="line">   joinNode.setChild(<span class="number">1</span>, rightFragment.getPlanRoot());</span><br><span class="line">   leftFragment.setPlanRoot(joinNode);</span><br><span class="line">   leftFragment.addChildren(rightFragment.getChildren());</span><br><span class="line">   context.getFragments().remove(rightFragment);</span><br><span class="line">   context.getFragments().remove(leftFragment);</span><br><span class="line">   context.getFragments().add(leftFragment);</span><br><span class="line"></span><br><span class="line">   leftFragment.mergeQueryGlobalDicts(rightFragment.getQueryGlobalDicts());</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> leftFragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JoinNode-DistributionMode-SHUFFLE-HASH-BUCKET"><a href="#JoinNode-DistributionMode-SHUFFLE-HASH-BUCKET" class="headerlink" title="JoinNode.DistributionMode.SHUFFLE_HASH_BUCKET"></a>JoinNode.DistributionMode.SHUFFLE_HASH_BUCKET</h4><p>如果 join-key 不全是表的 key-column，包含了 value-column，那么就得使用 shuffle 将数据进行正交。</p><ul><li>如果 build-table 和 probe-table 的数据源都不是 ExchangeNode，就不用生成新的 joinFragment，直接复用 leftFragment 即可。</li><li>如果其中有一个是 ExchangeNode，则删除该 ExchangeNode 对应的 fragment</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (distributionMode.equals(JoinNode.DistributionMode.SHUFFLE_HASH_BUCKET)) &#123;</span><br><span class="line">  setJoinPushDown(joinNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!(leftFragment.getPlanRoot() <span class="keyword">instanceof</span> ExchangeNode)</span><br><span class="line">   &amp;&amp; !(rightFragment.getPlanRoot() <span class="keyword">instanceof</span> ExchangeNode)) &#123;</span><br><span class="line">      <span class="comment">// 合并到一个 leftFragment 中</span></span><br><span class="line">      <span class="comment">// 此时，left、right 节点在一个 be 节点上，直接本地执行</span></span><br><span class="line">      joinNode.setChild(<span class="number">0</span>, leftFragment.getPlanRoot());</span><br><span class="line">      joinNode.setChild(<span class="number">1</span>, rightFragment.getPlanRoot());</span><br><span class="line">      leftFragment.setPlanRoot(joinNode);</span><br><span class="line">      <span class="comment">// 删除 rightFragment</span></span><br><span class="line">      leftFragment.addChildren(rightFragment.getChildren());</span><br><span class="line">      context.getFragments().remove(rightFragment);</span><br><span class="line"></span><br><span class="line">      context.getFragments().remove(leftFragment);</span><br><span class="line">      context.getFragments().add(leftFragment);</span><br><span class="line"></span><br><span class="line">      leftFragment.mergeQueryGlobalDicts(rightFragment.getQueryGlobalDicts());</span><br><span class="line">      <span class="keyword">return</span> leftFragment;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (leftFragment.getPlanRoot() <span class="keyword">instanceof</span> ExchangeNode</span><br><span class="line">   &amp;&amp; !(rightFragment.getPlanRoot() <span class="keyword">instanceof</span> ExchangeNode)) &#123;</span><br><span class="line">      <span class="keyword">return</span> computeShuffleHashBucketPlanFragment(context, rightFragment,</span><br><span class="line">              leftFragment, joinNode);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> computeShuffleHashBucketPlanFragment(context, leftFragment,</span><br><span class="line">        rightFragment, joinNode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>computeShuffleHashBucketPlanFragment 函数的逻辑如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PlanFragment <span class="title function_">computeShuffleHashBucketPlanFragment</span><span class="params">(ExecPlan context,</span></span><br><span class="line"><span class="params">                                                       <span class="comment">/** no exchange-node **/</span></span></span><br><span class="line"><span class="params">                                                       PlanFragment stayFragment,</span></span><br><span class="line"><span class="params">                                                       <span class="comment">/** exchange-node **/</span></span></span><br><span class="line"><span class="params">                                                       PlanFragment removeFragment,</span></span><br><span class="line"><span class="params">                                                       JoinNode hashJoinNode)</span> &#123;</span><br><span class="line">  hashJoinNode.setPartitionExprs(removeFragment.getDataPartition().getPartitionExprs());</span><br><span class="line">  <span class="type">DataPartition</span> <span class="variable">dataPartition</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataPartition</span>(TPartitionType.HASH_PARTITIONED,</span><br><span class="line">          removeFragment.getDataPartition().getPartitionExprs());</span><br><span class="line">  removeFragment.getChild(<span class="number">0</span>).setOutputPartition(dataPartition);</span><br><span class="line"></span><br><span class="line">  context.getFragments().remove(removeFragment);</span><br><span class="line">  context.getFragments().remove(stayFragment);</span><br><span class="line"></span><br><span class="line">  context.getFragments().add(stayFragment);</span><br><span class="line">  stayFragment.setPlanRoot(hashJoinNode);</span><br><span class="line">  stayFragment.addChildren(removeFragment.getChildren());</span><br><span class="line">  stayFragment.mergeQueryGlobalDicts(removeFragment.getQueryGlobalDicts());</span><br><span class="line">  <span class="keyword">return</span> stayFragment;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JoinNode-DistributionMode-LOCAL-HASH-BUCKET"><a href="#JoinNode-DistributionMode-LOCAL-HASH-BUCKET" class="headerlink" title="JoinNode.DistributionMode.LOCAL_HASH_BUCKET"></a>JoinNode.DistributionMode.LOCAL_HASH_BUCKET</h4><p>LOCAL_HASH_BUCKET 和 SHUFFLE_HASH_BUCKET 类似，只是分区方式不同。</p><h2 id="visitPhysicalDistribution"><a href="#visitPhysicalDistribution" class="headerlink" title="visitPhysicalDistribution"></a>visitPhysicalDistribution</h2><p>用于生成新的 Fragment，这个 Fragment 子树的第数据源节点是 ExchangeNode，而不是 OlapScanNode，那么就需要在 inputFragment 和 newFragment 之间确定数据分区方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> PlanFragment <span class="title function_">visitPhysicalDistribution</span><span class="params">(OptExpression optExpr, ExecPlan context)</span> &#123;</span><br><span class="line">    <span class="type">PlanFragment</span> <span class="variable">inputFragment</span> <span class="operator">=</span> visit(optExpr.inputAt(<span class="number">0</span>), context);</span><br><span class="line">    <span class="type">PhysicalDistributionOperator</span> <span class="variable">distribution</span> <span class="operator">=</span> (PhysicalDistributionOperator) optExpr.getOp();</span><br><span class="line"></span><br><span class="line">    <span class="type">ExchangeNode</span> <span class="variable">exchangeNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ExchangeNode</span>(context.getNextNodeId(),</span><br><span class="line">            inputFragment.getPlanRoot(), distribution.getDistributionSpec().getType());</span><br><span class="line"></span><br><span class="line">    DataPartition dataPartition;</span><br><span class="line">    <span class="keyword">if</span> (DistributionSpec.DistributionType.GATHER.equals(</span><br><span class="line">        distribution.getDistributionSpec().getType())) &#123;</span><br><span class="line">        exchangeNode.setNumInstances(<span class="number">1</span>);</span><br><span class="line">        dataPartition = DataPartition.UNPARTITIONED;</span><br><span class="line">        <span class="type">GatherDistributionSpec</span> <span class="variable">spec</span> <span class="operator">=</span> (GatherDistributionSpec)</span><br><span class="line">             distribution.getDistributionSpec();</span><br><span class="line">        <span class="keyword">if</span> (spec.hasLimit()) &#123;</span><br><span class="line">            exchangeNode.setLimit(spec.getLimit());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DistributionSpec.DistributionType.BROADCAST.equals(</span><br><span class="line">            distribution.getDistributionSpec().getType())) &#123;</span><br><span class="line">        exchangeNode.setNumInstances(inputFragment.getPlanRoot().getNumInstances());</span><br><span class="line">        dataPartition = DataPartition.UNPARTITIONED;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DistributionSpec.DistributionType.SHUFFLE.equals(</span><br><span class="line">        distribution.getDistributionSpec().getType())) &#123;</span><br><span class="line">        exchangeNode.setNumInstances(inputFragment.getPlanRoot().getNumInstances());</span><br><span class="line">        List&lt;ColumnRefOperator&gt; partitionColumns = getShuffleColumns(</span><br><span class="line">            (HashDistributionSpec) distribution.getDistributionSpec());</span><br><span class="line">        List&lt;Expr&gt; distributeExpressions = partitionColumns.stream().map(</span><br><span class="line">            e -&gt; ScalarOperatorToExpr.buildExecExpression(</span><br><span class="line">                e, <span class="keyword">new</span> <span class="title class_">ScalarOperatorToExpr</span>.FormatterContext(context.getColRefToExpr())))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line">        dataPartition = DataPartition.hashPartitioned(distributeExpressions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StarRocksPlannerException</span>(<span class="string">&quot;Unsupport exchange type : &quot;</span></span><br><span class="line">                + distribution.getDistributionSpec().getType(), INTERNAL_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">    exchangeNode.setDataPartition(dataPartition);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成新的 Fragment</span></span><br><span class="line">    <span class="type">PlanFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PlanFragment</span>(</span><br><span class="line">        context.getNextFragmentId(), exchangeNode, dataPartition);</span><br><span class="line">    fragment.setQueryGlobalDicts(distribution.getGlobalDicts());</span><br><span class="line">    inputFragment.setDestination(exchangeNode);</span><br><span class="line">    <span class="comment">// 设置输入的 fragment 的输出分区方式</span></span><br><span class="line">    inputFragment.setOutputPartition(dataPartition);</span><br><span class="line"></span><br><span class="line">    context.getFragments().add(fragment);</span><br><span class="line">    <span class="keyword">return</span> fragment;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="finalizeFragments"><a href="#finalizeFragments" class="headerlink" title="finalizeFragments"></a>finalizeFragments</h2><p>Fragment tree 构建完毕，在 finalizeFragments 函数中为每个 Fragment 设置DataSink，并翻转fragments，使 fragments[0] 是root-fragment。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecPlan <span class="title function_">finalizeFragments</span><span class="params">(ExecPlan execPlan, TResultSinkType resultSinkType)</span> &#123;</span><br><span class="line">    List&lt;PlanFragment&gt; fragments = execPlan.getFragments();</span><br><span class="line">    <span class="keyword">for</span> (PlanFragment fragment : fragments) &#123;</span><br><span class="line">        fragment.createDataSink(resultSinkType);</span><br><span class="line">    &#125;</span><br><span class="line">    Collections.reverse(fragments);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createDataSink"><a href="#createDataSink" class="headerlink" title="createDataSink"></a>createDataSink</h3><p>给每个 Fragment 生成一个 DataSink，和该 Fragment 的 DestFragment 的 ExchangeNode 配对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createDataSink</span><span class="params">(TResultSinkType resultSinkType)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (sink != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (destNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// we&#x27;re streaming to an exchange node</span></span><br><span class="line">        <span class="type">DataStreamSink</span> <span class="variable">streamSink</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataStreamSink</span>(destNode.getId());</span><br><span class="line">        streamSink.setPartition(outputPartition);</span><br><span class="line">        streamSink.setMerge(destNode.isMerge());</span><br><span class="line">        streamSink.setFragment(<span class="built_in">this</span>);</span><br><span class="line">        sink = streamSink;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (planRoot == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// only output expr, no FROM clause</span></span><br><span class="line">            <span class="comment">// &quot;select 1 + 2&quot;</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// add ResultSink</span></span><br><span class="line">        <span class="comment">// we&#x27;re streaming to an result sink</span></span><br><span class="line">        sink = <span class="keyword">new</span> <span class="title class_">ResultSink</span>(planRoot.getId(), resultSinkType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，生成的是 PlanFragment, 下一步需要在 Coordinator 中将 PlanFragment 转化为 FragmentInstance 在 BE 中执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入的 SQL 经过 Parser 后生成 AST 并最终转化为 Relation Tree， 基于 Relation 生成逻辑计划 logicalPlan，逻辑计划再经过优化器生成物理计划 PhysicalPlan，最终生成执行计划 ExecPlan。从 LogicalP</summary>
      
    
    
    
    <category term="CBO" scheme="https://szza.github.io/categories/CBO/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>Coordinator: ExexPlan 的实例化</title>
    <link href="https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/"/>
    <id>https://szza.github.io/2023/10/01/StarRocks/CBO/Coordinator/</id>
    <published>2023-10-01T02:00:01.000Z</published>
    <updated>2023-10-30T08:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>PlanFragmentBuilder 将 PhysicalPlan 转化为 ExecPlan 后得到一堆 Fragments，需要在 Coordinator 中将 Fragment 实例化为 FragmentInstance，设置具体的执行计划与 BE 节点参数。</p><h2 id="computeScanRangeAssignment"><a href="#computeScanRangeAssignment" class="headerlink" title="computeScanRangeAssignment"></a>computeScanRangeAssignment</h2><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/CBO/BackendSelector.svg?raw=true" alt="BackendSelector"></p><h2 id="computeFragmentHosts"><a href="#computeFragmentHosts" class="headerlink" title="computeFragmentHosts"></a>computeFragmentHosts</h2><p>computeFragmentHosts 函数是为每个 Fragment 分配运行的 BE 节点。Fragment 的 root_node 要么是 ExchangeNode，要么是 OlapScanNode，具体还要设置一些信息。</p><p>computeFragmentHosts 是按照从 childFragment（叶结点） 到 rootFragment（根节点）逆序遍历，这样父节点可以根据子节点选择 BE。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">computeFragmentHosts</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// from children --&gt; parent</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> fragments.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="type">PlanFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> fragments.get(i);</span><br><span class="line">        <span class="type">FragmentExecParams</span> <span class="variable">params</span> <span class="operator">=</span> </span><br><span class="line">            fragmentExecParamsMap.get(fragment.getFragmentId());</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">dopAdaptionEnabled</span> <span class="operator">=</span> usePipeline &amp;&amp;</span><br><span class="line">            connectContext.getSessionVariable().isPipelineDopAdaptionEnabled();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. DataPartition.UNPARTITIONED</span></span><br><span class="line">        <span class="keyword">if</span> (fragment.getDataPartition() == DataPartition.UNPARTITIONED) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. ExchangeNode</span></span><br><span class="line">        <span class="type">PlanNode</span> <span class="variable">leftMostNode</span> <span class="operator">=</span> findLeftmostNode(fragment.getPlanRoot());</span><br><span class="line">        <span class="keyword">if</span> (!(leftMostNode <span class="keyword">instanceof</span> ScanNode)) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. OlapScanNode </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DataPartition-UNPARTITIONED"><a href="#DataPartition-UNPARTITIONED" class="headerlink" title="DataPartition.UNPARTITIONED"></a>DataPartition.UNPARTITIONED</h3><p>当 fragment 的 DataSink 分区方式是 DataPartition.UNPARTITIONED 时，表示将数据全部输出到 destinations，此时为这个 Fragment 选择在哪个BE节点执行时，通过 SimpleScheduler.getBackendHost 方法从 BE节点中选择一个。</p><blockquote><p>Sink 分区方式是 DataPartition.UNPARTITIONED，应该只有 BROADCAST-JOIN 和 ResultSink 等几种，为啥这里不需要考虑输入，随机选择一个 BE节点去执行 ?</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fragment.getDataPartition() == DataPartition.UNPARTITIONED) &#123;</span><br><span class="line">    Reference&lt;Long&gt; backendIdRef = <span class="keyword">new</span> <span class="title class_">Reference</span>&lt;&gt;();</span><br><span class="line">    TNetworkAddress execHostport;</span><br><span class="line">    <span class="keyword">if</span> (usedComputeNode) &#123;</span><br><span class="line">        execHostport = SimpleScheduler.getComputeNodeHost(</span><br><span class="line">            <span class="built_in">this</span>.idToComputeNode, backendIdRef);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        execHostport = SimpleScheduler.getBackendHost(</span><br><span class="line">            <span class="built_in">this</span>.idToBackend, backendIdRef);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (execHostport == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UserException</span>(</span><br><span class="line">            <span class="string">&quot;Backend not found. Check if any backend is down or not. &quot;</span> + </span><br><span class="line">            backendInfosString(usedComputeNode));</span><br><span class="line">    &#125;</span><br><span class="line">    recordUsedBackend(execHostport, backendIdRef.getRef());</span><br><span class="line">    <span class="type">FInstanceExecParam</span> <span class="variable">instanceParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FInstanceExecParam</span>(</span><br><span class="line">                <span class="literal">null</span>, execHostport, <span class="number">0</span>, params);</span><br><span class="line">    params.instanceExecParams.add(instanceParam);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ExchangeNode"><a href="#ExchangeNode" class="headerlink" title="ExchangeNode"></a>ExchangeNode</h3><p>当 Fragment 的最左叶结点是 ExchangeNode 时，将当前 Fragment 执行节点设置为其 InputFragments 中 instance_num 最大的 inputFragment 所处的 BE 节点上。这样在 BE 端在 ragmentInstacne 之间 RPC 通信时，可以减少跨进行通信。主要有如下三步:</p><h4 id="T1-maxParallelism"><a href="#T1-maxParallelism" class="headerlink" title="T1 maxParallelism"></a>T1 maxParallelism</h4><p>寻找 InputFragments 中最大并行度 (maxParallelism) 的位置 (inputFragmentIndex)</p><p>currentChildFragmentParallelism 初始值是 instanceExecParams 的值，在 dopAdaptionEnabled 为 true 时（即 Fragment 的所有 Operator 都能 decompose_to_pipeline，目前应该所有的算子都支持了），currentChildFragmentParallelism 的真实 dop 需要考虑 fragment.pipelineDop。</p><p>开启 pipeline 时 numInstances * pipelineDop 的值等于开启 Pipeline 时的 numInstances 值，即总得并行度并不没有改变，只是之前没有 pipeline 时，并行度靠的是多个 Fragments 并行执行，现在开启 Pipeline 后，在一个 Fragment 中 dop 个线程去并发执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">inputFragmentIndex</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">maxParallelism</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; fragment.getChildren().size(); j++) &#123;</span><br><span class="line">    <span class="type">PlanFragment</span> <span class="variable">inputFragment</span> <span class="operator">=</span>fragment.getChild(j); </span><br><span class="line">    <span class="type">int</span> <span class="variable">currentChildFragmentParallelism</span> <span class="operator">=</span> fragmentExecParamsMap</span><br><span class="line">            .get(inputFragment.getFragmentId())</span><br><span class="line">            .instanceExecParams</span><br><span class="line">            .size();</span><br><span class="line">    <span class="keyword">if</span> (dopAdaptionEnabled) &#123;</span><br><span class="line">        currentChildFragmentParallelism *= </span><br><span class="line">            inputFragment.getPipelineDop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (currentChildFragmentParallelism &gt; maxParallelism) &#123;</span><br><span class="line">        maxParallelism = currentChildFragmentParallelism;</span><br><span class="line">        inputFragmentIndex = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T2-hostSet"><a href="#T2-hostSet" class="headerlink" title="T2. hostSet"></a>T2. hostSet</h4><p>计算 inputFragmentIndex 所处的 BE 集合 hostSet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">PlanFragmentId</span> <span class="variable">inputFragmentId</span></span><br><span class="line">    <span class="operator">=</span> fragment.getChild(inputFragmentIndex).getFragmentId();</span><br><span class="line"><span class="type">FragmentExecParams</span> <span class="variable">maxParallelismFragmentExecParams</span> </span><br><span class="line">    <span class="operator">=</span> fragmentExecParamsMap.get(inputFragmentId);</span><br><span class="line">Set&lt;TNetworkAddress&gt; hostSet = Sets.newHashSet();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (usedComputeNode) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isUnionFragment(fragment) &amp;&amp; isGatherOutput) &#123;</span><br><span class="line">        <span class="comment">// union fragment use all children&#x27;s host</span></span><br><span class="line">        <span class="comment">// if output fragment isn&#x27;t gather, all fragment must keep 1 instance</span></span><br><span class="line">        <span class="keyword">for</span> (PlanFragment child : fragment.getChildren()) &#123;</span><br><span class="line">            <span class="type">FragmentExecParams</span> <span class="variable">childParams</span> <span class="operator">=</span> </span><br><span class="line">                fragmentExecParamsMap.get(child.getFragmentId());</span><br><span class="line">            childParams.instanceExecParams</span><br><span class="line">                .stream().map(e -&gt; e.host).forEach(hostSet::add);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//make olapScan maxParallelism equals prefer compute node number</span></span><br><span class="line">        maxParallelism = hostSet.size() * fragment.getParallelExecNum();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (FInstanceExecParam execParams :</span><br><span class="line">                maxParallelismFragmentExecParams.instanceExecParams) &#123;</span><br><span class="line">            hostSet.add(execParams.host);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (dopAdaptionEnabled) &#123;</span><br><span class="line">    Preconditions.checkArgument(leftMostNode <span class="keyword">instanceof</span> ExchangeNode);</span><br><span class="line">    maxParallelism = hostSet.size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="T3-params-instanceExecParams"><a href="#T3-params-instanceExecParams" class="headerlink" title="T3 params.instanceExecParams"></a>T3 params.instanceExecParams</h4><p>现在需要根据 maxParallelism、parallel_exchange_instance_num 确定当前 PlanFragment 实例化为多少个(dop) FragmentInstance 对象：dop 取为 exchangeInstances（默认值是 4, 可以由 parallel_exchange_instance_num 更改）和子节点最大的并行度是 maxParallelism 中的较小值。</p><p>然后从 hostSet 中选出 dop 个 host 来作为每个 FragmentInsance 执行的 BE 节点。每个 FragmentInstance 的执行参数由 FInstanceExecParam 对象记录，params.instanceExecParams 的大小就是 PlanFragment 实例化为 FragmentInstance 的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">exchangeInstances</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (connectContext != <span class="literal">null</span> &amp;&amp; connectContext.getSessionVariable() != <span class="literal">null</span>) &#123;</span><br><span class="line">    exchangeInstances = </span><br><span class="line">        connectContext.getSessionVariable().getExchangeInstanceParallel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (exchangeInstances &gt; <span class="number">0</span> &amp;&amp; maxParallelism &gt; exchangeInstances) &#123;</span><br><span class="line">    List&lt;TNetworkAddress&gt; hosts = Lists.newArrayList(hostSet);</span><br><span class="line">    Collections.shuffle(hosts, random);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; exchangeInstances; index++) &#123;</span><br><span class="line">        <span class="type">TNetworkAddress</span> <span class="variable">host</span> <span class="operator">=</span> hosts.get(index % hosts.size());</span><br><span class="line">        <span class="type">FInstanceExecParam</span> <span class="variable">instanceParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FInstanceExecParam</span>(</span><br><span class="line">            <span class="literal">null</span>, host, <span class="number">0</span>, params);</span><br><span class="line">        params.instanceExecParams.add(instanceParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    List&lt;TNetworkAddress&gt; hosts = Lists.newArrayList(hostSet);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; maxParallelism; ++index) &#123;</span><br><span class="line">        <span class="type">TNetworkAddress</span> <span class="variable">host</span> <span class="operator">=</span> hosts.get(index % hosts.size());</span><br><span class="line">        <span class="type">FInstanceExecParam</span> <span class="variable">instanceParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FInstanceExecParam</span>(</span><br><span class="line">            <span class="literal">null</span>, host, <span class="number">0</span>, params);</span><br><span class="line">        params.instanceExecParams.add(instanceParam);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Collections.shuffle(params.instanceExecParams, random);</span><br><span class="line"><span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure><h3 id="OlapScanNode"><a href="#OlapScanNode" class="headerlink" title="OlapScanNode"></a>OlapScanNode</h3><p>以 ExchangeNode 为 Souce 的 Fragment 的执行节点依赖于其 InputFragment 的 HostSet，最终依赖的都是以 OlapScanNode 为 Source 的 leftFragment。</p><p>由于 ColocateJOIN 和 BucketShuffleJOIN Fragment 的最左侧节点 leftMostNode 也是 OlapSacnNode，因此对于这种情况需要特殊处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">parallelExecInstanceNum</span> <span class="operator">=</span> fragment.getParallelExecNum();</span><br><span class="line"><span class="type">int</span> <span class="variable">pipelineDop</span> <span class="operator">=</span> fragment.getPipelineDop();</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasColocate</span> <span class="operator">=</span> </span><br><span class="line">    isColocateFragment(fragment.getPlanRoot()) &amp;&amp;</span><br><span class="line">    fragmentIdToSeqToAddressMap.containsKey(fragment.getFragmentId()) &amp;&amp; </span><br><span class="line">    fragmentIdToSeqToAddressMap.get(fragment.getFragmentId()).size() &gt; <span class="number">0</span>;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">hasBucketShuffle</span> <span class="operator">=</span> isBucketShuffleJoin(fragment.getFragmentId().asInt());</span><br><span class="line"><span class="keyword">if</span> (hasColocate || hasBucketShuffle) &#123;</span><br><span class="line">    computeColocatedJoinInstanceParam(</span><br><span class="line">        fragmentIdToSeqToAddressMap.get(fragment.getFragmentId()),</span><br><span class="line">        fragmentIdBucketSeqToScanRangeMap.get(fragment.getFragmentId()),</span><br><span class="line">        parallelExecInstanceNum, pipelineDop, usePipeline, params);</span><br><span class="line">    computeBucketSeq2InstanceOrdinal(</span><br><span class="line">        params, fragmentIdToBucketNumMap.get(fragment.getFragmentId()));</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="computeColocatedJoinInstanceParam"><a href="#computeColocatedJoinInstanceParam" class="headerlink" title="computeColocatedJoinInstanceParam"></a>computeColocatedJoinInstanceParam</h4><ol><li><p>计算出每个 BE 节点上所有需要读取的 Tablet<br> 这是将所有待读取的 bucket 按照 BE 节点进行分类（即每个 BE 节点需要读取的 Tablets）存储于 addressToScanRanges。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">auto</span> <span class="variable">addressToScanRanges</span> <span class="operator">=</span> Maps.newHashMap();</span><br><span class="line"><span class="keyword">for</span> (auto bucketSeqAndScanRanges : bucketSeqToScanRange.entrySet()) &#123;</span><br><span class="line">  <span class="type">TNetworkAddress</span> <span class="variable">address</span> <span class="operator">=</span> </span><br><span class="line">      bucketSeqToAddress.get(bucketSeqAndScanRanges.getKey());</span><br><span class="line">  addressToScanRanges</span><br><span class="line">      .computeIfAbsent(address, k -&gt; Lists.newArrayList())</span><br><span class="line">      .add(bucketSeqAndScanRanges);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个节点上都有个 expectedInstanceNum，均分 addressToScanRange，使得每个 FragmentInstance 读取的 tablets 即 scanRangePerInstance</p><p> 开启了 pipeline 时，parallelExecInstanceNum 总是为 1，即只有一个 FragmentInstance 去执行 OlapScan，因此 scanRangesPerInstance 的大小还是 1。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (auto addressScanRange : addressToScanRanges.entrySet()) &#123;</span><br><span class="line">    <span class="type">auto</span> <span class="variable">scanRange</span> <span class="operator">=</span> addressScanRange.getValue();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedInstanceNum</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (parallelExecInstanceNum &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        expectedInstanceNum = </span><br><span class="line">            Math.min(scanRange.size(), parallelExecInstanceNum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. split how many scanRange one instance should scan</span></span><br><span class="line">    <span class="type">auto</span> <span class="variable">scanRangesPerInstance</span> <span class="operator">=</span> </span><br><span class="line">        ListUtil.splitBySize(scanRange, expectedInstanceNum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.construct instanceExecParam add the scanRange should be scan by instance</span></span><br><span class="line">    <span class="keyword">for</span> (auto scanRangePerInstance : scanRangesPerInstance) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>enableAssignScanRangesPerDriverSeq</p><p>预设的 pipelineDop（即 fragment.pipelineDop）默认值是 CPU 核心数的一半，真实的并行度 expectedDop 取值为 scanRangePerInstance 和 pipelineDop 的最小值，再将 scanRangePerInstance 按照 expectedDop 均分，确保每个线程读取的 scanRange 尽可能均衡读取，数据不至于倾斜太多。</p><p><strong>enableAssignScanRangesPerDriverSeq</strong> 函数用于确定是否直接为每个 PipelineDriver 赋值对应的 Bucket 去读取，这样可以避免 LocalShuffle（即不用计算从 bucket 中读取的数据该发送到哪个 PipelineDriver）。只有当每个 BE 节点上的 scanRanges 都不小于 pipelineDop &#x2F; 2 时，才该函数才会返回 true（也就是数据量较大时才会开启）。assignPerDriverSeq 为 true 时，下面两个对象生效：</p><ul><li><p>bucketSeqToDriverSeq: 记录每个 bucket 对应的 PipelineDriver</p></li><li><p>nodeToPerDriverSeqScanRanges 映射关系是 {scanId, driverSeq, scanRange}</p><p>一个 scanId 对应一个 OlapScanNode，将多个 OlapScanNode 要读取的scanRangePerInstance 就被划分为 expectedDop 份，每个 PipelineDriver 对应一个 Tablet 的 scanRange。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">boolean</span> <span class="variable">assignPerDriverSeq</span> <span class="operator">=</span> </span><br><span class="line">     enablePipeline &amp;&amp; </span><br><span class="line">     addressToScanRanges.values().stream().allMatch(scanRanges -&gt; </span><br><span class="line">         enableAssignScanRangesPerDriverSeq(scanRanges, pipelineDop));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (auto scanRangePerInstance : scanRangesPerInstance) &#123;</span><br><span class="line">   <span class="type">FInstanceExecParam</span> <span class="variable">instanceParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FInstanceExecParam</span>(</span><br><span class="line">             <span class="literal">null</span>, addressScanRange.getKey(), <span class="number">0</span>, params);</span><br><span class="line"></span><br><span class="line">   <span class="type">int</span> <span class="variable">expectedDop</span> <span class="operator">=</span> Math.min(scanRangePerInstance.size(), pipelineDop);</span><br><span class="line">   <span class="type">auto</span> <span class="variable">scanRangesPerDriverSeq</span> <span class="operator">=</span> </span><br><span class="line">          ListUtil.splitBySize(scanRangePerInstance, expectedDop);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 并行度比较高时</span></span><br><span class="line">   <span class="keyword">if</span> (assignPerDriverSeq) &#123;</span><br><span class="line">       instanceParam.pipelineDop = scanRangesPerDriverSeq.size();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 针对每个 PipelineDriver</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">driverSeq</span> <span class="operator">=</span> <span class="number">0</span>; driverSeq &lt; scanRangesPerDriverSeq.size(); ++driverSeq) &#123;</span><br><span class="line">     scanRangesPerDriverSeq.get(driverSeq).forEach(bucketSeqAndScanRanges -&gt; </span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span> (assignPerDriverSeq) &#123;</span><br><span class="line">            <span class="comment">// bucketSeqAndScanRanges 记录了每个 bucket 对应的 PiplineDriver</span></span><br><span class="line">            instanceParam.bucketSeqToDriverSeq.putIfAbsent(</span><br><span class="line">                bucketSeqAndScanRanges.getKey(), driverSeq);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            instanceParam.bucketSeqToDriverSeq.putIfAbsent(</span><br><span class="line">                bucketSeqAndScanRanges.getKey(), -<span class="number">1</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         bucketSeqAndScanRanges.getValue().forEach((scanId, scanRanges) -&gt; &#123;</span><br><span class="line">           <span class="comment">// 记录了每个 OlapScanNode 细分到每个 PipelineDriver 需要读取的 scanRange</span></span><br><span class="line">           <span class="keyword">if</span> (assignPerDriverSeq) &#123;</span><br><span class="line">              instanceParam.nodeToPerDriverSeqScanRanges</span><br><span class="line">                 .computeIfAbsent(scanId, k -&gt; <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;())</span><br><span class="line">                 .computeIfAbsent(driverSeq, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">                 .addAll(scanRanges);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             instanceParam.perNodeScanRanges</span><br><span class="line">                 .computeIfAbsent(scanId, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;())</span><br><span class="line">                 .addAll(scanRanges);</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">if</span> (assignPerDriverSeq) &#123;</span><br><span class="line">     instanceParam.nodeToPerDriverSeqScanRanges.forEach((scanId, perDriverSeqScanRanges) -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">driverSeq</span> <span class="operator">=</span> <span class="number">0</span>; driverSeq &lt; instanceParam.pipelineDop; ++driverSeq) &#123;</span><br><span class="line">         perDriverSeqScanRanges.computeIfAbsent(driverSeq, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">      &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   params.instanceExecParams.add(instanceParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="ShuffleJOIN"><a href="#ShuffleJOIN" class="headerlink" title="ShuffleJOIN"></a>ShuffleJOIN</h4><p>和上面的逻辑差不多，区别：这里一个 OlapScanNode 对应一个 FragmentInstance</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">assignScanRangesPerDriverSeq</span> <span class="operator">=</span> </span><br><span class="line">       usePipeline &amp;&amp;</span><br><span class="line">      (fragment.isAssignScanRangesPerDriverSeq() || </span><br><span class="line">       fragment.isForceAssignScanRangesPerDriverSeq());</span><br><span class="line"><span class="type">auto</span> <span class="variable">scanRangeAssignment</span> <span class="operator">=</span> </span><br><span class="line">   fragmentExecParamsMap.get(fragment.getFragmentId()).scanRangeAssignment;</span><br><span class="line"><span class="keyword">for</span> (auto tNetworkAddressMapEntry : scanRangeAssignment.entrySet()) &#123;</span><br><span class="line">  <span class="type">TNetworkAddress</span> <span class="variable">host</span> <span class="operator">=</span> tNetworkAddressMapEntry.getKey();</span><br><span class="line">  Map&lt;Integer, List&lt;TScanRangeParams&gt;&gt; NodeAndScanRanges =</span><br><span class="line">     tNetworkAddressMapEntry.getValue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. Handle normal scan node firstly</span></span><br><span class="line">  <span class="keyword">for</span> (Integer planNodeId : NodeAndScanRanges.keySet()) &#123;</span><br><span class="line">    List&lt;TScanRangeParams&gt; perNodeScanRanges = NodeAndScanRanges.get(planNodeId);</span><br><span class="line">    <span class="type">int</span> <span class="variable">expectedInstanceNum</span> <span class="operator">=</span> </span><br><span class="line">       Math.min(perNodeScanRanges.size(), parallelExecInstanceNum);</span><br><span class="line">    <span class="type">auto</span> <span class="variable">perInstanceScanRanges</span> <span class="operator">=</span> </span><br><span class="line">       ListUtil.splitBySize(perNodeScanRanges, expectedInstanceNum);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;TScanRangeParams&gt; scanRangeParams : perInstanceScanRanges) &#123;</span><br><span class="line">        <span class="type">FInstanceExecParam</span> <span class="variable">instanceParam</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FInstanceExecParam</span>(</span><br><span class="line">             <span class="literal">null</span>, host, <span class="number">0</span>, params);</span><br><span class="line">        params.instanceExecParams.add(instanceParam);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">assignPerDriverSeq</span> <span class="operator">=</span> </span><br><span class="line">          assignScanRangesPerDriverSeq &amp;&amp;</span><br><span class="line">          (enableAssignScanRangesPerDriverSeq(scanRangeParams, pipelineDop) || </span><br><span class="line">           fragment.isForceAssignScanRangesPerDriverSeq());</span><br><span class="line">        <span class="keyword">if</span> (!assignPerDriverSeq) &#123;</span><br><span class="line">          instanceParam.perNodeScanRanges.put(planNodeId, scanRangeParams);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 消除 localShuffle</span></span><br><span class="line">          <span class="type">int</span> <span class="variable">expectedDop</span> <span class="operator">=</span> Math.max(</span><br><span class="line">               <span class="number">1</span>, Math.min(pipelineDop, scanRangeParams.size()));</span><br><span class="line">          List&lt;List&lt;TScanRangeParams&gt;&gt; scanRangeParamsPerDriverSeq =</span><br><span class="line">                ListUtil.splitBySize(scanRangeParams, expectedDop);</span><br><span class="line">          instanceParam.pipelineDop = scanRangeParamsPerDriverSeq.size();</span><br><span class="line">          Map&lt;Integer, List&lt;TScanRangeParams&gt;&gt; scanRangesPerDriverSeq = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">          instanceParam.nodeToPerDriverSeqScanRanges.put(</span><br><span class="line">                 planNodeId, scanRangesPerDriverSeq);</span><br><span class="line">          <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">driverSeq</span> <span class="operator">=</span> <span class="number">0</span>; driverSeq &lt; instanceParam.pipelineDop; ++driverSeq) &#123;</span><br><span class="line">                scanRangesPerDriverSeq.put(</span><br><span class="line">                   driverSeq, scanRangeParamsPerDriverSeq.get(driverSeq));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="computeFragmentExecParams"><a href="#computeFragmentExecParams" class="headerlink" title="computeFragmentExecParams"></a>computeFragmentExecParams</h2><h3 id="TUniqueId"><a href="#TUniqueId" class="headerlink" title="TUniqueId"></a>TUniqueId</h3><p>生成 TUniqueId</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">instanceIds.clear();</span><br><span class="line"><span class="keyword">for</span> (FragmentExecParams params : fragmentExecParamsMap.values()) &#123;</span><br><span class="line">   <span class="keyword">if</span> (params.fragment.getSink() <span class="keyword">instanceof</span> ResultSink &amp;&amp; </span><br><span class="line">       params.instanceExecParams.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StarRocksPlannerException</span>(</span><br><span class="line">            <span class="string">&quot;This sql plan has multi result sinks&quot;</span>,</span><br><span class="line">            ErrorType.INTERNAL_ERROR);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; params.instanceExecParams.size(); ++j) &#123;</span><br><span class="line">       <span class="type">TUniqueId</span> <span class="variable">instanceId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TUniqueId</span>();</span><br><span class="line">       instanceId.setHi(queryId.hi);</span><br><span class="line">       instanceId.setLo(queryId.lo + instanceIds.size() + <span class="number">1</span>);</span><br><span class="line">       params.instanceExecParams.get(j).instanceId = instanceId;</span><br><span class="line">       instanceIds.add(instanceId);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="params-instanceExecParams"><a href="#params-instanceExecParams" class="headerlink" title="params.instanceExecParams"></a>params.instanceExecParams</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (FragmentExecParams params : fragmentExecParamsMap.values()) &#123;</span><br><span class="line">   <span class="keyword">if</span> (params.fragment <span class="keyword">instanceof</span> MultiCastPlanFragment) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (params.fragment.getDestFragment() == <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">PlanFragment</span> <span class="variable">fragment</span> <span class="operator">=</span> params.fragment;</span><br><span class="line">   <span class="type">PlanFragment</span> <span class="variable">destFragment</span> <span class="operator">=</span> fragment.getDestFragment();</span><br><span class="line">   <span class="type">FragmentExecParams</span> <span class="variable">destParams</span> <span class="operator">=</span> </span><br><span class="line">      fragmentExecParamsMap.get(destFragment.getFragmentId());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// set # of senders</span></span><br><span class="line">   fragment.getDestNode().setPartitionType(</span><br><span class="line">        fragment.getOutputPartition().getType());</span><br><span class="line">   <span class="type">DataSink</span> <span class="variable">sink</span> <span class="operator">=</span> fragment.getSink();</span><br><span class="line">   <span class="keyword">if</span> (sink <span class="keyword">instanceof</span> DataStreamSink) &#123;</span><br><span class="line">       <span class="type">DataStreamSink</span> <span class="variable">dataStreamSink</span> <span class="operator">=</span> (DataStreamSink) sink;</span><br><span class="line">       dataStreamSink.setExchDop(destParams.fragment.getPipelineDop());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="type">PlanNodeId</span> <span class="variable">exchId</span> <span class="operator">=</span> sink.getExchNodeId();</span><br><span class="line">   <span class="keyword">if</span> (destParams.perExchNumSenders.get(exchId.asInt()) == <span class="literal">null</span>) &#123;</span><br><span class="line">       destParams.perExchNumSenders.put(</span><br><span class="line">            exchId.asInt(), params.instanceExecParams.size());</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       destParams.perExchNumSenders.put(exchId.asInt(),</span><br><span class="line">            params.instanceExecParams.size() + </span><br><span class="line">              destParams.perExchNumSenders.get(exchId.asInt()));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="params-destinations"><a href="#params-destinations" class="headerlink" title="params.destinations"></a>params.destinations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (needScheduleByShuffleJoin(destFragment.getFragmentId().asInt(), sink)) &#123;</span><br><span class="line">   <span class="type">int</span> <span class="variable">bucketSeq</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> <span class="variable">bucketNum</span> <span class="operator">=</span> getFragmentBucketNum(destFragment.getFragmentId());</span><br><span class="line">   <span class="type">TNetworkAddress</span> <span class="variable">dummyServer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TNetworkAddress</span>(<span class="string">&quot;0.0.0.0&quot;</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (bucketSeq &lt; bucketNum) &#123;</span><br><span class="line">       <span class="type">TPlanFragmentDestination</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TPlanFragmentDestination</span>();</span><br><span class="line">       dest.fragment_instance_id = <span class="keyword">new</span> <span class="title class_">TUniqueId</span>(-<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">       dest.server = dummyServer;</span><br><span class="line">       dest.setBrpc_server(dummyServer);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (FInstanceExecParam instanceExecParams : destParams.instanceExecParams) &#123;</span><br><span class="line">           <span class="type">Integer</span> <span class="variable">driverSeq</span> <span class="operator">=</span> instanceExecParams.bucketSeqToDriverSeq.get(bucketSeq);</span><br><span class="line">           <span class="keyword">if</span> (driverSeq != <span class="literal">null</span>) &#123;</span><br><span class="line">               <span class="comment">// 设置目标 &#123;fragment_instance_id, driverSeq&#125;</span></span><br><span class="line">               dest.fragment_instance_id = instanceExecParams.instanceId;</span><br><span class="line">               dest.server = toRpcHost(instanceExecParams.host);</span><br><span class="line">               dest.setBrpc_server(toBrpcHost(instanceExecParams.host));</span><br><span class="line">               <span class="keyword">if</span> (driverSeq != FInstanceExecParam.ABSENT_DRIVER_SEQUENCE) &#123;</span><br><span class="line">                   dest.setPipeline_driver_sequence(driverSeq);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       bucketSeq++;</span><br><span class="line">       params.destinations.add(dest);</span><br><span class="line">   &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; destParams.instanceExecParams.size(); ++j) &#123;</span><br><span class="line">       <span class="type">TPlanFragmentDestination</span> <span class="variable">dest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TPlanFragmentDestination</span>();</span><br><span class="line">       dest.fragment_instance_id = destParams.instanceExecParams.get(j).instanceId;</span><br><span class="line">       dest.server = toRpcHost(destParams.instanceExecParams.get(j).host);</span><br><span class="line">       dest.setBrpc_server(toBrpcHost(destParams.instanceExecParams.get(j).host));</span><br><span class="line">       params.destinations.add(dest);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;PlanFragmentBuilder 将 PhysicalPlan 转化为 ExecPlan 后得到一堆 Fragments，需要在 Coordinator 中将 Fragment 实例化为 FragmentInstance，设置具体的执行计划与 BE 节点参数。&lt;/p&gt;</summary>
      
    
    
    
    <category term="CBO" scheme="https://szza.github.io/categories/CBO/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>FragmentInstance: BE 构建执行计划子树</title>
    <link href="https://szza.github.io/2023/08/29/StarRocks/Pipeline/FragmentInstance/"/>
    <id>https://szza.github.io/2023/08/29/StarRocks/Pipeline/FragmentInstance/</id>
    <published>2023-08-29T02:00:01.000Z</published>
    <updated>2023-11-03T13:10:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要阐述 BE 节点从接受 FE 执行计划到构建 PipelineDriver 并提交给 GlobalDriverExecutor 的过程。</p><p>每个 Query 在 StarRocks-FE 生成的物理计划（Physical Plan）后会被拆分为 PlanFragment 来实现 MPP，而 FragmentInstance 是 PlanFragment 的执行实例。简而言之，Query 最终是由多个 BE 节点上的 FragmentInstances 执行的，一个 FragmentInstance 对应着BE 节点上的 FragmentExecutor。</p><blockquote><p>概念理解可以参考 <a href="https://zhuanlan.zhihu.com/p/573181686">技术内幕 | StarRocks Pipeline 执行框架（上）</a>。</p></blockquote><h2 id="PInternalServiceImplBase"><a href="#PInternalServiceImplBase" class="headerlink" title="PInternalServiceImplBase"></a>PInternalServiceImplBase</h2><h4 id="exec-plan-fragment-by-pipeline"><a href="#exec-plan-fragment-by-pipeline" class="headerlink" title="_exec_plan_fragment_by_pipeline"></a>_exec_plan_fragment_by_pipeline</h4><p>开启了 Pipeline 引擎后，最终都是调用 _exec_plan_fragment_by_pipeline 函数来执行 FragmentInstance，内部主要由 pipeline::FragmentExecutor 完成，一共就两个操作：</p><ol><li><p>FragmentExecutor::prepare</p><p>将 FE 传递过来的 FragmentInstance 反序列化生成物理执行计划，即 ExecNode-Tree，然后 ExecNode 的子类（比如 OlapScanNode，HashJoinNode, ExchangeNode等）需要实现 <strong>ExecNode::decompose_to_pipeline</strong> 函数，通过 decompose_to_pipeline 函数将所有的 ExecNode 分解为 Pipeline Operators。</p><p>再根据 CPU 核数计算 pipeline_dop，生成 dop 个 PipelineDrivers。 </p></li><li><p>FragmentExecutor::execute</p><p> execute 函数比较简单，就是将生成的 drivers 提交给 GlobalDriverExecutor，提交后的状态变化就是前几篇博客所述。因此，本文着重 prepare 函数中的故事。</p></li></ol><p>RPC 接口代码如下。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Status PInternalServiceImplBase&lt;T&gt;::_exec_plan_fragment_by_pipeline(</span><br><span class="line">    <span class="type">const</span> TExecPlanFragmentParams&amp; t_common_param,</span><br><span class="line">    <span class="type">const</span> TExecPlanFragmentParams&amp; t_unique_request) &#123;</span><br><span class="line"></span><br><span class="line">    pipeline::FragmentExecutor fragment_executor;</span><br><span class="line">    <span class="keyword">auto</span> status = </span><br><span class="line">        fragment_executor.<span class="built_in">prepare</span>(_exec_env, t_common_param, t_unique_request);</span><br><span class="line">    <span class="keyword">if</span> (status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> fragment_executor.<span class="built_in">execute</span>(_exec_env);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> status.<span class="built_in">is_duplicate_rpc_invocation</span>() ? Status::<span class="built_in">OK</span>() : status;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FragmentExecutor"><a href="#FragmentExecutor" class="headerlink" title="FragmentExecutor"></a>FragmentExecutor</h2><p>一个 BE 节点可能会在存在一个 query 的多个 FragmentInstances 实例，统一由 QueryContext 进行管理。</p><p>在 FragmentExecutor::prepare 阶段需要完成的操作即 6 个 _prepare_xxx 系列函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FragmentExecutor</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FragmentExecutor</span>();</span><br><span class="line">    <span class="function">Status <span class="title">prepare</span><span class="params">(ExecEnv* exec_env, <span class="type">const</span> TExecPlanFragmentParams&amp; common_request,</span></span></span><br><span class="line"><span class="params"><span class="function">                   <span class="type">const</span> TExecPlanFragmentParams&amp; unique_request)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Several steps of prepare a fragment</span></span><br><span class="line">    <span class="comment">// 1. query context</span></span><br><span class="line">    <span class="comment">// 2. fragment context</span></span><br><span class="line">    <span class="comment">// 3. workgroup</span></span><br><span class="line">    <span class="comment">// 4. runtime state</span></span><br><span class="line">    <span class="comment">// 5. exec plan</span></span><br><span class="line">    <span class="comment">// 6. pipeline driver</span></span><br><span class="line">    Status _prepare_query_ctx(ExecEnv* exec_env, <span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request);</span><br><span class="line">    Status _prepare_fragment_ctx(<span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request);</span><br><span class="line">    Status _prepare_workgroup(<span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request);</span><br><span class="line">    Status _prepare_runtime_state(ExecEnv* exec_env, <span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request);</span><br><span class="line">    Status _prepare_exec_plan(ExecEnv* exec_env, <span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request);</span><br><span class="line">    Status _prepare_global_dict(<span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request);</span><br><span class="line">    Status _prepare_pipeline_driver(ExecEnv* exec_env, <span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request);</span><br><span class="line">    Status _prepare_stream_load_pipe(ExecEnv* exec_env, <span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request);</span><br><span class="line"></span><br><span class="line">    Status _decompose_data_sink_to_operator(RuntimeState* runtime_state, </span><br><span class="line">                                            PipelineBuilderContext* context,</span><br><span class="line">                                            <span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request,</span><br><span class="line">                                            std::unique_ptr&lt;starrocks::DataSink&gt;&amp; datasink,</span><br><span class="line">                                            <span class="type">const</span> TDataSink&amp; thrift_sink,</span><br><span class="line">                                            <span class="type">const</span> std::vector&lt;TExpr&gt;&amp; output_exprs);</span><br><span class="line">    <span class="comment">//... other methods or fields</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> _fragment_start_time = <span class="number">0</span>;</span><br><span class="line">    QueryContext* _query_ctx = <span class="literal">nullptr</span>;</span><br><span class="line">    std::shared_ptr&lt;FragmentContext&gt; _fragment_ctx = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="prepare-query-ctx"><a href="#prepare-query-ctx" class="headerlink" title="_prepare_query_ctx"></a>_prepare_query_ctx</h3><p>如图，每个 BE 节点都有一个 QueryContextManger 用于管理在一个 BE 上执行的所有 query，QueryContextManger 可以理解为Map，内部在 {query_id, query_context} 之间建立映射关系。</p><p>在 StaRocks-BE 中，全局唯一的对象基本都存储在类 <strong>ExecEnv</strong> 中，并在 ExecEnv::_init 函数中初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Status ExecEnv::_init(<span class="type">const</span> std::vector&lt;StorePath&gt;&amp; store_paths) &#123;</span><br><span class="line">    _query_context_mgr = <span class="keyword">new</span> pipeline::<span class="built_in">QueryContextManager</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_query_context_mgr-&gt;<span class="built_in">init</span>());</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">pipeline::QueryContextManager* <span class="title">query_context_mgr</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> _query_context_mgr; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为，BE 接受到一个新的 query，需要先在 query_context_mgr 中注册，再使用该 query 的参数对 _query_ctx 进行初始化。</p><p>这里重要的是设置查询超时时间，默认是 300s，这是一个 query 最大的可执行时间，其他设置基本都是默认关闭。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Status FragmentExecutor::_prepare_query_ctx(</span><br><span class="line">    ExecEnv* exec_env, <span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request) &#123;</span><br><span class="line">    <span class="comment">// prevent an identical fragment instance from multiple execution caused by FE&#x27;s</span></span><br><span class="line">    <span class="comment">// duplicate invocations of rpc exec_plan_fragment.</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; params = request.<span class="built_in">common</span>().params;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; query_id = params.query_id;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; fragment_instance_id = request.<span class="built_in">fragment_instance_id</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; query_options = request.<span class="built_in">common</span>().query_options;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 去重</span></span><br><span class="line">    <span class="keyword">auto</span>&amp;&amp; existing_query_ctx = exec_env-&gt;<span class="built_in">query_context_mgr</span>()-&gt;<span class="built_in">get</span>(query_id);</span><br><span class="line">    <span class="keyword">if</span> (existing_query_ctx) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp;&amp; existingfragment_ctx = </span><br><span class="line">            existing_query_ctx-&gt;<span class="built_in">fragment_mgr</span>()-&gt;<span class="built_in">get</span>(fragment_instance_id);</span><br><span class="line">        <span class="keyword">if</span> (existingfragment_ctx) &#123;</span><br><span class="line">            <span class="keyword">return</span> Status::<span class="built_in">DuplicateRpcInvocation</span>(</span><br><span class="line">                <span class="string">&quot;Duplicate invocations of exec_plan_fragment&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 通过 query_id 注册新的 query_contex</span></span><br><span class="line">    _query_ctx = exec_env-&gt;<span class="built_in">query_context_mgr</span>()-&gt;<span class="built_in">get_or_register</span>(query_id);</span><br><span class="line">    _query_ctx-&gt;<span class="built_in">set_exec_env</span>(exec_env);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 设置 fragment_instances 个数</span></span><br><span class="line">    <span class="keyword">if</span> (params.__isset.instances_number) &#123;</span><br><span class="line">        _query_ctx-&gt;<span class="built_in">set_total_fragments</span>(params.instances_number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 设置查询超时时间</span></span><br><span class="line">    _query_ctx-&gt;<span class="built_in">set_delivery_expire_seconds</span>(_calc_delivery_expired_seconds(request));</span><br><span class="line">    _query_ctx-&gt;<span class="built_in">set_query_expire_seconds</span>(_calc_query_expired_seconds(request));</span><br><span class="line">    <span class="comment">// initialize query&#x27;s deadline</span></span><br><span class="line">    _query_ctx-&gt;<span class="built_in">extend_delivery_lifetime</span>();</span><br><span class="line">    _query_ctx-&gt;<span class="built_in">extend_query_lifetime</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.3 是否开启 query profile，默认关闭</span></span><br><span class="line">    <span class="keyword">if</span> (query_options.__isset.enable_profile &amp;&amp; query_options.enable_profile) &#123;</span><br><span class="line">        _query_ctx-&gt;<span class="built_in">set_report_profile</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (query_options.__isset.pipeline_profile_level) &#123;</span><br><span class="line">        _query_ctx-&gt;<span class="built_in">set_profile_level</span>(query_options.pipeline_profile_level);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.4 是否开启查询 trace，默认关闭</span></span><br><span class="line">    <span class="type">bool</span> enable_query_trace = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (query_options.__isset.enable_query_debug_trace </span><br><span class="line">        &amp;&amp; query_options.enable_query_debug_trace) &#123;</span><br><span class="line">        enable_query_trace = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _query_ctx-&gt;<span class="built_in">set_query_trace</span>(std::<span class="built_in">make_shared</span>&lt;starrocks::debug::QueryTrace&gt;(</span><br><span class="line">        query_id, enable_query_trace));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="prepare-fragment-ctx"><a href="#prepare-fragment-ctx" class="headerlink" title="_prepare_fragment_ctx"></a>_prepare_fragment_ctx</h3><p>创建一个 FragmentContext 对象，设置所属的 query，自己的 fragment_instance_id，以及 FE 地址。只有等后续几个 _prepare_xxx 函数都成功执行，才会将此 _fragment_ctx 注册到 _query_ctx 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Status FragmentExecutor::_prepare_fragment_ctx(</span><br><span class="line">                        <span class="type">const</span> UnifiedExecPlanFragmentParams&amp; request) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; coord = request.<span class="built_in">common</span>().coord;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; query_id = request.<span class="built_in">common</span>().params.query_id;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; fragment_instance_id = request.<span class="built_in">fragment_instance_id</span>();</span><br><span class="line"></span><br><span class="line">    _fragment_ctx = std::<span class="built_in">make_shared</span>&lt;FragmentContext&gt;();</span><br><span class="line"></span><br><span class="line">    _fragment_ctx-&gt;<span class="built_in">set_query_id</span>(query_id);</span><br><span class="line">    _fragment_ctx-&gt;<span class="built_in">set_fragment_instance_id</span>(fragment_instance_id);</span><br><span class="line">    _fragment_ctx-&gt;<span class="built_in">set_fe_addr</span>(coord);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文主要阐述 BE 节点从接受 FE 执行计划到构建 PipelineDriver 并提交给 GlobalDriverExecutor 的过程。&lt;/p&gt;
&lt;p&gt;每个 Query 在 StarRocks-FE 生成的物理计划（Physical Plan）后会被拆分为 Plan</summary>
      
    
    
    
    <category term="Pipeline" scheme="https://szza.github.io/categories/Pipeline/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>HashAggregte: Aggregtor 与聚合算子实现</title>
    <link href="https://szza.github.io/2023/08/19/StarRocks/Pipeline/Aggregator-1/"/>
    <id>https://szza.github.io/2023/08/19/StarRocks/Pipeline/Aggregator-1/</id>
    <published>2023-08-19T02:00:01.000Z</published>
    <updated>2023-11-03T13:11:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>AggregateSinkOperator 的输入源通过 AggregateSinkOperator::push_chunk 完全输入到 Aggregator 后，构建好 HashMap 会通知 AggregateSourceOperator::pull_chunk 从 Aggregator 的 hashmap 提取chunk。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-AggregateNode-3.svg?raw=true" alt="Pipeline-AggregateNode-3"></p><h2 id="Aggregator"><a href="#Aggregator" class="headerlink" title="Aggregator"></a>Aggregator</h2><p>Aggregator 基于生成的 TAggregationNode 中包含的信息进行初始化：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TAggregationNode</span> </span>&#123;</span><br><span class="line">  <span class="number">1</span>: <span class="keyword">optional</span> <span class="type">list</span>&lt;Exprs.TExpr&gt; grouping_exprs</span><br><span class="line">  <span class="comment">// aggregate exprs. The root of each expr is the aggregate function. </span></span><br><span class="line">  <span class="comment">// The other exprs are the inputs to the aggregate function.</span></span><br><span class="line">  <span class="number">2</span>: <span class="keyword">required</span> <span class="type">list</span>&lt;Exprs.TExpr&gt; aggregate_functions</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tuple id used for intermediate aggregations </span></span><br><span class="line">  <span class="comment">// (with slots of agg intermediate types)</span></span><br><span class="line">  <span class="number">3</span>: <span class="keyword">required</span> Types.TTupleId intermediate_tuple_id</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Tupld id used for the aggregation output (with slots of agg output types)</span></span><br><span class="line">  <span class="comment">// Equal to intermediate_tuple_id if intermediate type == output type for all</span></span><br><span class="line">  <span class="comment">// aggregate functions.</span></span><br><span class="line">  <span class="number">4</span>: <span class="keyword">required</span> Types.TTupleId output_tuple_id</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set to true if this aggregation function requires finalization to complete</span></span><br><span class="line">  <span class="comment">// after all rows have been aggregated, and this node is not an intermediate</span></span><br><span class="line">  <span class="number">5</span>: <span class="keyword">required</span> <span class="type">bool</span> need_finalize</span><br><span class="line">  <span class="number">6</span>: <span class="keyword">optional</span> <span class="type">bool</span> use_streaming_preaggregation</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For vector query engine</span></span><br><span class="line">  <span class="number">20</span>: <span class="keyword">optional</span> <span class="type">bool</span> has_outer_join_child</span><br><span class="line">  <span class="number">21</span>: <span class="keyword">optional</span> TStreamingPreaggregationMode streaming_preaggregation_mode</span><br><span class="line"></span><br><span class="line">  <span class="comment">// For profile attributes&#x27; printing: `Grouping Keys` `Aggregate Functions`</span></span><br><span class="line">  <span class="number">22</span>: <span class="keyword">optional</span> <span class="type">string</span> sql_grouping_keys</span><br><span class="line">  <span class="number">23</span>: <span class="keyword">optional</span> <span class="type">string</span> sql_aggregate_functions</span><br><span class="line"></span><br><span class="line">  <span class="number">24</span>: <span class="keyword">optional</span> <span class="type">i32</span> agg_func_set_version = <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// used in query cache</span></span><br><span class="line">  <span class="number">25</span>: <span class="keyword">optional</span> <span class="type">list</span>&lt;Exprs.TExpr&gt; intermediate_aggr_exprs</span><br><span class="line"></span><br><span class="line">  <span class="comment">// used in pipeline engine</span></span><br><span class="line">  <span class="number">26</span>: <span class="keyword">optional</span> <span class="type">bool</span> interpolate_passthrough = <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="number">27</span>: <span class="keyword">optional</span> <span class="type">bool</span> use_sort_agg</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-AggregateNode-1.svg?raw=true" alt="Pipeline-AggregateNode-1"></p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-AggregateNode-2.svg?raw=true" alt="Pipeline-AggregateNode-2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;AggregateSinkOperator 的输入源通过 AggregateSinkOperator::push_chunk 完全输入到 Aggregator 后，构建好 HashMap 会通知 AggregateSourceOperator::pull_chunk 从 A</summary>
      
    
    
    
    <category term="Pipeline" scheme="https://szza.github.io/categories/Pipeline/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>HashJoin: HashBuildOperator、HashProbeOperator 流程剖析</title>
    <link href="https://szza.github.io/2023/08/13/StarRocks/Pipeline/HashJoin/"/>
    <id>https://szza.github.io/2023/08/13/StarRocks/Pipeline/HashJoin/</id>
    <published>2023-08-13T02:00:01.000Z</published>
    <updated>2023-11-03T13:11:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>HashJOIN 经过优化器后，生成的执行计划一般是右表是小表，用于 Build HashTable，左表是大表，用于 Probe HashTable。而左表必须等右表构建完 HashTable 才能执行 Probe 过程，因此 Build 和 Probe 之间存在一个依赖关系。</p><p>因此，在将 HashJoinNode 拆分为 Pipeline 时，会生成两条 Pipelines：</p><ul><li><p>Build Pipeline</p><p>  Build Pipeline 从表 t1 中读取所有符合条件的数据，并构建 HashTable。构建完成，则使 Probe Pipeline 解除阻塞，则从 blocked_driver_poller 中移除并添加到 ready_driver_queue 中，让 DriverExecutor 去执行 Probe。</p></li><li><p>Probe Pipeline  </p><p>  Probe Pipeline 则从表 t2 中不断获取数据，然后执行 probe。由于 Build 过程完成，HashTable 就可以确定了，那么 Probe 的过程是可以逐 chunk 执行，即从表 t2 每次读取一个 chunk 就可以执行一次 probe，因此 PipelineJob 是不会阻塞的。</p></li></ul><h2 id="HashJoinBuildOperator"><a href="#HashJoinBuildOperator" class="headerlink" title="HashJoinBuildOperator"></a>HashJoinBuildOperator</h2><h3 id="HashJoiner"><a href="#HashJoiner" class="headerlink" title="HashJoiner"></a>HashJoiner</h3><p>HashJOIN 是通过 HashJoiner 来实现的，HashJoinBuildOperator 和 HashJoinProbeOperator 共享一个 HashJoiner，通过 HashJoiner::_phase 来判断当时是 Build 还是 Probe 阶段，HashJoinProbeOperator 也是基于这个字段来解除阻塞。示意图如下：</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-HashJoin-1.svg?raw=true" alt="Pipeline-HashJoin-1"></p><h3 id="append-chunk-to-ht"><a href="#append-chunk-to-ht" class="headerlink" title="append_chunk_to_ht"></a>append_chunk_to_ht</h3><p>BuildOperator 通过 push_chunk 接口接收表 t1 数据，内部调用 HashJoiner::append_chunk_to_ht 函数来构建 hashTable，</p><p>注意：BuildOperator 的前一个 Operator 不一定就是 OlapScanOperator，也可能是 ExchangeSourceOperator。因为当 t1 数据量很大，无法在一个节点上构建完整的 HashTable 时，需要将 t1 的数据正交划分，再 ExchangeSink 发到多个节点上执行 HashJOIN，最后组合多个节点上 HashJOIN 的执行结果即可。</p><p>目前，一个 BuildOperator 最大行数不能超过 UINT32_MAX。push_chunk 的过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">HashJoinBuildOperator::push_chunk</span><span class="params">(RuntimeState* state, </span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _join_builder-&gt;<span class="built_in">append_chunk_to_ht</span>(state, chunk);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">HashJoiner::append_chunk_to_ht</span><span class="params">(RuntimeState* state, <span class="type">const</span> ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_phase != HashJoinPhase::BUILD) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!chunk || chunk-&gt;<span class="built_in">is_empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(_ht.<span class="built_in">get_row_count</span>() + chunk-&gt;<span class="built_in">num_rows</span>() &gt;= UINT32_MAX)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">NotSupported</span>(strings::<span class="built_in">Substitute</span>(</span><br><span class="line">            <span class="string">&quot;row count of right table in hash join &gt; $0&quot;</span>, UINT32_MAX));</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取 key_columns</span></span><br><span class="line">        <span class="built_in">SCOPED_TIMER</span>(_build_conjunct_evaluate_timer);</span><br><span class="line">        _prepare_key_columns(_key_columns, chunk, _build_expr_ctxs);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// copy chunk of right table</span></span><br><span class="line">        <span class="built_in">SCOPED_TIMER</span>(_copy_right_table_chunk_timer);</span><br><span class="line">        <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(</span><br><span class="line">            _ht.<span class="built_in">append_chunk</span>(state, chunk, _key_columns));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="prepare-key-columns"><a href="#prepare-key-columns" class="headerlink" title="_prepare_key_columns"></a>_prepare_key_columns</h4><p>_prepare_key_columns 函数是基于 expr_ctxs 从 chunk 中提取出 join-key 对应的列，将结果保存到 key_columns。</p><p>只不过对于 only_null、const_column 两种类型的列有优化，因此特殊判断下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> HashJoiner::_prepare_key_columns(Columns&amp; key_columns, </span><br><span class="line">                                      <span class="type">const</span> ChunkPtr&amp; chunk,</span><br><span class="line">                                      <span class="type">const</span> std::vector&lt;ExprContext*&gt;&amp; expr_ctxs) &#123;</span><br><span class="line">    key_columns.<span class="built_in">resize</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; expr_ctx : expr_ctxs) &#123;</span><br><span class="line">        <span class="comment">// 从 chunk 中提取出 column</span></span><br><span class="line">        <span class="keyword">auto</span> column_ptr = </span><br><span class="line">            <span class="built_in">EVALUATE_NULL_IF_ERROR</span>(expr_ctx, expr_ctx-&gt;<span class="built_in">root</span>(), chunk.<span class="built_in">get</span>());</span><br><span class="line">        <span class="keyword">if</span> (column_ptr-&gt;<span class="built_in">only_null</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> column = </span><br><span class="line">                ColumnHelper::<span class="built_in">create_column</span>(expr_ctx-&gt;<span class="built_in">root</span>()-&gt;<span class="built_in">type</span>(), <span class="literal">true</span>);</span><br><span class="line">            column-&gt;<span class="built_in">append_nulls</span>(chunk-&gt;<span class="built_in">num_rows</span>());</span><br><span class="line">            key_columns.<span class="built_in">emplace_back</span>(column);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (column_ptr-&gt;<span class="built_in">is_constant</span>()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> const_column = </span><br><span class="line">                ColumnHelper::<span class="built_in">as_raw_column</span>&lt;ConstColumn&gt;(column_ptr);</span><br><span class="line">            const_column-&gt;<span class="built_in">data_column</span>()-&gt;<span class="built_in">assign</span>(chunk-&gt;<span class="built_in">num_rows</span>(), <span class="number">0</span>);</span><br><span class="line">            key_columns.<span class="built_in">emplace_back</span>(const_column-&gt;<span class="built_in">data_column</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            key_columns.<span class="built_in">emplace_back</span>(column_ptr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JoinHashTable-append-chunk"><a href="#JoinHashTable-append-chunk" class="headerlink" title="JoinHashTable::append_chunk"></a>JoinHashTable::append_chunk</h4><p>在 HashJoiner::_ht 中有个内存数据结构 _table_items 记录着 BuildOperator::push_chunk 的所有数据：当调用 JoinHashTable::append_chunk 函数时，即将 chunk 中的参与构建 HashTable 的列添加到 _table_items-&gt;key_columns 和 _table_items-&gt;build_chunk 中。</p><p>注意：当 join-keys 中还包含 value columns 时，该 join-keys[i] 不会再单独赋值数据，在构建 HashTable 时会直接从 build_chunk 中获取，不会单独分配内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">JoinHashTable::append_chunk</span><span class="params">(RuntimeState* state, <span class="type">const</span> ChunkPtr&amp; chunk, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> Columns&amp; key_columns)</span> </span>&#123;</span><br><span class="line">    Columns&amp; columns = _table_items-&gt;build_chunk-&gt;<span class="built_in">columns</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 chunk 中参与构建 HashTable 的 value 列数据添加到 build_chunk 中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _table_items-&gt;build_column_count; i++) &#123;</span><br><span class="line">        SlotDescriptor* slot = _table_items-&gt;build_slots[i].slot;</span><br><span class="line">        ColumnPtr&amp; column = chunk-&gt;<span class="built_in">get_column_by_slot_id</span>(slot-&gt;<span class="built_in">id</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!columns[i]-&gt;<span class="built_in">is_nullable</span>() &amp;&amp; column-&gt;<span class="built_in">is_nullable</span>()) &#123;</span><br><span class="line">            <span class="comment">// upgrade to nullable column</span></span><br><span class="line">            columns[i] = NullableColumn::<span class="built_in">create</span>(</span><br><span class="line">                columns[i], NullColumn::<span class="built_in">create</span>(columns[i]-&gt;<span class="built_in">size</span>(), <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        columns[i]-&gt;<span class="built_in">append</span>(*column);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将参与构建 HashTable 的 key 列数据添加到 key_columns 中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _table_items-&gt;key_columns.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 如果 join-key 不在 build_chunk 中</span></span><br><span class="line">        <span class="keyword">if</span> (_table_items-&gt;join_keys[i].col_ref == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// upgrade to nullable column</span></span><br><span class="line">            <span class="keyword">if</span> (!_table_items-&gt;key_columns[i]-&gt;<span class="built_in">is_nullable</span>() </span><br><span class="line">                &amp;&amp; key_columns[i]-&gt;<span class="built_in">is_nullable</span>()) &#123;</span><br><span class="line">                <span class="type">size_t</span> row_count = _table_items-&gt;key_columns[i]-&gt;<span class="built_in">size</span>();</span><br><span class="line">                _table_items-&gt;key_columns[i] = NullableColumn::<span class="built_in">create</span>(</span><br><span class="line">                  _table_items-&gt;key_columns[i], NullColumn::<span class="built_in">create</span>(row_count, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            _table_items-&gt;key_columns[i]-&gt;<span class="built_in">append</span>(*key_columns[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="build-ht"><a href="#build-ht" class="headerlink" title="build_ht"></a>build_ht</h3><p>当 BuildOperator 的前一个 SourceOperator 数据已经全部 pulled，则会调用 HashJoinBuildOperator::set_finishing，在 set_finishing 函数中开始构建 HashTable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">HashJoinBuildOperator::set_finishing</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    _is_finished = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_join_builder-&gt;<span class="built_in">build_ht</span>(state));</span><br><span class="line">    <span class="comment">// build runtime bloomfilter ...</span></span><br><span class="line">    _join_builder-&gt;<span class="built_in">enter_probe_phase</span>();</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">HashJoiner::build_ht</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_phase == HashJoinPhase::BUILD) &#123;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_build(state));</span><br><span class="line">        <span class="built_in">COUNTER_SET</span>(_build_buckets_counter,</span><br><span class="line">           <span class="built_in">static_cast</span>&lt;<span class="type">int64_t</span>&gt;(_ht.<span class="built_in">get_bucket_size</span>()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="JoinHashTable-build"><a href="#JoinHashTable-build" class="headerlink" title="JoinHashTable::build"></a>JoinHashTable::build</h4><p>JoinHashTable::build 函数则是基于内存中的 {key_columns, build_chunk} 开始构建 HashTable。这个构建 HashTable 的算法也不难，可以参考 <a href="https://zhuanlan.zhihu.com/p/593611907">StarRocks Hash Join 源码解析</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">JoinHashTable::build</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_table_items-&gt;build_chunk-&gt;<span class="built_in">upgrade_if_overflow</span>());</span><br><span class="line">    _table_items-&gt;has_large_column = _table_items-&gt;build_chunk-&gt;<span class="built_in">has_large_column</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 join-key 包含在 build_chunk 中，则直接从 build_chunk 中获取</span></span><br><span class="line">    <span class="type">size_t</span> join_key_count = _table_items-&gt;join_keys.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; join_key_count; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_table_items-&gt;join_keys[i].col_ref != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            SlotId slot_id = _table_items-&gt;join_keys[i].col_ref-&gt;<span class="built_in">slot_id</span>();</span><br><span class="line">            _table_items-&gt;key_columns[i] = </span><br><span class="line">                _table_items-&gt;build_chunk-&gt;<span class="built_in">get_column_by_slot_id</span>(slot_id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_upgrade_key_columns_if_overflow());</span><br><span class="line"></span><br><span class="line">    _hash_map_type = _choose_join_hash_map();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开始构建 HashTable</span></span><br><span class="line">    <span class="keyword">switch</span> (_hash_map_type) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M(NAME)                                                                                                       \</span></span><br><span class="line"><span class="meta">    case JoinHashMapType::NAME:                                                                                       \</span></span><br><span class="line"><span class="meta">        _##NAME = std::make_unique<span class="string">&lt;typename decltype(_##NAME)::element_type&gt;</span>(_table_items.get(), _probe_state.get()); \</span></span><br><span class="line"><span class="meta">        _##NAME-&gt;build_prepare(state);                                                                                \</span></span><br><span class="line"><span class="meta">        _##NAME-&gt;probe_prepare(state);                                                                                \</span></span><br><span class="line"><span class="meta">        _##NAME-&gt;build(state);                                                                                        \</span></span><br><span class="line"><span class="meta">        break;</span></span><br><span class="line">        <span class="built_in">APPLY_FOR_JOIN_VARIANTS</span>(M)</span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> M</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashJoinProbeOperator"><a href="#HashJoinProbeOperator" class="headerlink" title="HashJoinProbeOperator"></a>HashJoinProbeOperator</h2><p>当 HashJoiner::build_ht 函数构建完 HashTable，会通过 HashJoiner::enter_probe_phase 函数主动进入 HashJoinPhase::PROBE 阶段。HashJoinProbeOperator::need_input 返回 true，解除阻塞，则会从 blocked_driver_poller 中剔除进入 ready poller 开始执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HashJoiner::enter_probe_phase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    _short_circuit_break();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> old_phase = HashJoinPhase::BUILD;</span><br><span class="line">    _phase.<span class="built_in">compare_exchange_strong</span>(old_phase, HashJoinPhase::PROBE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HashJoinProbeOperator::need_input</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _join_prober-&gt;<span class="built_in">need_input</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">HashJoiner::need_input</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _phase == HashJoinPhase::PROBE &amp;&amp; _probe_input_chunk == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="push-chunk"><a href="#push-chunk" class="headerlink" title="push_chunk"></a>push_chunk</h3><p>进入 HashJoinPhase::Probe 阶段后，Probe Pipeline 阻塞点就在 t2 的 pull_chunk。</p><p>一旦 SourceOperator::pull_chunk 返回一个chunk，DriverExecutor 就会推动 Probe Pipeline 状态机前进: SourceOperator:::pull_chunk –&gt; HashJoinProbeOperator::push_chunk –&gt; HashJoinProbeOperator::pull_chunk </p><p>Probe HashTable 的过程就发生在 HashJoinProbeOperator::pull_chunk 过程中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">HashJoinProbeOperator::push_chunk</span><span class="params">(RuntimeState* state, <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line">    _join_prober-&gt;<span class="built_in">push_chunk</span>(state, chunk);</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HashJoiner::push_chunk</span><span class="params">(RuntimeState* state, ChunkPtr chunk)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(chunk &amp;&amp; !chunk-&gt;<span class="built_in">is_empty</span>());</span><br><span class="line">    <span class="built_in">DCHECK</span>(!_probe_input_chunk);</span><br><span class="line"></span><br><span class="line">    _probe_input_chunk = std::<span class="built_in">move</span>(chunk);</span><br><span class="line">    _ht_has_remain = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 获取 probe 对应的 key-columns</span></span><br><span class="line">    _prepare_probe_key_columns();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pull-chunk"><a href="#pull-chunk" class="headerlink" title="pull_chunk"></a>pull_chunk</h3><p>pull_chunk 函数就是一个 Probe HashTable 的过程，过程详解 <a href="https://zhuanlan.zhihu.com/p/593611907">StarRocks Hash Join 源码解析</a>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;vectorized::ChunkPtr&gt; <span class="title">HashJoinProbeOperator::pull_chunk</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _join_prober-&gt;<span class="built_in">pull_chunk</span>(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">StatusOr&lt;ChunkPtr&gt; <span class="title">HashJoiner::pull_chunk</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(_phase != HashJoinPhase::BUILD);</span><br><span class="line">    <span class="keyword">return</span> _pull_probe_output_chunk(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StatusOr&lt;ChunkPtr&gt; HashJoiner::_pull_probe_output_chunk(RuntimeState* state) &#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(_phase != HashJoinPhase::BUILD);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> chunk = std::<span class="built_in">make_shared</span>&lt;Chunk&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_phase == HashJoinPhase::PROBE || _probe_input_chunk != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="built_in">DCHECK</span>(_ht_has_remain &amp;&amp; _probe_input_chunk);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(</span><br><span class="line">                <span class="built_in">RETURN_IF_ERROR</span>(_ht.<span class="built_in">probe</span>(state, _key_columns, &amp;_probe_input_chunk, &amp;chunk, &amp;_ht_has_remain)));</span><br><span class="line">        <span class="keyword">if</span> (!_ht_has_remain) &#123;</span><br><span class="line">            _probe_input_chunk = <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_filter_probe_output_chunk(chunk));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_phase == HashJoinPhase::POST_PROBE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_need_post_probe()) &#123;</span><br><span class="line">            <span class="built_in">enter_eos_phase</span>();</span><br><span class="line">            <span class="keyword">return</span> chunk;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(<span class="built_in">RETURN_IF_ERROR</span>(_ht.<span class="built_in">probe_remain</span>(state, &amp;chunk, &amp;_ht_has_remain)));</span><br><span class="line">        <span class="keyword">if</span> (!_ht_has_remain) &#123;</span><br><span class="line">            <span class="built_in">enter_eos_phase</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_filter_post_probe_output_chunk(chunk));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> chunk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Questtion"><a href="#Questtion" class="headerlink" title="Questtion"></a>Questtion</h2><p>StarRocks 中的 HashTable cache miss 比较高，效率没那么好？一个 cache-friendly HashTable 设计考量可以参考这篇论文 <a href="https://dl.acm.org/doi/10.14778/2850583.2850585">A Seven-Dimensional Analysis of Hashing Methods and its Implications on Query Processing</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;HashJOIN 经过优化器后，生成的执行计划一般是右表是小表，用于 Build HashTable，左表是大表，用于 Probe HashTable。而左表必须等右表构建完 HashTable 才能执行 Probe 过程，因此 Build 和 Probe 之间存在一个依赖</summary>
      
    
    
    
    <category term="Pipeline" scheme="https://szza.github.io/categories/Pipeline/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>Pipeline-Profile 分析</title>
    <link href="https://szza.github.io/2023/08/06/StarRocks/Pipeline/Pipeline-profile/"/>
    <id>https://szza.github.io/2023/08/06/StarRocks/Pipeline/Pipeline-profile/</id>
    <published>2023-08-06T02:00:01.000Z</published>
    <updated>2023-09-26T02:32:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RuntimeProfile"><a href="#RuntimeProfile" class="headerlink" title="RuntimeProfile"></a>RuntimeProfile</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://forum.mirrorship.cn/t/topic/5058">Pipeline-Profile 分析及优化指南: StarRocks 2.3+</a></li><li><a href="https://forum.mirrorship.cn/t/topic/4926">StarRocks开启Pipeline后并行度设置说明</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;RuntimeProfile&quot;&gt;&lt;a href=&quot;#RuntimeProfile&quot; class=&quot;headerlink&quot; title=&quot;RuntimeProfile&quot;&gt;&lt;/a&gt;RuntimeProfile&lt;/h2&gt;&lt;h2 id=&quot;Reference&quot;&gt;&lt;a hre</summary>
      
    
    
    
    <category term="Pipeline" scheme="https://szza.github.io/categories/Pipeline/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>Pipeline: 查询加速: QueryCache</title>
    <link href="https://szza.github.io/2023/08/05/StarRocks/Pipeline/StarRocks-QueryCache/"/>
    <id>https://szza.github.io/2023/08/05/StarRocks/Pipeline/StarRocks-QueryCache/</id>
    <published>2023-08-05T02:00:01.000Z</published>
    <updated>2023-10-19T03:14:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>输入数据源会被划分多个 Morsels，每个 morsel 都表征着一个要读取的数据源及其范围 {tablet_id, version}，这两个信息也包含在 scan_range 中。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-1.svg?raw=true" alt="QueryCache-1"></p><h2 id="enable-query-cache"><a href="#enable-query-cache" class="headerlink" title="enable_query_cache"></a>enable_query_cache</h2><p>在 query_cache 没有失效的情况下，N 个 MultiLaneOperator 之间的 lane 是一一对应的，数据流如下。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-2.svg?raw=true" alt="QueryCache-2"></p><p>一个 MultiLaneOperator 包含多个 MultiOperator::Lane，每个 MultiOperator::Lane 中都包含了一个 operator：一个 lane-chain 用于处理一个 morsel  数据。<br>将原本的的 一个 Operator 子划分为 _num_lanes 个，实现 tablet 内的并行，每当一个 lane-chain 处理完一个morsel的数据及其后续操作时（ last_chunk_received &#x3D; true，eof_sent &#x3D; true）会将结果缓存到 CacheMgr，供后续操作共享结果。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Lane</span> &#123;</span><br><span class="line">    pipeline::OperatorPtr processor;</span><br><span class="line">    <span class="type">int64_t</span> lane_owner;  <span class="comment">// tablet_id</span></span><br><span class="line">    <span class="type">int</span> lane_id;</span><br><span class="line">    <span class="type">bool</span> last_chunk_received; </span><br><span class="line">    <span class="type">bool</span> eof_sent;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Lane</span>(pipeline::OperatorPtr&amp;&amp; op, <span class="type">int</span> id)</span><br><span class="line">     : <span class="built_in">processor</span>(std::<span class="built_in">move</span>(op)), </span><br><span class="line">       <span class="built_in">lane_owner</span>(<span class="number">-1</span>),</span><br><span class="line">       <span class="built_in">lane_id</span>(id),</span><br><span class="line">       <span class="built_in">last_chunk_received</span>(<span class="literal">false</span>), </span><br><span class="line">       <span class="built_in">eof_sent</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// MultilaneOperator</span></span><br><span class="line">MultilaneOperator::<span class="built_in">MultilaneOperator</span>(pipeline::OperatorFactory* factory, </span><br><span class="line">                                     <span class="type">int32_t</span> driver_sequence,</span><br><span class="line">                                     <span class="type">size_t</span> num_lanes,</span><br><span class="line">                                     pipeline::Operators&amp;&amp; processors, </span><br><span class="line">                                     <span class="type">bool</span> can_passthrough)</span><br><span class="line">: pipeline::<span class="built_in">Operator</span>(factory, factory-&gt;<span class="built_in">id</span>(),</span><br><span class="line">                     factory-&gt;<span class="built_in">get_raw_name</span>(), </span><br><span class="line">                     factory-&gt;<span class="built_in">plan_node_id</span>(),</span><br><span class="line">                     driver_sequence),</span><br><span class="line">  _num_lanes(num_lanes),</span><br><span class="line">  _can_passthrough(can_passthrough) &#123;</span><br><span class="line">     _lanes.<span class="built_in">reserve</span>(_num_lanes);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; _num_lanes; ++i) &#123;</span><br><span class="line">        <span class="comment">// 每个 lane 对应着一个 operator</span></span><br><span class="line">        _lanes.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(processors[i]), i); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// MultilaneOperatorFactory</span></span><br><span class="line"><span class="function">pipeline::OperatorPtr <span class="title">MultilaneOperatorFactory::create</span><span class="params">(<span class="type">int32_t</span> degree_of_parallelism,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                       <span class="type">int32_t</span> driver_sequence)</span> </span>&#123;</span><br><span class="line">    pipeline::Operators processors;</span><br><span class="line">    processors.<span class="built_in">reserve</span>(_num_lanes);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; _num_lanes; ++i) &#123;</span><br><span class="line">        processors.<span class="built_in">push_back</span>(_factory-&gt;<span class="built_in">create</span>(</span><br><span class="line">            degree_of_parallelism * _num_lanes,</span><br><span class="line">             driver_sequence * _num_lanes + i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;MultilaneOperator&gt;(<span class="keyword">this</span>, driver_sequence,</span><br><span class="line">                                               _num_lanes,</span><br><span class="line">                                               std::<span class="built_in">move</span>(processors), </span><br><span class="line">                                               _can_passthrough);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="disable-query-cache"><a href="#disable-query-cache" class="headerlink" title="disable_query_cache"></a>disable_query_cache</h2><p>当 disable_query_cache 时，就退化为基本的状态，即此时每个 MultiLaneOperator 内部实际上只有一个 operator 在发挥作用，最后一个 MultiLaneOperator 中只有一个 passthrough_chunk 传递数据。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-3.svg?raw=true" alt="QueryCache-3"></p><h2 id="push-chunk"><a href="#push-chunk" class="headerlink" title="push_chunk"></a>push_chunk</h2><p>CacheOperator 内部有个 CacheMgr。在 push chunk 时，根据 chunk 的 {rows, bytes} 大小来决定 query_cache 是否有效。</p><p>LaneArbiter 的作用类似于全局锁，在 ScanOperator、MultiLaneOperator、CacheOperator 之间共享，记录着当前 query_cache 是否失效。<br>每次向 CacheOperator 中 push chunk 之前，都会检测 chunk 的 rows 和 bytes 是否超过 {max_rows, max_bytes} 阈值：</p><ul><li><p>如果超过，则转变为 passthrough 模式，不再向 CacheMgr 中写入数据，直接使用 passthrough_chunk 来存储每次读取的数据</p><p>注意，变成 passthrough 模式后，CacheMgr 的数据仍在没有清除，仍可为后续的读取提供缓存。</p></li><li><p>没有超过，则继续向 CacheMgr 中写数据</p></li></ul><p>每个 chunk 都有一个 owner 信息：</p><ul><li>owner_id：即 tablet_id，从 哪个 table_id 读取到的，通过 owner_id 可以定位到具体的 lane。</li><li>is_last_chunk：是不是这个 morsel 的最后一个 chunk；</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> CacheOperator::_should_passthrough(<span class="type">size_t</span> num_rows, <span class="type">size_t</span> num_bytes) &#123;</span><br><span class="line">    <span class="keyword">return</span> _cache_param.entry_max_rows &lt;= <span class="number">0</span> || num_rows &gt; _cache_param.entry_max_rows ||</span><br><span class="line">           _cache_param.entry_max_bytes &lt;= <span class="number">0</span> || num_bytes &gt; _cache_param.entry_max_bytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">CacheOperator::push_chunk</span><span class="params">(RuntimeState* state, <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(chunk != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (_lane_arbiter-&gt;<span class="built_in">in_passthrough_mode</span>()) &#123;</span><br><span class="line">        <span class="built_in">DCHECK</span>(_passthrough_chunk == <span class="literal">nullptr</span>);</span><br><span class="line">        _passthrough_chunk = chunk;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">auto</span> lane_owner = chunk-&gt;<span class="built_in">owner_info</span>().<span class="built_in">owner_id</span>();</span><br><span class="line">    <span class="built_in">DCHECK</span>(_owner_to_lanes.<span class="built_in">count</span>(lane_owner));</span><br><span class="line">    <span class="keyword">auto</span> lane_id = _owner_to_lanes[lane_owner];</span><br><span class="line">    <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane_id];</span><br><span class="line">    buffer-&gt;<span class="built_in">append_chunk</span>(chunk);</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 检测是否超过限制</span></span><br><span class="line">    <span class="keyword">if</span> (_should_passthrough(buffer-&gt;num_rows, buffer-&gt;num_bytes)) &#123;</span><br><span class="line">        _lane_arbiter-&gt;<span class="built_in">enable_passthrough_mode</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, lane_id] : _owner_to_lanes) &#123;</span><br><span class="line">            _per_lane_buffers[lane_id]-&gt;<span class="built_in">set_passthrough</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;<span class="built_in">should_populate_cache</span>()) &#123;</span><br><span class="line">         <span class="comment">// 写入 cache</span></span><br><span class="line">        <span class="built_in">populate_cache</span>(lane_owner);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="populate-cache"><a href="#populate-cache" class="headerlink" title="populate_cache"></a>populate_cache</h3><p>在 push chunk 时，每次都会尝试调用 PerLaneBuffer::should_populate_cache 函数来 check 是否需要将填充 cache：</p><ul><li>cached_version 是 cache_mgr 中目前 cache 的版本，required_version 是目前需要的版本，cached_version &lt; required_version 说明 cache_mgr 中缓存的数据过时，需要填充新的数据；</li><li>PLBS_TOTAL：表征这个 lane 的数据读取完毕，此时会把这个 per_lane_buff 的数据填充到 cache_mgr 中；</li></ul><p>完整的判断条件如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PerLaneBuffer::should_populate_cache</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cached_version &lt; required_version &amp;&amp; </span><br><span class="line">           (state == PLBS_HIT_TOTAL || state == PLBS_TOTAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>填充 cache 的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CacheOperator::populate_cache</span><span class="params">(<span class="type">int64_t</span> tablet_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> lane = _owner_to_lanes[tablet_id];</span><br><span class="line">    <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> cache_key_suffix_it = _cache_param.cache_key_prefixes.<span class="built_in">find</span>(tablet_id);</span><br><span class="line">    <span class="keyword">if</span> (cache_key_suffix_it == _cache_param.cache_key_prefixes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="comment">// uncacheable</span></span><br><span class="line">        buffer-&gt;state = PLBS_POPULATE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string cache_key = </span><br><span class="line">        _cache_param.digest + cache_key_suffix_it-&gt;second;</span><br><span class="line">    <span class="type">int64_t</span> current = <span class="built_in">GetMonoTimeMicros</span>();</span><br><span class="line">    <span class="keyword">auto</span> chunks = <span class="built_in">remap_chunks</span>(buffer-&gt;chunks, _cache_param.slot_remapping);</span><br><span class="line">    <span class="function">CacheValue <span class="title">cache_value</span><span class="params">(current, buffer-&gt;required_version, std::move(chunks))</span></span>;</span><br><span class="line">    <span class="comment">// If the cache implementation is global, </span></span><br><span class="line">    <span class="comment">// populate method must be asynchronous and try its best to</span></span><br><span class="line">    <span class="comment">// update the cache.</span></span><br><span class="line">    _cache_populate_bytes_counter-&gt;<span class="built_in">update</span>(buffer-&gt;num_bytes);</span><br><span class="line">    _cache_populate_chunks_counter-&gt;<span class="built_in">update</span>(buffer-&gt;chunks.<span class="built_in">size</span>());</span><br><span class="line">    _cache_populate_rows_counter-&gt;<span class="built_in">update</span>(buffer-&gt;num_rows);</span><br><span class="line">    _populate_tablets.<span class="built_in">insert</span>(tablet_id);</span><br><span class="line">     <span class="comment">// 缓存 mgr 中，超出容量时，kv会自动删除低优先级</span></span><br><span class="line">    _cache_mgr-&gt;<span class="built_in">populate</span>(cache_key, cache_value);</span><br><span class="line">    buffer-&gt;state = PLBS_POPULATE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pull-chunk"><a href="#pull-chunk" class="headerlink" title="pull_chunk"></a>pull_chunk</h2><p>从 CacheOperator 中获取数据时：</p><ul><li>如果 query_cache 未失效， 则从 PerLaneBuffer 中获取；</li><li>否则直接从 passthrough_chunk 读取</li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;vectorized::ChunkPtr&gt; <span class="title">CacheOperator::pull_chunk</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> opt_lane = _lane_arbiter-&gt;<span class="built_in">preferred_lane</span>();</span><br><span class="line">    <span class="keyword">if</span> (opt_lane.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> lane = opt_lane.<span class="built_in">value</span>();</span><br><span class="line">        <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane];</span><br><span class="line">        <span class="keyword">auto</span> chunk = _pull_chunk_from_per_lane_buffer(buffer);</span><br><span class="line">        <span class="keyword">if</span> (chunk != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> chunk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [_, lane_id] : _owner_to_lanes) &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane_id];</span><br><span class="line">        <span class="keyword">auto</span> chunk = _pull_chunk_from_per_lane_buffer(buffer);</span><br><span class="line">        <span class="keyword">if</span> (chunk != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> chunk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(_passthrough_chunk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pull-chunk-from-per-lane-buffer"><a href="#pull-chunk-from-per-lane-buffer" class="headerlink" title="_pull_chunk_from_per_lane_buffer"></a>_pull_chunk_from_per_lane_buffer</h3><p>当从 CacheOperator 中获取数据时，会从 PerLaneBufferPtr  中获取，如果 lane_id 中的数据已经读取完，则释放该 lane，让后续的 morsel 继续复用该lane继续提交任务。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vectorized::ChunkPtr CacheOperator::_pull_chunk_from_per_lane_buffer(PerLaneBufferPtr&amp; buffer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;<span class="built_in">has_chunks</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> chunk = buffer-&gt;<span class="built_in">get_next_chunk</span>();</span><br><span class="line">        <span class="keyword">if</span> (buffer-&gt;<span class="built_in">can_release</span>()) &#123;</span><br><span class="line">            _lane_arbiter-&gt;<span class="built_in">release_lane</span>(chunk-&gt;<span class="built_in">owner_info</span>().<span class="built_in">owner_id</span>()); <span class="comment">// 类似于释放锁的逻辑</span></span><br><span class="line">            buffer-&gt;<span class="built_in">reset</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chunk;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pick-morsel"><a href="#pick-morsel" class="headerlink" title="_pick_morsel"></a>_pick_morsel</h2><p>在 <a href="https://szza.github.io/2023/07/07/Pipeline/MorselQueue_3/">Morsel 和 OlapScanOperator</a> 中讲过 pick_morsel 函数，但是省略了 QueryCache 部分。</p><p>从 MorselQueue 中获取一个  morsel 后，先要从 lane_arbiter 中获得一个 lane slot 才能执行。</p><ul><li>query_cache::AR_BUSY： 没有可执行的任务</li><li>query_cache::AR_PROBE：获得一个可用的 lane slot，先去 cache 中探测下，是否已经缓存过 {tablet_id, version} 的部分数据，如果已经缓存一部分，则后续只需要读取增量部分。</li><li>query_cache::AR_SKIP： 这个 lane 已经处理过；</li><li>query_cache::AR_IO：<ul><li>passthrough 模式，或者</li><li>query-cache 失效后进入 passthroguh 模式，此时可能仍有部分缓存数据，尝试读取。</li></ul></li></ul><p>这部分代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Status ScanOperator::_pickup_morsel(RuntimeState* state, <span class="type">int</span> chunk_source_index) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 根据 morsel_queue 的策略，获取一个 mosel</span></span><br><span class="line">    <span class="built_in">ASSIGN_OR_RETURN</span>(<span class="keyword">auto</span> morsel, _morsel_queue-&gt;<span class="built_in">try_get</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_lane_arbiter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (morsel != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="comment">// 这个 morsel 对应的 tablet_id 和 version</span></span><br><span class="line">            <span class="keyword">auto</span> [lane_owner, version] = morsel-&gt;<span class="built_in">get_lane_owner_and_version</span>();</span><br><span class="line">            <span class="comment">// 这个 tablet 对应的 lane 是否被占据</span></span><br><span class="line">            <span class="keyword">auto</span> acquire_result = _lane_arbiter-&gt;<span class="built_in">try_acquire_lane</span>(lane_owner);</span><br><span class="line">            <span class="keyword">if</span> (acquire_result == query_cache::AR_BUSY) &#123;</span><br><span class="line">                <span class="comment">// 无可用的 lane</span></span><br><span class="line">                _morsel_queue-&gt;<span class="built_in">unget</span>(std::<span class="built_in">move</span>(morsel)); </span><br><span class="line">                <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (acquire_result == query_cache::AR_PROBE) &#123;</span><br><span class="line">                <span class="comment">// 首次探测 &#123;tablet_id, version&#125;</span></span><br><span class="line">                <span class="keyword">auto</span> hit = _cache_operator-&gt;<span class="built_in">probe_cache</span>(lane_owner, version);   </span><br><span class="line">                <span class="comment">// 初始化</span></span><br><span class="line">                <span class="built_in">RETURN_IF_ERROR</span>(_cache_operator-&gt;<span class="built_in">reset_lane</span>(state, lane_owner));</span><br><span class="line">                <span class="keyword">if</span> (!hit) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// hit 则从 cache 中获取，尽早跳出循环</span></span><br><span class="line">                <span class="keyword">auto</span> [delta_version, delta_rowsets] = </span><br><span class="line">                    _cache_operator-&gt;<span class="built_in">delta_version_and_rowsets</span>(lane_owner);</span><br><span class="line">                <span class="keyword">if</span> (!delta_rowsets.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    <span class="comment">// 已经缓存的 version</span></span><br><span class="line">                    morsel-&gt;<span class="built_in">set_from_version</span>(delta_version); </span><br><span class="line">                    <span class="comment">// 对应的 rowsets</span></span><br><span class="line">                    morsel-&gt;<span class="built_in">set_rowsets</span>(delta_rowsets);      </span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="built_in">ASSIGN_OR_RETURN</span>(morsel, _morsel_queue-&gt;<span class="built_in">try_get</span>());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (acquire_result == query_cache::AR_SKIP) &#123;</span><br><span class="line">                <span class="built_in">ASSIGN_OR_RETURN</span>(morsel, _morsel_queue-&gt;<span class="built_in">try_get</span>());</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (acquire_result == query_cache::AR_IO) &#123;</span><br><span class="line">                <span class="keyword">auto</span> [delta_verrsion, delta_rowsets] = </span><br><span class="line">                    _cache_operator-&gt;<span class="built_in">delta_version_and_rowsets</span>(lane_owner);</span><br><span class="line">                <span class="keyword">if</span> (!delta_rowsets.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    morsel-&gt;<span class="built_in">set_from_version</span>(delta_verrsion);</span><br><span class="line">                    morsel-&gt;<span class="built_in">set_rowsets</span>(delta_rowsets);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="delta-version-and-rowsets"><a href="#delta-version-and-rowsets" class="headerlink" title="delta_version_and_rowsets"></a>delta_version_and_rowsets</h3><p>delta_version_and_rowsets 方法从 CacheOperator::_per_lane_buffers 中获得已经 scan 缓存的  {version, rowset} 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;<span class="type">int64_t</span>, vector&lt;RowsetSharedPtr&gt;&gt; </span><br><span class="line">CacheOperator::<span class="built_in">delta_version_and_rowsets</span>(<span class="type">int64_t</span> tablet_id) &#123;</span><br><span class="line">    <span class="keyword">auto</span> lane_it = _owner_to_lanes.<span class="built_in">find</span>(tablet_id);</span><br><span class="line">    <span class="keyword">if</span> (lane_it == _owner_to_lanes.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">0</span>, vector&lt;RowsetSharedPtr&gt;&#123;&#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane_it-&gt;second];</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(</span><br><span class="line">            buffer-&gt;cached_version + <span class="number">1</span>, buffer-&gt;rowsets);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OlapChunkSource-init-olap-reader"><a href="#OlapChunkSource-init-olap-reader" class="headerlink" title="OlapChunkSource::_init_olap_reader"></a>OlapChunkSource::_init_olap_reader</h3><p>TabletReader 初始化时，即只读取增量部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status OlapChunkSource::_init_olap_reader(RuntimeState* runtime_state) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 只读取增量数据部分</span></span><br><span class="line">    _reader = std::<span class="built_in">make_shared</span>&lt;TabletReader&gt;(_tablet, </span><br><span class="line">                                             <span class="built_in">Version</span>(_morsel-&gt;<span class="built_in">from_version</span>(), _version),</span><br><span class="line">                                             std::<span class="built_in">move</span>(child_schema),</span><br><span class="line">                                             _morsel-&gt;<span class="built_in">rowsets</span>());</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_reader-&gt;<span class="built_in">prepare</span>());</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_reader-&gt;<span class="built_in">open</span>(_params));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CacheOperator-probe-cache"><a href="#CacheOperator-probe-cache" class="headerlink" title="CacheOperator::probe_cache"></a>CacheOperator::probe_cache</h3><p>CacheMgr 是全局唯一的，在开启 QueryCache 的情况下，每次执行都会尝试去填充 CacheMgr，隐藏 cache 数据来自于两部分：</p><ul><li>当前 scan 任务填充的</li><li>之前执行任务填充的</li></ul><p>从 MorselQueue 中获得一个 mosel 之后，使用 morsel的 {tablet_id, version} 到CacheMgr中查询是否有缓存部分数据，基于缓存结果再设置 TabletReader 的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CacheOperator::probe_cache</span><span class="params">(<span class="type">int64_t</span> tablet_id, <span class="type">int64_t</span> version)</span> </span>&#123; </span><br><span class="line">    _all_tablets.<span class="built_in">insert</span>(tablet_id);</span><br><span class="line">    <span class="comment">// allocate lane and PerLaneBuffer for tablet_id</span></span><br><span class="line">    <span class="type">int64_t</span> lane = _lane_arbiter-&gt;<span class="built_in">must_acquire_lane</span>(tablet_id);</span><br><span class="line"></span><br><span class="line">    _owner_to_lanes[tablet_id] = lane;</span><br><span class="line">    <span class="keyword">auto</span>&amp; buffer = _per_lane_buffers[lane];</span><br><span class="line">    buffer-&gt;<span class="built_in">reset</span>();</span><br><span class="line">    buffer-&gt;lane = lane;</span><br><span class="line">    buffer-&gt;required_version = version;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_cache_param.force_populate </span><br><span class="line">        || !_cache_param.cache_key_prefixes.<span class="built_in">count</span>(tablet_id)) &#123;</span><br><span class="line">        buffer-&gt;state = PLBS_MISS;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// probe cache</span></span><br><span class="line">    <span class="type">const</span> std::string&amp; cache_key = </span><br><span class="line">        _cache_param.digest + _cache_param.cache_key_prefixes.<span class="built_in">at</span>(tablet_id);</span><br><span class="line">    <span class="keyword">auto</span> probe_status = _cache_mgr-&gt;<span class="built_in">probe</span>(cache_key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache MISS when failed to probe</span></span><br><span class="line">    <span class="keyword">if</span> (!probe_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        buffer-&gt;state = PLBS_MISS;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span>&amp; cache_value = probe_status.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">if</span> (cache_value.version == version) &#123;</span><br><span class="line">        <span class="comment">// Cache HIT_TOTAL when cached version equals to required version</span></span><br><span class="line">        buffer-&gt;state = PLBS_HIT_TOTAL;     <span class="comment">// 完全缓存</span></span><br><span class="line">        buffer-&gt;cached_version = cache_value.version;</span><br><span class="line">        <span class="keyword">auto</span> chunks = <span class="built_in">remap_chunks</span>(</span><br><span class="line">            cache_value.result, _cache_param.reverse_slot_remapping);</span><br><span class="line">        _update_probe_metrics(tablet_id, chunks);</span><br><span class="line">        buffer-&gt;chunks = std::<span class="built_in">move</span>(chunks);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache_value.version &gt; version) &#123;</span><br><span class="line">        <span class="comment">// It rarely happens that required version is less that cached version,</span></span><br><span class="line">        <span class="comment">// the required version become stale when the query is postponed to be</span></span><br><span class="line">        <span class="comment">// processed because of some reasons, </span></span><br><span class="line">        <span class="comment">// for examples, non-deterministic query scheduling, network congestion etc. </span></span><br><span class="line">        <span class="comment">// make queries be executed out-of-order. so we must prevent stale result </span></span><br><span class="line">        <span class="comment">// from replacing fresh cached result.</span></span><br><span class="line">        buffer-&gt;state = PLBS_MISS;</span><br><span class="line">        buffer-&gt;cached_version = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Incremental updating cause the cached value become stale, </span></span><br><span class="line">        <span class="comment">// It is a very critical and complex situation.</span></span><br><span class="line">        <span class="comment">// here we support a multi-version cache mechanism.</span></span><br><span class="line">        <span class="comment">// 处理部分缓存</span></span><br><span class="line">        _handle_stale_cache_value(tablet_id, cache_value, buffer, version); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return true on cache hit, false on cache miss</span></span><br><span class="line">    <span class="keyword">if</span> (buffer-&gt;state == PLBS_HIT_TOTAL) &#123;</span><br><span class="line">        _lane_arbiter-&gt;<span class="built_in">mark_processed</span>(tablet_id);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer-&gt;state == PLBS_HIT_PARTIAL) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="handle-stale-cache-value-for-non-pk"><a href="#handle-stale-cache-value-for-non-pk" class="headerlink" title="_handle_stale_cache_value_for_non_pk"></a>_handle_stale_cache_value_for_non_pk</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> CacheOperator::_handle_stale_cache_value_for_non_pk(<span class="type">int64_t</span> tablet_id, CacheValue&amp; cache_value,</span><br><span class="line">                                                         PerLaneBufferPtr&amp; buffer, <span class="type">int64_t</span> version) &#123;</span><br><span class="line">    <span class="comment">// Try to reuse partial cache result when cached version is less than </span></span><br><span class="line">    <span class="comment">// required version, delta versions should be captured at first.</span></span><br><span class="line">    <span class="keyword">auto</span> status = StorageEngine::<span class="built_in">instance</span>()-&gt;<span class="built_in">tablet_manager</span>()-&gt;<span class="built_in">capture_tablet_and_rowsets</span>(</span><br><span class="line">            tablet_id, cache_value.version + <span class="number">1</span>, version);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cache MISS if delta versions are not captured,</span></span><br><span class="line">    <span class="comment">//  because aggressive cumulative compactions.</span></span><br><span class="line">    <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        buffer-&gt;state = PLBS_MISS;</span><br><span class="line">        buffer-&gt;cached_version = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delta versions are captured, several situations </span></span><br><span class="line">    <span class="comment">// should be taken into consideration.</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; [tablet, rowsets, rowsets_acq_rel] = status.<span class="built_in">value</span>();</span><br><span class="line">    <span class="keyword">auto</span> all_rs_empty = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">auto</span> min_version = std::numeric_limits&lt;<span class="type">int64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="keyword">auto</span> max_version = std::numeric_limits&lt;<span class="type">int64_t</span>&gt;::<span class="built_in">min</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; rs : rowsets) &#123;</span><br><span class="line">        all_rs_empty &amp;= !rs-&gt;<span class="built_in">has_data_files</span>();</span><br><span class="line">        min_version = std::<span class="built_in">min</span>(min_version, rs-&gt;<span class="built_in">start_version</span>());</span><br><span class="line">        max_version = std::<span class="built_in">max</span>(max_version, rs-&gt;<span class="built_in">end_version</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Version <span class="title">delta_versions</span><span class="params">(min_version, max_version)</span></span>;</span><br><span class="line">    buffer-&gt;tablet = tablet;</span><br><span class="line">    <span class="keyword">auto</span> has_delete_predicates = tablet-&gt;<span class="built_in">has_delete_predicates</span>(delta_versions);</span><br><span class="line">    <span class="comment">// case 1: there exist delete predicates in delta versions, </span></span><br><span class="line">    <span class="comment">// or data model can not support multiversion cache and </span></span><br><span class="line">    <span class="comment">// the tablet has non-empty delta rowsets;</span></span><br><span class="line">    <span class="comment">// then cache result is not reuse, so cache miss.</span></span><br><span class="line">    <span class="keyword">if</span> (has_delete_predicates || (!_cache_param.can_use_multiversion &amp;&amp; !all_rs_empty)) &#123;</span><br><span class="line">        buffer-&gt;state = PLBS_MISS;</span><br><span class="line">        buffer-&gt;cached_version = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前cache的版本</span></span><br><span class="line">    buffer-&gt;cached_version = cache_value.version; </span><br><span class="line">    <span class="keyword">auto</span> chunks = <span class="built_in">remap_chunks</span>(cache_value.result, _cache_param.reverse_slot_remapping);</span><br><span class="line">    _update_probe_metrics(tablet_id, chunks);</span><br><span class="line">    <span class="comment">// 从 cache_mgr 中获得的存量</span></span><br><span class="line">    buffer-&gt;chunks = std::<span class="built_in">move</span>(chunks); </span><br><span class="line">    <span class="comment">// case 2: all delta versions are empty rowsets, so the cache result is hit totally.</span></span><br><span class="line">    <span class="keyword">if</span> (all_rs_empty) &#123;</span><br><span class="line">        buffer-&gt;state = PLBS_HIT_TOTAL;</span><br><span class="line">        buffer-&gt;chunks.<span class="built_in">back</span>()-&gt;<span class="built_in">owner_info</span>().<span class="built_in">set_last_chunk</span>(<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// case 3: otherwise, the cache result is partial result of per-tablet computation,</span></span><br><span class="line">    <span class="comment">// so delta versions must be scanned and merged </span></span><br><span class="line">    <span class="comment">// with cache result to generate total result.</span></span><br><span class="line">    buffer-&gt;state = PLBS_HIT_PARTIAL;</span><br><span class="line">    <span class="comment">// 当前cache的版本</span></span><br><span class="line">    buffer-&gt;rowsets = std::<span class="built_in">move</span>(rowsets); </span><br><span class="line">    buffer-&gt;rowsets_acq_rel = std::<span class="built_in">move</span>(rowsets_acq_rel);</span><br><span class="line">    buffer-&gt;num_rows = <span class="number">0</span>;</span><br><span class="line">    buffer-&gt;num_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; chunk : buffer-&gt;chunks) &#123;</span><br><span class="line">        buffer-&gt;num_rows += chunk-&gt;<span class="built_in">num_rows</span>();</span><br><span class="line">        buffer-&gt;num_bytes += chunk-&gt;<span class="built_in">bytes_usage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    buffer-&gt;chunks.<span class="built_in">back</span>()-&gt;<span class="built_in">owner_info</span>().<span class="built_in">set_last_chunk</span>(<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LaneArbiter"><a href="#LaneArbiter" class="headerlink" title="LaneArbiter"></a>LaneArbiter</h2><p>在 CacheOperator 中创建，然后以指针形式分享给 ScanOperator、MultiLaneOperator。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/QueryCache-4.svg?raw=true" alt="QueryCache-4"></p><p>LaneArbiter 类似于锁的作用，共有 _nun_lanes 个 slots，可以同时有 num_lane 个任务并发执行：</p><ul><li>try_acquire_lane： 执行任务前，先通过 try_acquire_lane 函数来获取 slot</li><li>release_lane： 执行任务结束，再使用 release_lane 函数来是否 slot</li></ul><h3 id="try-acquire-lane"><a href="#try-acquire-lane" class="headerlink" title="try_acquire_lane"></a>try_acquire_lane</h3><p>在获取scan任务之前，先通过 try_acquire_lane 来获得一个 slot：</p><ul><li>in_passthrough_mode &#x3D;&#x3D; true，则不考虑 query—cache</li><li>_processed.count(lane_owner) 为 1 则这个 lane_owner 已经处理完，不再考虑</li><li>_acquire_lane 函数从 _assignments 数组中获得一个处于 LANE_UNASSIGNED 状态的 lane，返回值<ul><li>NO_FREE_LANE: 表示没有可用的 slot，返回 AcquireResult::AR_BUSY</li><li>NEW_LANE_BIT: 则表示存在可用的 slot，返回 AcquireResult::AR_PROBE</li><li>otherwise，相同的 lane_onwer 再次获取 lane</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AcquireResult <span class="title">LaneArbiter::try_acquire_lane</span><span class="params">(LaneOwnerType lane_owner)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">in_passthrough_mode</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> AcquireResult::AR_IO;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 已处理过</span></span><br><span class="line">    <span class="keyword">if</span> (_processed.<span class="built_in">count</span>(lane_owner)) &#123;</span><br><span class="line">        <span class="keyword">return</span> AcquireResult::AR_SKIP;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 尚未处理</span></span><br><span class="line">    <span class="keyword">auto</span> lane = _acquire_lane(lane_owner);</span><br><span class="line">    <span class="keyword">if</span> (lane == NO_FREE_LANE) &#123;</span><br><span class="line">        <span class="keyword">return</span> AcquireResult::AR_BUSY;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">if</span> ((lane &amp; NEW_LANE_BIT) == NEW_LANE_BIT) &#123;</span><br><span class="line">        <span class="keyword">return</span> AcquireResult::AR_PROBE;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> AcquireResult::AR_IO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="release-lane"><a href="#release-lane" class="headerlink" title="release_lane"></a>release_lane</h3><p>当 CacheOperator::_per_lane_buffers 中的数据读完完毕，会调用  LaneArbiter::release_lane 函数，来标志某个 lane 已经处理完毕。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LaneArbiter::release_lane</span><span class="params">(LaneOwnerType lane_owner)</span> </span>&#123;</span><br><span class="line">    _processed.<span class="built_in">insert</span>(lane_owner);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; _assignment : _assignments) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_assignment.lane_owner == lane_owner) &#123;</span><br><span class="line">            _assignment = LANE_UNASSIGNED; <span class="comment">// 设置为初始化状态</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PipelineDriver-prepare"><a href="#PipelineDriver-prepare" class="headerlink" title="PipelineDriver::prepare"></a>PipelineDriver::prepare</h3><p>将 CacheOperator 融入到 PipelineDriver 中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PipelineDriver::prepare</span><span class="params">(RuntimeState* runtime_state)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="type">ssize_t</span> cache_op_idx = <span class="number">-1</span>;</span><br><span class="line">    query_cache::CacheOperatorPtr cache_op = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="comment">// 在一个 pipeline 中寻找 CacheOperator 的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; _operators.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cache_op = std::<span class="built_in">dynamic_pointer_cast</span>&lt;query_cache::CacheOperator&gt;(_operators[i]);</span><br><span class="line">            cache_op != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            cache_op_idx = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cache_op != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        query_cache::LaneArbiterPtr lane_arbiter = cache_op-&gt;<span class="built_in">lane_arbiter</span>();</span><br><span class="line">        query_cache::MultilaneOperators multilane_operators;</span><br><span class="line">        <span class="comment">// CacheOperator 之前的 operator 都被 wapper 在 MultilaneOperator 或者 OlapScanOperator</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; cache_op_idx; ++i) &#123;</span><br><span class="line">            <span class="keyword">auto</span>&amp; op = _operators[i];</span><br><span class="line">            <span class="comment">// 在 pipeline_builder 中构建的对应的 factory</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">auto</span>* multilane_op = <span class="built_in">dynamic_cast</span>&lt;query_cache::MultilaneOperator*&gt;(op.<span class="built_in">get</span>()); </span><br><span class="line">                multilane_op != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                multilane_op-&gt;<span class="built_in">set_lane_arbiter</span>(lane_arbiter);</span><br><span class="line">                multilane_operators.<span class="built_in">push_back</span>(multilane_op);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span>* olap_scan_op = <span class="built_in">dynamic_cast</span>&lt;OlapScanOperator*&gt;(op.<span class="built_in">get</span>()); </span><br><span class="line">                       olap_scan_op != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                olap_scan_op-&gt;<span class="built_in">set_lane_arbiter</span>(lane_arbiter);</span><br><span class="line">                <span class="comment">// 设置 cache_operator</span></span><br><span class="line">                olap_scan_op-&gt;<span class="built_in">set_cache_operator</span>(cache_op);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache_op-&gt;<span class="built_in">set_multilane_operators</span>(std::<span class="built_in">move</span>(multilane_operators));</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入数据源会被划分多个 Morsels，每个 morsel 都表征着一个要读取的数据源及其范围 {tablet_id, version}，这两个信息也包含在 scan_range 中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/szza/szz</summary>
      
    
    
    
    <category term="Pipeline" scheme="https://szza.github.io/categories/Pipeline/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>MPP: ExchangeSourceOperator 设计详解</title>
    <link href="https://szza.github.io/2023/07/31/StarRocks/Pipeline/ExchangeNode_2/"/>
    <id>https://szza.github.io/2023/07/31/StarRocks/Pipeline/ExchangeNode_2/</id>
    <published>2023-07-31T02:00:01.000Z</published>
    <updated>2023-11-03T13:12:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ExchangeSourceOperator"><a href="#ExchangeSourceOperator" class="headerlink" title="ExchangeSourceOperator"></a>ExchangeSourceOperator</h2><h3 id="DataStreamMgr-create-recvr"><a href="#DataStreamMgr-create-recvr" class="headerlink" title="DataStreamMgr::create_recvr"></a>DataStreamMgr::create_recvr</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">PassThroughChunkBuffer* <span class="title">DataStreamMgr::get_pass_through_chunk_buffer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> TUniqueId&amp; query_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _pass_through_chunk_buffer_manager.<span class="built_in">get</span>(query_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::shared_ptr&lt;DataStreamRecvr&gt; <span class="title">DataStreamMgr::create_recvr</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        RuntimeState* state, <span class="type">const</span> RowDescriptor&amp; row_desc,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> TUniqueId&amp; fragment_instance_id, PlanNodeId dest_node_id,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">int</span> num_senders, <span class="type">int</span> buffer_size, </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">const</span> std::shared_ptr&lt;RuntimeProfile&gt;&amp; profile, <span class="type">bool</span> is_merging,</span></span></span><br><span class="line"><span class="params"><span class="function">        std::shared_ptr&lt;QueryStatisticsRecvr&gt; sub_plan_query_statistics_recvr,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="type">bool</span> is_pipeline, <span class="type">int32_t</span> degree_of_parallelism, <span class="type">bool</span> keep_order)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> recvr = std::<span class="built_in">make_shared</span>&lt;DataStreamRecvr&gt;(</span><br><span class="line">                <span class="keyword">this</span>, state, row_desc, </span><br><span class="line">                fragment_instance_id, dest_node_id, num_senders, is_merging,</span><br><span class="line">                buffer_size, profile, std::<span class="built_in">move</span>(sub_plan_query_statistics_recvr),</span><br><span class="line">                is_pipeline, degree_of_parallelism,</span><br><span class="line">                keep_order,</span><br><span class="line">                <span class="built_in">get_pass_through_chunk_buffer</span>(state-&gt;<span class="built_in">query_id</span>())));</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> bucket = <span class="built_in">get_bucket</span>(fragment_instance_id);</span><br><span class="line">    <span class="keyword">auto</span>&amp; receiver_map = _receiver_map[bucket];</span><br><span class="line">    <span class="function">std::lock_guard&lt;Mutex&gt; <span class="title">l</span><span class="params">(_lock[bucket])</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> iter = receiver_map.<span class="built_in">find</span>(fragment_instance_id);</span><br><span class="line">    <span class="keyword">if</span> (iter == receiver_map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        receiver_map.<span class="built_in">emplace</span>(fragment_instance_id, std::<span class="built_in">make_shared</span>&lt;RecvrMap&gt;());</span><br><span class="line">        iter = receiver_map.<span class="built_in">find</span>(fragment_instance_id);</span><br><span class="line">        _fragment_count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    iter-&gt;second-&gt;<span class="built_in">emplace</span>(dest_node_id, recvr);</span><br><span class="line">    _receiver_count += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> recvr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ExchangeNode-set-num-senders"><a href="#ExchangeNode-set-num-senders" class="headerlink" title="ExchangeNode::set_num_senders"></a>ExchangeNode::set_num_senders</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set senders of exchange nodes before pipeline build</span></span><br><span class="line">std::vector&lt;ExecNode*&gt; exch_nodes;</span><br><span class="line">plan-&gt;<span class="built_in">collect_nodes</span>(TPlanNodeType::EXCHANGE_NODE, &amp;exch_nodes);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>* exch_node : exch_nodes) &#123;</span><br><span class="line">    <span class="type">int</span> num_senders = <span class="built_in">FindWithDefault</span>(params.per_exch_num_senders, exch_node-&gt;<span class="built_in">id</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">down_cast</span>&lt;ExchangeNode*&gt;(exch_node)-&gt;<span class="built_in">set_num_senders</span>(num_senders);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DataStreamRecvr"><a href="#DataStreamRecvr" class="headerlink" title="DataStreamRecvr"></a>DataStreamRecvr</h3><ul><li><p>is_merging 为 true 时，num_queues 为 num_senders，而 num_sender_per_queue 就是 1</p><p>  此时，_sender_queues 中有 num_queues 个 PipelineSenderQueue，每个 1 中只有一个 ChunkQueue。</p></li><li><p>is_merging 为 false 时，num_queue 为 1，而 num_sender_per_queue 为 num_senders</p><p>  此时，_sender_queues 中只有 1 个 PipelineSenderQueue，每个 PipelineSenderQueue 中有 dop 个 ChunkQueue。</p></li></ul><p>is_merging 只有在 Sort 时才会为 true，下面先视为 false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">DataStreamRecvr::<span class="built_in">DataStreamRecvr</span>(DataStreamMgr* stream_mgr, RuntimeState* runtime_state,</span><br><span class="line">                                 <span class="type">const</span> RowDescriptor&amp; row_desc,</span><br><span class="line">                                 <span class="type">const</span> TUniqueId&amp; fragment_instance_id,</span><br><span class="line">                                 PlanNodeId dest_node_id, <span class="type">int</span> num_senders,</span><br><span class="line">                                 <span class="type">bool</span> is_merging, <span class="type">int</span> total_buffer_limit,</span><br><span class="line">                                 std::shared_ptr&lt;RuntimeProfile&gt; profile,</span><br><span class="line">                                 std::shared_ptr&lt;QueryStatisticsRecvr&gt; sub_plan_query_statistics_recvr,</span><br><span class="line">                                 <span class="type">bool</span> is_pipeline, <span class="type">int32_t</span> dop, <span class="type">bool</span> keep_order,</span><br><span class="line">                                 PassThroughChunkBuffer* pass_through_chunk_buffer)</span><br><span class="line">        : _mgr(stream_mgr),</span><br><span class="line">          _fragment_instance_id(fragment_instance_id),</span><br><span class="line">          _dest_node_id(dest_node_id),</span><br><span class="line">          _total_buffer_limit(total_buffer_limit),</span><br><span class="line">          _row_desc(row_desc),</span><br><span class="line">          _is_merging(is_merging),</span><br><span class="line">          _num_buffered_bytes(<span class="number">0</span>),</span><br><span class="line">          _profile(std::<span class="built_in">move</span>(profile)),</span><br><span class="line">          _instance_profile(runtime_state-&gt;<span class="built_in">runtime_profile_ptr</span>()),</span><br><span class="line">          _query_mem_tracker(runtime_state-&gt;<span class="built_in">query_mem_tracker_ptr</span>()),</span><br><span class="line">          _instance_mem_tracker(runtime_state-&gt;<span class="built_in">instance_mem_tracker_ptr</span>()),</span><br><span class="line">          _sub_plan_query_statistics_recvr(std::<span class="built_in">move</span>(sub_plan_query_statistics_recvr)),</span><br><span class="line">          _is_pipeline(is_pipeline),</span><br><span class="line">          _degree_of_parallelism(dop),</span><br><span class="line">          _keep_order(keep_order),</span><br><span class="line">          _pass_through_context(pass_through_chunk_buffer, fragment_instance_id, dest_node_id) &#123;</span><br><span class="line">    <span class="comment">// Create one queue per sender if is_merging is true.</span></span><br><span class="line">    <span class="type">int</span> num_queues = is_merging ? num_senders : <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num_sender_per_queue = is_merging ? <span class="number">1</span> : num_senders;</span><br><span class="line">    _sender_queues.<span class="built_in">reserve</span>(num_queues);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; num_queues; ++i) &#123;</span><br><span class="line">        SenderQueue* queue = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (_is_pipeline) &#123;</span><br><span class="line">            queue = _sender_queue_pool.<span class="built_in">add</span>(<span class="keyword">new</span> <span class="built_in">PipelineSenderQueue</span>(</span><br><span class="line">                                                <span class="keyword">this</span>,</span><br><span class="line">                                                num_sender_per_queue,</span><br><span class="line">                                                is_merging ? <span class="number">1</span> : dop));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//..</span></span><br><span class="line">        &#125;</span><br><span class="line">        _sender_queues.<span class="built_in">push_back</span>(queue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the counters</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    _pass_through_context.<span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">if</span> (runtime_state-&gt;<span class="built_in">query_options</span>().__isset.transmission_encode_level) &#123;</span><br><span class="line">        _encode_level = runtime_state-&gt;<span class="built_in">query_options</span>().transmission_encode_level;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DataStreamRecvr::PipelineSenderQueue::<span class="built_in">PipelineSenderQueue</span>(</span><br><span class="line">    DataStreamRecvr* parent_recvr, <span class="type">int32_t</span> num_senders, <span class="type">int32_t</span> degree_of_parallism)</span><br><span class="line">        : <span class="built_in">SenderQueue</span>(parent_recvr),</span><br><span class="line">          _num_remaining_senders(num_senders),</span><br><span class="line">          _chunk_queues(degree_of_parallism),</span><br><span class="line">          _chunk_queue_states(degree_of_parallism) &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent_recvr-&gt;_is_merging) &#123;</span><br><span class="line">        _producer_token = std::<span class="built_in">make_unique</span>&lt;ChunkQueue::<span class="type">producer_token_t</span>&gt;(_chunk_queues[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transmit-chunk"><a href="#transmit-chunk" class="headerlink" title="transmit_chunk"></a>transmit_chunk</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DataStreamMgr::transmit_chunk</span><span class="params">(<span class="type">const</span> PTransmitChunkParams&amp; request, ::google::protobuf::Closure** done)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> PUniqueId&amp; finst_id = request.<span class="built_in">finst_id</span>();</span><br><span class="line">    TUniqueId t_finst_id;</span><br><span class="line">    t_finst_id.hi = finst_id.<span class="built_in">hi</span>();</span><br><span class="line">    t_finst_id.lo = finst_id.<span class="built_in">lo</span>();</span><br><span class="line">    std::shared_ptr&lt;DataStreamRecvr&gt; recvr = <span class="built_in">find_recvr</span>(t_finst_id, request.<span class="built_in">node_id</span>());</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(recvr == <span class="literal">nullptr</span>, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.<span class="built_in">has_query_statistics</span>()) &#123;</span><br><span class="line">        recvr-&gt;<span class="built_in">add_sub_plan_statistics</span>(request.<span class="built_in">query_statistics</span>(), request.<span class="built_in">sender_id</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DeferOp <span class="title">op</span><span class="params">([&amp;eos, &amp;recvr, &amp;request]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (request.eos()) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            recvr-&gt;remove_sender(request.sender_id(), request.be_number());</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (request.<span class="built_in">chunks_size</span>() &gt; <span class="number">0</span> || request.<span class="built_in">use_pass_through</span>()) &#123;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(recvr-&gt;<span class="built_in">add_chunks</span>(request, request.<span class="built_in">eos</span>() ? <span class="literal">nullptr</span> : done));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DataStreamRecvr-add-chunks"><a href="#DataStreamRecvr-add-chunks" class="headerlink" title="DataStreamRecvr::add_chunks"></a>DataStreamRecvr::add_chunks</h4><p>BE 在接受到 <em>transmit_chunk</em> RPC 后，就会调用 DataStreamRecvr::add_chunks 函数来处理请求。先基于 sender_id 将定位到具体的 SenderQueue，即 _sender_queues[sender_id]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DataStreamRecvr::add_chunks</span><span class="params">(<span class="type">const</span> PTransmitChunkParams&amp; request, ::google::protobuf::Closure** done)</span> </span>&#123;</span><br><span class="line">    MemTracker* prev_tracker = tls_thread_status.<span class="built_in">set_mem_tracker</span>(_instance_mem_tracker.<span class="built_in">get</span>());</span><br><span class="line">    <span class="function">DeferOp <span class="title">op</span><span class="params">([&amp;] &#123; tls_thread_status.set_mem_tracker(prev_tracker); &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SCOPED_TIMER</span>(_process_total_timer);</span><br><span class="line">    <span class="built_in">SCOPED_TIMER</span>(_sender_total_timer);</span><br><span class="line">    <span class="built_in">COUNTER_UPDATE</span>(_request_received_counter, <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> sender_id = _is_merging ? request.<span class="built_in">sender_id</span>() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// Add all batches to the same queue if _is_merging is false.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_keep_order) &#123;</span><br><span class="line">        <span class="built_in">DCHECK</span>(_is_pipeline);</span><br><span class="line">        <span class="keyword">return</span> _sender_queues[sender_id]-&gt;<span class="built_in">add_chunks_and_keep_order</span>(request, done);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _sender_queues[sender_id]-&gt;<span class="built_in">add_chunks</span>(request, done);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PipelineSenderQueue-add-chunks"><a href="#PipelineSenderQueue-add-chunks" class="headerlink" title="PipelineSenderQueue::add_chunks"></a>PipelineSenderQueue::add_chunks</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> keep_order&gt;</span><br><span class="line">Status DataStreamRecvr::PipelineSenderQueue::<span class="built_in">add_chunks</span>(<span class="type">const</span> PTransmitChunkParams&amp; request,</span><br><span class="line">                                                        ::google::protobuf::Closure** done) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">bool</span> use_pass_through = request.<span class="built_in">use_pass_through</span>();</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_is_cancelled || _num_remaining_senders &lt;= <span class="number">0</span>, Status::<span class="built_in">OK</span>());</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(<span class="built_in">try_to_build_chunk_meta</span>(request));</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> total_chunk_bytes = <span class="number">0</span>;</span><br><span class="line">    _is_pipeline_level_shuffle = </span><br><span class="line">        request.<span class="built_in">has_is_pipeline_level_shuffle</span>() &amp;&amp; request.<span class="built_in">is_pipeline_level_shuffle</span>();</span><br><span class="line"></span><br><span class="line">    ChunkList chunks = use_pass_through</span><br><span class="line">        ? <span class="built_in">get_chunks_from_pass_through</span>(request.<span class="built_in">sender_id</span>(), total_chunk_bytes)</span><br><span class="line">        : <span class="built_in">get_chunks_from_request</span>&lt;<span class="literal">false</span>&gt;(request, total_chunk_bytes)));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_is_cancelled, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove the short-circuited chunks</span></span><br><span class="line">    <span class="keyword">if</span> (_is_pipeline_level_shuffle) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> iter = chunks.<span class="built_in">begin</span>(); iter != chunks.<span class="built_in">end</span>();) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_chunk_queue_states[iter-&gt;driver_sequence].is_short_circuited) &#123;</span><br><span class="line">                total_chunk_bytes -= iter-&gt;chunk_bytes;</span><br><span class="line">                chunks.<span class="built_in">erase</span>(iter++);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            iter++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!chunks.<span class="built_in">empty</span>() &amp;&amp; done != <span class="literal">nullptr</span> &amp;&amp; _recvr-&gt;<span class="built_in">exceeds_limit</span>(total_chunk_bytes)) &#123;</span><br><span class="line">        chunks.<span class="built_in">back</span>().closure = *done;</span><br><span class="line">        chunks.<span class="built_in">back</span>().queue_enter_time = <span class="built_in">MonotonicNanos</span>();</span><br><span class="line">        *done = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp;&amp; chunk : chunks) &#123;</span><br><span class="line">        <span class="type">int</span> driver_seq = _is_pipeline_level_shuffle ? chunk.driver_sequence : <span class="number">0</span>;</span><br><span class="line">        <span class="type">size_t</span> chunk_bytes = chunk.chunk_bytes;</span><br><span class="line">        <span class="keyword">auto</span>* closure = chunk.closure;</span><br><span class="line">        _chunk_queues[driver_seq].<span class="built_in">enqueue</span>(std::<span class="built_in">move</span>(chunk));</span><br><span class="line">        _chunk_queue_states[driver_seq].blocked_closure_num += closure != <span class="literal">nullptr</span>;</span><br><span class="line">        _total_chunks++;</span><br><span class="line">        <span class="keyword">if</span> (_chunk_queue_states[driver_seq].is_short_circuited) &#123;</span><br><span class="line">            <span class="built_in">short_circuit</span>(driver_seq);</span><br><span class="line">        &#125;</span><br><span class="line">        _recvr-&gt;_num_buffered_bytes += chunk_bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="pull-chunk"><a href="#pull-chunk" class="headerlink" title="pull_chunk"></a>pull_chunk</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;vectorized::ChunkPtr&gt; <span class="title">ExchangeSourceOperator::pull_chunk</span><span class="params">(RuntimeState* state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> chunk = std::<span class="built_in">make_unique</span>&lt;vectorized::Chunk&gt;();</span><br><span class="line">    <span class="built_in">RETURN_IF_ERROR</span>(_stream_recvr-&gt;<span class="built_in">get_chunk_for_pipeline</span>(&amp;chunk, _driver_sequence));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">eval_runtime_bloom_filters</span>(chunk.<span class="built_in">get</span>());</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">move</span>(chunk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DataStreamRecvr-get-chunk-for-pipeline"><a href="#DataStreamRecvr-get-chunk-for-pipeline" class="headerlink" title="DataStreamRecvr::get_chunk_for_pipeline"></a>DataStreamRecvr::get_chunk_for_pipeline</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DataStreamRecvr::get_chunk_for_pipeline</span><span class="params">(std::unique_ptr&lt;vectorized::Chunk&gt;* chunk,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               <span class="type">const</span> <span class="type">int32_t</span> driver_sequence)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!_is_merging);</span><br><span class="line">    <span class="built_in">DCHECK_EQ</span>(_sender_queues.<span class="built_in">size</span>(), <span class="number">1</span>);</span><br><span class="line">    vectorized::Chunk* tmp_chunk = <span class="literal">nullptr</span>;</span><br><span class="line">    Status status = _sender_queues[<span class="number">0</span>]-&gt;<span class="built_in">get_chunk</span>(&amp;tmp_chunk, driver_sequence);</span><br><span class="line">    chunk-&gt;<span class="built_in">reset</span>(tmp_chunk);</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PipelineSenderQueue-get-chunk"><a href="#PipelineSenderQueue-get-chunk" class="headerlink" title="PipelineSenderQueue::get_chunk"></a>PipelineSenderQueue::get_chunk</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Status DataStreamRecvr::PipelineSenderQueue::<span class="built_in">get_chunk</span>(vectorized::Chunk** chunk, <span class="type">const</span> <span class="type">int32_t</span> driver_sequence) &#123;</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_is_cancelled, Status::<span class="built_in">Cancelled</span>(<span class="string">&quot;Cancelled&quot;</span>));</span><br><span class="line">   </span><br><span class="line">    <span class="type">size_t</span> index = _is_pipeline_level_shuffle ? driver_sequence : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp; chunk_queue = _chunk_queues[index];</span><br><span class="line">    <span class="keyword">auto</span>&amp; chunk_queue_state = _chunk_queue_states[index];</span><br><span class="line"></span><br><span class="line">    ChunkItem item;</span><br><span class="line">    <span class="keyword">if</span> (!chunk_queue.<span class="built_in">try_dequeue</span>(item)) &#123;</span><br><span class="line">        chunk_queue_state.unpluging = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DeferOp <span class="title">defer_op</span><span class="params">([&amp;]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">auto</span>* closure = item.closure;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (closure != <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            MemTracker* prev_tracker = tls_thread_status.set_mem_tracker(</span></span></span><br><span class="line"><span class="params"><span class="function">                ExecEnv::GetInstance()-&gt;process_mem_tracker());</span></span></span><br><span class="line"><span class="params"><span class="function">            DeferOp op([&amp;] &#123; tls_thread_status.set_mem_tracker(prev_tracker); &#125;);</span></span></span><br><span class="line"><span class="params"><span class="function">            closure-&gt;Run();</span></span></span><br><span class="line"><span class="params"><span class="function">            chunk_queue_state.blocked_closure_num--;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (item.chunk_ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ChunkUniquePtr chunk_ptr = std::<span class="built_in">make_unique</span>&lt;vectorized::Chunk&gt;();</span><br><span class="line">        faststring uncompressed_buffer;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_deserialize_chunk(item.pchunk, chunk_ptr.<span class="built_in">get</span>(), &amp;uncompressed_buffer));</span><br><span class="line">        *chunk = chunk_ptr.<span class="built_in">release</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        *chunk = item.chunk_ptr.<span class="built_in">release</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _total_chunks--;</span><br><span class="line">    _recvr-&gt;_num_buffered_bytes -= item.chunk_bytes;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.zhihu.com/collection/853861081">StarRocks Exchange 算子源码解析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ExchangeSourceOperator&quot;&gt;&lt;a href=&quot;#ExchangeSourceOperator&quot; class=&quot;headerlink&quot; title=&quot;ExchangeSourceOperator&quot;&gt;&lt;/a&gt;ExchangeSourceOperat</summary>
      
    
    
    
    <category term="Pipeline" scheme="https://szza.github.io/categories/Pipeline/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>MPP: ExchangeSinkOperator 详解 RPC 有序性保证和数据 shuffle</title>
    <link href="https://szza.github.io/2023/07/30/StarRocks/Pipeline/ExchangeNode_1/"/>
    <id>https://szza.github.io/2023/07/30/StarRocks/Pipeline/ExchangeNode_1/</id>
    <published>2023-07-30T02:00:01.000Z</published>
    <updated>2023-11-03T13:12:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇所述都单个 FragmentInstance 内的执行流。StarRocks 是 MPP 架构，并发执行多个 FragmentInstances。因此就涉及到多个 FragmentInstances 之间数据通信，FragmentExecutor 在构造每个 PipelineDriver 时，最后一个 Operator 肯定是 Sink。如果 Sink 的对端是另一个 FragmentInstance，则 Sink 会是 ExchangeSinkOperator，接受端使用 ExchangeSourceOperator 来接受数据。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-FragmentInstance-1.svg?raw=true" alt="Pipeline-FragmentInstance-1"></p><p>StarRocks 输入输出的 Buffer 都是所有 PipelineDrivers 共享的，这也符合论文 <a href="https://szza.github.io/2023/04/02/Paper/Morsel-Driven-Parallelism">Morsel-Driven-Parallelism</a> 所述的设计。</p><p>同样，ExchangeSinkOperator 中的 SinkBuffer 也是在所有 PipelineDrivers 间共享。从构造 ExchangeSinkOperatorFactory 到 ExchangeSinkOperator 如下。</p><h2 id="create-exchange-sink"><a href="#create-exchange-sink" class="headerlink" title="create_exchange_sink"></a>create_exchange_sink</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;ExchangeSinkOperatorFactory&gt; _create_exchange_sink_operator(</span><br><span class="line">    PipelineBuilderContext* context, <span class="type">const</span> TDataStreamSink&amp; stream_sink,</span><br><span class="line">    <span class="type">const</span> DataStreamSender* sender, <span class="type">size_t</span> dop) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> fragment_ctx = context-&gt;<span class="built_in">fragment_context</span>();</span><br><span class="line">    <span class="type">bool</span> is_dest_merge = stream_sink.__isset.is_merge &amp;&amp; stream_sink.is_merge;</span><br><span class="line">    TPartitionType part_type = sender-&gt;<span class="built_in">get_partition_type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> is_pipeline_level_shuffle = <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int32_t</span> dest_dop = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">        part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">        dest_dop = stream_sink.dest_dop;</span><br><span class="line">        is_pipeline_level_shuffle = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">DCHECK_GT</span>(dest_dop, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 1. 构造 sink_buffer </span></span><br><span class="line">    std::shared_ptr&lt;SinkBuffer&gt; sink_buffer = std::<span class="built_in">make_shared</span>&lt;SinkBuffer&gt;(</span><br><span class="line">        fragment_ctx, sender-&gt;<span class="built_in">destinations</span>(), is_dest_merge, dop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ExchangeSinkOperatorFactory&gt;(</span><br><span class="line">            context-&gt;<span class="built_in">next_operator_id</span>(), stream_sink.dest_node_id,</span><br><span class="line">            sink_buffer, <span class="comment">// 传递给 ExchangeSinkOperatorFactory</span></span><br><span class="line">            sender-&gt;<span class="built_in">get_partition_type</span>(),</span><br><span class="line">            sender-&gt;<span class="built_in">destinations</span>(), is_pipeline_level_shuffle,</span><br><span class="line">            dest_dop, sender-&gt;<span class="built_in">sender_id</span>(),</span><br><span class="line">            sender-&gt;<span class="built_in">get_dest_node_id</span>(), sender-&gt;<span class="built_in">get_partition_exprs</span>(),</span><br><span class="line">            !is_dest_merge &amp;&amp; sender-&gt;<span class="built_in">get_enable_exchange_pass_through</span>(),</span><br><span class="line">            sender-&gt;<span class="built_in">get_enable_exchange_perf</span>() &amp;&amp; !context-&gt;has_aggregation,</span><br><span class="line">            fragment_ctx, sender-&gt;<span class="built_in">output_columns</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 ExchangeSinkOperator</span></span><br><span class="line"><span class="function">OperatorPtr <span class="title">ExchangeSinkOperatorFactory::create</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int32_t</span> degree_of_parallelism, <span class="type">int32_t</span> driver_sequence)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_shared</span>&lt;ExchangeSinkOperator&gt;(</span><br><span class="line">            <span class="keyword">this</span>, _id, _plan_node_id,</span><br><span class="line">            driver_sequence,  <span class="comment">// 具体的 PipelineDriver</span></span><br><span class="line">            _buffer,          <span class="comment">// 传递给所有的 PipelineDrivers</span></span><br><span class="line">            _part_type,</span><br><span class="line">            _destinations,</span><br><span class="line">            _is_pipeline_level_shuffle,</span><br><span class="line">            _num_shuffles_per_channel,</span><br><span class="line">            _sender_id, _dest_node_id,</span><br><span class="line">            _partition_expr_ctxs,</span><br><span class="line">            _enable_exchange_pass_through,</span><br><span class="line">            _enable_exchange_perf,</span><br><span class="line">            _fragment_ctx,</span><br><span class="line">            _output_columns);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>ExchangeSinkOperator 构造函数中的 <em>_destinations</em> 表示所有的对端，即 Sink 的接受者，每一个 _destinations[i] 都被封装为一个 ExchangeSinkOperator::Channel 对象，并通过 Channel 对象向对端发送 RPC，但是内部通过 SinkBuffer::_try_to_send_rpc 函数发出去的。</p><p>此外，Channel 对象还可以判断是否与对端在同一个BE进程中，如果在一个 BE 进程中，则不用 PRC 跨进程通信，转而使用共享内存的方式。</p><p>Channel 构造函数如下：</p><ul><li>_brpc_dest_addr: 对端 BE 的 bRPC 监听地址 ipport</li><li>_fragment_instance_id: 对端 BE 上的 fragment_instance</li><li>_dest_node_id: 接受数据的 ExchangeSourceOperator 所属的 ExchangeNode id</li></ul><p>这三个信息就可以唯一确定谁接受消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Channel</span>(ExchangeSinkOperator* parent, </span><br><span class="line">    <span class="type">const</span> TNetworkAddress&amp; brpc_dest,</span><br><span class="line">    <span class="type">const</span> TUniqueId&amp; fragment_instance_id,</span><br><span class="line">    PlanNodeId dest_node_id, </span><br><span class="line">    <span class="type">int32_t</span> num_shuffles,</span><br><span class="line">    <span class="type">bool</span> enable_exchange_pass_through,</span><br><span class="line">    <span class="type">bool</span> enable_exchange_perf,</span><br><span class="line">    PassThroughChunkBuffer* pass_through_chunk_buffer)</span><br><span class="line">    : _parent(parent),</span><br><span class="line">      _brpc_dest_addr(brpc_dest),</span><br><span class="line">      _fragment_instance_id(fragment_instance_id),</span><br><span class="line">      _dest_node_id(dest_node_id),</span><br><span class="line">      _enable_exchange_pass_through(enable_exchange_pass_through),</span><br><span class="line">      _enable_exchange_perf(enable_exchange_perf),</span><br><span class="line">      _pass_through_context(pass_through_chunk_buffer,</span><br><span class="line">                            fragment_instance_id,</span><br><span class="line">                            dest_node_id),</span><br><span class="line">      _chunks(num_shuffles) &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="Channel-is-local"><a href="#Channel-is-local" class="headerlink" title="Channel::is_local"></a>Channel::is_local</h3><p>is_local 函数用于判断和对端是否在 同一个 BE 进程中。此外，_enable_exchange_pass_through 是由于 FE 传递过来的参数，可以由用户更改是否开启 PassThrough 模式，默认值为 true。若 _enable_exchange_pass_through 为 true，且和对端在一个 BE 进程中，则 _use_pass_through 为 true，后续数据传输就不走 RPC 了，而是通过 <strong>_pass_through_context</strong> 在两个 FragmentInstance 之间传递数据。</p><blockquote><p>这个设计就是通过共享内存在多线程间传递数据</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> ExchangeSinkOperator::Channel::<span class="built_in">is_local</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (BackendOptions::<span class="built_in">get_localhost</span>() != _brpc_dest_addr.hostname) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (config::brpc_port != _brpc_dest_addr.port) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ExchangeSinkOperator::Channel::_check_use_pass_through() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_enable_exchange_pass_through) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">is_local</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> ExchangeSinkOperator::Channel::_prepare_pass_through() &#123;</span><br><span class="line">    _pass_through_context.<span class="built_in">init</span>();</span><br><span class="line">    _use_pass_through = _check_use_pass_through();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PTransmitChunkParams"><a href="#PTransmitChunkParams" class="headerlink" title="PTransmitChunkParams"></a>PTransmitChunkParams</h3><p>在讲解 Channel::send_one_chunk 发送消息之前，先说下传输数据的 proto 格式。如下 PTransmitChunkParams 就是数据传输协议。</p><ul><li>eos: 表示本次 PRC 是否是最后一个 chunk</li><li>sequence: 本次 RPC 请求的序号</li><li>chunks: RPC 是批量发送模式，chunks 中包含了多次 RPC 数据</li><li>use_pass_through: false 时对端从 chunks 中反序列得到数据，true 时从共享内存中获得数据</li><li>is_pipeline_level_shuffle: 其赋值见上文的 _create_exchange_sink_operator 函数</li><li>driver_sequences: 在 <em>is_pipeline_level_shuffle</em> 为 true 时生效。此时和 driver_sequences_size 和 chunks_size 一样，每个 chunk[i] 直接写入 driver_sequences[i] 对应的 PipelineDriver 的输入源。</li></ul><p>全部字段如下。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">message </span><span class="title class_">PTransmitChunkParams</span> &#123;</span><br><span class="line">    <span class="comment">// non-change member</span></span><br><span class="line">    <span class="keyword">optional</span> PUniqueId finst_id = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> node_id = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// Id of this fragment in its role as a sender.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> sender_id = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int32</span> be_number = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">// If set to true, indicates that no more row batches will be sent</span></span><br><span class="line">    <span class="comment">// for this dest_node_id.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">bool</span> eos = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">// RPC sequence number for the send channel.</span></span><br><span class="line">    <span class="comment">// Sever will check this number to see if some packet has lost.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">int64</span> sequence = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The protobuf data structure for column chunk.</span></span><br><span class="line">    <span class="keyword">repeated</span> ChunkPB chunks = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Some statistics for the runing query.</span></span><br><span class="line">    <span class="keyword">optional</span> PQueryStatistics query_statistics = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="type">bool</span> use_pass_through = <span class="number">9</span> [default = <span class="literal">false</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Whether enable pipeline level shuffle.</span></span><br><span class="line">    <span class="keyword">optional</span> <span class="type">bool</span> is_pipeline_level_shuffle = <span class="number">10</span> [default = <span class="literal">false</span>];</span><br><span class="line">    <span class="comment">// Driver sequences of pipeline level shuffle.</span></span><br><span class="line">    <span class="keyword">repeated</span> <span class="type">int32</span> driver_sequences = <span class="number">11</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Channel-send-one-chunk"><a href="#Channel-send-one-chunk" class="headerlink" title="Channel::send_one_chunk"></a>Channel::send_one_chunk</h3><p>Channel 有三种方式发送RPC 数据:</p><ul><li>send_chunk_request 是直接发送 RPC 请求，</li><li>send_one_chunk 是批量发送 RPC 数据，超过大小阈值或者最后一个 RPC 才会发送</li><li>add_rows_selective 也是批量模式，不过会先对输入 Chunk 进行筛选后再调用 send_one_chunk。</li></ul><p>这里以 send_one_chunk 为例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Status ExchangeSinkOperator::Channel::<span class="built_in">send_one_chunk</span>(RuntimeState* state,</span><br><span class="line">                                                     <span class="type">const</span> Chunk* chunk, </span><br><span class="line">                                                     <span class="type">int32_t</span> driver_sequence,</span><br><span class="line">                                                     <span class="type">bool</span> eos, </span><br><span class="line">                                                     <span class="type">bool</span>* is_real_sent) &#123;</span><br><span class="line"></span><br><span class="line">    *is_real_sent = <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_ignore_local_data &amp;&amp; !eos, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_chunk_request == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        _chunk_request = std::<span class="built_in">make_shared</span>&lt;PTransmitChunkParams&gt;();</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_node_id</span>(_dest_node_id);</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_sender_id</span>(_parent-&gt;_sender_id);</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_be_number</span>(_parent-&gt;_be_number);</span><br><span class="line">        <span class="keyword">if</span> (_parent-&gt;_is_pipeline_level_shuffle) &#123;</span><br><span class="line">            _chunk_request-&gt;<span class="built_in">set_is_pipeline_level_shuffle</span>(<span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. batch 数据</span></span><br><span class="line">    <span class="keyword">if</span> (chunk != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_use_pass_through) &#123;</span><br><span class="line">            <span class="comment">// 1.1 使用共享内存方式传递数据</span></span><br><span class="line">            <span class="comment">//     发送端没有序列化，对端接受到数据也不用反序列化</span></span><br><span class="line">            <span class="type">size_t</span> chunk_size = </span><br><span class="line">                serde::ProtobufChunkSerde::<span class="built_in">max_serialized_size</span>(*chunk);</span><br><span class="line">            <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(_pass_through_context.<span class="built_in">append_chunk</span>(</span><br><span class="line">                        _parent-&gt;_sender_id, chunk, chunk_size,</span><br><span class="line">                        _parent-&gt;_is_pipeline_level_shuffle </span><br><span class="line">                         ? driver_sequence : <span class="number">-1</span>));</span><br><span class="line">            _current_request_bytes += chunk_size;</span><br><span class="line">            <span class="built_in">COUNTER_UPDATE</span>(_parent-&gt;_bytes_pass_through_counter, chunk_size);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2 RPC 方式通信，则攒批</span></span><br><span class="line">            <span class="keyword">if</span> (_parent-&gt;_is_pipeline_level_shuffle) &#123;</span><br><span class="line">                _chunk_request-&gt;<span class="built_in">add_driver_sequences</span>(driver_sequence);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 数据序列化后添加到 pchunk 中</span></span><br><span class="line">            <span class="keyword">auto</span> pchunk = _chunk_request-&gt;<span class="built_in">add_chunks</span>();</span><br><span class="line">            <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(<span class="built_in">RETURN_IF_ERROR</span>(_parent-&gt;<span class="built_in">serialize_chunk</span>(</span><br><span class="line">                chunk, pchunk, &amp;_is_first_chunk)));</span><br><span class="line">            _current_request_bytes += pchunk-&gt;<span class="built_in">data</span>().<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 真正的发送消息</span></span><br><span class="line">    <span class="comment">//    条件是: batched 的数据超过内存限制，或者是最后一条数据（eos 为 true）</span></span><br><span class="line">    <span class="keyword">if</span> (_current_request_bytes &gt; config::max_transmit_batched_bytes || eos) &#123;</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_eos</span>(eos);</span><br><span class="line">        _chunk_request-&gt;<span class="built_in">set_use_pass_through</span>(_use_pass_through);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> delta_statistic = state-&gt;<span class="built_in">intermediate_query_statistic</span>()) &#123;</span><br><span class="line">            delta_statistic-&gt;<span class="built_in">to_pb</span>(_chunk_request-&gt;<span class="built_in">mutable_query_statistics</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        butil::IOBuf attachment;</span><br><span class="line">        <span class="type">int64_t</span> attachment_physical_bytes = </span><br><span class="line">            _parent-&gt;<span class="built_in">construct_brpc_attachment</span>(_chunk_request, attachment);</span><br><span class="line">        TransmitChunkInfo info &#123;_fragment_instance_id, _brpc_stub,</span><br><span class="line">                                 std::<span class="built_in">move</span>(_chunk_request),</span><br><span class="line">                                 attachment, attachment_physical_bytes,</span><br><span class="line">                                 _brpc_dest_addr&#125;;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_parent-&gt;_buffer-&gt;<span class="built_in">add_request</span>(info));</span><br><span class="line">        _current_request_bytes = <span class="number">0</span>;</span><br><span class="line">        *is_real_sent = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SinkBuffer-add-request"><a href="#SinkBuffer-add-request" class="headerlink" title="SinkBuffer::add_request"></a>SinkBuffer::add_request</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">SinkBuffer::add_request</span><span class="params">(TransmitChunkInfo&amp; request)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_is_finishing, Status::<span class="built_in">OK</span>());</span><br><span class="line">    <span class="keyword">if</span> (!request.attachment.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        _bytes_enqueued += request.attachment.<span class="built_in">size</span>();</span><br><span class="line">        _request_enqueued++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span>&amp; instance_id = request.fragment_instance_id;</span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(_try_to_send_rpc(instance_id, </span><br><span class="line">            [&amp;]() &#123; _buffers[instance_id.lo].<span class="built_in">push</span>(request); &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SinkBuffer-try-to-send-rpc"><a href="#SinkBuffer-try-to-send-rpc" class="headerlink" title="SinkBuffer::_try_to_send_rpc"></a>SinkBuffer::_try_to_send_rpc</h3><p>SinkBuffer 设计要稍微复杂点，因为要考虑顺序。下面将 _try_to_send_rpc 函数分解为4部分来剖析细节。完整代码见 <a href="https://github.com/StarRocks/starrocks/blob/fbfb7ed80e284d349694adbb57d3f1c643e46e58/be/src/exec/pipeline/exchange/sink_buffer.cpp#L257C1-L257C1">_try_to_send_rpc</a>。</p><h4 id="Part1-callback"><a href="#Part1-callback" class="headerlink" title="Part1: callback"></a>Part1: callback</h4><p>_try_to_send_rpc 函数第二个参数 <em>pre_works_cb</em> 会在发送 RPC 之前执行，比如上面 add_request 函数传入的 cb 是将新增的 RPC 请求 request 添加到 _buffers[instance_id.lo] 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">    <span class="comment">//! 注意：这里是有 mutex</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;Mutex&gt; <span class="title">l</span><span class="params">(*_mutexes[instance_id.lo])</span></span>;</span><br><span class="line">    <span class="built_in">pre_works_cb</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">DeferOp <span class="title">decrease_defer</span><span class="params">([<span class="keyword">this</span>]() &#123; --_num_sending_rpc; &#125;)</span></span>;</span><br><span class="line">    ++_num_sending_rpc;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part2-限流"><a href="#Part2-限流" class="headerlink" title="Part2: 限流"></a>Part2: 限流</h4><p>_buffers[instance_id] 中存储的是所有待发送给 instance_id 的 RPCs。在发送 RPC 之前会先检测下是否需要限流:  </p><ul><li><p>_is_dest_merge 为 true，此时需要保证发送顺序性<br>  比如 SQL 中包含 ORDER BY，TOPN 等操作时，要求输出结果有序。在 FragmentInstances 之间交换数据时，需要发送端和接收端一起保证顺序性，实现方式类似 TCP 滑动窗口。</p><p>  如图，_request_seqs[instance_id] 记录的是给 instance_id 实例已发送 RPC 的最大序号，_max_continuous_acked_seqs[instance_id] 记录的是 instance_id 已回应 RPC 的最大连续序号，差值是不连续的窗口大小 <em>discontinuous_acked_window_size</em></p><p>  此时限流的标准是该 window_size 不能超过阈值 <em>config::pipeline_sink_brpc_dop</em>（默认值 64），<strong>防止乱序数据太多</strong>。</p><p>  <img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-2.svg?raw=true" alt="StarRocks/Pipeline-ExchangeNode-2"></p></li><li><p>_is_dest_merge 为 false，此时不需要保证发送的顺序性</p><p> _num_in_flight_rpcs[instance_id] 记录的是已发送给 instance_id 但尚未收到 response 的 PRC 数量，该数据量不能超过阈值 config::pipeline_sink_brpc_dop（默认值 64），如果超过则暂停发送，<strong>防止对端处理不过来</strong>。</p></li></ul><p>限流代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">  <span class="comment">//...above code</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// part2</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(_is_finishing, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 限流</span></span><br><span class="line">    <span class="type">int64_t</span> too_much_rpc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (_is_dest_merge) &#123;</span><br><span class="line">      <span class="type">int64_t</span> discontinuous_acked_window_size =</span><br><span class="line">        _request_seqs[instance_id.lo] - _max_continuous_acked_seqs[instance_id.lo];</span><br><span class="line">      too_much_brpc_process = </span><br><span class="line">        discontinuous_acked_window_size &gt;= config::pipeline_sink_brpc_dop;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      too_much_brpc_process = </span><br><span class="line">        _num_in_flight_rpcs[instance_id.lo] &gt;= config::pipeline_sink_brpc_dop;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">RETURN_IF</span> (buffer.<span class="built_in">empty</span>() || too_much_rpc, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br></pre></td></tr></table></figure><h4 id="Part3-Order"><a href="#Part3-Order" class="headerlink" title="Part3: Order"></a>Part3: Order</h4><p>顺序性保证，要求发送过程如下:</p><ul><li>必须等收到第一个 RPC 的 response 之后，后续 RPCs 才能发送出去，保证基准不会出问题</li><li>最后一个 RPC（即 eos 为 true 的 RPC）必须是最后一个发送给对端，用于通知对端后续不会再有数据发送，让对端做好 finishing 操作</li><li>中间 RPCs 可以一定程度的乱序，但是通过 _max_continuous_acked_seqs 来维护总体的有序性</li></ul><p>所以，一共有两处需要等待（need_wait 为 true):</p><ol><li><p>中间的 RPCs 需要等待收到第一个 RPC 的 response</p><p> _num_finished_rpcs[instance_id] &#x3D;&#x3D; 0 和 _num_in_flight_rpcs[instance_id] &gt; 0 就能说明还没收到第一个 RPC 的 response。</p></li><li><p>最后一个 RPC 需要等待前面所有的 RPCs 都都收到 response</p><p>_num_remaining_eos 和 _num_sinkers 可以用来确定当前 RPC 是否为发送给 instance_id 实例的最后一个 EOS RPC. 它们在构造函数中赋值如下：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; dest : destinations) &#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; instance_id = dest.fragment_instance_id;</span><br><span class="line">  _num_sinkers[instance_id] = _num_sinkers; </span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line">_num_remaining_eos = _num_sinkers.<span class="built_in">size</span>() * num_sinkers;</span><br></pre></td></tr></table></figure><p> _num_sinkers 在 <em>_create_exchange_sink_operator</em> 函数中被赋值为 dop，如果 _num_sinkers[instance_id] 为 0，则表示当前 Sink 给 instance_id 对应的 FragmentInstance 实例的所有 PipelineDrivers ExchangeSourceOperator 该发送的数据都发送了，此时就需要给 RPC request 中的 eos 标志设为 true，告知对端不会再有数据了（即 ExchangeSourceOperator 即将进入 OperatorStage::FINISHING 阶段）。</p></li></ol><p>Part3 就是做上述两处检测。当 <em>need_wait</em> 为 true，当前 RPC 不会被发送给对端，即从 _buffer[instance_id] 中取出的 RPC request 不会被 pop 出去。</p><blockquote><p>DeferOp 是基于 RAII 设计的类，在 DeferOp 对象离开作用域时调用传入的回调函数。</p></blockquote><p>核心代码及其注释如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 2. 提取待发送的 RPC request</span></span><br><span class="line">        TransmitChunkInfo&amp; request = buffer.<span class="built_in">front</span>();</span><br><span class="line">        <span class="type">bool</span> need_wait = <span class="literal">false</span>;</span><br><span class="line">        <span class="function">DeferOp <span class="title">pop_defer</span><span class="params">([&amp;need_wait, &amp;buffer, mem_tracker = _mem_tracker]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 如果需要等待</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (need_wait) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 能正常发送给对端</span></span></span></span><br><span class="line"><span class="params"><span class="function">            SCOPED_THREAD_LOCAL_MEM_TRACKER_SETTER(mem_tracker);</span></span></span><br><span class="line"><span class="params"><span class="function">            buffer.pop();</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.1 CHECK: 必须等待第一个 add_request 对应的 RPC 返回，才能继续发送</span></span><br><span class="line">        <span class="keyword">if</span> (_num_finished_rpcs[instance_id.lo] == <span class="number">0</span> </span><br><span class="line">            &amp;&amp; _num_in_flight_rpcs[instance_id.lo] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            need_wait = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.2 CHECK: 最后一个 RPC，必须是最后一个发送，且只发送一次</span></span><br><span class="line">        <span class="keyword">auto</span>&amp; params = request.params;</span><br><span class="line">        <span class="keyword">if</span> (params-&gt;<span class="built_in">eos</span>()) &#123;</span><br><span class="line">            <span class="function">DeferOp <span class="title">eos_defer</span><span class="params">([<span class="keyword">this</span>, &amp;instance_id, &amp;need_wait]() &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (need_wait) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">return</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="keyword">if</span> (--_num_remaining_eos == <span class="number">0</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">// 所有对端的 FragmentInstances 该发送的数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="comment">// 都已发送完</span></span></span></span><br><span class="line"><span class="params"><span class="function">                    _is_finishing = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">                &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="comment">// 给 instance_id 的一个 PipelineDriver 发送完数据</span></span></span></span><br><span class="line"><span class="params"><span class="function">                --_num_sinkers[instance_id.lo];</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// instance_id 对应的 FragmentInstance 中</span></span><br><span class="line">            <span class="comment">// 还有 PipelineDrviers 还没有接受到完整的数据</span></span><br><span class="line">            <span class="keyword">if</span> (_num_sinkers[instance_id.lo] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (params-&gt;<span class="built_in">chunks_size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                params-&gt;<span class="built_in">set_eos</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 仍有尚未收到 response 的 RPCs</span></span><br><span class="line">                <span class="comment">// 则需要 wait</span></span><br><span class="line">                <span class="keyword">if</span> (_num_in_flight_rpcs[instance_id.lo] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    need_wait = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// else-branch: _num_in_flight_rpcs[instance_id] 为 0</span></span><br><span class="line">                <span class="comment">// 此时 params-&gt;eos() 就是 true</span></span><br><span class="line">                <span class="comment">// 表示这个是该 FragmentInstance 最后一个 RPC 请求</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125; <span class="comment">// while</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Part4-Send-RPC"><a href="#Part4-Send-RPC" class="headerlink" title="Part4: Send RPC"></a>Part4: Send RPC</h4><p>通过了上面的校验，下面就是真正发送 RPC request 的代码。 Part4 核心部分是设置 RPC 回调函数。</p><blockquote><p>bRPC 异步回调相关知识可以参考：<a href="https://github.com/apache/brpc/blob/master/docs/cn/client.md">异步访问</a></p></blockquote><p>由于是异步发送 RPC 消息，因此要设置回调函数来处理返回结果。 通过 DisposableClosure 继承 google::protobuf::Closure 传递给 bRPC。在 RPC 返回时执行 <em>Closure::Run</em> 函数。这里就是根据 RPC 发送结果即 ctnl.Failed() 来判断调用哪个 callback。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DisposableClosure</span> : <span class="keyword">public</span> google::protobuf::Closure &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> FailedFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> C&amp;)&gt;;</span><br><span class="line">    <span class="keyword">using</span> SuccessFunc = std::function&lt;<span class="built_in">void</span>(<span class="type">const</span> C&amp;, <span class="type">const</span> T&amp;)&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DisposableClosure</span>(<span class="type">const</span> C&amp; ctx) : _ctx(ctx) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addFailedHandler</span><span class="params">(FailedFunc fn)</span> </span>&#123; _failed_handler = std::<span class="built_in">move</span>(fn); &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addSuccessHandler</span><span class="params">(SuccessFunc fn)</span> </span>&#123; _success_handler = fn; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Run</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 自我释放内存</span></span><br><span class="line">      <span class="function">std::unique_ptr&lt;DisposableClosure&gt; <span class="title">self_guard</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cntl.<span class="built_in">Failed</span>()) &#123;</span><br><span class="line">          _failed_handler(_ctx);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          _success_handler(_ctx, result);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    brpc::Controller cntl;</span><br><span class="line">    T result;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> C _ctx;</span><br><span class="line">    FailedFunc _failed_handler;</span><br><span class="line">    SuccessFunc _success_handler;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>两个回调函数如下:</p><ol><li><p>SuccessFunc</p><p> ctnl.Failed() 为 false 只表明 RPC 请求确实发送给对端了，但是对端接受到 RPC 后真正的处理结果由 result.status() 来表征。如果对端处理失败，则取消当前 FragmentInstance，进而由 GloablDriverExecutor 取消整个 query。否则就 <strong>递归</strong> 执行 _try_to_send_rpc 函数，不断地从 _buffer[instance_id] 中取出 RPC request 发送给 instance_id 对应的 FragmentInstance。此时传入的 pre_work_cb 中有 <em>_process_send_window</em> 函数，这是用来处理滑动窗口的。</p><p> SuccessFunc 代码如下。 </p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">success_cb = [<span class="keyword">this</span>](<span class="type">const</span> ClosureContext&amp; ctx, </span><br><span class="line">                    <span class="type">const</span> PTransmitChunkResult&amp; result) &#123;</span><br><span class="line">  Status <span class="built_in">status</span>(result.<span class="built_in">status</span>());</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 更新记录</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;Mutex&gt; <span class="title">l</span><span class="params">(*_mutexes[ctx.instance_id.lo])</span></span>;</span><br><span class="line">    ++_num_finished_rpcs[ctx.instance_id.lo];</span><br><span class="line">    --_num_in_flight_rpcs[ctx.instance_id.lo];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 对端处理失败，则取消当前 FragmentInstance</span></span><br><span class="line">    _is_finishing = <span class="literal">true</span>;</span><br><span class="line">    _fragment_ctx-&gt;<span class="built_in">cancel</span>(status);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对端处理成功，则递归发送 RPC 给对端</span></span><br><span class="line">    _try_to_send_rpc(ctx.instance_id, [&amp;]() &#123;</span><br><span class="line">                _update_network_time(ctx.instance_id,</span><br><span class="line">                                     ctx.send_timestamp,</span><br><span class="line">                                     result.<span class="built_in">receiver_post_process_time</span>());</span><br><span class="line">                _process_send_window(ctx.instance_id, ctx.sequence); &#125;); </span><br><span class="line">  &#125;</span><br><span class="line">  --_total_in_flight_rpc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>FailedFunc</p><p> 如果因为网络等问题 RPC 无法发送给对端，则取消当前 FragmentInstance 的 PipelineDriver，并更新相关状态。</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">failed_cb = [<span class="keyword">this</span>](<span class="type">const</span> ClosureContext&amp; ctx) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// 算子完成</span></span><br><span class="line">  _is_finishing = <span class="literal">true</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 更新记录</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;Mutex&gt; <span class="title">l</span><span class="params">(*_mutexes[ctx.instance_id.lo])</span></span>;</span><br><span class="line">    ++_num_finished_rpcs[ctx.instance_id.lo];</span><br><span class="line">    --_num_in_flight_rpcs[ctx.instance_id.lo];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取消当前 FragmentInstance 的 PipelineDrivers</span></span><br><span class="line">  std::string err_msg = fmt::format(</span><br><span class="line">     <span class="string">&quot;transmit chunk rpc failed:&#123;&#125;&quot;</span>, <span class="built_in">print_id</span>(ctx.instance_id));</span><br><span class="line">  _fragment_ctx-&gt;<span class="built_in">cancel</span>(Status::<span class="built_in">InternalError</span>(err_msg));</span><br><span class="line"></span><br><span class="line">  --_total_in_flight_rpc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><p>RPC 回调函数 closure 设置完毕，就可以将 RPC 真正发送出去了，这个由 <em>_send_rpc</em> 函数完成。完成代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_try_to_send_rpc(<span class="type">const</span> TUniqueId&amp; instance_id,</span><br><span class="line">                                    <span class="type">const</span> std::function&lt;<span class="built_in">void</span>()&gt;&amp; pre_works_cb) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">//... above code</span></span><br><span class="line"></span><br><span class="line">        params-&gt;<span class="built_in">mutable_finst_id</span>()-&gt;<span class="built_in">CopyFrom</span>(_instance_id2finst_id[instance_id.lo]);</span><br><span class="line">        params-&gt;<span class="built_in">set_sequence</span>(++_request_seqs[instance_id.lo]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!request.attachment.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            _bytes_sent += request.attachment.<span class="built_in">size</span>();</span><br><span class="line">            _request_sent++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 callback</span></span><br><span class="line">        <span class="keyword">auto</span>* closure = <span class="keyword">new</span> <span class="built_in">DisposableClosure</span>&lt;PTransmitChunkResult, ClosureContext&gt;(</span><br><span class="line">                &#123;instance_id, params-&gt;<span class="built_in">sequence</span>(), <span class="built_in">MonotonicNanos</span>()&#125;);</span><br><span class="line">        <span class="keyword">if</span> (_first_send_time == <span class="number">-1</span>) &#123;</span><br><span class="line">            _first_send_time = <span class="built_in">MonotonicNanos</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        closure-&gt;<span class="built_in">addFailedHandler</span>(failed_cb);</span><br><span class="line">        closure-&gt;<span class="built_in">addSuccessHandler</span>(success_cb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在发送 RPC 前，递增变量</span></span><br><span class="line">        ++_total_in_flight_rpc;</span><br><span class="line">        ++_num_in_flight_rpcs[instance_id.lo];</span><br><span class="line"></span><br><span class="line">        _mem_tracker-&gt;<span class="built_in">release</span>(request.attachment_physical_bytes);</span><br><span class="line">        ExecEnv::<span class="built_in">GetInstance</span>()-&gt;<span class="built_in">process_mem_tracker</span>()-&gt;<span class="built_in">consume</span>(</span><br><span class="line">            request.attachment_physical_bytes);</span><br><span class="line"></span><br><span class="line">        closure-&gt;cntl.<span class="built_in">Reset</span>();</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">set_timeout_ms</span>(_brpc_timeout_ms);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">bthread_self</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> _send_rpc(closure, request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">SCOPED_THREAD_LOCAL_MEM_TRACKER_SETTER</span>(<span class="literal">nullptr</span>);</span><br><span class="line">            <span class="keyword">return</span> _send_rpc(closure, request);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="process-send-window"><a href="#process-send-window" class="headerlink" title="_process_send_window"></a>_process_send_window</h4><p>sequence 是本次成功的 RPC，下面用 sequence 来更新滑动窗口的逻辑也是比较简洁的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> SinkBuffer::_process_send_window(<span class="type">const</span> TUniqueId&amp; instance_id, <span class="type">const</span> <span class="type">int64_t</span> sequence) &#123;</span><br><span class="line">    <span class="comment">// Both sender side and receiver side can tolerate disorder of tranmission</span></span><br><span class="line">    <span class="comment">// if receiver side is not ExchangeMergeSortSourceOperator</span></span><br><span class="line">    <span class="keyword">if</span> (!_is_dest_merge) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span>&amp; seqs = _discontinuous_acked_seqs[instance_id.lo];</span><br><span class="line">    seqs.<span class="built_in">insert</span>(sequence);</span><br><span class="line">    <span class="keyword">auto</span>&amp; max_continuous_acked_seq = _max_continuous_acked_seqs[instance_id.lo];</span><br><span class="line">    std::unordered_set&lt;<span class="type">int64_t</span>&gt;::iterator it;</span><br><span class="line">    <span class="keyword">while</span> ((it = seqs.<span class="built_in">find</span>(max_continuous_acked_seq + <span class="number">1</span>)) != seqs.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        seqs.<span class="built_in">erase</span>(it);</span><br><span class="line">        ++max_continuous_acked_seq;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SinkBuffer-send-rpc"><a href="#SinkBuffer-send-rpc" class="headerlink" title="SinkBuffer::_send_rpc"></a>SinkBuffer::_send_rpc</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">Status SinkBuffer::_send_rpc(DisposableClosure&lt;PTransmitChunkResult,</span><br><span class="line">                             ClosureContext&gt;* closure,</span><br><span class="line">                             <span class="type">const</span> TransmitChunkInfo&amp; request) &#123;</span><br><span class="line">    <span class="keyword">auto</span> expected_iobuf_size = request.attachment.<span class="built_in">size</span>() </span><br><span class="line">                             + request.params-&gt;<span class="built_in">ByteSizeLong</span>() </span><br><span class="line">                             + <span class="built_in">sizeof</span>(<span class="type">size_t</span>) * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(expected_iobuf_size &gt; _rpc_http_min_size)) &#123;</span><br><span class="line">        butil::IOBuf iobuf;</span><br><span class="line">        <span class="function">butil::IOBufAsZeroCopyOutputStream <span class="title">wrapper</span><span class="params">(&amp;iobuf)</span></span>;</span><br><span class="line">        request.params-&gt;<span class="built_in">SerializeToZeroCopyStream</span>(&amp;wrapper);</span><br><span class="line">        <span class="comment">// append params to iobuf</span></span><br><span class="line">        <span class="type">size_t</span> params_size = iobuf.<span class="built_in">size</span>();</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(</span><br><span class="line">            &amp;params_size, <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(iobuf);</span><br><span class="line">        <span class="comment">// append attachment</span></span><br><span class="line">        <span class="type">size_t</span> attachment_size = request.attachment.<span class="built_in">size</span>();</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(</span><br><span class="line">            &amp;attachment_size, <span class="built_in">sizeof</span>(<span class="type">size_t</span>));</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(request.attachment);</span><br><span class="line">        closure-&gt;cntl.<span class="built_in">http_request</span>().<span class="built_in">set_content_type</span>(<span class="string">&quot;application/proto&quot;</span>);</span><br><span class="line">        <span class="keyword">auto</span> res = BrpcStubCache::<span class="built_in">create_http_stub</span>(request.brpc_addr);</span><br><span class="line">        <span class="built_in">RETURN_IF</span>(!res.<span class="built_in">ok</span>(), res.<span class="built_in">status</span>());</span><br><span class="line">        <span class="comment">// 异步 RPC </span></span><br><span class="line">        res.<span class="built_in">value</span>()-&gt;<span class="built_in">transmit_chunk_via_http</span>(</span><br><span class="line">            &amp;closure-&gt;cntl, <span class="literal">NULL</span>, &amp;closure-&gt;result, closure);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 异步 RPC</span></span><br><span class="line">        closure-&gt;cntl.<span class="built_in">request_attachment</span>().<span class="built_in">append</span>(request.attachment);</span><br><span class="line">        request.brpc_stub-&gt;<span class="built_in">transmit_chunk</span>(</span><br><span class="line">            &amp;closure-&gt;cntl, request.params.<span class="built_in">get</span>(), &amp;closure-&gt;result, closure);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="push-chunk"><a href="#push-chunk" class="headerlink" title="push_chunk"></a>push_chunk</h2><p>上面讲解了 Channel 是如何 batched RPCs 到真正发送 RPC 给对端。下面来讲解 ExchangeSinkOperator::push_chunk。</p><p>_output_columns 是当前 Sink 需要输出的列，当前一个 Operator 将数据 Chunk 推向 ExchangeSinkOperator 时，需要从 chunk 中提取出 _output_columns 中所必须的列数据即可，得到的即 send_chunk。</p><h3 id="TPartitionType-UNPARTITIONED"><a href="#TPartitionType-UNPARTITIONED" class="headerlink" title="TPartitionType::UNPARTITIONED"></a>TPartitionType::UNPARTITIONED</h3><p>当传输数据方式是 TPartitionType::UNPARTITIONED，即广播模式，给每个对端都发送一份完整的数据，如下图所示。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-3.svg?raw=true" alt="StarRocks/Pipeline-ExchangeNode-3"></p><p>即遍历 _channels 给所有的 Channel[idx] 发送数据。也正如前文所述，如果 Channel::use_pass_through() 为 true，则可以走共享内存模式，而不用 RPC 通信。反之，则需要先序列化再进行 RPC 发送。</p><blockquote><p>Channel 发现 ExchangeSinkOperator::_is_pipeline_level_shuffle 为 false 时，在 Channel::send_one_chunk 函数中不会处理 DEFAULT_DRIVER_SEQUENCE。</p></blockquote><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ExchangeSinkOperator::push_chunk</span><span class="params">(RuntimeState* state, </span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint16_t</span> num_rows = chunk-&gt;<span class="built_in">num_rows</span>();</span><br><span class="line">    <span class="built_in">RETURN_IF</span>(num_rows == <span class="number">0</span>, Status::<span class="built_in">OK</span>());</span><br><span class="line"></span><br><span class="line">    vectorized::Chunk temp_chunk;</span><br><span class="line">    vectorized::Chunk* send_chunk = chunk.<span class="built_in">get</span>();</span><br><span class="line">    <span class="keyword">if</span> (!_output_columns.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int32_t</span> cid : _output_columns) &#123;</span><br><span class="line">            temp_chunk.<span class="built_in">append_column</span>(chunk-&gt;<span class="built_in">get_column_by_slot_id</span>(cid), cid);</span><br><span class="line">        &#125;</span><br><span class="line">        send_chunk = &amp;temp_chunk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (_part_type == TPartitionType::UNPARTITIONED || _num_shuffles == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_chunk_request == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            _chunk_request = std::<span class="built_in">make_shared</span>&lt;PTransmitChunkParams&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::vector&lt;<span class="type">int</span>&gt; not_pass_through_channles;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> idx : _channel_indices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (_channels[idx]-&gt;<span class="built_in">use_pass_through</span>()) &#123;</span><br><span class="line">               <span class="comment">// pass_through 模式，直接传递数据</span></span><br><span class="line">                <span class="built_in">RETURN_IF_ERROR</span>(_channels[idx]-&gt;<span class="built_in">send_one_chunk</span>(</span><br><span class="line">                    state, send_chunk, DEFAULT_DRIVER_SEQUENCE, <span class="literal">false</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//记录需要爱 RPC 通信的对端</span></span><br><span class="line">                not_pass_through_channles.<span class="built_in">emplace_back</span>(idx);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!not_pass_through_channles.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 1. create a new chunk PB to serialize</span></span><br><span class="line">            ChunkPB* pchunk = _chunk_request-&gt;<span class="built_in">add_chunks</span>();</span><br><span class="line">            <span class="comment">// 2. 将输入的 send_chunk 序列化到 pchunk 中</span></span><br><span class="line">            <span class="built_in">TRY_CATCH_BAD_ALLOC</span>(<span class="built_in">RETURN_IF_ERROR</span>(<span class="built_in">serialize_chunk</span>(</span><br><span class="line">                send_chunk, pchunk, &amp;_is_first_chunk, _channels.<span class="built_in">size</span>())));</span><br><span class="line">            _current_request_bytes += pchunk-&gt;<span class="built_in">data</span>().<span class="built_in">size</span>();</span><br><span class="line">            <span class="comment">// 3. 如果请求的字节数超过限制，再通过 Channel 发送</span></span><br><span class="line">            <span class="keyword">if</span> (_current_request_bytes &gt; config::max_transmit_batched_bytes) &#123;</span><br><span class="line">                butil::IOBuf attachment;</span><br><span class="line">                <span class="type">int64_t</span> attachment_physical_bytes =</span><br><span class="line">                     <span class="built_in">construct_brpc_attachment</span>(_chunk_request, attachment);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> idx : not_pass_through_channles) &#123;</span><br><span class="line">                    <span class="built_in">RETURN_IF_ERROR</span>(_channels[idx]-&gt;<span class="built_in">send_chunk_request</span>(</span><br><span class="line">                        state, </span><br><span class="line">                        std::<span class="built_in">make_shared</span>&lt;PTransmitChunkParams&gt;(*_chunk_request),</span><br><span class="line">                        attachment, </span><br><span class="line">                        attachment_physical_bytes));</span><br><span class="line">                &#125;</span><br><span class="line">                _current_request_bytes = <span class="number">0</span>;</span><br><span class="line">                _chunk_request.<span class="built_in">reset</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TPartitionType-RANDOM"><a href="#TPartitionType-RANDOM" class="headerlink" title="TPartitionType::RANDOM"></a>TPartitionType::RANDOM</h3><p>TPartitionType::RANDOM 的数据分发策略是 Round-robin，每次调用 ExchangeSinkOperator::push_chunk 都挑选一个同进程的 FragmentInstance 作为对端。如下图所示。<br><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-4.svg?raw=true" alt="StarRocks/Pipeline-ExchangeNode-4"></p><p>_curr_random_channel_idx 指示当前发送给哪个 Local Channels。见代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ExchangeSinkOperator::push_chunk</span><span class="params">(RuntimeState* state, <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (_part_type == TPartitionType::UNPARTITIONED || _num_shuffles == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_part_type == TPartitionType::RANDOM) &#123;</span><br><span class="line">        std::vector&lt;Channel*&gt; local_channels;</span><br><span class="line">        <span class="comment">// 1. 挑选处同进程的 FragmenInstance</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; channel : _channels) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel-&gt;<span class="built_in">is_local</span>()) &#123;</span><br><span class="line">                local_channels.<span class="built_in">emplace_back</span>(channel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有 Local Channel，才选择 Remote Channel</span></span><br><span class="line">        <span class="keyword">if</span> (local_channels.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            local_channels = _channels;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span>&amp; channel = local_channels[_curr_random_channel_idx];</span><br><span class="line">        <span class="type">bool</span> real_sent = <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 2. 发送</span></span><br><span class="line">        <span class="built_in">RETURN_IF_ERROR</span>(channel-&gt;<span class="built_in">send_one_chunk</span>(</span><br><span class="line">                state, send_chunk,</span><br><span class="line">                DEFAULT_DRIVER_SEQUENCE,</span><br><span class="line">                <span class="literal">false</span>, &amp;real_sent));</span><br><span class="line">        <span class="comment">// 3. 只有在 RPC 真的发送出去了，才会切换到下一个 FragmentInstance</span></span><br><span class="line">        <span class="keyword">if</span> (real_sent) &#123;</span><br><span class="line">            _curr_random_channel_idx = </span><br><span class="line">                (_curr_random_channel_idx + <span class="number">1</span>) % local_channels.<span class="built_in">size</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// else if</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TPartitionType-BUCKET-SHUFFLE-HASH-PARTITIONED"><a href="#TPartitionType-BUCKET-SHUFFLE-HASH-PARTITIONED" class="headerlink" title="TPartitionType::BUCKET_SHUFFLE&#x2F;HASH_PARTITIONED"></a>TPartitionType::BUCKET_SHUFFLE&#x2F;HASH_PARTITIONED</h3><p>这两种数据分发策略要复杂点，二者本质不同点在于使用的 Hash 函数。如下示意图。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-5.svg?raw=true" alt="StarRocks/Pipeline-ExchangeNode-5"></p><h4 id="hash-values"><a href="#hash-values" class="headerlink" title="hash_values"></a>hash_values</h4><p>Shuffler::exchange_shuffle 函数用于将 chunk 的每一行都分发到具体的分区 {instance_id, driver_seq} 中。参数 hash_values 是对 chunk 中每一行的 join-key 进行 hash 值。BUCKET_SHUFFLE_HASH_PARTITIONED 和 HASH_PARTITIONED 两种策略根本区别也在于这里。</p><blockquote><p>这里的分区列的 “partition” 和建分区表时的 “partition” 不是一个含义。这里的是对端 {instnace_id, driver_seq} 处理的数据源。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ExchangeSinkOperator::push_chunk</span><span class="params">(RuntimeState* state, </span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">const</span> vectorized::ChunkPtr&amp; chunk)</span> </span>&#123;</span><br><span class="line"> <span class="comment">//...</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (_part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">          _part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//1. 计算 hash 的分区列</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; _partitions_columns.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">ASSIGN_OR_RETURN</span>(</span><br><span class="line">          _partitions_columns[i], _partition_expr_ctxs[i]-&gt;<span class="built_in">evaluate</span>(chunk.<span class="built_in">get</span>()));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 2. 为每个分区列计算 hash 值</span></span><br><span class="line">      <span class="keyword">if</span> (_part_type == TPartitionType::HASH_PARTITIONED) &#123;</span><br><span class="line">        _hash_values.<span class="built_in">assign</span>(num_rows, HashUtil::FNV_SEED);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vectorized::ColumnPtr&amp; column : _partitions_columns) &#123;</span><br><span class="line">           column-&gt;<span class="built_in">fnv_hash</span>(&amp;_hash_values[<span class="number">0</span>], <span class="number">0</span>, num_rows);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当 join-key 和分桶键一样</span></span><br><span class="line">        <span class="comment">// 则和分桶键使用一样的 Hash 函数</span></span><br><span class="line">        _hash_values.<span class="built_in">assign</span>(num_rows, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vectorized::ColumnPtr&amp; column : _partitions_columns) &#123;</span><br><span class="line">           column-&gt;<span class="built_in">crc32_hash</span>(&amp;_hash_values[<span class="number">0</span>], <span class="number">0</span>, num_rows);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//..</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br></pre></td></tr></table></figure><h4 id="exchange-shuffle"><a href="#exchange-shuffle" class="headerlink" title="exchange_shuffle"></a>exchange_shuffle</h4><p>TPartitionType::UNPARTITIONED 和 TPartitionType::RANDOM 两种策略的 shuffle 粒度是 chunk ，即可以直接将整个 chunk 发送给 FragmentInstance。而 (BUCKET_SHUFFLE_)HASH_PARTITIONED 策略，shuffle 的粒度是 row，需要把一个 chunk 分发到不同 {FragmentInstance, PipelineDriver} 中。 </p><p>因此，可以把 (channl_id, driver_sequence) 视为一个坐标，那么 exchange_shuffle 函数就是将 chunk 的 num_rows 行数据均匀分布在 channels_size * num_shuffles_per_channel 的平面上。其中 num_shuffles_per_channel 表征的是 dop。</p><p>shuffle 策略实现如下：</p><ul><li>two_level_shuffle 为 false 表示不需要再次 shuffle，直接获取 channel_id 即可，这里的 channel_id 实际上是 FE 中已经计算好的值</li><li>two_level_shuffle 为 true 则需要在 BE 端再次进行 shuffle</li></ul><p>实现如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">bool</span> two_level_shuffle, <span class="keyword">typename</span> ReduceOp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">exchange_shuffle</span><span class="params">(std::vector&lt;<span class="type">uint32_t</span>&gt;&amp; shuffle_channel_ids, </span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> std::vector&lt;<span class="type">uint32_t</span>&gt;&amp; hash_values,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">size_t</span> num_rows)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_rows; ++i) &#123;</span><br><span class="line">        <span class="type">size_t</span> channel_id = <span class="built_in">ReduceOp</span>()(hash_values[i], _num_channels);</span><br><span class="line">        <span class="type">size_t</span> shuffle_id;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(!two_level_shuffle)</span> </span>&#123;</span><br><span class="line">            shuffle_id = channel_id;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 基于均匀分布将 hash_values 映射到 [0, _num_shuffles_per_channel) 区间</span></span><br><span class="line">            <span class="type">uint32_t</span> driver_sequence = <span class="built_in">ReduceOp</span>()(</span><br><span class="line">                HashUtil::<span class="built_in">xorshift32</span>(hash_values[i]), _num_shuffles_per_channel);</span><br><span class="line">            shuffle_id = </span><br><span class="line">                channel_id * _num_shuffles_per_channel + driver_sequence;</span><br><span class="line">        &#125;</span><br><span class="line">        shuffle_channel_ids[i] = shuffle_id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到 chunk 每一行的 hash_values 后，并基于 Shuffler::exchange_shuffle 函数得到每一行所属的分区，结果存储于 _shuffle_channel_ids。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (_part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">         _part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">// 3. Compute row indexes for each channel&#x27;s each shuffle</span></span><br><span class="line">     _shuffler-&gt;<span class="built_in">exchange_shuffle</span>(_shuffle_channel_ids, _hash_values, num_rows);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="channel-row-idx-start-points"><a href="#channel-row-idx-start-points" class="headerlink" title="channel_row_idx_start_points"></a>channel_row_idx_start_points</h4><p>接下来就是 shuffle 之后的处理流程：_row_indexes 将 chunk 中所有发往同一个分区的 row_ids 连续存储在一起，并用 _channel_row_idx_start_points 记录每个分区起始偏移量。如下示意图:</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/Pipeline-ExchangeNode-6.svg?raw=true" alt="StarRocks/Pipeline-ExchangeNode-6"></p><p>这个流程分为如下三个 for-loop:</p><ol><li><p>计算每个分区的行数</p><p> _shuffle_channel_ids[i] 表征 partitions[i]，那么第一个 for-loop 计算完，_channel_row_idx_start_points[i] 即表征 chunk 落在 partitions[i] 的行数。</p><p> 比如有三个分区，分别是 9, 10, 11行，经过第一个 for-loop，start_points 中存储的值就是:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 10 11</span><br></pre></td></tr></table></figure></li><li><p>计算每个分区最后的位置</p><p>上述例子，经过第二个 for-loop 后， start_points 中存储的值就是:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9 19 30</span><br></pre></td></tr></table></figure></li><li><p>将同一个分区的在chunk中的行号记录在 _row_indexes，同时将 _channel_row_idx_start_points 更新到每个分区的起始位置。</p><p> 此时 _row_indexes 和 start_points 的值变更结果如下:</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_row_indexes[0:8] = partition0</span><br><span class="line">_row_indexes[9:18] = partition1</span><br><span class="line">_row_indexes[19:29] = partition2</span><br><span class="line"></span><br><span class="line">start_points[0] = 0</span><br><span class="line">start_points[1] = 9</span><br><span class="line">start_points[2] = 19</span><br></pre></td></tr></table></figure></li></ol><p>三个 for-loop 的完成代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (_part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">          _part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="comment">// _num_shuffles = _channels.size() * _num_shuffles_per_channel</span></span><br><span class="line">      _channel_row_idx_start_points.<span class="built_in">assign</span>(_num_shuffles + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//4.1 </span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_rows; ++i) &#123;</span><br><span class="line">          _channel_row_idx_start_points[_shuffle_channel_ids[i]]++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.2</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">1</span>; i &lt;= _num_shuffles; ++i) &#123;</span><br><span class="line">          _channel_row_idx_start_points[i] += _channel_row_idx_start_points[i - <span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 4.3</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int32_t</span> i = num_rows - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">          _row_indexes[_channel_row_idx_start_points[_shuffle_channel_ids[i]] - <span class="number">1</span>] = i;</span><br><span class="line">          _channel_row_idx_start_points[_shuffle_channel_ids[i]]--;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="add-rows-selective"><a href="#add-rows-selective" class="headerlink" title="add_rows_selective"></a>add_rows_selective</h4><p>上面四步对chunk完成了分区，并将结果记录在 _row_indexes 和 _start_points 中，最后一步就是将所有分区数据发送出去，只需要遍历 (_channel_indices, _num_shuffles_per_channel) 二维区间，再使用 Channel::add_rows_selective 函数发送数据，没啥可说，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (_part_type == TPartitionType::HASH_PARTITIONED ||</span><br><span class="line">          _part_type == TPartitionType::BUCKET_SHUFFLE_HASH_PARTITIONED) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// above code</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int32_t</span> channel_id : _channel_indices) &#123;</span><br><span class="line">      <span class="keyword">if</span> (_channels[channel_id]-&gt;<span class="built_in">get_fragment_instance_id</span>().lo == <span class="number">-1</span>) &#123;</span><br><span class="line">          <span class="comment">// dest bucket is no used, continue</span></span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; _num_shuffles_per_channel; ++i) &#123;</span><br><span class="line">          <span class="type">int</span> shuffle_id = channel_id * _num_shuffles_per_channel + i;</span><br><span class="line">          <span class="type">int</span> driver_sequence = _driver_sequence_per_shuffle[shuffle_id];</span><br><span class="line"></span><br><span class="line">          <span class="type">size_t</span> from = _channel_row_idx_start_points[shuffle_id];</span><br><span class="line">          <span class="type">size_t</span> size = _channel_row_idx_start_points[shuffle_id + <span class="number">1</span>] - from;</span><br><span class="line">          <span class="keyword">if</span> (size == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="comment">// no data for this channel continue;</span></span><br><span class="line">              <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">RETURN_IF_ERROR</span>(_channels[channel_id]-&gt;<span class="built_in">add_rows_selective</span>(send_chunk,         </span><br><span class="line">                                                                    driver_sequence, </span><br><span class="line">                                                                    _row_indexes.<span class="built_in">data</span>(), </span><br><span class="line">                                                                    from, size,</span><br><span class="line">                                                                    state));</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.zhihu.com/collection/853861081">StarRocks Exchange 算子源码解析</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前面几篇所述都单个 FragmentInstance 内的执行流。StarRocks 是 MPP 架构，并发执行多个 FragmentInstances。因此就涉及到多个 FragmentInstances 之间数据通信，FragmentExecutor 在构造每个 Pip</summary>
      
    
    
    
    <category term="Pipeline" scheme="https://szza.github.io/categories/Pipeline/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>GloablDriverExecutor: 实现协程模型的执行器</title>
    <link href="https://szza.github.io/2023/07/22/StarRocks/Pipeline/PipelineExecutor/"/>
    <id>https://szza.github.io/2023/07/22/StarRocks/Pipeline/PipelineExecutor/</id>
    <published>2023-07-22T02:00:01.000Z</published>
    <updated>2023-11-03T13:13:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前面几篇已经叙述了 PipelineDriver、DriverQueue、PipelinePoller 等设计，下面再来看看是 GlobalDriverExecutor 怎么将他们组合在一起的。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-1.svg?raw=true" alt="pipeline-1"></p><p>由于 _driver_queue 和 _blocked_driver_poller 是在 _thread_pool 中所有 workers 间共享的。一个 query FragemntInstance 划分成 dop 个 PipelineDrivers 分发（dispatch）给 n 个 worker 去执行。但是有可能 driver0 开始分配给 worker0，在执行过程中被添加到 blocked_driver_poller，后又被 worker1 取出，最终 driver0 在 work1 中执行。</p><blockquote><p>这里是不是能优化下？分为两个队列 LocalReadyQueue，RemoteReadyQueue：只有 local_ready_queue 中满了，才会从其他 workers 中窃取(steal) PipelineDrivers 放到 remote_ready_queue，<u>减少 corss-core 通信</u>。</p></blockquote><h2 id="worker"><a href="#worker" class="headerlink" title="worker"></a>worker</h2><p>Executor 的所有 workers 都是阻塞等待在 DrvierQueue::take 处，当 DriverQueue 中有添加了新的 Ready PipelineDrvier 时，就会有一个 worker 解除阻塞。</p><ol><li>对于取出的 ready_driver，worker 会先检测其状态，过滤一些已经处于终态（CANCELED、FINISH、INTERNEL_ERROR）的 Driver，会调用 GlobalDriverExecutor::_finalize_driver 函数，如果是 FragementInstance 的最后一个 PipelineDriver，则生成该 FragmentInstance 的查询统计信息（即 profile），汇报给 Frontend。</li><li>对于正常处于 READY&#x2F;Running 状态的 driver，则调用 PipelineDriver::process 函数，推动 pipeline 状态机前进。</li></ol><ul><li>如果返回的状态 <strong>maybe_state</strong>.is_not_ok，则通过 QueryContext::cancel 将当前 Backend 上该 query 的所有 FragmentInstances 标记为取消状态。后续该 query 所有的 drivers，无论是在 Poller 中或者正在 Executor 中的，在执行前会去检测 fragment_ctx::is_canceled，如果返回 true，则取消本次执行，进入 step(1)</li><li>如果 maybe_state.is_ok，则会根据此时 driver 的状态，判断是重新放回到 driver_queue、或是 blocked_driver_poller，或者说直接完成了。</li></ul><p>在执行过程中，会设置并更新 Driver、DriverQueue 的统计信息，便于 DrvierQueue 更为准确地调度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> GlobalDriverExecutor::_worker_thread() &#123;</span><br><span class="line">    <span class="keyword">auto</span> current_thread = Thread::<span class="built_in">current_thread</span>();</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> worker_id = _next_id++;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_num_threads_setter.<span class="built_in">should_shrink</span>()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0. 取出 READY 状态的 driver</span></span><br><span class="line">        <span class="keyword">auto</span> maybe_driver = <span class="keyword">this</span>-&gt;_driver_queue-&gt;<span class="built_in">take</span>();</span><br><span class="line">        <span class="keyword">auto</span> driver = maybe_driver.<span class="built_in">value</span>();</span><br><span class="line">        <span class="built_in">DCHECK</span>(driver != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span>* query_ctx = driver-&gt;<span class="built_in">query_ctx</span>();</span><br><span class="line">        <span class="keyword">auto</span>* fragment_ctx = driver-&gt;<span class="built_in">fragment_ctx</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计信息</span></span><br><span class="line">        driver-&gt;<span class="built_in">increment_schedule_times</span>();</span><br><span class="line">        _schedule_count++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">auto</span> runtime_state_ptr = fragment_ctx-&gt;<span class="built_in">runtime_state_ptr</span>();</span><br><span class="line">        <span class="keyword">auto</span>* runtime_state = runtime_state_ptr.<span class="built_in">get</span>();</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">SCOPED_THREAD_LOCAL_MEM_TRACKER_SETTER</span>(</span><br><span class="line">                runtime_state-&gt;<span class="built_in">instance_mem_tracker</span>());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 1.1 终态检测: 检测 fragment 是否已经取消</span></span><br><span class="line">            <span class="keyword">if</span> (fragment_ctx-&gt;<span class="built_in">is_canceled</span>()) &#123;</span><br><span class="line">                driver-&gt;<span class="built_in">cancel_operators</span>(runtime_state);</span><br><span class="line">                <span class="keyword">if</span> (driver-&gt;<span class="built_in">is_still_pending_finish</span>()) &#123;</span><br><span class="line">                    driver-&gt;<span class="built_in">set_driver_state</span>(DriverState::PENDING_FINISH);</span><br><span class="line">                    _blocked_driver_poller-&gt;<span class="built_in">add_blocked_driver</span>(driver);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _finalize_driver(driver,</span><br><span class="line">                                     runtime_state,</span><br><span class="line">                                     DriverState::CANCELED);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1.2 终态检测：driver 是否已经处于终态</span></span><br><span class="line">            <span class="keyword">if</span> (driver-&gt;<span class="built_in">is_finished</span>()) &#123;</span><br><span class="line">                _finalize_driver(driver, runtime_state, driver-&gt;<span class="built_in">driver_state</span>());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 统计信息 </span></span><br><span class="line">            <span class="type">int64_t</span> start_time = driver-&gt;<span class="built_in">get_active_time</span>();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 推动 PipelineDriver</span></span><br><span class="line">            StatusOr&lt;DriverState&gt; maybe_state;</span><br><span class="line">            <span class="built_in">TRY_CATCH_ALL</span>(maybe_state, driver-&gt;<span class="built_in">process</span>(runtime_state, worker_id));</span><br><span class="line"></span><br><span class="line">            Status status = maybe_state.<span class="built_in">status</span>();</span><br><span class="line">            <span class="keyword">this</span>-&gt;_driver_queue-&gt;<span class="built_in">update_statistics</span>(driver);</span><br><span class="line">            <span class="type">int64_t</span> end_time = driver-&gt;<span class="built_in">get_active_time</span>();</span><br><span class="line">            _driver_execution_ns += end_time - start_time;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2.1  PipelineDriver 执行过程出错</span></span><br><span class="line">            <span class="keyword">if</span> (!status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">                <span class="comment">// 取消整个 query</span></span><br><span class="line">                query_ctx-&gt;<span class="built_in">cancel</span>(status);</span><br><span class="line">                driver-&gt;<span class="built_in">cancel_operators</span>(runtime_state);</span><br><span class="line">                <span class="keyword">if</span> (driver-&gt;<span class="built_in">is_still_pending_finish</span>()) &#123;</span><br><span class="line">                    driver-&gt;<span class="built_in">set_driver_state</span>(DriverState::PENDING_FINISH);</span><br><span class="line">                    _blocked_driver_poller-&gt;<span class="built_in">add_blocked_driver</span>(driver);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    _finalize_driver(driver, </span><br><span class="line">                                     runtime_state,</span><br><span class="line">                                     DriverState::INTERNAL_ERROR);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 2.2 没有出错则更新状态，重新放回 driver_queue 或是添加到 poller</span></span><br><span class="line">            <span class="keyword">auto</span> driver_state = maybe_state.<span class="built_in">value</span>();</span><br><span class="line">            <span class="keyword">switch</span> (driver_state) &#123;</span><br><span class="line">            <span class="comment">// 重新放回 ready_driver</span></span><br><span class="line">            <span class="keyword">case</span> READY:</span><br><span class="line">            <span class="keyword">case</span> RUNNING: &#123;</span><br><span class="line">                <span class="keyword">this</span>-&gt;_driver_queue-&gt;<span class="built_in">put_back_from_executor</span>(driver);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 终态</span></span><br><span class="line">            <span class="keyword">case</span> FINISH:</span><br><span class="line">            <span class="keyword">case</span> CANCELED:</span><br><span class="line">            <span class="keyword">case</span> INTERNAL_ERROR: &#123;</span><br><span class="line">                _finalize_driver(driver, runtime_state, driver_state);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 阻塞</span></span><br><span class="line">            <span class="keyword">case</span> INPUT_EMPTY:</span><br><span class="line">            <span class="keyword">case</span> OUTPUT_FULL:</span><br><span class="line">            <span class="keyword">case</span> PENDING_FINISH:</span><br><span class="line">            <span class="keyword">case</span> PRECONDITION_BLOCK: &#123;</span><br><span class="line">                _blocked_driver_poller-&gt;<span class="built_in">add_blocked_driver</span>(driver);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">DCHECK</span>(<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Coroutione"><a href="#Coroutione" class="headerlink" title="Coroutione"></a>Coroutione</h2><p>那么这个协程模型体现在哪呢？</p><p>PipelineDriver::process 中变量 <em>should_yield</em> 被设置为 true 时，</p><ul><li>要么是当前状态受阻，则该 driver 放入到 _blocked_driver_poller</li><li>或者是当前时间片用完，都会重新放回到 _driver_queue，重新调度分发，给其他 drivers 执行的可能</li></ul><p>只要有 Ready&#x2F;Running 状态的 driver，Executor 的 worker 就不会阻塞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前面几篇已经叙述了 PipelineDriver、DriverQueue、PipelinePoller 等设计，下面再来看看是 GlobalDriverExecutor 怎么将他们组合在一起的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/sz</summary>
      
    
    
    
    <category term="Pipeline" scheme="https://szza.github.io/categories/Pipeline/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
  <entry>
    <title>QuerySharedDriverQueue: 多级反馈队列</title>
    <link href="https://szza.github.io/2023/07/19/StarRocks/Pipeline/DriverQueue_1/"/>
    <id>https://szza.github.io/2023/07/19/StarRocks/Pipeline/DriverQueue_1/</id>
    <published>2023-07-19T02:00:01.000Z</published>
    <updated>2023-09-26T02:32:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>DriverQueue 的继承派生关系如下图所示。QuerySharedDriverQueue 是用于没有设置 ResuorceGroup 的 query，即 default ResourceGroup，而 WorkGroupDriverQueue 是针对设置了 ResourceGroup 的 query。</p><p>本文专注于 QuerySharedDriverQueue 的实现，ResuorceGroup 后文单独讲解。下文 DriverQueue 一般指 QuerySharedDriverQueue。 </p><p>DriverQueue 本质上是个调度 PipelineDrivers 的数据结构，这样 DrvierQueue 本身就不需要占据一个线程，它可以在 GloablEexecuotr::work_thread 所在的核上运行。</p><p><img src="https://github.com/szza/szza.github.io.images/blob/master/StarRocks/pipeline-driver-queue-1.svg?raw=true" alt="pipeline-driver-queue-1"></p><h2 id="DriverAcct"><a href="#DriverAcct" class="headerlink" title="DriverAcct"></a>DriverAcct</h2><p>DriverQueue 实现调度，需要依赖 PipelineDriver 运行时的统计信息。比如，在前文我们说过了 <a href="https://szza.github.io/2023/07/15/Pipeline/PipelineDriver_2">PipelineDriver</a> 每执行一次 PipelineDriver:process 函数都会更新统计信息。</p><p>统计信息由 DriverAcct 记录：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DriverAcct</span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">get_last_time_spent</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> last_time_spent; &#125;</span><br><span class="line">    <span class="function"><span class="type">int64_t</span> <span class="title">get_accumulated_time_spent</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> accumulated_time_spent; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> schedule_times&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int64_t</span> schedule_effective_times&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int64_t</span> last_time_spent&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int64_t</span> last_chunks_moved&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int64_t</span> accumulated_time_spent&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int64_t</span> accumulated_chunks_moved&#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int64_t</span> accumulated_rows_moved&#123;<span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>PipelineDriver 中统计信息如下。利用这些统计信息就能实现更为准确的调度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DriverAcct&amp; <span class="title">PipelineDriver::driver_acct</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> _driver_acct; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> PipelineDriver::_update_driver_acct(<span class="type">size_t</span> total_chunks_moved,</span><br><span class="line">                                         <span class="type">size_t</span> total_rows_moved,</span><br><span class="line">                                         <span class="type">size_t</span> time_spent) &#123;</span><br><span class="line">    <span class="built_in">driver_acct</span>().<span class="built_in">update_last_chunks_moved</span>(total_chunks_moved);</span><br><span class="line">    <span class="built_in">driver_acct</span>().<span class="built_in">update_accumulated_rows_moved</span>(total_rows_moved);</span><br><span class="line">    <span class="built_in">driver_acct</span>().<span class="built_in">update_last_time_spent</span>(time_spent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> PipelineDriver::_update_statistics(<span class="type">size_t</span> total_chunks_moved,</span><br><span class="line">                                        <span class="type">size_t</span> total_rows_moved,</span><br><span class="line">                                        <span class="type">size_t</span> time_spent) &#123;</span><br><span class="line">    _update_driver_acct(total_chunks_moved,</span><br><span class="line">                        total_rows_moved,</span><br><span class="line">                        time_spent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update statistics of scan operator</span></span><br><span class="line">    <span class="keyword">if</span> (ScanOperator* scan = <span class="built_in">source_scan_operator</span>()) &#123;</span><br><span class="line">        <span class="built_in">query_ctx</span>()-&gt;<span class="built_in">incr_cur_scan_rows_num</span>(</span><br><span class="line">            scan-&gt;<span class="built_in">get_last_scan_rows_num</span>());</span><br><span class="line">        <span class="built_in">query_ctx</span>()-&gt;<span class="built_in">incr_cur_scan_bytes</span>(</span><br><span class="line">            scan-&gt;<span class="built_in">get_last_scan_bytes</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update cpu cost of this query</span></span><br><span class="line">    <span class="type">int64_t</span> accounted_cpu_cost </span><br><span class="line">        = <span class="built_in">driver_acct</span>().<span class="built_in">get_last_time_spent</span>()</span><br><span class="line">        + <span class="built_in">source_operator</span>()-&gt;<span class="built_in">get_last_growth_cpu_time_ns</span>()</span><br><span class="line">        + <span class="built_in">sink_operator</span>()-&gt;<span class="built_in">get_last_growth_cpu_time_ns</span>();</span><br><span class="line">    <span class="built_in">query_ctx</span>()-&gt;<span class="built_in">incr_cpu_cost</span>(accounted_cpu_cost);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SubQuerySharedDriverQueue"><a href="#SubQuerySharedDriverQueue" class="headerlink" title="SubQuerySharedDriverQueue"></a>SubQuerySharedDriverQueue</h2><p>QuerySharedDriverQueue 基于多级反馈队列实现，每一 level 的时间片不同，每一 level 的 PipelineDriver 是由 SubQuerySharedDriverQueue 来存储。</p><p>SubQuerySharedDriverQueue 有三个字段：</p><ul><li>queue：用于存放 Pipelinerivers，如果 driver 已经 DriverState::CANCELED 状态则从头部压入，否则从尾部压入</li><li>pending_cancel_queue：用于存放正在取消的 driver</li><li>cancelled_set：用于记录已经取消的 drivers，如果 queue 中取出的 drivers 已经在 canceled_set 中，则忽略该 driver，从 queue 中重新取</li></ul><p>结构如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SubQuerySharedDriverQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update_accu_time</span><span class="params">(<span class="type">const</span> DriverRawPtr driver)</span> </span>&#123;</span><br><span class="line">        _accu_consume_time.<span class="built_in">fetch_add</span>(</span><br><span class="line">            driver-&gt;<span class="built_in">driver_acct</span>().<span class="built_in">get_last_time_spent</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">accu_time_after_divisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> _accu_consume_time.<span class="built_in">load</span>() / factor_for_normal; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">const</span> DriverRawPtr driver)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cancel</span><span class="params">(<span class="type">const</span> DriverRawPtr driver)</span></span>;</span><br><span class="line">    <span class="function">DriverRawPtr <span class="title">take</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    std::deque&lt;DriverRawPtr&gt; queue;</span><br><span class="line">    std::queue&lt;DriverRawPtr&gt; pending_cancel_queue;</span><br><span class="line">    std::unordered_set&lt;DriverRawPtr&gt; cancelled_set;</span><br><span class="line">    <span class="type">size_t</span> num_drivers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// factor for normalization</span></span><br><span class="line">    <span class="type">double</span> factor_for_normal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::atomic&lt;<span class="type">int64_t</span>&gt; _accu_consume_time = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><p>driver 如果已经处于 DriverState::CANCELED 状态，则从头部压入，否则从尾部压入。cancel 函数是直接压入 pending_cancel_queue 中。 queue 和 pending_cancel_queue 是可能存在重复的 driver，因此需要 cancelled_set 去重。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SubQuerySharedDriverQueue::put</span><span class="params">(<span class="type">const</span> DriverRawPtr driver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (driver-&gt;<span class="built_in">driver_state</span>() == DriverState::CANCELED) &#123;</span><br><span class="line">        queue.<span class="built_in">emplace_front</span>(driver);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        queue.<span class="built_in">emplace_back</span>(driver);</span><br><span class="line">    &#125;</span><br><span class="line">    num_drivers++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SubQuerySharedDriverQueue::cancel</span><span class="params">(<span class="type">const</span> DriverRawPtr driver)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cancelled_set.<span class="built_in">count</span>(driver) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">DCHECK</span>(driver-&gt;<span class="built_in">is_in_ready_queue</span>());</span><br><span class="line">        pending_cancel_queue.<span class="built_in">emplace</span>(driver);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="take"><a href="#take" class="headerlink" title="take"></a>take</h3><p>从 SubQuerySharedDriverQueue 中获取 driver 时</p><ul><li>如果 pending_cancel_queue 不为空，率先从 pending_cancel_queue 中取，并将获得的 driver 记录在 cancelld_set 中。</li><li>否则，再从 queue 中获取，如果 driver 已经在 cancelled_set 中记录，则忽略并重新从 queue 中获取。</li></ul><p>代码也是比较简单的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DriverRawPtr <span class="title">SubQuerySharedDriverQueue::take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DCHECK</span>(!<span class="built_in">empty</span>());</span><br><span class="line">    <span class="keyword">if</span> (!pending_cancel_queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        DriverRawPtr driver = pending_cancel_queue.<span class="built_in">front</span>();</span><br><span class="line">        pending_cancel_queue.<span class="built_in">pop</span>();</span><br><span class="line">        cancelled_set.<span class="built_in">insert</span>(driver);</span><br><span class="line">        --num_drivers;</span><br><span class="line">        <span class="keyword">return</span> driver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        DriverRawPtr driver = queue.<span class="built_in">front</span>();</span><br><span class="line">        queue.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">auto</span> iter = cancelled_set.<span class="built_in">find</span>(driver);</span><br><span class="line">        <span class="keyword">if</span> (iter != cancelled_set.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            cancelled_set.<span class="built_in">erase</span>(iter);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            --num_drivers;</span><br><span class="line">            <span class="keyword">return</span> driver;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="QuerySharedDriverQueue"><a href="#QuerySharedDriverQueue" class="headerlink" title="QuerySharedDriverQueue"></a>QuerySharedDriverQueue</h2><p>QuerySharedDriverQueue 一共有 QUEUE_SIZE（值是 8）个 SubQuerySharedDriverQueue，每个 SubQueue 对应的时间片依次是 <strong>{0.2s, 0.6s, 1.2s, 2s, 3s, 4.2s, 5.6s, 7.2s}</strong>:</p><ul><li>比如 SubQueue[0] 的时间片范围是 <strong>[0, 0.2)</strong>, </li><li>超过 7.2s 的 Pipeline 都位于最后一个队列 SubQueue[7] 中，即 SubQueue[7] 的时间范围是 [5.6, +∞)。</li></ul><p>每个 Driver 消耗的时间片记录在 <code>DriverAcct::accumulated_time_spent</code>，PipelineDriver 每执行一次就会调用一次 _update_statistics 函数来更新 DriverAcct 中的统计值，当 <em>accumulated_time_spent</em> 超过当前 SubQueue 的时间片区间，driver 就进入下一个 SubQueue。</p><p>QuerySharedDriverQueue 的构造函数如下 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">QuerySharedDriverQueue::<span class="built_in">QuerySharedDriverQueue</span>() &#123;</span><br><span class="line">    <span class="type">double</span> factor = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = QUEUE_SIZE - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="comment">// initialize factor for every sub queue,</span></span><br><span class="line">        <span class="comment">// Higher priority queues have more execution time,</span></span><br><span class="line">        <span class="comment">// so they have a larger factor.</span></span><br><span class="line">        _queues[i].factor_for_normal = factor;</span><br><span class="line">        factor *= RATIO_OF_ADJACENT_QUEUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int64_t</span> time_slice = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; QUEUE_SIZE; ++i) &#123;</span><br><span class="line">        time_slice += LEVEL_TIME_SLICE_BASE_NS * (i + <span class="number">1</span>);</span><br><span class="line">        _level_time_slices[i] = time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compute-driver-level"><a href="#compute-driver-level" class="headerlink" title="_compute_driver_level"></a>_compute_driver_level</h3><p>向 QuerySharedDriverQueue 添加 driver 时，从上一次所处的层 <code>PipelineDriver::get_driver_queue_level</code> 开始，再基于 accumulated_time_spent 计算 driver 本次将位于 DriverQueue 中的哪一层。</p><p>因此，一个长时间的运行的 driver 在 DriverQueue 中不断下沉。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> QuerySharedDriverQueue::_compute_driver_level(<span class="type">const</span> DriverRawPtr driver) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="type">int</span> time_spent = driver-&gt;<span class="built_in">driver_acct</span>().<span class="built_in">get_accumulated_time_spent</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = driver-&gt;<span class="built_in">get_driver_queue_level</span>(); i &lt; QUEUE_SIZE; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (time_spent &lt; _level_time_slices[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QUEUE_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put-back"><a href="#put-back" class="headerlink" title="put_back"></a>put_back</h3><p>put_back 函数将 READY 的 driver 放入到 DriverQueue，</p><ul><li>PipelineDriver::_driver_queue_level 记录每次在 DrvierQueue 中的层。</li><li>PipelineDriver::_in_ready_queue 标记是否被 <code>put_back</code> 到 DrvierQueue 中</li><li>PipelineDriver::_in_queue 即 driver 所属的 DriverQueue</li></ul><p>插入一个 driver 后，通过 _cv 解除 take 函数处的阻塞，Executor 就可以继续通过 DriverQueue::take 函数获得新的可执行的 driver</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuerySharedDriverQueue::put_back</span><span class="params">(<span class="type">const</span> DriverRawPtr driver)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> level = _compute_driver_level(driver);</span><br><span class="line">    driver-&gt;<span class="built_in">set_driver_queue_level</span>(level);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_global_mutex)</span></span>;</span><br><span class="line">        _queues[level].<span class="built_in">put</span>(driver);</span><br><span class="line">        driver-&gt;<span class="built_in">set_in_ready_queue</span>(<span class="literal">true</span>);</span><br><span class="line">        driver-&gt;<span class="built_in">set_in_queue</span>(<span class="keyword">this</span>);</span><br><span class="line">        _cv.<span class="built_in">notify_one</span>();</span><br><span class="line">        ++_num_drivers;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// QuerySharedDriverQueue::put_back_from_executor is identical to put_back.</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuerySharedDriverQueue::put_back_from_executor</span><span class="params">(<span class="type">const</span> DriverRawPtr driver)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">put_back</span>(driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="take-1"><a href="#take-1" class="headerlink" title="take"></a>take</h3><p>put_back 函数是通过 <em>_compute_driver_level</em> 函数来确定 SubQueue 的层数。take 函数则通过 SubQuerySharedDriverQueue::accu_time_after_divisor() 来确定。 </p><ul><li><p>_accu_consume_time 字段是该 SubQueue 的耗时</p><p>这个值实际上和 <code>DriverAcct::accumulated_time_spent</code> 大小一样：每次更新统计时都是累加的 <code>DriverAcct::last_time_spent</code>。因此 put_back&#x2F;take 的衡量标准是一样的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DriverAcct::update_last_time_spent</span><span class="params">(<span class="type">int64_t</span> time_spent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;last_time_spent = time_spent;</span><br><span class="line">    <span class="keyword">this</span>-&gt;accumulated_time_spent += time_spent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SubQuerySharedDriverQueue::update_accu_time</span><span class="params">(<span class="type">const</span> DriverRawPtr driver)</span> </span>&#123;</span><br><span class="line">    _accu_consume_time.<span class="built_in">fetch_add</span>(driver-&gt;<span class="built_in">driver_acct</span>().<span class="built_in">get_last_time_spent</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>factor_for_normal 是在 QUEUE_SIZE 个 SubQueue 的正则系数</p></li></ul><p>二者相处得到归一化的时间系数，<u>使得每一层都有机会被访问到</u>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">SubQuerySharedDriverQueue::accu_time_after_divisor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _accu_consume_time.<span class="built_in">load</span>() / factor_for_normal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>确定好 level 后，就可以直接从该 level 提取出 READY 状态的 PipelineDriver。如果整个 DriverQueue 都空的，则基于 _cv 阻塞等待。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StatusOr&lt;DriverRawPtr&gt; <span class="title">QuerySharedDriverQueue::take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// -1 means no candidates; else has candidate.</span></span><br><span class="line">  <span class="type">int</span> queue_idx = <span class="number">-1</span>;</span><br><span class="line">  <span class="type">double</span> target_accu_time = <span class="number">0</span>;</span><br><span class="line">  DriverRawPtr driver_ptr;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(_global_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="built_in">RETURN_IF</span>(_is_closed, Status::<span class="built_in">Cancelled</span>(<span class="string">&quot;Shutdown&quot;</span>));</span><br><span class="line">        <span class="comment">// Find the queue with the smallest execution time.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; QUEUE_SIZE; ++i) &#123;</span><br><span class="line">            <span class="comment">// we just search for queue has element</span></span><br><span class="line">            <span class="keyword">if</span> (!_queues[i].<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                <span class="type">double</span> local_target_time = _queues[i].<span class="built_in">accu_time_after_divisor</span>();</span><br><span class="line">                <span class="keyword">if</span> (queue_idx &lt; <span class="number">0</span> || local_target_time &lt; target_accu_time) &#123;</span><br><span class="line">                    target_accu_time = local_target_time;</span><br><span class="line">                    queue_idx = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue_idx &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        _cv.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// record queue&#x27;s index to accumulate time for it.</span></span><br><span class="line">    driver_ptr = _queues[queue_idx].<span class="built_in">take</span>();</span><br><span class="line">    driver_ptr-&gt;<span class="built_in">set_in_ready_queue</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    --_num_drivers;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// next pipeline driver to execute.</span></span><br><span class="line">  <span class="keyword">return</span> driver_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DriverQueue 的继承派生关系如下图所示。QuerySharedDriverQueue 是用于没有设置 ResuorceGroup 的 query，即 default ResourceGroup，而 WorkGroupDriverQueue 是针对设置了 Resou</summary>
      
    
    
    
    <category term="Pipeline" scheme="https://szza.github.io/categories/Pipeline/"/>
    
    
    <category term="StarRocks" scheme="https://szza.github.io/tags/StarRocks/"/>
    
  </entry>
  
</feed>
