<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>szza</title>
  
  <subtitle>look code art</subtitle>
  <link href="https://szza.github.io/atom.xml" rel="self"/>
  
  <link href="https://szza.github.io/"/>
  <updated>2023-07-31T14:35:00.000Z</updated>
  <id>https://szza.github.io/</id>
  
  <author>
    <name>fibonaccii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>内存分配器之 concurrent_arena</title>
    <link href="https://szza.github.io/2022/01/07/RocksDB/MemoryAllocator/2_concurrent_arena/"/>
    <id>https://szza.github.io/2022/01/07/RocksDB/MemoryAllocator/2_concurrent_arena/</id>
    <published>2022-01-07T06:15:35.000Z</published>
    <updated>2023-07-31T14:35:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrent-arena"><a href="#concurrent-arena" class="headerlink" title="concurrent_arena"></a>concurrent_arena</h1><p>在上一期的 <a href="./2_arena.md">存分配器之 arena</a> 中，讲解了 RocksDb 是如何混合new、mmap设计一个高效的内存分配器。这一期，我们继续深入探索 RocksDb 是如何设计出一个高效的多线程内存分配器 <code>concurrent_arena</code> 。</p><p>let’s go</p><p>多线程程序的性能关键，有两个关键因素：</p><ul><li><p>减少竞争</p><p>减少竞争，有诸多方式，比如使用原子变量、细粒度锁（fine-grained mutex），threadlocal。</p></li><li><p>False Sharing</p><p>降低false sharing，一般解决办法是将线程间共享的数据大小与cacheline大小对齐（align）。</p></li></ul><p>而 concurrent_arena 即在 arena 的基础上，增加了一些多线程间的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcurrentArena</span> :</span> <span class="keyword">public</span> Allocator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// @brief 参数 @c block_size 与 @c huge_page_size 含义同 Arena 中</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ConcurrentArena</span><span class="params">(<span class="keyword">size_t</span> block_size = Arena::kMinBlockSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">size_t</span> huge_page_size = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 分配无须对齐的内存</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 分配需要对齐的内存</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes, </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Logger* logger = <span class="literal">nullptr</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Shard</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> padding[<span class="number">40</span>] ROCKSDB_FIELD_UNUSED; </span><br><span class="line">    <span class="keyword">mutable</span> SpinMutex mutex;</span><br><span class="line">    <span class="keyword">char</span>* free_begin_; </span><br><span class="line">    <span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; allocated_and_unused_; </span><br><span class="line"></span><br><span class="line">    Shard() : free_begin_(<span class="literal">nullptr</span>), allocated_and_unused_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">size_t</span> tls_cpuid; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> padding0[<span class="number">56</span>] ROCKSDB_FIELD_UNUSED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> shard_block_size_;</span><br><span class="line"></span><br><span class="line">  CoreLocalArray&lt;Shard&gt; shards_; <span class="comment">// 存储数据</span></span><br><span class="line"></span><br><span class="line">  Arena arena_;                                     <span class="comment">// 内存分配器</span></span><br><span class="line">  <span class="keyword">mutable</span> SpinMutex arena_mutex_;                   <span class="comment">// 保证使用 arena 分配内存时线程安全</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; arena_allocated_and_unused_;  <span class="comment">// arena_ 剩余可使用的内存 </span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; memory_allocated_bytes_;      <span class="comment">// arena 总的分配内存</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; irregular_block_num_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span> padding1[<span class="number">56</span>] ROCKSDB_FIELD_UNUSED;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Shard"><a href="#ConcurrentArena-Shard" class="headerlink" title="ConcurrentArena::Shard"></a>ConcurrentArena::Shard</h3><p>为避免竞争，<code>concurrent_arena</code> 使用将每个线程所需的内存分配在线程所属的cpu核上，如此每个线程在分配内存时都会使用自己的内存，如此就避免了竞争。这也是一种空间换时间的策略，类似于threadlocal思想。</p><p>结构体 <code>Shard</code> 记录了每个核上的内存分配、使用情况。字段 <code>shards_</code> 记录了所有核上shard。</p><p>类<code>CoreLocalArray</code> 本质上是个数组，为了提高多线程的访问效率，要将<code>Shard</code>的大小对齐到cacheline大小，以阻止false sharing现象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Shard</span> &#123;</span></span><br><span class="line">   <span class="comment">// 填充字节以对齐到 cacheline, 避免 false sharding</span></span><br><span class="line">   <span class="keyword">char</span> padding[<span class="number">40</span>] ROCKSDB_FIELD_UNUSED; </span><br><span class="line">   <span class="comment">// 用于保护 free_begin_ 指向的数据</span></span><br><span class="line">   <span class="keyword">mutable</span> SpinMutex mutex;</span><br><span class="line">   <span class="comment">// 每个core上分配内存地址</span></span><br><span class="line">   <span class="keyword">char</span>* free_begin_; </span><br><span class="line">   <span class="comment">// 每个core剩余可用内存</span></span><br><span class="line">   <span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; allocated_and_unused_; </span><br><span class="line"></span><br><span class="line">   Shard() : free_begin_(<span class="literal">nullptr</span>), allocated_and_unused_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> CoreLocalArray&lt;Shard&gt; shards_;</span><br></pre></td></tr></table></figure><h4 id="CoreLocalArray"><a href="#CoreLocalArray" class="headerlink" title="CoreLocalArray"></a>CoreLocalArray</h4><p>类 <code>CoreLocalArray</code>  只用于存储数据，本身不是线程安全的，因此需要 <code>Shard::mutex</code> 字段保护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoreLocalArray</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  CoreLocalArray();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 数组元素个数</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">Size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @return 返回当前线程所在core上的数据地址 ptr</span></span><br><span class="line">  <span class="function">T* <span class="title">Access</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> AccessElementAndIndex().first;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// @return 不仅返回当前线程所在core上的数据地址 ptr，还返回该core的index</span></span><br><span class="line">  std::pair&lt;T*, size_t&gt; AccessElementAndIndex() const;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 通过 core_idx 来获取该 core 的数据</span></span><br><span class="line">  <span class="function">T* <span class="title">AccessAtCore</span><span class="params">(<span class="keyword">size_t</span> core_idx)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T[]&gt; data_;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">int</span> size_shift_;             </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-CoreLocalArray"><a href="#CoreLocalArray-CoreLocalArray" class="headerlink" title="CoreLocalArray::CoreLocalArray"></a>CoreLocalArray::CoreLocalArray</h5><p>C++11中提供了<code>std::thread::hardware_concurrency</code> 函数，来获取CPU的核数<code>num_cpus</code>，将线程数设置为 <code>num_cpus</code>，如此就能避免在一个进程中线程频繁的在不同的core上来回切换，降低线程切换上下文的开销。</p><ul><li>如果<code>num_cpus &lt;= 8</code>，则启动8个线程；</li><li>否则，开启<code>num_cpus</code>个线程（num_cpus 一般也是2的幂）。</li></ul><p>代码简洁如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CoreLocalArray&lt;T&gt;::CoreLocalArray() &#123;</span><br><span class="line">  <span class="keyword">int</span> num_cpus = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(<span class="built_in">std</span>::thread::hardware_concurrency());</span><br><span class="line">  size_shift_ = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span> &lt;&lt; size_shift_ &lt; num_cpus) &#123;</span><br><span class="line">    ++size_shift_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每个core上都有类型 T 的数据</span></span><br><span class="line">  data_.reset(<span class="keyword">new</span> T[<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-AccessAtCore"><a href="#CoreLocalArray-AccessAtCore" class="headerlink" title="CoreLocalArray::AccessAtCore"></a>CoreLocalArray::AccessAtCore</h5><p><code>AccessAtCore</code> 函数，用于获取核<code>core_idx</code>上的数据，即获取数组<code>data_[core_idx]</code>中数据。</p><p>在这解释下为啥类型<code>T</code>大小需要对齐到 cacheline大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* CoreLocalArray&lt;T&gt;::AccessAtCore(<span class="keyword">size_t</span> core_idx) <span class="keyword">const</span> &#123;</span><br><span class="line">  assert(core_idx &lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_);</span><br><span class="line">  <span class="keyword">return</span> &amp;data_[core_idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-AccessElementAndIndex"><a href="#CoreLocalArray-AccessElementAndIndex" class="headerlink" title="CoreLocalArray::AccessElementAndIndex"></a>CoreLocalArray::AccessElementAndIndex</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">pair</span>&lt;T*, <span class="keyword">size_t</span>&gt; CoreLocalArray&lt;T&gt;::AccessElementAndIndex() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">int</span> cpuid = port::PhysicalCoreID(); <span class="comment">// 获取cpu的物理id</span></span><br><span class="line">  <span class="keyword">size_t</span> core_idx;</span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(cpuid &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// cpu id unavailable, just pick randomly</span></span><br><span class="line">    core_idx = Random::GetTLSInstance()-&gt;Uniform(<span class="number">1</span> &lt;&lt; size_shift_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将 cpuid 映射到 1 &lt;&lt; size_shift_ 以内</span></span><br><span class="line">    core_idx = <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(cpuid &amp; ((<span class="number">1</span> &lt;&lt; size_shift_) - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;AccessAtCore(core_idx), core_idx&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-ShardAllocatedAndUnused"><a href="#ConcurrentArena-ShardAllocatedAndUnused" class="headerlink" title="ConcurrentArena::ShardAllocatedAndUnused"></a>ConcurrentArena::ShardAllocatedAndUnused</h3><p><code>ShardAllocatedAndUnused</code> 则用于记录，<code>shards</code>中各个<code>shard</code>中剩余可用内存大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有已分配但未使用的内存</span></span><br><span class="line"> <span class="function"><span class="keyword">size_t</span> <span class="title">ConcurrentArena::ShardAllocatedAndUnused</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">   <span class="keyword">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; shards_.Size(); ++i) &#123;</span><br><span class="line">     total += </span><br><span class="line">       shards_.AccessAtCore(i)-&gt;allocated_and_unused_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> total;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-ConcurrentArena"><a href="#ConcurrentArena-ConcurrentArena" class="headerlink" title="ConcurrentArena::ConcurrentArena"></a>ConcurrentArena::ConcurrentArena</h3><p><code>ConcurrentArena</code> 的构造函数比较简单：</p><ol><li>初始化每个<code>shard</code> 需要分配的内存大小 <code>shard_block_size_</code>；</li><li>初始化 <code>shards_</code> 数组；</li><li>初始化<code>arena</code></li><li>调用<code>Fixup</code>函数，初始化内存使用情况；</li></ol><p>简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentArena::ConcurrentArena(<span class="keyword">size_t</span> block_size,</span><br><span class="line">                                 AllocTracker* tracker,</span><br><span class="line">                                 <span class="keyword">size_t</span> huge_page_size)</span><br><span class="line">    : shard_block_size_(<span class="built_in">std</span>::min(kMaxShardBlockSize, block_size / <span class="number">8</span>)),</span><br><span class="line">      shards_(),</span><br><span class="line">      arena_(block_size, tracker, huge_page_size) &#123;</span><br><span class="line">  Fixup();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Fixup"><a href="#ConcurrentArena-Fixup" class="headerlink" title="ConcurrentArena::Fixup"></a>ConcurrentArena::Fixup</h3><p><code>FixUp</code> 函数用于记录当前内存情况。</p><p>下面三个原子变量写入新值时，使用<code>::std::memory_order_relaxed</code>即能满足。关于<code>memory order</code>，花了两个周末的时候重温了下，有时间会再出博客深度讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConcurrentArena::Fixup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arena_ 所分配的内存中剩余可使用的内存</span></span><br><span class="line">    arena_allocated_and_unused_.store(arena_.AllocatedAndUnused(), <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// arena 分配的内存总量</span></span><br><span class="line">    memory_allocated_bytes_.store(arena_.MemoryAllocatedBytes(), <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    irregular_block_num_.store(arena_.IrregularBlockNum(), <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Repick"><a href="#ConcurrentArena-Repick" class="headerlink" title="ConcurrentArena::Repick"></a>ConcurrentArena::Repick</h3><p><code>Repick</code> 函数，用来初始化线程。把一个线程绑定到所属的核<code>tls_cpuid</code>。这样下次以后这个线程需要内存，直接去对应的<code>shard</code>获取内存。</p><p>注意，<code>tls_cpuid</code> 默认为0，因此对于<code>core_idx</code>为0的线程需要映射到<code>num_cpus</code>，这样就能通过<code>tls_cpuid != 0</code>来判断这个线程是否初始化过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ConcurrentArena::Shard* <span class="title">ConcurrentArena::Repick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> shard_and_index = shards_.AccessElementAndIndex();</span><br><span class="line">  <span class="comment">// 用于将 cord_idx 为 0 时 映射为 num_cpus，来体现此线程已初始化 </span></span><br><span class="line">  tls_cpuid = shard_and_index.second | shards_.Size();</span><br><span class="line">  <span class="keyword">return</span> shard_and_index.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-AllocateImpl"><a href="#ConcurrentArena-AllocateImpl" class="headerlink" title="ConcurrentArena::AllocateImpl"></a>ConcurrentArena::AllocateImpl</h3><p>整个流程如下：</p><ol><li><p>先判断此次分配内存，是否需要从arena直接分配即可</p><ul><li>超过一个shards内存大小的1/4</li><li>上层强制使用 arena</li><li>该线程首次调用<code>AllocateImpl</code> 函数，此时<code>shards</code>中的各个<code>shard-&gt;free_begin</code>尚未指向有效内存地址；</li></ul><p>如果要使用 <code>arena_</code>，则需要使用<code>arena_mutex_</code>保护。</p></li><li><p>尝试从shard中获取内存</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">AllocateImpl</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">bool</span> force_arena, <span class="keyword">const</span> Func&amp; func)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> cpu;</span><br><span class="line">  <span class="comment">// 直接使用arena分配内存，有两种情况：</span></span><br><span class="line">  <span class="comment">// 1. 待分配的内存比较大。</span></span><br><span class="line">  <span class="comment">// 2. Repick 尚未调用过，并且当前 arena_mutex_ 能直接获得</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;SpinMutex&gt; <span class="title">arena_lock</span><span class="params">(arena_mutex_, <span class="built_in">std</span>::defer_lock)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; shard_block_size_ / <span class="number">4</span> </span><br><span class="line">      <span class="comment">// 使用 huge_page</span></span><br><span class="line">      || force_arena </span><br><span class="line">      <span class="comment">// 判断条件执行到此，说明 所需的内存 bytes 并不大，比较小</span></span><br><span class="line">      <span class="comment">// 原则上是不需要使用 arena，但是如果同时满足以下二个条件：</span></span><br><span class="line">      <span class="comment">//  1. 没有执行过 Repick 函数</span></span><br><span class="line">      <span class="comment">//  2. 成功获得锁</span></span><br><span class="line">      || ((cpu = tls_cpuid) == <span class="number">0</span>   <span class="comment">// 线程尚未初始化</span></span><br><span class="line">           &amp;&amp; !shards_.AccessAtCore(<span class="number">0</span>)-&gt;allocated_and_unused_.load(<span class="built_in">std</span>::memory_order_relaxed) </span><br><span class="line">           &amp;&amp; arena_lock.try_lock())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arena_lock.owns_lock()) &#123;</span><br><span class="line">      <span class="comment">// 阻塞等待</span></span><br><span class="line">      arena_lock.lock();</span><br><span class="line">      <span class="comment">// 获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> rv = func(); <span class="comment">// 分配内存的回调函数</span></span><br><span class="line">    Fixup();</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 选择一个 shard 来满足此次内存分配</span></span><br><span class="line">  Shard* s = shards_.AccessAtCore(cpu &amp; (shards_.Size() - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (!s-&gt;mutex.try_lock()) &#123;</span><br><span class="line">    s = Repick();</span><br><span class="line">    s-&gt;mutex.lock();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;SpinMutex&gt; <span class="title">lock</span><span class="params">(s-&gt;mutex, <span class="built_in">std</span>::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> avail = s-&gt;allocated_and_unused_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (avail &lt; bytes) &#123;</span><br><span class="line">    <span class="comment">// reload</span></span><br><span class="line">    <span class="comment">// 此时需要使用 arnea 来分配内存</span></span><br><span class="line">    <span class="comment">// 1. 该 core 所剩的内存不足</span></span><br><span class="line">    <span class="comment">// 2. 第一次执行（本质还是第一种情况）</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;SpinMutex&gt; <span class="title">reload_lock</span><span class="params">(arena_mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> exact = arena_allocated_and_unused_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    assert(exact == arena_.AllocatedAndUnused());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exact &gt;= bytes &amp;&amp; arena_.IsInInlineBlock()) &#123;</span><br><span class="line">      <span class="comment">// 如果还没有消耗完 arena 的inline block的内存，则直接使用该内存</span></span><br><span class="line">      <span class="comment">// 这样就可以避免分配新的block，</span></span><br><span class="line">      <span class="keyword">auto</span> rv = func(); <span class="comment">// 执行回调函数分配</span></span><br><span class="line">      Fixup();</span><br><span class="line">      <span class="keyword">return</span> rv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avail = exact &gt;= shard_block_size_ / <span class="number">2</span> &amp;&amp; exact &lt; shard_block_size_ * <span class="number">2</span></span><br><span class="line">                ? exact</span><br><span class="line">                : shard_block_size_;</span><br><span class="line">    <span class="comment">// 重新分配内存</span></span><br><span class="line">    <span class="comment">// 首次调用即在此分配内存</span></span><br><span class="line">    s-&gt;free_begin_ = arena_.AllocateAligned(avail);</span><br><span class="line">    Fixup();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可用内存减少</span></span><br><span class="line">  s-&gt;allocated_and_unused_.store(avail - bytes, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">char</span>* rv;</span><br><span class="line">  <span class="keyword">if</span> ((bytes % <span class="keyword">sizeof</span>(<span class="keyword">void</span>*)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// aligned allocation from the beginning</span></span><br><span class="line">    rv = s-&gt;free_begin_;</span><br><span class="line">    s-&gt;free_begin_ += bytes;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// unaligned from the end</span></span><br><span class="line">    rv = s-&gt;free_begin_ + avail - bytes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concurrent-arena&quot;&gt;&lt;a href=&quot;#concurrent-arena&quot; class=&quot;headerlink&quot; title=&quot;concurrent_arena&quot;&gt;&lt;/a&gt;concurrent_arena&lt;/h1&gt;&lt;p&gt;在上一期的 &lt;a href=</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>内存分配器之 arena</title>
    <link href="https://szza.github.io/2022/01/06/RocksDB/MemoryAllocator/2_arena/"/>
    <id>https://szza.github.io/2022/01/06/RocksDB/MemoryAllocator/2_arena/</id>
    <published>2022-01-06T06:15:35.000Z</published>
    <updated>2023-07-31T14:54:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天，就开始逐步更新剖析 RocksDb 源码的博客。思前想后，准备自下而上，因此还是从内存分配器开始叭。</p><p>在 RocksDb 中主要有两类内存分配器<code>MemoryAllocator</code>、<code>Allocator</code>。</p><h4 id="MemoryAllocator"><a href="#MemoryAllocator" class="headerlink" title="MemoryAllocator"></a>MemoryAllocator</h4><p><code>MemoryAllocator</code> 是个基类，RocksDb 提供了两个子类：<code>MemkindKmemAllocator</code>、<code>JemallocNodumpAllocator</code>，而这两个子类，实际上分别是 <a href="https://github.com/memkind/memkind">memkind</a>、<a href="https://github.com/jemalloc/jemalloc">jemalloc</a>两个开源库的 wrapper，即利用两个开源库的函数来实现<code>Allocate</code>、<code>Deallocate</code>操作。<code>jemalloc</code>后者有时间再开专题专门细解，这里就不展开说了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MemoryAllocator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~MemoryAllocator() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///@note 需要保证线程安全</span></span><br><span class="line">  <span class="comment">///@param 至少分配的内存大小</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>* <span class="title">Allocate</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///@note 需要保证线程安全</span></span><br><span class="line">  <span class="comment">///@brief 释放之前由 Allocate 分配的内存</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Deallocate</span><span class="params">(<span class="keyword">void</span>* p)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///@brief 返回 ptr 指向的block的内存大小</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">UsableSize</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> allocation_size)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// default implementation just returns the allocation size</span></span><br><span class="line">    <span class="keyword">return</span> allocation_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h2><p>本节主要详细讲解<code>Allocator</code>及其子类<code>Arena</code>的实现。</p><p>类 <code>Allocator</code> 是个基类，主要有两个接口：</p><ul><li><code>Allocate</code>：分配无须对齐的内存；</li><li><code>AllocateAligned</code>：分配需要经过对齐的内存；</li></ul><p>关于内存对齐，可以参考之前写过的一期博客 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析]，在这一期，通过讲解<code>Allocator</code>，会更加深刻的理解内存对齐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Allocator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~Allocator() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span>* <span class="title">Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes, </span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                Logger* logger = <span class="literal">nullptr</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">BlockSize</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基类<code>Allocator</code> 有两个子类，<code>Arena</code> 和<code>concurrent_arena</code>，分别用于单线程和多线程内存分配，其中 <code>concurrent_arena</code> 也是个<code>Arena</code>的<code>wrapper</code>，外加了一些措施，保证<code>Arnea</code>在多线程下的安全。因此，本文先详细讲解下<code>Arena</code>，下一节再把注意力集中在concurrent_arena`的多线程设计上。</p><img src="/Users/shuzhuangzhuang/self_study/graph/需求/rocksdb/images/Allocator.jpg" style="zoom:50%;" /><h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><p>类<code>Arena</code> 在分配内存时，是以 <code>block</code> 为单位，即每次先分配一个<code>block</code>大小的内存，后续所需<code>bytes</code>大小的内存时，会先尝试从<code>block</code> 中获取，如果这个<code>block</code>中剩余的可用内存能满足<code>bytes</code>，则从<code>block</code>中划出一部分给上层使用，否则才从操作系统中获取。</p><p>一个<code>block</code>容纳的内存大小，由<code>kBlockSize</code>参数来指定。</p><p>现在<code>Arena</code>怎么实现基类中<code>Allocate</code>、<code>AllocateAligned</code>两个接口？</p><p><code>Arena</code> 中有两个指针：<code>aligned_alloc_ptr_</code>、<code>unaligned_alloc_ptr_</code>，当一个<code>block</code>的内存创建完毕时：</p><ul><li><code>aligned_alloc_ptr_</code>：指向该<code>block</code>的首地址（低地址），后续用于分配需要对齐的内存；</li><li><code>unaligned_alloc_ptr_</code>：指向该<code>block</code>的末地址（高地址），后续用于分配不需要对齐的内存。</li></ul><p>示意图如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block : [-------------------------]</span><br><span class="line">        ^                         ^</span><br><span class="line">        |                         | </span><br><span class="line">   aligned_alloc_ptr_    unaligned_alloc_ptr_</span><br></pre></td></tr></table></figure><p>为啥要这么做？</p><p>由于每次内存对齐操作可能存在一定的浪费，而同一个类中所需的内存对齐大小一般是固定的，因此从blokc的一端只分配需要对齐的内存，若内存对齐大小是固定的，那么每次分配的内存也都是连续的，如此就可以减少因为内存对齐带来的浪费。</p><p>从<code>block</code>的另一端分配无需对齐的内存，还能提高内存利用率。</p><blockquote><p>比如，block的大小为7个字节，分配一块需要4字节对齐的内存，还剩下3字节的内存，可以继续用于无须对齐的内存。</p></blockquote><p>下面先整体看看类<code>Arean</code>。</p><blockquote><p>在下面的源码分析中，做了一些简化，去除了一些统计内存大小部分的代码，读者可自行追溯RocksDb中该部分的源码。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Arena</span> :</span> <span class="keyword">public</span> Allocator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  Arena(<span class="keyword">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kInlineSize = <span class="number">2048</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kMinBlockSize;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kMaxBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Arena</span><span class="params">(<span class="keyword">size_t</span> block_size = kMinBlockSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                 AllocTracker* tracker = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">size_t</span> huge_page_size = <span class="number">0</span>)</span></span>;</span><br><span class="line">  ~Arena();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 分配无需对齐的内存</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 分配需要对齐的内存</span></span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes, </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                        Logger* logger = <span class="literal">nullptr</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// 当前已使用内存大小</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">ApproximateMemoryUsage</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blocks_memory_ + blocks_.capacity() * <span class="keyword">sizeof</span>(<span class="keyword">char</span>*) - alloc_bytes_remaining_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 总的已分配内存</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">MemoryAllocatedBytes</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> blocks_memory_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 剩余可用内存</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">AllocatedAndUnused</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> alloc_bytes_remaining_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 分配的不对齐block数</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">IrregularBlockNum</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> irregular_block_num; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 一个 block 的内存大小</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">BlockSize</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> kBlockSize; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// blocks_ 是否用的栈上内存</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">IsInInlineBlock</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blocks_.empty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">alignas</span>(<span class="keyword">max_align_t</span>) <span class="keyword">char</span> inline_block_[kInlineSize];</span><br><span class="line">  <span class="comment">// 一个block分配的内存大小</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> kBlockSize;           </span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>*&gt; Blocks; </span><br><span class="line">  <span class="comment">// 使用new分配的block集合</span></span><br><span class="line">  Blocks blocks_;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MmapInfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* addr_;</span><br><span class="line">    <span class="keyword">size_t</span> length_;</span><br><span class="line"></span><br><span class="line">    MmapInfo(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> length) : addr_(addr), length_(length) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 使用 mmap 分配内存的block集合</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;MmapInfo&gt; huge_blocks_; </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">size_t</span> irregular_block_num = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span>* unaligned_alloc_ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">char</span>* aligned_alloc_ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 当前block剩余可用内存</span></span><br><span class="line">  <span class="keyword">size_t</span> alloc_bytes_remaining_ = <span class="number">0</span>; </span><br><span class="line">   <span class="comment">// 目前一共分配的内存</span></span><br><span class="line">  <span class="keyword">size_t</span> blocks_memory_ = <span class="number">0</span>;        </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">size_t</span> hugetlb_size_ = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// MAP_HUGETLB</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateFromHugePage</span><span class="params">(<span class="keyword">size_t</span> bytes)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateFallback</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">bool</span> aligned)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">char</span>* <span class="title">AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Arena-Arena"><a href="#Arena-Arena" class="headerlink" title="Arena::Arena"></a>Arena::Arena</h3><p>先来看看构造函数 <code>Arena::Arena</code>。这里，主要初始化一些类成员变量：</p><ul><li><p><code>kBlockSize</code></p><p>字段<code>kBlockSize</code> ，表达的是以后每次分配一个block时的内存大小。在初始化之前，使用<code>OptimizeBlockSize</code>函数对传入的参数<code>block_size</code>进行限制，使其满足后续的<code>assert</code>判断。</p><p>通过 <code>OptimizeBlockSize</code> 函数限制<code>block_size</code>的值，减少后续分配需要对齐的内存浪费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> Arena::kMinBlockSize = <span class="number">4096</span>;           <span class="comment">// 最小为 4k</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> Arena::kMaxBlockSize = <span class="number">2u</span> &lt;&lt; <span class="number">30</span>;       <span class="comment">// 最大为 8k</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kAlignUnit = <span class="keyword">alignof</span>(<span class="keyword">max_align_t</span>); <span class="comment">// 按照 8 byte 对齐</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">OptimizeBlockSize</span><span class="params">(<span class="keyword">size_t</span> block_size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确保满足： Arena::kMinBlockSize &lt;= block_size &lt;= Arena::kMaxBlockSize</span></span><br><span class="line">  block_size = <span class="built_in">std</span>::max(Arena::kMinBlockSize, block_size);</span><br><span class="line">  block_size = <span class="built_in">std</span>::min(Arena::kMaxBlockSize, block_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保 block_size 是 8 的倍数</span></span><br><span class="line">  <span class="keyword">if</span> (block_size % kAlignUnit != <span class="number">0</span>) &#123;</span><br><span class="line">    block_size = (<span class="number">1</span> + block_size / kAlignUnit) * kAlignUnit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>inline_block_</code></p><p>字段<code>inline_block_</code> ，其中的<code>inline</code>语义是指这块内存分配在栈上，在地址上和<code>Arena</code>是连续的。这对于那些只需要分配小内存的操作具有优势，可以避免从堆上分配内存。当这块内存使用完毕，会再从堆上获取。</p></li><li><p><code>hugetlb_size_</code></p><p>字段<code>hugetlb_size_</code>，是默认情况下使用<code>mmap</code>给block分配的内存大小。如果 <code>hugetlb_size_ == 0</code>，则表示不使用<code>mmap</code>分配内存。</p><p>当然，<code>hugetlb_size_</code> 在构造函数中也是经过向上取整操作，变为 8 的倍数。</p></li></ul><p>现在，可以很好的阅读构造函数 <code>Arena::Arena</code> 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Arena::Arena(<span class="keyword">size_t</span> block_size, </span><br><span class="line">             AllocTracker* tracker, </span><br><span class="line">             <span class="keyword">size_t</span> huge_page_size)</span><br><span class="line">    : kBlockSize(OptimizeBlockSize(block_size)) &#123;</span><br><span class="line">  assert(kBlockSize &gt;= kMinBlockSize &amp;&amp; kBlockSize &lt;= kMaxBlockSize &amp;&amp;</span><br><span class="line">         kBlockSize % kAlignUnit == <span class="number">0</span>);</span><br><span class="line">  alloc_bytes_remaining_ = <span class="keyword">sizeof</span>(inline_block_);</span><br><span class="line">  blocks_memory_ += alloc_bytes_remaining_;</span><br><span class="line">  <span class="comment">// 对齐侧指向了低地址</span></span><br><span class="line">  aligned_alloc_ptr_ = inline_block_;</span><br><span class="line">  <span class="comment">// 不对齐侧指向了高地址</span></span><br><span class="line">  unaligned_alloc_ptr_ = inline_block_ + alloc_bytes_remaining_;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  hugetlb_size_ = huge_page_size;</span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_ &amp;&amp; kBlockSize &gt; hugetlb_size_) &#123;</span><br><span class="line">    <span class="comment">// hugetlb_size_ 向上取整</span></span><br><span class="line">    hugetlb_size_ = ((kBlockSize - <span class="number">1U</span>) / hugetlb_size_ + <span class="number">1U</span>) * hugetlb_size_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  (<span class="keyword">void</span>)huge_page_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateNewBlock"><a href="#Arena-AllocateNewBlock" class="headerlink" title="Arena::AllocateNewBlock"></a>Arena::AllocateNewBlock</h3><p><code>AllocateNewBlock</code> 函数比较普通，本质上就是使用 <code>new</code> 操作从操作系统获取内存。</p><p>这里面稍微有个<code>trick</code>的操作，是<code>blocks_.emplace_back(nullptr);</code> 这行，作用是在<code>blocks_</code>中预留一个指针大小的空间，即 <code>sizeof(Block*)</code>，出于内存泄露的考虑，使用了<code>emplace_back</code>，而不是<code>reserve</code>函数。</p><p>RocksDb 解释如下：</p><ul><li>如果<code>emplace_back</code> 函数抛出异常，不会发生内存泄露，因为此时还没使用<code>new</code>分配内存；</li><li>如果<code>new</code> 抛出异常（即<code>std::bad_alloc</code>异常），也不会发生内存泄露，因为在<code>blocks_</code>中预留的空间将会基于RAII语义被清除。</li></ul><p><code>AllocateNewBlock</code> 函数，直接使用<code>new</code>操作分配内存，不负责进行内存对齐操作。如果需要按照某个<code>alignment</code>大小进行对齐，得调用 <code>AllocateAligned</code>  函数，这个后面再说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///@return 返回指针，指向当前分配的 block</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Reserve space in `blocks_` before allocating memory via new.</span></span><br><span class="line">  <span class="comment">// Use `emplace_back()` instead of `reserve()` to let std::vector manage its</span></span><br><span class="line">  <span class="comment">// own memory and do fewer reallocations.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// - If `emplace_back` throws, no memory leaks because we haven&#x27;t called `new`</span></span><br><span class="line">  <span class="comment">//   yet.</span></span><br><span class="line">  <span class="comment">// - If `new` throws, no memory leaks because the vector will be cleaned up</span></span><br><span class="line">  <span class="comment">//   via RAII.</span></span><br><span class="line">  blocks_.emplace_back(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 分配内存</span></span><br><span class="line">  <span class="keyword">char</span>* block = <span class="keyword">new</span> <span class="keyword">char</span>[block_bytes];</span><br><span class="line">  <span class="keyword">size_t</span> allocated_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ROCKSDB_MALLOC_USABLE_SIZE</span></span><br><span class="line">  allocated_size = malloc_usable_size(block);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  allocated_size = block_bytes;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 增加已分配内存</span></span><br><span class="line">  blocks_memory_ += allocated_size;</span><br><span class="line">  <span class="comment">// 赋值</span></span><br><span class="line">  blocks_.back() = block;</span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来解释下为何使用<code>reserve</code>可能会导致内存泄露，写法如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="keyword">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  blocks_.reserve(<span class="number">1</span>);        <span class="comment">// 预留空间</span></span><br><span class="line">  <span class="keyword">char</span>* block = <span class="keyword">new</span> <span class="keyword">char</span>[block_bytes];</span><br><span class="line">  <span class="keyword">size_t</span> allocated_size;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ROCKSDB_MALLOC_USABLE_SIZE</span></span><br><span class="line">  allocated_size = malloc_usable_size(block);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  allocated_size = block_bytes;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  blocks_memory_ += allocated_size;</span><br><span class="line">  blocks_.emplace_back(block); <span class="comment">// 抛出异常???</span></span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理由很简单：上面这个写法，如果在<code>emplace_back</code>的过程中抛出异常，那么 <code>block</code> 指向的内存将会泄露。</p><p>尽管<code>emplace_back</code>抛异常这种bad case极少出现，但也应该为RocksDb的细致点赞。</p><h3 id="Arena-AllocateFromHugePage"><a href="#Arena-AllocateFromHugePage" class="headerlink" title="Arena::AllocateFromHugePage"></a>Arena::AllocateFromHugePage</h3><p><code>Arena</code> 中有两种方式从操作系统获取内存：</p><ul><li><code>new</code>：即如<code>Arena::AllocateNewBlock</code> 函中数的实现；</li><li><code>mmap</code>：即如 <code>Arena::AllocateFromHugePage</code> 函数中的实现。</li></ul><p><code>mmap</code>、<code>munmap</code>函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>; </span><br><span class="line"><span class="comment">// 释放 mmap 分配的内存</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;   </span><br></pre></td></tr></table></figure><p>使用<code>mmap</code>分配内存，需要<code>linux</code>内核支持  <a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/maz/arm-platforms/+/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2/Documentation/vm/hugetlbpage.txt">HUGE_PAGE</a>，即当前linux内核具有 <code>MAP_HUGETLB</code> 标志位， 即可以如下操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///@return 返回指针，指向当前分配的 block</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateFromHugePage</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先使用 emplace_back 理由同上</span></span><br><span class="line">  huge_blocks_.emplace_back(<span class="literal">nullptr</span> <span class="comment">/* addr */</span>, <span class="number">0</span> <span class="comment">/* length */</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 mmap 从 hugepage 中分配 bytes 个字节</span></span><br><span class="line">  <span class="keyword">void</span>* addr = mmap(<span class="literal">nullptr</span>, </span><br><span class="line">                    bytes, </span><br><span class="line">                    (PROT_READ | PROT_WRITE),</span><br><span class="line">                    (MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB), <span class="comment">// 需要 MAP_HUGETLB 支持</span></span><br><span class="line">                    <span class="number">-1</span>, </span><br><span class="line">                    <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  huge_blocks_.back() = MmapInfo(addr, bytes);</span><br><span class="line">  blocks_memory_ += bytes;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(addr);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  (<span class="keyword">void</span>)bytes;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateFallback"><a href="#Arena-AllocateFallback" class="headerlink" title="Arena::AllocateFallback"></a>Arena::AllocateFallback</h3><p>好嘞，介绍完上面两种分配内存的措施，现在来看看统一上述两个操作的<code>AllocateFallback</code>函数。</p><p>当调用<code>AllocateFallback</code>函数时，是上层发现当前<code>block</code>中剩余的内存无法满足<code>bytes</code>个字节的需求，需要重新从操作系统获取内存。运行到<code>AllocateFallback</code>函数时，逻辑如下：</p><ul><li><p>如果所需的内存大小 <code>bytes</code> 超过了<code>kBlockSize / 4</code>，就直接从操作系统中获取<code>bytes</code>大小的内存，返回给<code>AllocateFallback</code>函数的调用方。那么就能避免浪费当前 block 中剩余的内存，这部分可以继续保留，供给下一次内存分配时使用。</p></li><li><p>否则，当前block中剩余的内存就将会被抛弃，重新从操作系统获中分配一个block的内存，供给上层使用。</p><p>此时，由 <code>bytes &lt;= kBlockSize / 4</code>，因此也降低了浪费，</p></li></ul><p>现在，顺着代码注释往下看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="keyword">size_t</span> bytes, <span class="keyword">bool</span> aligned)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    ++irregular_block_num;</span><br><span class="line">    <span class="comment">// 如果所需的内存大小 bytes 超过了 block 的1/4，那么就直接分配内存</span></span><br><span class="line">    <span class="keyword">return</span> AllocateNewBlock(bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span>* block_head = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_) &#123;</span><br><span class="line">    <span class="comment">// mmap 分配的的一个block内存大小为 hugetlb_size_</span></span><br><span class="line">    size = hugetlb_size_;</span><br><span class="line">    block_head = AllocateFromHugePage(size);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (!block_head) &#123;</span><br><span class="line">    <span class="comment">// block_head == nullptr, 即当前linux内核不支 hugetlb</span></span><br><span class="line">    <span class="comment">// 那么使用 new 来分配内存</span></span><br><span class="line">    size = kBlockSize;</span><br><span class="line">    block_head = AllocateNewBlock(size);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//! 之前block未使用的内存就忽略了，</span></span><br><span class="line">  <span class="comment">//! 但不会内存泄露，因为会在析构函数 ~Arena 中释放</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前block划掉 bytes 个字节后，剩余的可用内存大小</span></span><br><span class="line">  alloc_bytes_remaining_ = size - bytes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (aligned) &#123;</span><br><span class="line">    aligned_alloc_ptr_ = block_head + bytes; <span class="comment">// 从低地址端增加 bytes 字节</span></span><br><span class="line">    unaligned_alloc_ptr_ = block_head + size;</span><br><span class="line">    <span class="comment">// 表示 [block_head, block_head + bytes) 可用</span></span><br><span class="line">    <span class="keyword">return</span> block_head;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    aligned_alloc_ptr_ = block_head; </span><br><span class="line">    unaligned_alloc_ptr_ = block_head + size - bytes; <span class="comment">// 尾部向前推动 bytes</span></span><br><span class="line">    <span class="comment">// 表示 [unaligned_alloc_ptr_, unaligned_alloc_ptr_ + bytes) 可用</span></span><br><span class="line">    <span class="keyword">return</span> unaligned_alloc_ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateAligned"><a href="#Arena-AllocateAligned" class="headerlink" title="Arena::AllocateAligned"></a>Arena::AllocateAligned</h3><p>最后，就是对外提供分配对齐内存的函数 <code>AllocateAligned</code>。</p><p>其输入参数<code>huge_page_size</code>，语义是在使用mmap分配内存时的自定义 <code>alignment</code>，如果 <code>huge_page_size</code>  为 0，只是表示此时不需要自定义的<code>alignment</code>，使用默认的<code>kAlignUnit</code>即可。</p><p>换句话说，当需要自定义<code>alignment</code>时，RcoskDb 是准备使用<code>mmap</code>来分配内存。</p><p>当使用默认的<code>kAlignUnit</code>，如果当前block中剩余的可用内存能满足need个字节（need个字节，是bytes字节按照<code>kAlignUnit</code>对齐的后的大小），则继续从当前block中划分出去need个字节，否则就使用上述的<code>AllocateFallback</code>函数，重新从操作系统分配内存。</p><p>现在，顺着代码注释向下看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Arena::AllocateAligned</span><span class="params">(<span class="keyword">size_t</span> bytes, </span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">size_t</span> huge_page_size,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Logger* logger)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Pointer size should be a power of 2</span></span><br><span class="line">  assert((kAlignUnit &amp; (kAlignUnit - <span class="number">1</span>)) == <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义的内存对齐值 huge_page_size，只使用mmap来分配</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (huge_page_size &gt; <span class="number">0</span> &amp;&amp; bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    assert(logger != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 将 bytes 向上调整到 huge_page_size 的整倍数</span></span><br><span class="line">    <span class="keyword">size_t</span> reserved_size = ((bytes - <span class="number">1U</span>) / huge_page_size + <span class="number">1U</span>) * huge_page_size;</span><br><span class="line">    assert(reserved_size &gt;= bytes);</span><br><span class="line">    <span class="keyword">char</span>* addr = AllocateFromHugePage(reserved_size);</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      ROCKS_LOG_WARN(logger,</span><br><span class="line">                     <span class="string">&quot;AllocateAligned fail to allocate huge TLB pages: %s&quot;</span>,</span><br><span class="line">                     errnoStr(errno).c_str());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  (<span class="keyword">void</span>)huge_page_size;</span><br><span class="line">  (<span class="keyword">void</span>)logger;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面则使用默认的 kAlignUnit 对齐大小</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> current_mod =</span><br><span class="line">      <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(aligned_alloc_ptr_) &amp; (kAlignUnit - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 计算距离对齐还差几个字节</span></span><br><span class="line">  <span class="keyword">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : kAlignUnit - current_mod);</span><br><span class="line">  <span class="comment">// 对齐后需分配的字节数</span></span><br><span class="line">  <span class="keyword">size_t</span> needed = bytes + slop;  </span><br><span class="line">  <span class="keyword">char</span>* result;</span><br><span class="line">  <span class="comment">// 当前block中的剩余内存是否能满足此次 needed 个字节需求</span></span><br><span class="line">  <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="comment">// result 调整到对齐后的位置</span></span><br><span class="line">    result = aligned_alloc_ptr_ + slop; </span><br><span class="line">    <span class="comment">// 调整到对齐后的位置</span></span><br><span class="line">    aligned_alloc_ptr_ += needed;  </span><br><span class="line">    <span class="comment">// block中剩余的字节数</span></span><br><span class="line">    alloc_bytes_remaining_ -= needed;   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前 block 剩余的内存不足，则从操作系统获取</span></span><br><span class="line">    result = AllocateFallback(bytes, <span class="literal">true</span> <span class="comment">/* aligned */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  assert((<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(result) &amp; (kAlignUnit - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>by the way</strong></p><p>这里稍微总结下，如何向上调整、计算对齐后的地址。</p><p>实际上计算的方法有很多种，但是都符合上一期 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析] 最后提到了一点：本质上就是以「<code>alignment</code>进制」向上（下）取为<code>alignment</code>的整倍数。</p><p>比如，在十进制下，12向上取整为10的倍数，即20。</p><p>理解了这一层之后，再来看看下面几个计算方式：</p><ul><li><p>case 1：<code>size_t aligned = ((bytes - 1U) / alignment + 1U) * alignment</code></p><p>单纯地将<code>bytes</code>向上调整为<code>alignment</code>的整倍数，可以实现为  <code>(bytes / alignment + 1U) * alignment</code>，那为啥要 <code>- 1</code> 呢？</p><p>如果<code>bytes</code>本身就已是<code>alignment</code>的整数，按照这 native 实现，会无端将<code>bytes</code>增加了<code>alignment</code>。为了应对这种情况，需要先减少1。</p><p>此外，在 <code>Arena::Arena</code> 中调整<code>hugetlb_size_</code> 时，也是如此计算。而在<code>OptimizeBlockSize</code>函数中，调整<code>block_size</code>时，可以确定<code>block_size</code> 不是 <code>kAlignUnit</code>的整数时，就可将<code>-1</code>去掉，简化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block_size % kAlignUnit != <span class="number">0</span>) &#123;</span><br><span class="line">  block_size = (<span class="number">1</span> + block_size / kAlignUnit) * kAlignUnit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>case 2：<code>size_t aligned = (bytes - 1u + alignment) &amp; -alignment</code></p><p>这种实现，利用位位运算将余数清除，效率较高，这也是<code>std::align</code> 函数的实现方式，这在 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析] 分析过，这里顺带再解释下。</p><p>其中 <code>alignment</code> 是无符号数，<code>-alignment</code> 的值实际上是 <code>::pow(2, n) - alignment</code>。那么<code>bytes - 1u + alignment</code> 对 <code>-alignment</code> 取 <code>&amp;</code>操作，就能保证 <code>bytes - 1u + alignment</code> 的高位不变，而小于<code>alignment</code> 的余数全部清除。 </p></li></ul><p>万变不离其宗，理解了这个逻辑，无论是向上调整、亦或是向下调整，都能很好理解了。</p><h3 id="Arena-Allocate"><a href="#Arena-Allocate" class="headerlink" title="Arena::Allocate"></a>Arena::Allocate</h3><p>讲完了上面<code>AllocateAligned</code>函数之后，再看<code>Allocate</code>函数，就非常好理解了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  assert(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 如果当前block剩余足够的内存，则直接分配</span></span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    unaligned_alloc_ptr_ -= bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> unaligned_alloc_ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不用对齐</span></span><br><span class="line">  <span class="keyword">return</span> AllocateFallback(bytes, <span class="literal">false</span> <span class="comment">/* unaligned */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-Arena-1"><a href="#Arena-Arena-1" class="headerlink" title="Arena::~Arena"></a>Arena::~Arena</h3><p>释放所有已分配的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Arena::~Arena() &#123;</span><br><span class="line">  <span class="comment">// 释放所有使用 new 分配的内存</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; block : blocks_) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] block;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; mmap_info : huge_blocks_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mmap_info.addr_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放所有使用 mmap 分配的内存</span></span><br><span class="line">    <span class="keyword">auto</span> ret = munmap(mmap_info.addr_, mmap_info.length_);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO(sdong): Better handling</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Say-Something"><a href="#Say-Something" class="headerlink" title="Say Something"></a>Say Something</h2><p>一个优秀的开源项目，其单元测试（unitest）也是很好的学习资料。尤其对于RocksDb这类比较大的项目，无法下手的话，可以先从单元测试着手。</p><p>下一期，讲解下多线程内存分配器的设计，会更加硬核，敬请期待。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天，就开始逐步更新剖析 RocksDb 源码的博客。思前想后，准备自下而上，因此还是从内存分配器开始叭。&lt;/p&gt;
&lt;p&gt;在 RocksDb 中主要有两类内存分配器&lt;code&gt;MemoryAllocator&lt;/code&gt;、&lt;code&gt;Allocator&lt;/code&gt;。&lt;/p</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析</title>
    <link href="https://szza.github.io/2022/01/01/C++/0_align/"/>
    <id>https://szza.github.io/2022/01/01/C++/0_align/</id>
    <published>2022-01-01T06:09:54.000Z</published>
    <updated>2022-02-14T14:21:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>关于内存对齐，有诸多好处，因此常常在分配内存时也会将内存对齐这一因素纳入考量。</p><p>这一节，来讲下内存对齐以及C++11中关于内存对齐引入的<code>alignof</code>、<code>alignas</code>、<code>std::aligned_storage</code>、<code>std::align</code> ，其中前两个为关键字，后两个分别为类和函数。</p><h2 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h2><p>我们知道，C++中的内置的基础类型，比如<code>char</code>、<code>int</code>、<code>float</code>、<code>double</code>，在内存布局上都是按照其 <code>sizeof</code> 大小进行对齐（alignment）。</p><p>什么叫对齐？</p><p>比如，<code>sizoef(int)</code> 值为 4，如果满足内存对齐要求，那么int类型变量<code>a</code>的地址<code>&amp;a</code>对4取余的结果应该是0。</p><p>下面提供一个编译期就能检测内存对齐的宏 <code>CHECK_ALIGN</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_ALIGN(ptr, alignment)                       \</span></span><br><span class="line">  <span class="keyword">do</span>&#123;                                                     \</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">size_t</span> status                               \</span><br><span class="line">       = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(ptr) % alignment;    \</span><br><span class="line">    <span class="keyword">static_assert</span>(status == <span class="number">0</span>, <span class="string">&quot;ptr must be aligned&quot;</span>);    \</span><br><span class="line">  &#125;<span class="keyword">while</span>(<span class="number">0</span>)                                               \</span><br></pre></td></tr></table></figure><p>下面我们来校验内置类型的内存对齐大小确实等于其<code>sizoef(T)</code>值，demo如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">long</span> l ;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">  CHECK_ALIGN(&amp;c, <span class="keyword">sizeof</span>(c));</span><br><span class="line">  CHECK_ALIGN(&amp;i, <span class="keyword">sizeof</span>(i));</span><br><span class="line">  CHECK_ALIGN(&amp;l, <span class="keyword">sizeof</span>(l));</span><br><span class="line">  CHECK_ALIGN(&amp;f, <span class="keyword">sizeof</span>(f));</span><br><span class="line">  CHECK_ALIGN(&amp;i, <span class="keyword">sizeof</span>(l)); <span class="comment">// 编译错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述demo中的 <code>CHECK_ALIGN(&amp;i, sizeof(l));</code> 会导致编译错误，因为<code>int</code>类型变量的内存对齐大小要求是4，而<code>long</code>在gcc下是8个字节，即<code>sizoef(l)</code>为8，故而编译失败。</p><p>到此，我相信你应该明白何为「内存对齐」了。</p><h2 id="alignof"><a href="#alignof" class="headerlink" title="alignof"></a>alignof</h2><p>C++11引入的关键字<code>alignof</code>，可直接获取类型<code>T</code>的内存对齐要求。<code>alignof</code>的返回值类型是<code>size_t</code>，用法类似于<code>sizeof</code>。</p><p>下面先来看看<code>alignof</code>的用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOW_SIZEOF_AND_ALIGNOF(T)                                   \</span></span><br><span class="line">  <span class="keyword">do</span> &#123;                                                               \</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(&quot;</span> &lt;&lt; #T &lt;&lt; <span class="string">&quot;):\t&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(T) &lt;&lt; <span class="string">&quot;,\t&quot;</span>     \</span><br><span class="line">              &lt;&lt; <span class="string">&quot;alignof(&quot;</span> &lt;&lt; #T &lt;&lt; <span class="string">&quot;):\t&quot;</span> &lt;&lt; <span class="keyword">alignof</span>(T)            \</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;                                          \</span><br><span class="line">  &#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  SHOW_SIZEOF_AND_ALIGNOF(<span class="keyword">char</span>);</span><br><span class="line">  SHOW_SIZEOF_AND_ALIGNOF(<span class="keyword">int</span>);</span><br><span class="line">  SHOW_SIZEOF_AND_ALIGNOF(<span class="keyword">long</span>);</span><br><span class="line">  SHOW_SIZEOF_AND_ALIGNOF(<span class="keyword">float</span>);</span><br><span class="line">  SHOW_SIZEOF_AND_ALIGNOF(<span class="keyword">double</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，这也是符合前文关于基础类型内存对齐的论述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(char):   1,      alignof(char):  1</span><br><span class="line">sizeof(int):    4,      alignof(int):   4</span><br><span class="line">sizeof(long):   8,      alignof(long):  8</span><br><span class="line">sizeof(<span class="built_in">float</span>):  4,      alignof(<span class="built_in">float</span>): 4</span><br><span class="line">sizeof(double): 8,      alignof(double):8</span><br></pre></td></tr></table></figure><p>好，到此我相信你已经对内存对齐和<code>alignof</code>有了基本了解。下面我们来看看类的内存对齐。</p><p>现在有类<code>Foo</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span> </span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> i1; </span><br><span class="line">  <span class="keyword">int</span> i2;</span><br><span class="line">  <span class="keyword">long</span> l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>考虑下<code>alignof(Foo)</code>和<code>sizeof(Foo)</code>分别会是多少，即下面的demo会输出？？？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  SHOW_SIZEOF_AND_ALIGNOF(Foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Think Again~~~~</p><p>3</p><p>2</p><p>1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(Foo):    24,     alignof(Foo):   8</span><br></pre></td></tr></table></figure><p>嗯？怎么会是这个结果？</p><p>为了更好地解释这个结果，我准备借助<code>offsetof</code>函数，来获取成员变量距离类起始地址的偏移量，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Offset of member MEMBER in a struct of type TYPE. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(OBJECT_TYPE, MEMBER) __builtin_offsetof (OBJECT_TYPE, MEMBER)</span></span><br></pre></td></tr></table></figure><p>好，现在看下如下代码，并猜测下输出？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; offsetof(Foo, c)  &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; offsetof(Foo, i1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span> </span><br><span class="line">            &lt;&lt; offsetof(Foo, i2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; offsetof(Foo, l)  &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">0   <span class="comment"># c 的偏移量为 0 </span></span><br><span class="line">4   <span class="comment"># i1 的偏移量为 4， c  -&gt; i1 中间填充了 3个字节，才满足 4 字节的内存对齐要求</span></span><br><span class="line">8   <span class="comment"># i2 的偏移量为 8,  i1 -&gt; i2 无填充</span></span><br><span class="line">16  <span class="comment"># l 的偏移量为 16， i2 -&gt; l  中间填充了4个字节，才满足8字节的内存对齐要求</span></span><br></pre></td></tr></table></figure><p>好，到此，我准备基于这个输出来解释<code>alignof</code>了。</p><p>对于<code>Foo</code>而言，所谓内存对齐，即<code>Foo</code>中每个字段都要满足内存对齐。而内存对齐最严格（即对齐字节数最大）的字段满足了，其他的字段也就满足了。</p><p>假设现在有三个起始地址，分别是 0、1、4，我们来看看是否都能满足<code>Foo</code>中所有字段的内存对齐要求。</p><p>起始地址分别0、1、4，各个字段的地址如下三列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span>   </span><br><span class="line">  <span class="keyword">char</span> c;     <span class="comment">// 0  |  1  |  4</span></span><br><span class="line">  <span class="keyword">int</span> i1;     <span class="comment">// 4  |  5  |  8</span></span><br><span class="line">  <span class="keyword">int</span> i2;     <span class="comment">// 8  |  9  |  12 </span></span><br><span class="line">  <span class="keyword">long</span> l;     <span class="comment">// 16 |  17 |  20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的右侧三列结果可以看出，只有起始地址为0（8的整倍数）的恰好能满足所有字段内存对齐的要求。因此，<code>alignof(Foo)</code>输出为8。</p><h2 id="alignas"><a href="#alignas" class="headerlink" title="alignas"></a>alignas</h2><p>上面讲述的内存对齐要求都是默认情况下的，有时候考虑到cacheline、以及向量化操作，可能会需要改变一个类的<code>alignof</code>值。</p><p>怎么办？</p><p>在C++11之前，需要依赖靠编译器的扩展指令，C++11之后可以借助<code>alignas</code>关键字。</p><blockquote><p>比如，在C++11之前，gcc实现 <code>alignas(alignment)</code> 效果的方式为  <code>__attribute__((__aligned__((alignment)))</code></p></blockquote><p>仍然以上述的<code>Foo</code>为例子，不过此时你希望<code>Foo</code>对象的起始地址总是32的倍数，C++11之后借助<code>alignas</code>关键字，可以如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">32</span>)</span> Foo </span>&#123; </span><br><span class="line">  Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> i1; </span><br><span class="line">  <span class="keyword">int</span> i2;</span><br><span class="line">  <span class="keyword">long</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  Foo foo;</span><br><span class="line">  CHECK_ALIGN(&amp;foo, <span class="keyword">alignof</span>(foo));</span><br><span class="line">  SHOW_SIZEOF_AND_ALIGNOF(Foo);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; .&#x2F;main</span><br><span class="line">0x16d6f34e0</span><br><span class="line">sizeof(Foo):    32,     alignof(Foo):   32</span><br></pre></td></tr></table></figure><p>说完<code>alignas</code>的基础用法，下面说下使用<code>alignas</code>时的注意事项，即<code>alignas(alignment)</code>中的<code>alignment</code>也不是随意写的，对于类型<code>T</code>，需要满足如下两个条件。</p><h3 id="1-alignment-gt-alignof-T"><a href="#1-alignment-gt-alignof-T" class="headerlink" title="1. alignment &gt;= alignof(T)"></a>1. alignment &gt;= alignof(T)</h3><p>仍然以<code>Foo</code>为例，在没有<code>alignas</code>修饰时，默认的Foo的内存对齐要求<code>alignof(Foo)</code>为8，现在尝试使用<code>alignas</code>让<code>Foo</code>的对齐要求为4，操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">4</span>)</span> Foo </span>&#123; </span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> i1;</span><br><span class="line">  <span class="keyword">int</span> i2;</span><br><span class="line">  <span class="keyword">long</span> l; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时 <code>SHOW_SIZEOF_AND_ALIGNOF(Foo);</code>的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(Foo):    24,     alignof(Foo):   8</span><br></pre></td></tr></table></figure><p>可以看出，此时的<code>alignas</code>是失效的，在其他编译器下也许直接编译失败。</p><h3 id="2-alignment-pow-2-N"><a href="#2-alignment-pow-2-N" class="headerlink" title="2. alignment == pow(2, N)"></a>2. alignment == pow(2, N)</h3><p>即<code>alignas</code> 指定的大小<code>alignment</code>必须是2的正数幂（<code>N&gt;0</code>），否则也是失效，在有些编译器下也许直接编译失败。</p><p>仍然以<code>Foo</code>为例子，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">9</span>)</span> Foo </span>&#123; </span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> i1;</span><br><span class="line">  <span class="keyword">int</span> i2;</span><br><span class="line">  <span class="keyword">long</span> l; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">main.cc:<span class="number">20</span>:<span class="number">19</span>: error: requested alignment <span class="string">&#x27;9&#x27;</span> is <span class="keyword">not</span> a positive power of <span class="number">2</span></span><br><span class="line">   <span class="number">20</span> | <span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">9</span>)</span> Foo </span>&#123;</span><br><span class="line">      |                   ^~~</span><br></pre></td></tr></table></figure><p>好，到此，我想你应该大致理解了<code>alignof</code>和<code>alignas</code>两个关键字，更多用法可以参`<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a>。</p><h2 id="std-aligned-storage"><a href="#std-aligned-storage" class="headerlink" title="std::aligned_storage"></a>std::aligned_storage</h2><p>在C++11中，也引入了一个满足内存对齐要求的静态内存分配类<code>std::aligned_storage</code>，其类模板原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &lt;type_traits&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="built_in">std</span>::<span class="keyword">size_t</span> Len, </span><br><span class="line">          <span class="built_in">std</span>::<span class="keyword">size_t</span> Align = <span class="comment">/*default-alignment*/</span> &gt;</span><br><span class="line">struct aligned_storage;</span><br></pre></td></tr></table></figure><p>类<code> std::aligned_storage</code>对象构造完成时，即分配了长度为<code>Len</code>个字节的内存，且该内存满足大小为 <code>Align</code> 的对齐要求。</p><p>下面，我们先来看看 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a> 给的一个demo，来熟悉下怎么使用<code>std::aligned_storage</code>。</p><p>类 <code>StaticVector</code> ，是一个满足内存对齐要求的静态数组，模板参数<code>T</code>是元素类型，<code>N</code>是数组元素个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticVector</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StaticVector() &#123; </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">alignof</span>(T) &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(T)&lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; N; ++idx) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; &amp;data[idx] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~StaticVector() &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">size_t</span> pos = <span class="number">0</span>; pos &lt; m_size; ++pos) &#123;</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(data+pos)-&gt;~T();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(m_size &gt;= N) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::bad_alloc&#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">new</span>(data+m_size) T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">      ++m_size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">const</span> T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos) <span class="keyword">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> T*&gt;(data+pos);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type data[N]; // C++11</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">aligned_storage_t</span>&lt;<span class="keyword">sizeof</span>(T), <span class="keyword">alignof</span>(T)&gt; data[N];        <span class="comment">// c++14</span></span><br><span class="line">  <span class="keyword">size_t</span> m_size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类<code>StaticVector</code>的使用如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct <span class="title">alignas</span><span class="params">(<span class="number">32</span>)</span> Foo </span>&#123; </span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> i1; </span><br><span class="line">  <span class="keyword">int</span> i2;</span><br><span class="line">  <span class="keyword">long</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    StaticVector&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="number">2</span>&gt; v1;</span><br><span class="line">    v1.emplace_back(<span class="number">5</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; v1[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    StaticVector&lt;Foo, <span class="number">2</span>&gt;v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在输出前，我们预测下：</p><ul><li><code>std:::string</code> 的<code>alignof</code>值是8，那么<code>StaticVector</code>分配的两个<code>std::string</code>对象地址，都应该是8的倍数</li><li><code>Foo</code>的<code>alignof</code>值是32，那么<code>StaticVector</code>为<code>Foo</code> 分配的两个<code>Foo</code>对象地址，都是32的倍数，</li></ul><p>好，现在我们来看下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align_stroe.cc -o as &amp;&amp; ./as</span><br><span class="line">8/32</span><br><span class="line">0x16b5734c0</span><br><span class="line">0x16b5734e0</span><br><span class="line">*****</span><br><span class="line">32/32</span><br><span class="line">0x16b573470</span><br><span class="line">0x16b573490</span><br></pre></td></tr></table></figure><p>所以，到此，你也许理解了<code>std::aligned_storage</code> 中<code>aligned</code>的含义，即每个对象都是经过内存对齐的。</p><p>熟悉了<code>std::aligned_storage</code> 的用法，现在来看看他的实现叭，毕竟没人愿意只做个调包侠（滑稽脸）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in std namespace;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="built_in">std</span>::<span class="keyword">size_t</span> _Len&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">aligned_storage_msa</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> __<span class="title">type</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __data[_Len];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span>((__<span class="title">aligned__</span>)) &#123;</span> &#125; __align;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="built_in">std</span>::<span class="keyword">size_t</span> _Len, </span><br><span class="line">      <span class="built_in">std</span>::<span class="keyword">size_t</span> _Align = <span class="keyword">alignof</span>(<span class="keyword">typename</span> __aligned_storage_msa&lt;_Len&gt;::__type)&gt;</span><br><span class="line">struct aligned_storage &#123;</span><br><span class="line">  <span class="keyword">union</span> type &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> __data[_Len];</span><br><span class="line">    <span class="function">struct <span class="title">alignas</span><span class="params">(_Align)</span> </span>&#123; &#125; __align;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>std::aligned_storage</code> 内部，是通过一个<code>union</code>来实现的：</p><ul><li><code>unsigned char __data[_Len];</code>：这一行保证了分配的内存大小是<code>_Len</code>个字节</li><li><code>struct alignas(_Align) &#123; &#125; __align;</code> ：这一行保证了分配的内存是按照<code>Align</code> 大小进行对齐的。</li></ul><p>其中，第二点很好理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">alignas</span>(<span class="number">16</span>) <span class="keyword">char</span> aligned_data[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unaligned: &quot;</span>&lt;&lt; <span class="keyword">alignof</span>(data) &lt;&lt; <span class="string">&quot;, aligned: &quot;</span> &lt;&lt; <span class="keyword">alignof</span>(aligned_data) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unaligned: <span class="number">1</span>, aligned: <span class="number">16</span></span><br></pre></td></tr></table></figure><p>因此，如果只有<code>unsigned char __data[_Len]；</code>，无法保证内存对齐，需要<code>struct alignas(_Align) &#123; &#125; __align</code>的辅助。</p><p>最后再提下 <code>std::__aligned_storage_msa</code>的必要性：在构造类<code>std::aligned_storage</code>对象时，如果没有指定类的第二个模板参数<code>_Align</code>，即内存对齐大小，由<code>std::__aligned_storage_msa</code>为你设置默认的内存对齐大小。</p><p>可以看出，在 <code>std::__aligned_storage_msa</code> 的实现中，<code>__attribute__((__aligned__))</code> 后面是没有参数的，此时gcc即会根据平台生成默认内存对齐大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="built_in">std</span>::__aligned_storage_msa&lt;<span class="keyword">sizeof</span>(<span class="number">1</span>)&gt;::__type) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="built_in">std</span>::__aligned_storage_msa&lt;<span class="keyword">sizeof</span>(<span class="number">4</span>)&gt;::__type) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="built_in">std</span>::__aligned_storage_msa&lt;<span class="keyword">sizeof</span>(<span class="number">16</span>)&gt;::__type) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">alignof</span>(<span class="built_in">std</span>::__aligned_storage_msa&lt;<span class="keyword">sizeof</span>(<span class="number">32</span>)&gt;::__type) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align_stroe.cc -o as &amp;&amp; ./as</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>这个大小就是gcc编译器默认的内存大小。</p><h2 id="std-align"><a href="#std-align" class="headerlink" title="std::align"></a>std::align</h2><p>类<code>std::aligned_storage</code> 是一个静态的内存对齐分配器，即在类<code>std::aligned_storage</code>对象构造完时，就已满足设定内存大小、内存对齐要求，但是如果现在有一块内存，想从中取出一块符合某对齐要求的内存，咋办？</p><p>此时就可以使用<code>std::align</code>函数，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param  alignment 是想要分配的内存符合的内存对齐大小</span></span><br><span class="line"><span class="comment">/// @param  size 想要分配内存的大小</span></span><br><span class="line"><span class="comment">/// @param  ptr 是个输入输出参数，输入时指向待使用的内存，输出时调整为符合alignment对齐要求的内存地址</span></span><br><span class="line"><span class="comment">/// @param  space 是ptr指向的内存剩余的空间</span></span><br><span class="line"><span class="comment">/// @return 如果 ptr 经过调整后能满足大小为 alignment 的对齐要求，则返回ptr的值，否则返回 nullptr</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">align</span><span class="params">( <span class="built_in">std</span>::<span class="keyword">size_t</span> alignment,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::<span class="keyword">size_t</span> size,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="keyword">void</span>*&amp; ptr,</span></span></span><br><span class="line"><span class="function"><span class="params">             <span class="built_in">std</span>::<span class="keyword">size_t</span>&amp; space)</span></span>;</span><br></pre></td></tr></table></figure><p>下面，我们继续先来看看 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a> 中提供的一个demo，熟悉下怎么使用<code>std::align</code>这个函数。</p><p>类<code>Arena</code>内已有一块缓冲区<code>buffer</code>，每次调用<code>AlignedAllocate&lt;T&gt;(size_t alignment)</code>函数时，即需要从<code>buffer</code>中取出大小为<code>sizeof(T)</code>的一块内存<code>ptr</code>，<code>AlignedAllocate</code>函数的输入参数<code>alignment</code>指定了获得的内存<code>ptr</code>满足的内存对齐要求。</p><p>现在来看看实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arena</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> buffer[N];</span><br><span class="line">  <span class="keyword">void</span>* ptr;</span><br><span class="line">  <span class="keyword">size_t</span> size;</span><br><span class="line"></span><br><span class="line">  Arena() : ptr(buffer), size(N) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @return 返回的指针满足大小为 alignment 的内存对齐要求</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T* <span class="title">AlignedAllocate</span><span class="params">(<span class="keyword">size_t</span> alignment = <span class="keyword">alignof</span>(T))</span> </span>&#123;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ptr: &quot;</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(ptr) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">std</span>::align(alignment, <span class="keyword">sizeof</span>(T), ptr, size)) &#123;</span><br><span class="line">          T* result = <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">          ptr = (<span class="keyword">char</span>*)ptr + <span class="keyword">sizeof</span>(T);</span><br><span class="line">          size -= <span class="keyword">sizeof</span>(T);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若无，则返回 nullptr</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Arena&lt;<span class="number">64</span>&gt; arena;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* p1 = arena.AlignedAllocate&lt;<span class="keyword">char</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p1) *p1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;allocated a char at &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)p1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>* p2 = arena.AlignedAllocate&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p2) *p2 = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;allocated an int at &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)p2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span>* p3 = arena.AlignedAllocate&lt;<span class="keyword">int</span>&gt;(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> (p3) *p3 = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;allocated an int at &quot;</span> &lt;&lt; (<span class="keyword">void</span>*)p3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下面的输出可以看出，<code>AlignedAllocate</code> 函数返回的内存地址都是符合设定的内存对齐要求的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align.cc -o align &amp;&amp; ./align </span><br><span class="line">ptr: 0x16fc2b4b8, allocated a char at 0x16fc2b4b8     <span class="comment"># 1 byte 内存对齐，指针无须调整</span></span><br><span class="line">ptr: 0x16fc2b4b9, allocated an int at 0x16fc2b4bc     <span class="comment"># 4 byte 内存对齐，指针调整了 3 个字节</span></span><br><span class="line">ptr: 0x16fc2b4c0, allocated an int at 0x16fc2b4c0     <span class="comment"># 32 byte 内存对齐，指针无须调整</span></span><br></pre></td></tr></table></figure><p>最后，我们再来看看<code>std::align</code>函数的实现，稍微简化后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &lt;memory&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span>* <span class="title">align</span><span class="params">(<span class="keyword">size_t</span> __align, <span class="keyword">size_t</span> __size, <span class="keyword">void</span> *&amp;__ptr, <span class="keyword">size_t</span> &amp;__space)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> __intptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uintptr_t</span>&gt;(__ptr);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> __aligned = (__intptr - <span class="number">1u</span> + __align) &amp; -__align;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> __diff = __aligned - __intptr;</span><br><span class="line">  <span class="comment">// 如果没有剩余的空间，直接返回 nullptr</span></span><br><span class="line">  <span class="keyword">if</span> ((__size + __diff) &gt; __space)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">   __space -= __diff;</span><br><span class="line">   <span class="keyword">return</span> __ptr = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span> *&gt;(__aligned);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::align</code>的实现里，最为关键的一步，即计算对齐后的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> __aligned = (__intptr - <span class="number">1u</span> + __align) &amp; -__align;</span><br></pre></td></tr></table></figure><p>对于这一步，本来想写个证明啥的，还是举个例子来解释比较通俗。</p><p>按照<code>__align</code>大小进行内存对齐，即可视为按<code>__align</code>进制向上取整。</p><p>什么意思呢？</p><p>比如说，现在按照10进制对齐，有地址12，想让12向上调整到10的倍数，怎么做？</p><ol><li>先加上一个步长：<code>12 + 10 - 1 = 21</code></li><li>将余数1清掉：<code>21 &amp;  (-10) = 20</code>。这一步中，<code>-10</code> 的本质就是保证高位不变，将低位全部变为0，取<code>&amp;</code>之后，取余就全部清理了。</li></ol><p>现在的内存对齐，本质上也是向上取整：<code>__intptr - 1u + __align</code>是为了向前一个步长，再对  <code>-__align</code>取<code>&amp;</code>，来清除余数。</p><p>关于内存对齐，很多项目里都有涉及，最近在阅读RocksDb也再次遇到，于是乎就找了个契机写下了这篇博客，后续会尝试更新RocksDb。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于内存对齐，有诸多好处，因此常常在分配内存时也会将内存对齐这一因素纳入考量。&lt;/p&gt;
&lt;p&gt;这一节，来讲下内存对齐以及C++11中关于内存对齐引入的&lt;code&gt;alignof&lt;/code&gt;、&lt;code&gt;alignas&lt;/code&gt;、&lt;code&gt;std::aligned_s</summary>
      
    
    
    
    <category term="深入了解 Modern C++" scheme="https://szza.github.io/categories/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>从 std::auto_ptr 到 std::unique_ptr 到进化之路</title>
    <link href="https://szza.github.io/2021/12/21/C++/unique_ptr/"/>
    <id>https://szza.github.io/2021/12/21/C++/unique_ptr/</id>
    <published>2021-12-21T04:47:23.000Z</published>
    <updated>2022-02-14T14:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>从本期，就开始智能指针源码分析之路，从源码中了解他们的设计。</p><p>智能指针，可以分为两类：</p><ul><li>独占型：如<code>std::unique_ptr</code>，一份资源，仅能由一个<code>std::unique_ptr</code>对象管理；</li><li>共享型：如<code>std::shared_ptr</code>，一份资源，可以由多个<code>std::shared_ptr</code>对象共同管理，当没有<code>std::shared_ptr</code>对象指向这份的资源，资源才会被释放，即基于引用技术原理。</li></ul><p>本期，先来讲解<code>std::unique_ptr</code>，之后会分几期来讲解<code>std::shared_ptr</code>的设计。</p><p>不过，在讲解<code>std::unique_ptr</code>之前，先讲解下C++03中的失败品：<code>std::auto_ptr</code>。</p><h2 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h2><p>原本也是想要将 <code>std::auto_ptr</code> 设计成资源独占型的指针，即像现在的<code>std::unique_ptr</code>，但由于移动语义直到C++11中才出现，使得<code>std::auto_ptr</code>终究成了失败品。</p><p>不明白，没关系，go on。</p><p>在C++03标准下，有如下demo中的一个场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">iptr</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; &gt; integer_vec;</span><br><span class="line"></span><br><span class="line">    integer_vec.push_back(iptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在C++03标准中还没有引入移动语义，只能以<code>push_back</code>函数向<code>vector</code>中添加元素。</p><p>如果你没接触过<code>std::auto_ptr</code>，应该会认为上面的demo是能编译通过的，但实际上是无法编译通过的。</p><p>编译指令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -<span class="built_in">std</span>=c++<span class="number">03</span>  main.cc -o main &amp;&amp; ./main</span><br></pre></td></tr></table></figure><p>下面只贴出最初的错误信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc<span class="number">-8.2</span>/include/c++/<span class="number">8.2</span><span class="number">.0</span>/ext/new_allocator.h:<span class="number">146</span>:<span class="number">9</span>: error: no matching function <span class="keyword">for</span> call to ‘<span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt;::<span class="built_in">auto_ptr</span>(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt;&amp;)’</span><br><span class="line">       &#123; ::<span class="keyword">new</span>((<span class="keyword">void</span> *)__p) _Tp(__val); &#125;</span><br><span class="line">         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><p>先给出导致错误的结论：是由于类<code>std::auto_ptr</code> 没有提供<code>const std::auto_ptr&lt;T&gt;&amp;</code>类型的复制构造函数。</p><p>那为啥会没有呢？</p><p>因为<code>std::auto_ptr</code>的设计者，想使<code>std::auto_ptr</code>的复制构造函数具备移动构造函数的属性（如果不懂右值、移动等内容，可以看看 <a href="https://mp.weixin.qq.com/s?__biz=MzkyMjIxMzIxNA==&mid=2247483868&idx=1&sn=3271bc5f1694818a493fd54185b341dd&chksm=c1f68fedf68106fb21fedd83136aa39a1ed01761ad68018d9bedd1591d9241cb8838432d634b&token=1599630750&lang=zh_CN#rd">右值引用的正确用法</a>），这就使得<code>std::auto_ptr</code>复制构造函数的输入参数<code>__a</code>不能由 const 修饰，否则<code>__a</code>指向的资源就无法移动到新创建的对象中了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&amp; __a) <span class="keyword">throw</span>() : _M_ptr(__a.release()) &#123;&#125; </span><br></pre></td></tr></table></figure><p>这就导致<code>std::auto_ptr</code>中，所有和赋值有关的操作，都不能有<code>const</code>修饰。</p><p><code>std::auto_ptr</code>的核心代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">auto_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  _Tp *_M_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(element_type *__p = <span class="number">0</span>)</span> <span class="title">throw</span><span class="params">()</span> : _<span class="title">M_ptr</span><span class="params">(__p)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&amp; __a) <span class="keyword">throw</span>() : _M_ptr(__a.release()) &#123;&#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">  <span class="built_in">auto_ptr</span>(<span class="built_in">auto_ptr</span>&lt;_Tp1&gt;&amp; __a) <span class="keyword">throw</span>() : _M_ptr(__a.release()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">auto_ptr</span> &amp;<span class="keyword">operator</span>=(<span class="built_in">auto_ptr</span>&amp; __a) <span class="keyword">throw</span>() &#123;</span><br><span class="line">    reset(__a.release());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> _M_ptr; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">element_type* <span class="title">release</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    element_type *__tmp = _M_ptr;</span><br><span class="line">    _M_ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(element_type *__p = <span class="number">0</span>)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__p != _M_ptr) &#123;</span><br><span class="line">      <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">      _M_ptr = __p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="by-the-way"><a href="#by-the-way" class="headerlink" title="by the way"></a>by the way</h3><p>对于最上面的demo，我们再啰嗦几点：为什么会在 <code>construct</code>函数中报错？</p><ol><li><p>因为<code>push_back</code>函数中，输入参数<code>__x</code>是<code>const std::auto_ptr&amp;</code>类型，能接受<code>iptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt; </span><br><span class="line"><span class="keyword">void</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;::push_back(<span class="keyword">const</span> value_type&amp; __x);</span><br></pre></td></tr></table></figure></li><li><p>在<code>push_back</code>函数内部会调用 <code>_Alloc_traits::construct</code> 函数来构造一个新的<code>std::auto_ptr</code>对象<code>obj</code>，然后将这个<code>obj</code>放到<code>integer_vec</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Alloc_traits::construct(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish, __x);</span><br></pre></td></tr></table></figure></li><li><p>因为要构造<code>obj</code>，那么必要会调用<code>std::auto_ptr</code>的复制构造函数，且输入参数是<code>__x</code>；</p></li><li><p>但由于<code>__x</code> 是 <code>const std::auto_ptr&amp;</code> 类型，二<code>std::auto_ptr</code>的复制构造函数输入类型是<code>std::auto_ptr&amp;</code>，接受不了<code>__x</code>作为输入，因此会导致<code>construct</code>函数执行失败。出现上述的错误。</p></li></ol><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>C++11引入移动语义，提出了<code>std::unique_ptr</code>，才真正地完成了<code>std::auto_ptr</code>的设计意图，而原本的<code>std::auto_ptr</code>也被标记为<code>deprecated</code>。</p><p>由于 <code>std::unique_ptr</code> 对象管理的资源，不可共享，只能在 <code>std::unique_ptr</code> 对象之间转移，因此类<code>std::unique_ptr</code> 就禁止了复制构造函数、赋值表达式，仅实现了移动构造函数等。</p><p>此外，<code>std::unique_ptr</code> 有两个版本：</p><ol><li>管理单个对象（例如以 <code>new</code> 分配）</li><li>管理动态分配的对象数组（例如以 <code>new[]</code> 分配）</li></ol><p>因此， <code>std::unique_ptr</code> 的类模板有如下两个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 适合 new 分配的内存</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">unique_ptr</span> &#123; <span class="comment">/****/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 针对 new[] 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span>&lt;</span>_Tp[], _Dp&gt; &#123; <span class="comment">/****/</span> &#125;;</span><br></pre></td></tr></table></figure><p>在下面的情况中，<code>std::unique_ptr</code>对象管理的资源，会调用传入的析构器<code>_Dp</code>来释放放资源：</p><ul><li>当前<code>std::unique_ptr</code> 对象被销毁，生命周期结束；</li><li>重新给当前<code>std::unique_ptr</code>对象赋值，比如调用 <code>operator=</code>、<code>reset()</code> 等操作。</li></ul><p>下面就先讲解下默认的析构器<code>std::default_delete</code>。</p><h3 id="std-default-delete"><a href="#std-default-delete" class="headerlink" title="std::default_delete"></a>std::default_delete</h3><p>由于<code>std::unique_ptr</code> 有两个版本，因此默认的析构器也存在两个版本，即对<code>new[]</code> 进行特化。</p><p>此外，这就导致后文的<code>make_unique</code> 函数也需要对<code>new[]</code>进行特化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span> &#123;</span> <span class="comment">/****/</span> &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span>&lt;</span>_Tp[]&gt; &#123; <span class="comment">/****/</span> &#125;;</span><br></pre></td></tr></table></figure><p>由于默认采用<code>new</code>、<code>new[]</code>来分配内存的，而<code>sd::default_delete</code> 实际上是个仿函数，内部也是基于<code>delete</code>、<code>delete[]</code>来释放内存资源的。</p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>类<code>std::default_delete</code>  实际上是个仿函数，并且是个空类，因此他的默认构造函数直接设置为<code>default</code>了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/// @brief 默认构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 复制构造函数</span></span><br><span class="line">  <span class="comment">///        _Up* 必须能转为 _Tp*，否则无法编译通过</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, </span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value&gt;::type&gt;</span><br><span class="line">  default_delete(<span class="keyword">const</span> default_delete&lt;_Up&gt;&amp; ) <span class="keyword">noexcept</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 释放内存</span></span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>()(_Tp *__ptr) <span class="keyword">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，<code>std::default_delete</code> 还有个复制构造函数，这里传入<code>_Up*</code>参数 必须能转换为 <code>_Tp*</code> 类型，否则在编译期会报错。所谓<code>_Up*</code> 能转换为 <code>_Tp*</code>，即<code>is_convertible&lt;_Up*, _Tp*&gt;::value</code> 为 true，这个值在编译期就能确定，如果为false，就相当于不存在这个复制构造函数。</p><p>不信，可以把下面的代码复制到IDE中，会有红线提示，编译会出错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::is_convertible&lt;<span class="keyword">float</span>*, <span class="keyword">double</span>*&gt;::value;                  <span class="comment">// false: float* 不能直接转换为 double*</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::default_delete&lt;<span class="keyword">double</span>&gt; <span class="title">de</span><span class="params">(<span class="built_in">std</span>::default_delete&lt;<span class="keyword">float</span>&gt;&#123;&#125;)</span></span>; <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><p>在<code>std::default_delete</code>的内部，实现的<code>operator()</code> 函数会调用<code>delete</code>来 析构传入的指针<code>__ptr</code>，对于<code>__ptr</code>需要满足两点：</p><ul><li><code>__ptr</code>不能是个<code>void</code>类型；</li><li>大小也不能是0。</li></ul><p>否则无法提供完整的信息去析构<code>__ptr</code>指向的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp *__ptr)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static_assert</span>(!is_void&lt;_Tp&gt;::value, <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">  <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(_Tp) &gt; <span class="number">0</span>, <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">  <span class="keyword">delete</span> __ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，你就可以这样来使用<code>std::default_delete</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* iptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">std</span>::default_delete&lt;<span class="keyword">int</span>&gt;()(iptr); <span class="comment">// delete iptr;</span></span><br></pre></td></tr></table></figure><p>使用<code>valgrind</code>检测也不存在内存泄露。</p><h4 id="delete-1"><a href="#delete-1" class="headerlink" title="delete[]"></a>delete[]</h4><p>当输入类型是<code>_Tp[]</code>时，会进入此版本。实现和上面的版本差不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">default_delete</span>&lt;</span>_Tp[]&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// @brief 默认构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 复制构造函数</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, </span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up (*)[], _Tp (*)[]&gt;::value&gt;::type&gt;</span><br><span class="line">  default_delete(<span class="keyword">const</span> default_delete&lt;_Up[]&gt; &amp;) <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 释放内存</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up (*)[], _Tp (*)[]&gt;::value&gt;::type</span><br><span class="line">  <span class="keyword">operator</span>()(_Up *__ptr) <span class="keyword">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(<span class="keyword">sizeof</span>(_Tp) &gt; <span class="number">0</span>, <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] __ptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，这样就可以使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* iptr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="built_in">std</span>::default_delete&lt;<span class="keyword">int</span>[]&gt;()(iptr); </span><br></pre></td></tr></table></figure><p>使用<code>valgrind</code>检查也没有任何内存泄露。</p><p>因此，<code>std::default_delete</code> 对两种常用的内存释放方式进行重载，提供了同一个统一接口。</p><h3 id="std-uniq-ptr-impl"><a href="#std-uniq-ptr-impl" class="headerlink" title="std::__uniq_ptr_impl"></a>std::__uniq_ptr_impl</h3><p>类<code>std::unique_ptr</code> 内部只有一个成员变量，其类型是 <code>std::__uniq_ptr_impl</code>。</p><p>类<code>std::__uniq_ptr_impl</code>实际上就一个<code>&lt;pointer, Deleter&gt;</code>的一个wrapper，即简单封装了指向资源的指针，以及对应的析构器 <code>Deleter</code>。</p><p>先大致看下<code>std::__uniq_ptr_impl</code>的部分实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">uniq_ptr_impl</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> _DeleterConstraint = enable_if&lt;__and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;, </span><br><span class="line">                                              is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;</span><br><span class="line">  </span><br><span class="line">  __uniq_ptr_impl() = <span class="keyword">default</span>;</span><br><span class="line">  __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del&gt;</span><br><span class="line">  __uniq_ptr_impl(pointer __p, _Del&amp;&amp; __d)</span><br><span class="line">  : _M_t(__p, <span class="built_in">std</span>::forward&lt;_Del&gt;(__d)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  pointer&amp;   _M_ptr()           &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">  pointer    _M_ptr()     <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">  _Dp&amp;       _M_deleter()       &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line">  <span class="keyword">const</span> _Dp&amp; _M_deleter() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(__uniq_ptr_impl&amp; __rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(<span class="keyword">this</span>-&gt;_M_ptr(), __rhs._M_ptr());</span><br><span class="line">    <span class="built_in">std</span>::swap(<span class="keyword">this</span>-&gt;_M_deleter(), __rhs._M_deleter());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  tuple&lt;pointer, _Dp&gt; _M_t; <span class="comment">// pointer 的定义后文讲解</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类<code>std::__uniq_ptr_impl</code> 的成员变量<code>_M_t</code>是由<code>tuple</code>类型：</p><ul><li>第一个成员：是指针，指向资源；</li><li>第二个成员：是析构器，用于释放指针指向的资源。</li></ul><p>由于在X86-84位系统上指针大小是8，而<code>_Dp</code>在默认情况下（即<code>std::default_delete</code>）是个空类，得益于<a href="https://mp.weixin.qq.com/s?__biz=MzkyMjIxMzIxNA==&mid=2247485249&idx=1&sn=f395397f1621cf8a4d897d0213ca1788&chksm=c1f68970f68100666cbb65313780797bc65490703dac02a9603e0b9733fa01db270ca445f0e6&token=1599630750&lang=zh_CN#rd">空基类优化</a>，因此<code>_M_t</code> 的大小是8。</p><blockquote><p><strong>NOTICE</strong>：如果自定义了一个<code>Deleter</code>，且不是空类，则<code>std::unique_ptr</code>的大小会增加。</p></blockquote><p>下面，来分析下<code>std::__uniq_ptr_impl</code> 中的 <code>pointer</code>类型，他的完整实现及注释如下。</p><p>因此，当<code>_Dp</code>是默认的析构器<code>std::default_delete</code>时，<code>pointer</code> 即 <code>_Tp*</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"> <span class="class"><span class="keyword">class</span> __<span class="title">uniq_ptr_impl</span></span></span><br><span class="line"><span class="class"> &#123;</span>    </span><br><span class="line">   <span class="comment">/// 原型</span></span><br><span class="line">   <span class="comment">/// @brief 特化版本决议失败，则会进入此版本</span></span><br><span class="line">   <span class="comment">/// @type  此时 type 就是 _up*</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">   struct _Ptr</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">using</span> type = _Up*;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/// 特化版本</span></span><br><span class="line">   <span class="comment">/// @brief 如果 类 _Ep 中有 pointer 的定义，则会进入此特化版本</span></span><br><span class="line">   <span class="comment">/// @type  此时 type 是 _Ep 中的 pointer </span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> _<span class="title">Ptr</span>&lt;</span>_Up, _Ep, <span class="keyword">__void_t</span>&lt;<span class="keyword">typename</span> remove_reference&lt;_Ep&gt;::type::pointer&gt;&gt;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">using</span> type = <span class="keyword">typename</span> remove_reference&lt;_Ep&gt;::type::pointer;</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">using</span> pointer = <span class="keyword">typename</span> _Ptr&lt;_Tp, _Dp&gt;::type;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"> &#125;；</span><br></pre></td></tr></table></figure><h3 id="std-unique-ptr-1"><a href="#std-unique-ptr-1" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p>分析的进度终于到了类<code>std::unique_ptr</code>，它的设计主要如下四点：</p><ol><li>禁止复制构造函数、复制赋值的重载，即设置为<code>=delete</code>；</li><li>实现各种移动构造函数；</li><li>实现移动赋值重载，即<code>operator=</code>，需要先释放本身的资源，再将对方的资源移动过来；</li><li>如果资源没有释放过，则会在析构函数中释放。</li></ol><p>为便于理解，先看下<code>std::unique_ptr</code>的部分源码及其注释，另一个特化版本差不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line">class <span class="built_in">unique_ptr</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">  <span class="keyword">using</span> _DeleterConstraint = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint::type;</span><br><span class="line"></span><br><span class="line">  __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</span><br><span class="line">  <span class="keyword">using</span> element_type = _Tp;</span><br><span class="line">  <span class="keyword">using</span> deleter_type = _Dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// 用于检测从另一个 std::unique_ptr 对象转换过来是否安全</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line">  <span class="keyword">using</span> __safe_conversion_up = __and_&lt;is_convertible&lt;<span class="keyword">typename</span> <span class="built_in">unique_ptr</span>&lt;_Up, _Ep&gt;::pointer, pointer&gt;,</span><br><span class="line">                                      __not_&lt;is_array&lt;_Up&gt;&gt;&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/*** Move constructors. ***/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 移动构造函数</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">  : _M_t(__u.release(), <span class="built_in">std</span>::forward&lt;deleter_type&gt;(__u.get_deleter())) &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 移动赋值</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">unique_ptr</span>&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    reset(__u.release()); </span><br><span class="line">    get_deleter() = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(__u.get_deleter());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 设置 unique_ptr 对象为初始化状态</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">nullptr_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    reset();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 禁止复制</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> <span class="built_in">unique_ptr</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">unique_ptr</span> &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">unique_ptr</span> &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  ~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(__is_invocable&lt;deleter_type&amp;, pointer&gt;::value,</span><br><span class="line">                  <span class="string">&quot;unique_ptr&#x27;s deleter must be invocable with a pointer&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span>&amp; __ptr = _M_t._M_ptr();</span><br><span class="line">    <span class="keyword">if</span> (__ptr != <span class="literal">nullptr</span>)</span><br><span class="line">       get_deleter()(<span class="built_in">std</span>::move(__ptr)); <span class="comment">// 析构</span></span><br><span class="line">    __ptr = pointer();                  <span class="comment">// 设置为初始化状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 返回指针</span></span><br><span class="line">  <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> _M_t._M_ptr(); &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/// @brief 返回一个指向内部的deleter的引用</span></span><br><span class="line">  <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_t._M_deleter();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Return @c true if the stored pointer is not null.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get() == pointer() ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Release ownership of any stored pointer.</span></span><br><span class="line">  <span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pointer __p = get();</span><br><span class="line">    _M_t._M_ptr() = pointer();</span><br><span class="line">    <span class="keyword">return</span> __p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(__is_invocable&lt;deleter_type &amp;, pointer&gt;::value,</span><br><span class="line">                  <span class="string">&quot;unique_ptr&#x27;s deleter must be invocable with a pointer&quot;</span>);</span><br><span class="line">    <span class="built_in">std</span>::swap(_M_t._M_ptr(), __p);</span><br><span class="line">    <span class="keyword">if</span> (__p != pointer())</span><br><span class="line">      get_deleter()(<span class="built_in">std</span>::move(__p));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="built_in">unique_ptr</span> &amp;__u)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(__is_swappable&lt;_Dp&gt;::value, <span class="string">&quot;deleter must be swappable&quot;</span>);</span><br><span class="line">    _M_t.swap(__u._M_t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::unique_ptr</code> 的设计总体比较清晰。</p><p>到此，<code>std::unique_ptr</code>的设计分析差不多就结束了，下面对源码中（上面未列出）几个模板稍微分析下。</p><h4 id="DeleterConstraint"><a href="#DeleterConstraint" class="headerlink" title="_DeleterConstraint"></a>_DeleterConstraint</h4><p><code>_DeleterConstraint</code> 定义于<code>std::__uniq_ptr_impl</code>之中，用于限制传入的析构器<code>Deleter</code>必须满足以下两点：</p><ol><li>传入的<code>Deleter</code> 不能是指针；</li><li>必须具备默认构造函数。</li></ol><p>否则，<code>std::unique_ptr</code> 的构造函数会失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> _DeleterConstraint = enable_if&lt;__and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;, </span><br><span class="line">                                        is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Del&gt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">: _M_t()</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Del&gt;&gt;</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="Require"><a href="#Require" class="headerlink" title="_Require"></a>_Require</h4><p>其原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Cond&gt;</span><br><span class="line"><span class="keyword">using</span> _Require = <span class="keyword">__enable_if_t</span>&lt;__and_&lt;_Cond...&gt;::value&gt;;</span><br></pre></td></tr></table></figure><p><code>_Require</code>模板是要求所有传入的条件<code>Cond</code>都为true，则<code>_Require</code>修饰的函数才会存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 如果传入的 _Del 没有复制构造函数，则unique_ptr此版本构造函数就不存在</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = deleter_type,</span><br><span class="line">          <span class="keyword">typename</span> = _Require&lt;is_copy_constructible&lt;_Del&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p, <span class="keyword">const</span> deleter_type&amp; __d) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p, __d) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 如果传入的 _Del 没有移动构造函数，则 unique_ptr此版本构造函数就不存在</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = deleter_type,</span><br><span class="line">          <span class="keyword">typename</span> = _Require&lt;is_move_constructible&lt;_Del&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p, <span class="keyword">__enable_if_t</span>&lt;!is_lvalue_reference&lt;_Del&gt;::value, _Del&amp;&amp;&gt; __d) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p, <span class="built_in">std</span>::move(__d))</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="safe-conversion-up"><a href="#safe-conversion-up" class="headerlink" title="__safe_conversion_up"></a>__safe_conversion_up</h4><p>在构造函数中，有时候需要通过其他<code>std::unique_ptr</code>对象来构造当前<code>std::unique_ptr</code>对象，但是<code>pointer</code>类型可能不同，模板<code>__safe_conversion_up</code>可以在编译期确定是否可以转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line"><span class="keyword">using</span> __safe_conversion_up = __and_&lt;is_convertible&lt;<span class="keyword">typename</span> <span class="built_in">unique_ptr</span>&lt;_Up, _Ep&gt;::pointer, pointer&gt;,</span><br><span class="line">                                    __not_&lt;is_array&lt;_Up&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure><p>此外还有个条件模板<code>conditional</code>，实现编译期的条件表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Cond ? _Iftrue ： _Iffalse;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> _Cond, <span class="keyword">typename</span> _Iftrue, <span class="keyword">typename</span> _Iffalse&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conditional</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">typedef</span> _Iftrue type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iftrue, <span class="keyword">typename</span> _Iffalse&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">conditional</span>&lt;</span><span class="literal">false</span>, _Iftrue, _Iffalse&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> _Iffalse type; &#125;;</span><br></pre></td></tr></table></figure><p>最终，可以用于构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 由其他std::unique_ptr对象 __u 构造this</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, </span><br><span class="line">          <span class="keyword">typename</span> _Ep, </span><br><span class="line">          <span class="keyword">typename</span> = _Require&lt;__safe_conversion_up&lt;_Up, _Ep&gt;,   <span class="comment">// 先判断指针，必须可转换</span></span><br><span class="line">          <span class="keyword">typename</span> conditional&lt;is_reference&lt;_Dp&gt;::value,        <span class="comment">// 再判断析构器</span></span><br><span class="line">                               is_same&lt;_Ep, _Dp&gt;,               </span><br><span class="line">                               is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt;</span><br><span class="line"> <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&lt;_Up, _Ep&gt;&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line"> : _M_t(__u.release(), <span class="built_in">std</span>::forward&lt;_Ep&gt;(__u.get_deleter()))</span><br><span class="line"> &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="std-make-unique"><a href="#std-make-unique" class="headerlink" title="std::make_unique"></a>std::make_unique</h3><p>最后，再来看下<code>std::make_unique</code> 函数，它在C++14中引入，这在之前的’编译器优化之copy elision’一期中也讲解过怎么设计它。</p><p>现在，我们再来看看C++14中 <code>std::make_unique()</code> 的实现，如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 返回类型 ***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MakeUniq</span></span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">typedef</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt; __single_object; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 为数组类型特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MakeUniq</span>&lt;</span>_Tp[]&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> <span class="built_in">unique_ptr</span>&lt;_Tp[]&gt; __array; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 无效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">size_t</span> _Bound&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">MakeUniq</span>&lt;</span>_Tp[_Bound]&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">invalid_type</span> &#123;</span> &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 函数实现 ***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// std::make_unique for single objects</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> _MakeUniq&lt;_Tp&gt;::<span class="function">__single_object <span class="title">make_unique</span><span class="params">(_Args&amp;&amp; ...__args)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> _Tp(<span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// std::make_unique for arrays of unknown bound</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> _MakeUniq&lt;_Tp&gt;::<span class="function">__array <span class="title">make_unique</span><span class="params">(<span class="keyword">size_t</span> __num)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> <span class="keyword">remove_extent_t</span>&lt;_Tp&gt;[__num]()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Disable std::make_unique for arrays of known bound</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> _MakeUniq&lt;_Tp&gt;::<span class="function">__invalid_type <span class="title">make_unique</span><span class="params">(_Args&amp;&amp; ...)</span> </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>结束，再回顾下<code>std::unique_ptr</code> 和 <code>std::auto_ptr</code>。</p><p>可以发现<code>std::auto_ptr</code>的失败在于CXX03中并不支持移动语义，而<code>std::auto_ptr</code> 却试图用复制构造函数来实现移动构造函数的功能，结果导致其无法与<code>vector</code> 等容器兼容，论为失败品。</p><p><code>std::unique_ptr</code> 的分析为止。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从本期，就开始智能指针源码分析之路，从源码中了解他们的设计。&lt;/p&gt;
&lt;p&gt;智能指针，可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独占型：如&lt;code&gt;std::unique_ptr&lt;/code&gt;，一份资源，仅能由一个&lt;code&gt;std::unique_ptr&lt;/code&gt;对</summary>
      
    
    
    
    <category term="深入了解 Modern C++" scheme="https://szza.github.io/categories/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>异步通信</title>
    <link href="https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"/>
    <id>https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/</id>
    <published>2021-12-09T03:40:15.000Z</published>
    <updated>2022-02-14T14:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h1><p>之前有两期讲解了服务端框的架构，这一期来讲下服务器是如何与客户端进行异步通信的，下一期再讲述客户端是如何异步非阻塞connect服务器的。</p><ul><li>通信，无外乎两点：1）服务器读取对端发送过来的数据；2）向对端发送数据。</li><li>异步，目前常用的是<code>epoll</code> + 回调函数。</li></ul><p>下面从非阻塞IO开始，逐步构建异步通信框架。</p><h2 id="Non-Blocking-IO"><a href="#Non-Blocking-IO" class="headerlink" title="Non-Blocking IO"></a>Non-Blocking IO</h2><p>在服务端常用的IO读写操作，主要是<code>read</code>、<code>write</code>及其衍生函数。</p><p>所谓阻塞模式，也是<code>read</code>、<code>write</code>等操作的默认行为，比如<code>read</code>函数从<code>stdin</code>读取输入，如果用户没有从终端输入，则会一直阻塞在<code>read</code>函数处。</p><p>在非阻塞模式下，<code>read</code>继续从终端读取数据，如果用户没有在终端输入数据，<code>read</code>函数并不会阻塞等待，而是立即返回-1，并将错误码<code>errno</code> 设置为<code>EAGAIN</code> 或者 <code>EWOULDBLOCK</code>。此时<code>read</code>函数返回值<code>n</code>有三种可能：</p><ul><li><code>n &gt; 0</code>：读取到<code>n</code>个字节；</li><li><code>n == 0</code>：对端关闭、文件末尾；</li><li><code>n == -1</code>：表示遇到问题，<ul><li><code>errno == EAGAIN/EWOULDBLOCK </code>：在非阻塞IO模式下，表示没有数据可读，可忽略本次<code>read</code>操作；</li><li><code>errno == EINTR</code>：表示被信号中断，重新读取一次即可。</li><li>其他错误类型。</li></ul></li></ul><p>写操作<code>write</code>函数也基本类似，更加详细可以<code>man 2 read/write</code> 查看。</p><p>因此，非阻塞IO非常适合服务器设计，不会在<code>read/write</code>处发生堵塞。</p><p>将文件描述符fd设置为非阻塞模式，有如下两种方式（来自muduo）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNonBlockAndCloseOnExec</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> flags = ::fcntl(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">  flags |= O_NONBLOCK;</span><br><span class="line">  <span class="keyword">int</span> ret = ::fcntl(sockfd, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// close-on-exec</span></span><br><span class="line">  flags = ::fcntl(sockfd, F_GETFD, <span class="number">0</span>);</span><br><span class="line">  flags |= FD_CLOEXEC;</span><br><span class="line">  ret = ::fcntl(sockfd, F_SETFD, flags);</span><br><span class="line"></span><br><span class="line">  (<span class="keyword">void</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockets::createNonblockingOrDie</span><span class="params">(<span class="keyword">sa_family_t</span> family)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> VALGRIND</span></span><br><span class="line">  <span class="comment">// 方式1 </span></span><br><span class="line">  <span class="keyword">int</span> sockfd = ::socket(family, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;sockets::createNonblockingOrDie&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setNonBlockAndCloseOnExec(sockfd);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="comment">// 方式2：系统内核支持 SOCK_NONBLOCK 标志，更加安全。</span></span><br><span class="line">  <span class="keyword">int</span> sockfd = ::socket(family, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;sockets::createNonblockingOrDie&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ET-amp-LT"><a href="#ET-amp-LT" class="headerlink" title="ET &amp; LT"></a>ET &amp; LT</h2><p>众所周知，<code>epoll</code>有两种工作模式：<code>ET </code>&amp; <code>LT</code>。但是在讲解 ET &amp; LT 之前，先讲解下「高电平」和「低电平」的概念。</p><h3 id="高低电平"><a href="#高低电平" class="headerlink" title="高低电平"></a>高低电平</h3><p>对于可读事件：</p><ul><li>内核中<code>socket</code>的<code>recv_buff </code> 为空，此时为「低电平」状态，即无数据可读</li><li>内核中<code>socket</code>的<code>recv_buff </code> 不空，此时为「高电平」状态，此时有数据可读</li></ul><p>对于可写事件：</p><ul><li>内核中<code>socket</code>的<code>send_buff</code>为满 ，此时为「低电平」状态，不可发送数据</li><li>内核中<code>socket</code>的<code>send_buff</code>不满，此时为「高电平」状态，可发送数据</li></ul><p>简而言之，「低电平」状态下不能进行读、写操作，「高电平」则可以读、写。</p><p>为便于描述，<code>socket</code>的接受缓冲区定义为<code>recv_buff</code>，<code>socket</code>的发送缓冲区定义为<code>send_buff</code>，<code>connfd</code>是服务端与对端建立连接的文件描述符。</p><h3 id="LT（Level-Triggered）"><a href="#LT（Level-Triggered）" class="headerlink" title="LT（Level Triggered）"></a>LT（Level Triggered）</h3><p>LT，电平触发，即socket缓冲区处于高电平时触发事件。此外，<code>epoll_wait</code>的默认工作模式也是LT。</p><h4 id="可读事件"><a href="#可读事件" class="headerlink" title="可读事件"></a>可读事件</h4><p>为接受对端<code>connfd</code>发送的数据，服务器首先要为<code>connfd</code>注册可读事件<code>EPOLLIN</code>。</p><p>如此，当对端发送数据过来，服务器<code>connfd</code>的<code>recv_buff </code> 不为空，则<code>epoll_wait</code>上的可读事件触发，在读回调函数<code>HandleRead</code>中从<code>socket</code>的<code>recv_buff </code> 中读取数据。</p><p>然而，即使服务端本次没有将scoket<code>recv_buff </code> 中的数据全部读取，下次调用<code>epoll_wait</code>时也依然会触发可读事件。</p><p>为啥？</p><p>因为，只要<code>recv_buff </code> 中的数据没有读取完，即为「高电平」状态，那么就会一直触发<code>epoll_wait</code>的<code>EPOLLIN</code> 事件，直到<code>recv_buff </code> 变空，即为「低电平」状态。</p><p>因此<code>LT</code>模式下，不用担心数据漏读的问题。</p><h4 id="可写事件"><a href="#可写事件" class="headerlink" title="可写事件"></a>可写事件</h4><p>然而，可写事件与可读事件不同：可读事件是被动触发的，即服务端不知道对端何时发送数据。因此服务端与对端建立连接之后，要立即为<code>connfd</code>注册可读事件，然后在<code>epoll_wait</code>上阻塞等待客户端发送数据过来。</p><p>那么，可写事件呢？是服务端主动触发的。</p><p>服务端与对端建立连接后，<code>connfd</code>的<code>send_buff</code>是空的，即处于高电平，是可以直接发送数据的。</p><p>如果此时为<code>connfd</code>注册可写事件，这就会导致<code>epoll_wait</code>一直检测到<code>connfd</code>上的可写事件触发，但实际上服务端又没有数据可以发送给对端，造成服务端的CPU资源无端被消耗。</p><p>因此，在<code>LT</code>模式下，当服务端要向对端发送数据时，不需要先通过<code>epoll_ctl</code>注册可写事件，然后阻塞在<code>epoll_wait</code>上等待可写事件的发生。<font color=red> 正确的做法如下</font>：</p><ul><li>直接发送数据 <code>n = write(connfd, outbuffer, sizeof(outbuffer))</code>；</li><li>如果此次数据没有发送完毕，即<code>n != sizeof(outbuffer)</code>，则为<code>connfd</code>注册可写事件；</li><li>在<code>epoll_wait</code>上等待可写事件触发；</li><li>可写事件触发，则将剩余的数据发送完毕；</li><li>如果没有发送完毕，则等待下次的可写事件；发送完毕，则取消关注可写事件。</li></ul><p><strong>注意</strong>：当数据发送完毕，一定要取消可写事件，否则当<code>connfd</code>的<code>send_buff</code>变空，后面又没有可发的数据，则又会导致<code>epoll_wait</code>一直触发可写事件。</p><h3 id="ET（Edge-Triggered）"><a href="#ET（Edge-Triggered）" class="headerlink" title="ET（Edge Triggered）"></a>ET（Edge Triggered）</h3><p>ET，所谓边缘触发，即只有在电平状态发生变化时才会触发。开启ET模式，需要设置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">ev.events = EPOLLIN | EPOLLET; <span class="comment">// ET 模式</span></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br></pre></td></tr></table></figure><h4 id="可读事件-1"><a href="#可读事件-1" class="headerlink" title="可读事件"></a>可读事件</h4><p>注册了可读事件后，阻塞于<code>epoll_wait</code>等待对端发送数据，再触发可读事件。</p><p><strong>注意</strong>：如果服务端没有将<code>recv_buff </code> 中的数据全部读取，那么进入下一轮循环并阻塞在<code>epoll_wait</code>后，可读事件就再也不会触发。</p><p>为啥？</p><p>在<code>ET</code>模式下，只有<code>connfd</code>的<code>recv_buffer</code>电平状态发生变化才会触发可读事件，但只要<code>recv_buff </code> 中还有数据，则一直为高电平状态，那么即便下次对端又发送数据过来，并不会改<code>recv_buff </code> 的电平状态，这就导致<code>epoll_wait</code>就无法再检测到<code>connfd</code>上的可读事件。</p><p>那么对端发送了数据，服务端迟迟无法给出回应。如果是<code>listenfd</code>，那么这个服务器就不再能处理新的连接请求了。</p><p>因此，如果不熟悉<code>ET</code>模式的正确使用方法，很可能导致整个服务器无法使用。</p><p>那<code>ET</code>模式下，怎么处理可读事件？</p><p>一旦检测到<code>connfd</code>上的可读事件，需要不停地从<code>recv_buff </code> 中读取数据，直到<code>read</code>函数返回<code>-1</code>，且错误码<code>errno</code>是<code>EAGAIN</code>标志。</p><p>这标志着<code>recv_buff </code> 中的数据已经读取完（已处于低电平），下次对端再发送数据过来（变为高电平），就能再次触发可读事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(; ; ;) &#123; </span><br><span class="line">  ret = read(connfd, buffer, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EAGAIN) &#123; </span><br><span class="line">     LOG(NOTICE) &lt;&lt; <span class="string">&quot;READ DONE&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>但是又有一个问题：</p><ul><li><code>read</code>函数，什么情况下才会返回<code>EAGAIN</code>？</li><li>要是<code>read</code> 函数不返回<code>EAGAIN</code>，那么岂不是一直在<code>while/for</code>循环？</li></ul><p>仅在<code>connfd</code>设置为非阻塞模式时，<code>read</code>函数无法从空的<code>recv_buff</code>继续读取到数据，此时错误码<code>errno</code>就会被设置为<code>EAGAIN</code>。</p><h4 id="可写事件-1"><a href="#可写事件-1" class="headerlink" title="可写事件"></a>可写事件</h4><p>ET模式下，在与客户端建立连接后，<strong>可以为<code>connfd</code>注册可写事件</strong>，因为此时<code>connfd</code>的<code>send_buff</code>是空的，处于高电平，不会触发可写事件。</p><p>当服务端要通过<code>connfd</code>向客户端发送数据时，直接发送即可：</p><ul><li><p>如果应用层缓冲区<code>outbuffer</code>的数据大小小于<code>send_buff</code>大小，则无须任何操作；</p><p>换言之，<code>connfd</code>的<code>send_buff</code>能容纳<code>outbuffer</code>中的全部数据，那么<code>send_buff</code>依然未满，即处于高电平状态。下次应用层有待发送的数据，直接发送即可；</p></li><li><p>如果<code>outbuffer</code>中的数据大小大于<code>send_buff</code>大小，那么<code>write(connfd, outbuffer, size)</code>返回-1 且 <code>errno</code>是<code>EAGAIN</code>。</p><p>由于<code>send_buff</code>满了，即处于「低电平」状态，表示不可再接受来自应用层的数据。为了将<code>outbuffer</code>中剩余的数据也发送到对端，此时需要为<code>connfd</code>注册可写事件。</p><p>当<code>send_buff</code>的数据发送出去，则会变为「高电平」状态，此时就会触发<code>connfd</code>上的可写事件，进而就能继续发送<code>outbuffer</code>中剩下的数据了。</p></li></ul><p>总结下，写操作要一直写到应用层<code>outBuffer</code>为空，或者<code>write</code>函数返回<code>EAGAIN</code>。</p><p>上面的 <code>epoll LT</code> 模式注：如果数据未发送完毕，需要注册可写事件；可写事件触发后，尝试发送<code>outBuffer</code>中的剩余数据，如果数据此时还不能全部发送完，<strong>不用再次注册可写事件，若全部发送完毕，需要取消注册可写事件</strong>。</p><p>如果是 <code>epoll ET</code> 模：如果数据未发送完毕，注册可写事件；可写事件触发后，尝试发送剩余数据，如果数据此时还不能全部发送完，<strong>需要再次注册可写事件，以便让可写事件下次再次触发，数据全部发送完毕，不用取消注册可写事件</strong>。</p><h3 id="LT-or-ET"><a href="#LT-or-ET" class="headerlink" title="LT  or ET ?"></a>LT  or ET ?</h3><p>说了这么多，那自己设计一个服务器，到底是选 <code>ET</code> 还是 <code>LT</code> ?</p><p>从个人的目前经验来说，看到的大多数都是<code>LT</code>。</p><p>对于可读事件，<code>ET</code>模式只会触发一次<code>epoll_wait</code>，而<code>LT</code>模式下，如果不能一次性读取完<code>recv_buff </code> 中的数据，则会多次触发<code>epoll_wait</code>，增加系统调用开销。</p><p>如果我使用<code>LT</code>模式，且一次就将<code>recv_buff </code> 中的数据全部读取出来，那不也就只调用一次<code>epoll_wait</code>，不就和<code>ET</code>模式一样了？</p><p>此外，LT模式下的<code>read</code>函数可以少一次系统调用，因为<code>ET</code>模式下的<code>read</code>操作必须读取到返回<code>EAGAIN</code>，就多了一次系统调用开销。</p><p>这就是<code>muduo</code>设计了一个<code>InputBuffer</code>的原因，而在<code>redis</code>中也有个输入缓冲区。</p><blockquote><p>muduo、libuv、redis等都是采用LT模式，其他库不太清楚。</p></blockquote><p>更为重要的是，<code>ET</code>模式操作不当，容易造成数据漏读、甚至服务器阻塞等问题，而良好的设计的<code>LT</code>模式效率也依然很高。</p><p>下面我们从muduo源码角度还原上述过程。</p><h2 id="muduo源码展示"><a href="#muduo源码展示" class="headerlink" title="muduo源码展示"></a>muduo源码展示</h2><p>确定好大的方向是「LT模式的<code>epoll</code> + 非阻塞IO」来设计异步通信之后。下面，我们就根据「网络编程」的前三期大致梳理下muduo服务端的源码。</p><h3 id="监听客户端连接请求"><a href="#监听客户端连接请求" class="headerlink" title="监听客户端连接请求"></a>监听客户端连接请求</h3><p>当muduo的服务器<code>TcpServer</code>运行时，会先在<code>Acceptor</code>中创建一个非阻塞的<code>listenfd</code>，用于监听客户端的连接请求，即muduo中的<code>acceptSocket_</code>字段， 并为<code>acceptSocket_</code>注册可读事件、设置可读回调函数 <code>Acceptor::handleRead</code>。</p><p>这样，服务端就能监听客户端<code>cli</code>的连接请求：</p><ul><li>当监听到客户端的连接请求后，在读取回调函数<code>Acceptor::handleRead</code>中为请求连接的客户端<code>cli</code>创建<code>TcpConnection</code>对象<code>conn</code>；</li><li>在众多<code>sub-eventloops</code>线程中，选择一个<code>sub-loop</code>线程，将<code>conn</code>分发到该<code>sub-loop</code>线程；</li><li>以后服务端与该<code>cli</code>的通信，都在<code>sub-loop</code>线程中完成，而<code>Acceptor</code>所在的<code>main-eventloop</code>线程，只是负责监听客户端的连接请求。</li></ul><p>如此，<code>Accptor</code>的作用即任务分发器<code>dispatcher</code>：</p><p>整个框架逻辑如图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::Acceptor(EventLoop* loop, <span class="keyword">const</span> InetAddress&amp; listenAddr, <span class="keyword">bool</span> reuseport)</span><br><span class="line">  : loop_(loop),</span><br><span class="line">    acceptSocket_(sockets::createNonblockingOrDie(listenAddr.family())),</span><br><span class="line">    acceptChannel_(loop, acceptSocket_.fd()),</span><br><span class="line">    listening_(<span class="literal">false</span>),</span><br><span class="line">    idleFd_(::open(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))</span><br><span class="line">&#123;</span><br><span class="line">  assert(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line">  acceptSocket_.setReuseAddr(<span class="literal">true</span>);</span><br><span class="line">  acceptSocket_.setReusePort(reuseport); <span class="comment">// 设置端口复用</span></span><br><span class="line">  acceptSocket_.bindAddress(listenAddr); <span class="comment">// 绑定地址</span></span><br><span class="line">  acceptChannel_.setReadCallback(<span class="built_in">std</span>::bind(&amp;Acceptor::handleRead, <span class="keyword">this</span>)); <span class="comment">// 可读事件回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自然，分发任务的操作就是在可读事件的回调函数<code>Acceptor::handleRead</code>中完成的，其核心就是<code>newConnectionCallback_</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  InetAddress peerAddr;</span><br><span class="line">  <span class="keyword">int</span> connfd = acceptSocket_.accept(&amp;peerAddr); <span class="comment">// 获取客户端的 ip:port</span></span><br><span class="line">  <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">      newConnectionCallback_(connfd, peerAddr); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      sockets::close(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">&quot;in Acceptor::handleRead&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">      ::close(idleFd_);</span><br><span class="line">      idleFd_ = ::accept(acceptSocket_.fd(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      ::close(idleFd_);</span><br><span class="line">      idleFd_ = ::open(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而回调函数<code>newConnectionCallback_</code>最终初始化为<code>TcpServer</code>类中的<code>TcpServer::newConnection</code>函数：</p><ul><li>创建<code>TcpConnection</code>对象 <code>conn</code>；</li><li><code>TcpServer</code>中的<code>connections_</code>记录着每个客户端，因此要把新创建的客户端记录在<code>connections_</code>中；</li><li>为<code>conn</code>设置一些回调函数；</li><li>将<code>conn</code>放到<code>sub-eventloop</code>中运行，以后服务器与该客户端的通讯就在<code>ioLoop</code>中进行了。</li></ul><p>整个逻辑如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> InetAddress&amp; peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  EventLoop* ioLoop = threadPool_-&gt;getNextLoop(); <span class="comment">// 从子线程中选择一个</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.c_str(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  <span class="built_in">string</span> connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">  LOG_INFO &lt;&lt; <span class="string">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_</span><br><span class="line">           &lt;&lt; <span class="string">&quot;] - new connection [&quot;</span> &lt;&lt; connName</span><br><span class="line">           &lt;&lt; <span class="string">&quot;] from &quot;</span> &lt;&lt; peerAddr.toIpPort();</span><br><span class="line">  <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">  <span class="comment">// 创建TcpConnection对象</span></span><br><span class="line">  <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          connName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          sockfd,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          localAddr,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          peerAddr))</span></span>;</span><br><span class="line">  connections_[connName] = conn;</span><br><span class="line">  <span class="comment">// 设置相关的回调函数</span></span><br><span class="line">  conn-&gt;setConnectionCallback(connectionCallback_);</span><br><span class="line">  conn-&gt;setMessageCallback(messageCallback_);</span><br><span class="line">  conn-&gt;setWriteCompleteCallback(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">  <span class="comment">// 放到 sub-eventloop 中运行</span></span><br><span class="line">  ioLoop-&gt;runInLoop(<span class="built_in">std</span>::bind(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>TcpConnection::connectEstablished</code>回调函数中，为每个刚建立连接的<code>TcpConnection</code>对象注册可读事件，这是为了监听等待客户端的发送数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  assert(state_ == kConnecting);</span><br><span class="line">  setState(kConnected);</span><br><span class="line">  channel_-&gt;tie(shared_from_this());</span><br><span class="line">  channel_-&gt;enableReading(); <span class="comment">// 注册可读事件</span></span><br><span class="line">  connectionCallback_(shared_from_this());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个<code>conn</code>的可读、可写等事件的回调函数在<code>TcpConnection</code>构造函数中就完成了初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::TcpConnection(EventLoop* loop,</span><br><span class="line">                             <span class="keyword">const</span> <span class="built_in">string</span>&amp; nameArg,</span><br><span class="line">                             <span class="keyword">int</span> sockfd,</span><br><span class="line">                             <span class="keyword">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                             <span class="keyword">const</span> InetAddress&amp; peerAddr)</span><br><span class="line">  : loop_(CHECK_NOTNULL(loop)),</span><br><span class="line">    name_(nameArg),</span><br><span class="line">    state_(kConnecting),</span><br><span class="line">    reading_(<span class="literal">true</span>),</span><br><span class="line">    socket_(<span class="keyword">new</span> Socket(sockfd)),</span><br><span class="line">    channel_(<span class="keyword">new</span> Channel(loop, sockfd)),</span><br><span class="line">    localAddr_(localAddr),</span><br><span class="line">    peerAddr_(peerAddr),</span><br><span class="line">    highWaterMark_(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">  channel_-&gt;setReadCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1)); <span class="comment">// 读回调</span></span><br><span class="line">  channel_-&gt;setWriteCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));   <span class="comment">// 写回调</span></span><br><span class="line">  channel_-&gt;setCloseCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));   <span class="comment">// 关闭回调</span></span><br><span class="line">  channel_-&gt;setErrorCallback(<span class="built_in">std</span>::bind(&amp;TcpConnection::handleError, <span class="keyword">this</span>));   <span class="comment">// 错误处理回调</span></span><br><span class="line">  LOG_DEBUG &lt;&lt; <span class="string">&quot;TcpConnection::ctor[&quot;</span> &lt;&lt;  name_ &lt;&lt; <span class="string">&quot;] at &quot;</span> &lt;&lt; <span class="keyword">this</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; sockfd;</span><br><span class="line">  socket_-&gt;setKeepAlive(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，当<code>conn</code>对应的客户端发送过来数据时，触发可读事件后，会调用<code>TcpConnection::handleRead</code>来进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  <span class="keyword">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">ssize_t</span> n = inputBuffer_.readFd(channel_-&gt;fd(), &amp;savedErrno);</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    messageCallback_(shared_from_this(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    handleClose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleRead&quot;</span>;</span><br><span class="line">    handleError();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，启动服务器到和客户端建立连接请求的过程、接受数据的流程大致结束了。</p><h3 id="可写事件-2"><a href="#可写事件-2" class="headerlink" title="可写事件"></a>可写事件</h3><p>在前面说过<code>LT</code>模式下的可写事件需要注意的点，下面顺着代码注释去看就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* data, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  <span class="keyword">ssize_t</span> nwrote   = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">size_t</span> remaining = len;</span><br><span class="line">  <span class="keyword">bool</span> faultError  = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (state_ == kDisconnected)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;disconnected, give up writing&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 如果没有关注可写事件 且 outbuffer_ 中无待发送数据，说明之前的数据都已经写完</span></span><br><span class="line">  <span class="comment">/// 对于 用户来说是向 outbuffer_ 中写，</span></span><br><span class="line">  <span class="comment">/// 对于 socket 来说是从 outbuffer_ 中读取</span></span><br><span class="line">  <span class="keyword">if</span> (!channel_-&gt;isWriting() &amp;&amp; outbuffer_.readableBytes() == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    nwrote = sockets::write(channel_-&gt;fd(), data, len);</span><br><span class="line">    <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      remaining = len - nwrote;</span><br><span class="line">      <span class="comment">// 全部写完了，那么就执行写完成回调</span></span><br><span class="line">      <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)</span><br><span class="line">      &#123;</span><br><span class="line">        loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">    &#123;</span><br><span class="line">      nwrote = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/// socket 的发送缓冲已经满，无法将 outbuffer_ 的数据都复制到 socket 的 send_buff</span></span><br><span class="line">      <span class="comment">/// 非阻塞模式下，函数返回 -1 &amp;&amp; errno == EWOULDBLOCK</span></span><br><span class="line">      <span class="comment">/// 如果错误码不是EWOULDBLOCK，那么是真的产生错误了，需要关闭连接</span></span><br><span class="line">      <span class="keyword">if</span> (errno != EWOULDBLOCK) </span><br><span class="line">      &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::sendInLoop&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></span><br><span class="line">        &#123;</span><br><span class="line">          faultError = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  assert(remaining &lt;= len);</span><br><span class="line">  <span class="comment">/// @brief: 运行到这有两种可能：</span></span><br><span class="line">  <span class="comment">/// 1 之前没有注册可写事件，且 outbuffer_ 中没有可读取数据，</span></span><br><span class="line">  <span class="comment">/// 运行到此是因为此次数据 data 没有发送完</span></span><br><span class="line">  <span class="comment">/// 2 之前的数据没有发送完，又来了新的数据</span></span><br><span class="line">  <span class="comment">/// 无论哪种情况，处理方式：</span></span><br><span class="line">  <span class="comment">///  将数据复制到 outbuffer_ 中，关注 EPOLLOUT 事件，等待可写事件触发，发送数据</span></span><br><span class="line">  <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">size_t</span> oldLen = outbuffer_.readableBytes();</span><br><span class="line">    <span class="comment">// 待发送的内容已经超过标志位了，就调用高水位这个函数</span></span><br><span class="line">    <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_  &amp;&amp;</span><br><span class="line">        oldLen &lt; highWaterMark_  &amp;&amp;</span><br><span class="line">        highWaterMarkCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(highWaterMarkCallback_, </span><br><span class="line">                                   shared_from_this(), </span><br><span class="line">                                   oldLen + remaining));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 将剩余的内容加如 outbuffer_</span></span><br><span class="line">    outbuffer_.append(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>*&gt;(data)+nwrote, remaining);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在LT 模式下不需要重复关注可写事件，即使运行到此的第二种情况不需要再关注可写事件</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;isWriting())</span><br><span class="line">    &#123;</span><br><span class="line">      channel_-&gt;enableWriting();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief: 写回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;assertInLoopThread();</span><br><span class="line">  <span class="comment">/// 触发写回调函数</span></span><br><span class="line">  <span class="comment">/// 将 @b outbuffer_ 中的数据复制到 @b socket 的`send_buff`</span></span><br><span class="line">  <span class="keyword">if</span> (channel_-&gt;isWriting())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = sockets::write(channel_-&gt;fd(),</span><br><span class="line">                               outbuffer_.peek(),</span><br><span class="line">                               outbuffer_.readableBytes());</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      outbuffer_.retrieve(n);</span><br><span class="line">      <span class="comment">/// 如果 @b outbuffer_ 中的数据全部写完，</span></span><br><span class="line">      <span class="comment">/// 那么就可以取消关注 @b EPOLLOUT ，防止出现 busy loop</span></span><br><span class="line">      <span class="comment">/// 并且调用写完成回调函数</span></span><br><span class="line">      <span class="comment">/// 如果全部写完，此时就需要取消关注可写事件</span></span><br><span class="line">      <span class="comment">/// 如果 @b outbuffer_ 中还有数据，就继续等待下次可写事件的触发</span></span><br><span class="line">      <span class="keyword">if</span> (outbuffer_.readableBytes() == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        channel_-&gt;disableWriting();</span><br><span class="line">        <span class="keyword">if</span> (writeCompleteCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">          loop_-&gt;queueInLoop(<span class="built_in">std</span>::bind(writeCompleteCallback_, shared_from_this()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (state_ == kDisconnecting)</span><br><span class="line">        &#123;</span><br><span class="line">          shutdownInLoop();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleWrite&quot;</span>;</span><br><span class="line">      <span class="comment">// if (state_ == kDisconnecting)</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   shutdownInLoop();</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;Connection fd = &quot;</span> &lt;&lt; channel_-&gt;fd()</span><br><span class="line">              &lt;&lt; <span class="string">&quot; is down, no more writing&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>到此，就差不多了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异步通信&quot;&gt;&lt;a href=&quot;#异步通信&quot; class=&quot;headerlink&quot; title=&quot;异步通信&quot;&gt;&lt;/a&gt;异步通信&lt;/h1&gt;&lt;p&gt;之前有两期讲解了服务端框的架构，这一期来讲下服务器是如何与客户端进行异步通信的，下一期再讲述客户端是如何异步非阻塞conne</summary>
      
    
    
    
    <category term="nio" scheme="https://szza.github.io/categories/nio/"/>
    
    
    <category term="nio" scheme="https://szza.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>多线程 HashTable 设计</title>
    <link href="https://szza.github.io/2021/11/26/RocksDB/utility/HashTablel/"/>
    <id>https://szza.github.io/2021/11/26/RocksDB/utility/HashTablel/</id>
    <published>2021-11-26T06:15:35.000Z</published>
    <updated>2023-07-31T14:48:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashTable-lt-T-Hash-Equal-gt"><a href="#HashTable-lt-T-Hash-Equal-gt" class="headerlink" title="HashTable&lt;T, Hash, Equal&gt;"></a>HashTable&lt;T, Hash, Equal&gt;</h2><p>RocksDb 为了优化多核下的HashTable性能，放弃了全局锁设计，取而代之是如下分段锁设计：在并发下，将全局锁上的竞争分散到各个bucket上。</p><p>对每个桶（bucket）分配一个锁（mutex），当获取某个bucket中的元素时，只使用对应bucket的mutex即可，这样对其他bucket的元素就没有额外的负担。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                         |&lt;-------- alpha -------------&gt;|</span></span><br><span class="line"><span class="comment">//               Buckets   Collision list</span></span><br><span class="line"><span class="comment">//          ---- +----+    +---+---+--- ...... ---+---+---+</span></span><br><span class="line"><span class="comment">//         /     |    |---&gt;|   |   |              |   |   |</span></span><br><span class="line"><span class="comment">//        /      +----+    +---+---+--- ...... ---+---+---+</span></span><br><span class="line"><span class="comment">//       /       |    |</span></span><br><span class="line"><span class="comment">// Locks/        +----+</span></span><br><span class="line"><span class="comment">// +--+/         .    .</span></span><br><span class="line"><span class="comment">// |  |          .    .</span></span><br><span class="line"><span class="comment">// +--+          .    .</span></span><br><span class="line"><span class="comment">// |  |          .    .</span></span><br><span class="line"><span class="comment">// +--+          .    .</span></span><br><span class="line"><span class="comment">// |  |          .    .</span></span><br><span class="line"><span class="comment">// +--+          .    .</span></span><br><span class="line"><span class="comment">//     \         +----+</span></span><br><span class="line"><span class="comment">//      \        |    |</span></span><br><span class="line"><span class="comment">//       \       +----+</span></span><br><span class="line"><span class="comment">//        \      |    |</span></span><br><span class="line"><span class="comment">//         \---- +----+</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="keyword">class</span> <span class="title">Hash</span>, <span class="keyword">class</span> <span class="title">Equal</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashTable</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">HashTable</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity = <span class="number">1024</span> * <span class="number">1024</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">float</span> load_factor = <span class="number">2.0</span>, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">uint32_t</span> nlocks = <span class="number">256</span>)</span></span></span><br><span class="line">      : nbuckets_(static_cast&lt;uint32_t&gt;(load_factor ? capacity / load_factor : 0)),</span><br><span class="line">        nlocks_(nlocks) &#123;</span><br><span class="line">    assert(capacity);</span><br><span class="line">    assert(load_factor);</span><br><span class="line">    assert(nbuckets_);</span><br><span class="line">    assert(nlocks_);</span><br><span class="line"></span><br><span class="line">    buckets_.reset(<span class="keyword">new</span> Bucket[nbuckets_]);</span><br><span class="line">  <span class="comment">// initialize</span></span><br><span class="line">    mlock(buckets_.get(), nbuckets_ * <span class="keyword">sizeof</span>(Bucket));</span><br><span class="line">    mlock(locks_.get(), nlocks_ * <span class="keyword">sizeof</span>(port::RWMutex));</span><br><span class="line"></span><br><span class="line">    assert(buckets_);</span><br><span class="line">    assert(locks_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~HashTable() &#123; AssertEmptyBuckets(); &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Bucket</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt; list_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">AssertEmptyBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nbuckets_; ++i) &#123;</span><br><span class="line">      WriteLock _(&amp;locks_[i % nlocks_]);</span><br><span class="line">      assert(buckets_[i].list_.empty());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> nbuckets_;                 <span class="comment">// 桶的总数</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Bucket[]&gt; buckets_;       <span class="comment">// 桶</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> nlocks_;                   <span class="comment">// 锁的总数</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;port::RWMutex[]&gt; locks_;  <span class="comment">// 锁 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h4><p>每个bucket都指向一个链表，用于解决hash冲突，因此当查找一个key时，需要在链表中顺序查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 顺序查找，时间复杂度O(N)</span></span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;::<span class="function">iterator <span class="title">Find</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T&gt;* <span class="built_in">list</span>, <span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>-&gt;begin(); it != <span class="built_in">list</span>-&gt;end(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Equal()(*it, t)) &#123;</span><br><span class="line">      <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">list</span>-&gt;end();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///@brief 在 bucket 中查找 t</span></span><br><span class="line"><span class="comment">///@param ret 就是传出参数，返回true时有效</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Find</span><span class="params">(Bucket* bucket, <span class="keyword">const</span> T&amp; t, T* ret)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = Find(&amp;bucket-&gt;list_, t);</span><br><span class="line">  <span class="keyword">if</span> (it != bucket-&gt;list_.end()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      *ret = *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将 t 添加到 bucket 中，不会重复添加</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(Bucket* bucket, <span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = Find(&amp;bucket-&gt;list_, t);</span><br><span class="line">  <span class="keyword">if</span> (it != bucket-&gt;list_.end()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 不存在，则添加</span></span><br><span class="line">  bucket-&gt;list_.push_back(t);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Erase"><a href="#Erase" class="headerlink" title="Erase"></a>Erase</h4><p><code>Erase</code> 和 <code>Insert</code>类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Erase</span><span class="params">(Bucket* bucket, <span class="keyword">const</span> T&amp; t, T* ret)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = Find(&amp;bucket-&gt;list_, t);</span><br><span class="line">  <span class="keyword">if</span> (it != bucket-&gt;list_.end()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      *ret = *it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bucket-&gt;list_.erase(it);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GetMutex"><a href="#GetMutex" class="headerlink" title="GetMutex"></a>GetMutex</h4><p><code>GetMutex</code>函数，用于获得一个key对应的mutex。</p><ul><li>获得 key 对应的 hash_code</li><li>获得 hash_code 映射到 buckets_ 中的索引 bucket_idx</li><li>通过 bucket_idx 映射到 locks_ 中的索引 lock_idx</li></ul><p>最终，对 key 进行同步操作的锁就是 <code>locks_[lock_idx]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">port::RWMutex* <span class="title">GetMutex</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> h = Hash()(t);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> bucket_idx = h % nbuckets_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> lock_idx = bucket_idx % nlocks_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;locks_[lock_idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>下面来看看，将一个 key 插入到 HashTable 中的过程。</p><ul><li>获得 <code>bucket_idx</code>、<code>lock_idx</code></li><li>使用 <code>locks_[lock_idx]</code> 对要修改的 <code>buckets_[bucket_idx]</code> 进行保护，再调用bucket级别的insert方法，将key插入到 <code>buckets_[bucket_idx]</code> 中。</li></ul><p>整体表现如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Insert</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">uint64_t</span> h = Hash()(t);</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">uint32_t</span> bucket_idx = h % nbuckets_;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">uint32_t</span> lock_idx = bucket_idx % nlocks_;</span><br><span class="line"></span><br><span class="line">   WriteLock _(&amp;locks_[lock_idx]);</span><br><span class="line">   <span class="keyword">auto</span>&amp; bucket = buckets_[bucket_idx];</span><br><span class="line">   <span class="keyword">return</span> Insert(&amp;bucket, t);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其余方法，和 <code>Insert</code> 类似。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HashTable-lt-T-Hash-Equal-gt&quot;&gt;&lt;a href=&quot;#HashTable-lt-T-Hash-Equal-gt&quot; class=&quot;headerlink&quot; title=&quot;HashTable&amp;lt;T, Hash, Equal&amp;gt;&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>persistent cache 设计</title>
    <link href="https://szza.github.io/2021/11/26/RocksDB/utility/persistent_cache/"/>
    <id>https://szza.github.io/2021/11/26/RocksDB/utility/persistent_cache/</id>
    <published>2021-11-26T06:15:35.000Z</published>
    <updated>2023-07-31T15:01:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="persistent-cache"><a href="#persistent-cache" class="headerlink" title="persistent cache"></a>persistent cache</h2><p>RocksDb  利用分层概念，设计了persistent cache：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; PersistentTieredCache architecture:</span><br><span class="line">&#x2F;&#x2F; +--------------------------+ PersistentCacheTier that handles multiple tiers</span><br><span class="line">&#x2F;&#x2F; | +----------------+       |</span><br><span class="line">&#x2F;&#x2F; | | RAM            | PersistentCacheTier that handles RAM (VolatileCacheImpl)</span><br><span class="line">&#x2F;&#x2F; | +----------------+       |</span><br><span class="line">&#x2F;&#x2F; |   | next                 |</span><br><span class="line">&#x2F;&#x2F; |   v                      |</span><br><span class="line">&#x2F;&#x2F; | +----------------+       |</span><br><span class="line">&#x2F;&#x2F; | | NVM            | PersistentCacheTier implementation that handles NVM</span><br><span class="line">&#x2F;&#x2F; | +----------------+ (BlockCacheImpl)</span><br><span class="line">&#x2F;&#x2F; |   | next                 |</span><br><span class="line">&#x2F;&#x2F; |   V                      |</span><br><span class="line">&#x2F;&#x2F; | +----------------+       |</span><br><span class="line">&#x2F;&#x2F; | | LE-SSD         | PersistentCacheTier implementation that handles LE-SSD</span><br><span class="line">&#x2F;&#x2F; | +----------------+ (BlockCacheImpl)</span><br><span class="line">&#x2F;&#x2F; |   |                      |</span><br><span class="line">&#x2F;&#x2F; |   V                      |</span><br><span class="line">&#x2F;&#x2F; |  null                    |</span><br><span class="line">&#x2F;&#x2F; +--------------------------+</span><br><span class="line">&#x2F;&#x2F;               |</span><br><span class="line">&#x2F;&#x2F;               V</span><br><span class="line">&#x2F;&#x2F;              null</span><br></pre></td></tr></table></figure><ul><li>在最上层，数据全都是在内存中，这一部分属于易失性数据由 <code>VolatileCacheImpl</code> 实现</li><li>其他层，在内存和文件中的数据进行交互，由 <code>BlockCacheImpl</code> 实现。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;persistent-cache&quot;&gt;&lt;a href=&quot;#persistent-cache&quot; class=&quot;headerlink&quot; title=&quot;persistent cache&quot;&gt;&lt;/a&gt;persistent cache&lt;/h2&gt;&lt;p&gt;RocksDb  利用分层概</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>IndexBlock 源码分析</title>
    <link href="https://szza.github.io/2021/11/26/RocksDB/Table/builder/2_IndexBlock/"/>
    <id>https://szza.github.io/2021/11/26/RocksDB/Table/builder/2_IndexBlock/</id>
    <published>2021-11-26T06:15:35.000Z</published>
    <updated>2023-07-31T14:33:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IndexBuilder"><a href="#IndexBuilder" class="headerlink" title="IndexBuilder"></a>IndexBuilder</h2><p><code>IndexBuilder</code> 是个基类，一共有三个子类：</p><ol><li><code>ShortenedIndexBuilder</code></li><li><code>HashIndexBuilder</code></li><li><code>PartitionedIndexBuilder</code></li></ol><p>一个<code>IndexBlock</code> 会构建一个许多<code>IndexBlock</code>，每个<code>IndexBlock</code>都包含两个字段：</p><ul><li> <code>primary index block</code></li><li><code>meta_blocks</code>：主要是存储着关于 <code>primary index block</code> 的一些列<code>meta data</code>.</li></ul><p>这个<code>IndexBlocks</code>用于接受 <code>IndexBuilder::Finish</code> 调用时候的传出参数，用来接受<code>IndexBuilder</code>添加的<code>block</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> IndexBuilder* <span class="title">CreateIndexBuilder</span><span class="params">(BlockBasedTableOptions::IndexType index_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> InternalKeyComparator* comparator,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> InternalKeySliceTransform* int_key_slice_transform,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> <span class="keyword">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> BlockBasedTableOptions&amp; table_opt)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">IndexBlocks</span> &#123;</span></span><br><span class="line">    Slice index_block_contents;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Slice&gt; meta_blocks;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">IndexBuilder</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator* comparator)</span></span></span><br><span class="line"><span class="function">      : <span class="title">comparator_</span><span class="params">(comparator)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~IndexBuilder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 添加 &#123;key, block_handle&#125; 至 block_builder</span></span><br><span class="line">  <span class="comment">/// 其中 key in [last_key_in_current_block, first_key_in_next_block)</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddIndexEntry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* last_key_in_current_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> BlockHandle&amp; block_handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 回调函数：只要有 key 添加，这个函数就会被调用</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnKeyAdded</span><span class="params">(<span class="keyword">const</span> Slice&amp; <span class="comment">/*key*/</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将 IndexBuilder 添加的数据序存储到 @c index_blocks 中</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks)</span> </span>&#123;</span><br><span class="line">    BlockHandle last_partition_block_handle;</span><br><span class="line">    <span class="keyword">return</span> Finish(index_blocks, last_partition_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 子类重写这个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> BlockHandle&amp; last_partition_block_handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 当前这个IndexBluiler 的大小</span></span><br><span class="line">  <span class="comment">/// 必须先调用 ::Finish 函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">IndexSize</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">seperator_is_key_plus_seq</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">const</span> InternalKeyComparator* comparator_;</span><br><span class="line">  <span class="keyword">size_t</span> index_size_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="ShortenedIndexBuilder"><a href="#ShortenedIndexBuilder" class="headerlink" title="ShortenedIndexBuilder"></a>ShortenedIndexBuilder</h2><p><code>ShortenedIndexBuilder</code> 是个基础的<code>IndexBuilder</code>，在存储<code>&#123;k,v&#125;</code>时，可以尽可能的压缩内存空间，被在后面的<code>HashIndexBuilder</code>、<code>PartitionedIndexBuilder</code> 内置使用。</p><p>他的使用过程大致如下：</p><ol><li>通过 <code>AddIndexEntry</code> 函数来添加<code>&#123;k, v&#125;</code>，其中<code>key</code>是计算出来位于<code>[last_key_in_current_block, first_key_in_next_block)</code>区间的最短字符串，<code>value</code>是<code>block_hadnle</code>，即是表征某个block。</li><li>在每个添加<code>&#123;k, v&#125;</code>时，都会触发回调函数<code>onKeyAdd</code>，这可以用来记录一些额外的信息；</li><li>添加完毕的时候，调用<code>::Finish</code>函数，将通过 <code>AddIndexEntry</code> 函数添加的<code>&#123;k ,block_handle&#125;</code>序列化成字符串返回。</li></ol><p>下面先大致看下 <code>ShortenedIndexBuilder</code>类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShortenedIndexBuilder</span> :</span> <span class="keyword">public</span> IndexBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ShortenedIndexBuilder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> InternalKeyComparator* comparator,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">int</span> index_block_restart_interval, </span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> format_version,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="function"><span class="params">      BlockBasedTableOptions::IndexShorteningMode shortening_mode,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">bool</span> include_first_key)</span></span></span><br><span class="line">      : IndexBuilder(comparator),</span><br><span class="line">        index_block_builder_(index_block_restart_interval,</span><br><span class="line">                             <span class="literal">true</span> <span class="comment">/*use_delta_encoding*/</span>,</span><br><span class="line">                             use_value_delta_encoding),</span><br><span class="line">        index_block_builder_without_seq_(index_block_restart_interval,</span><br><span class="line">                                         <span class="literal">true</span> <span class="comment">/*use_delta_encoding*/</span>,</span><br><span class="line">                                         use_value_delta_encoding),</span><br><span class="line">        use_value_delta_encoding_(use_value_delta_encoding),</span><br><span class="line">        include_first_key_(include_first_key),</span><br><span class="line">        shortening_mode_(shortening_mode) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 低于版本2的不支持，需要 &gt;= 3</span></span><br><span class="line">    seperator_is_key_plus_seq_ = (format_version &lt;= <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在每个block添加第一个key时候进入if分支</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnKeyAdded</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (include_first_key_ &amp;&amp; current_block_first_internal_key_.empty()) &#123;</span><br><span class="line">      current_block_first_internal_key_.assign(key.data(), key.size());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 目的是 将 @c block_handle 添加到 @c index_block_builder_ 中，</span></span><br><span class="line">  <span class="comment">///        细节编码可以参考代码解释。</span></span><br><span class="line">  <span class="comment">/// @param last_key_in_current_block 会变成存储 @c block_handle 对应的key</span></span><br><span class="line">  <span class="comment">/// @param first_key_in_next_block 指示当前 block 是否是最后一个block</span></span><br><span class="line">  <span class="comment">/// @param block_handle</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddIndexEntry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* last_key_in_current_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复用基类的 ::Finish 函数</span></span><br><span class="line">  <span class="keyword">using</span> IndexBuilder::Finish;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 将当前使用 @c AddIndexEntry 添加block handle, @c index_blocks 中</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> BlockHandle&amp; <span class="comment">/*last_partition_block_handle*/</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">IndexSize</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> index_size_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">seperator_is_key_plus_seq</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seperator_is_key_plus_seq_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionedIndexBuilder</span>;</span> <span class="comment">// 友元，侵入式设计</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  BlockBuilder index_block_builder_;              <span class="comment">// 存储添加的数据</span></span><br><span class="line">  BlockBuilder index_block_builder_without_seq_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> use_value_delta_encoding_;</span><br><span class="line">  <span class="keyword">bool</span> seperator_is_key_plus_seq_;                <span class="comment">// 如果可以为 false，则能节省内存</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> include_first_key_;</span><br><span class="line">  BlockBasedTableOptions::IndexShorteningMode shortening_mode_;</span><br><span class="line">  BlockHandle last_encoded_handle_ = BlockHandle::NullBlockHandle(); <span class="comment">// 记录最后添加的 block</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> current_block_first_internal_key_; <span class="comment">// 当前block的第一个key</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>ShortenedIndexBuilder</code>中有个成员变量<code>seperator_is_key_plus_seq_</code>，这是为进一步压缩存储空间。</p><p>在前面，我们知道一个<code>internalkey</code>是由<code>&#123;userkey, seq, type&#125;</code>三部分组成，如果可以仅由<code>userkey</code>便能分辨不同的<code>internalkey</code>，那么就没必要加上<code>&#123;seq, type&#125;</code>，自然就可以进一步减少内存消耗。</p><p>因此，存在两个成员变量<code>index_block_builder_</code>、<code>index_block_builder_without_seq_</code>。</p><p>下面我们来看看<code>AddIndexEntry</code> 函数是如何处理的。</p><h3 id="AddIndexEntry"><a href="#AddIndexEntry" class="headerlink" title="AddIndexEntry"></a>AddIndexEntry</h3><p><code>last_key_in_urrent_block</code> 是个输入输出参数，最终存储的<code>&#123;k, v&#125;</code>中<code>k</code>会记录在<code>last_key_in_current_block</code>中。</p><p>整个过程如下：</p><h4 id="1-计算待存储的-key"><a href="#1-计算待存储的-key" class="headerlink" title="1. 计算待存储的 key"></a>1. 计算待存储的 <code>key</code></h4><p>对于非最后一个block，则 <code>first_key_in_next_block</code> 不为 <code>nullptr</code>。</p><p>对于压缩模式<code>shortening_mode_</code>有三种选择：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">IndexShorteningMode</span> :</span> <span class="keyword">char</span> &#123;</span><br><span class="line">   kNoShortening,</span><br><span class="line">   kShortenSeparators,   </span><br><span class="line">   kShortenSeparatorsAndSuccessor,</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>只要不是<code>kNoShortening</code>，都会选择一个<code>[last_key_in_current_block, first_key_in_next_block)</code>区间最短的字符串来当做即将存储的<code>key</code>，而这个<code>key</code>也会记录在<code>last_key_in_current_block</code> 中。</p><p>注意，上面寻找<code>key</code>的区间是左闭右开。</p><p>如果<code>seperator_is_key_plus_seq_ == false</code>，即仅使用<code>key</code>的<code>userkey</code>、<code>first_key_in_next_block</code>的<code>userkey</code>来比较，发现二者相等，那么就需要将 <code>seperator_is_key_plus_seq_ = true</code>，来满足区间需求。</p><p>但是，如果当前blocks是最后一个，此时<code>first_key_in_next_block == nullptr</code>。</p><p>如果此时的<code>shortening_mode_ == IndexShorteningMode::kShortenSeparatorsAndSuccessor</code>，那么只需找出大于<code>last_key_in_current_block</code>的键，来来做带存储的<code>key</code>。</p><p>第一部分的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddIndexEntry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* last_key_in_current_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...1....</span></span><br><span class="line">   <span class="keyword">if</span> (first_key_in_next_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (shortening_mode_ !=</span><br><span class="line">         BlockBasedTableOptions::IndexShorteningMode::kNoShortening) &#123;</span><br><span class="line">       <span class="comment">// last_key_in_current_block 的值修改为 </span></span><br><span class="line">       <span class="comment">// [last_key_in_current_block, first_key_in_next_block] 区间的</span></span><br><span class="line">       comparator_-&gt;FindShortestSeparator(last_key_in_current_block,</span><br><span class="line">                                          *first_key_in_next_block);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 不用携带 seq_,则直接用 UserKey 进行比较</span></span><br><span class="line">     <span class="comment">// 此时，如果两个 UserKey 相等</span></span><br><span class="line">     <span class="comment">// 则说明，光靠 UserKEy 无法比较</span></span><br><span class="line">     <span class="keyword">if</span> (!seperator_is_key_plus_seq_ &amp;&amp;</span><br><span class="line">         comparator_-&gt;user_comparator()-&gt;Compare(</span><br><span class="line">             ExtractUserKey(*last_key_in_current_block),</span><br><span class="line">             ExtractUserKey(*first_key_in_next_block)) == <span class="number">0</span>) &#123;</span><br><span class="line">       seperator_is_key_plus_seq_ = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// first_key_in_next_block == nullptr</span></span><br><span class="line">     <span class="comment">// 即当前 block 即最后一个 block</span></span><br><span class="line">     <span class="keyword">if</span> (shortening_mode_ == BlockBasedTableOptions::IndexShorteningMode::</span><br><span class="line">                                 kShortenSeparatorsAndSuccessor) &#123;</span><br><span class="line">       <span class="comment">// 将 last_key_in_current_block 设置大于他的字符串</span></span><br><span class="line">       comparator_-&gt;FindShortSuccessor(last_key_in_current_block);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...next...</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-编码-block-handle"><a href="#2-编码-block-handle" class="headerlink" title="2. 编码 block_handle"></a>2. 编码 block_handle</h4><p>经过第一步，找出了待存储的<code>key</code>，即 <code>last_key_in_current_block</code>，它宛如一个分隔符，分开两个block：</p><ul><li><p>基于<code>block_handle</code>来构造<code>IndexValue</code>对象 <code>entry</code>，并将<code>entry</code>编码序列化到<code>encoded_entry</code>中。</p></li><li><p>如果<code>ShortenedIndexBuilder</code>支持<code>use_value_delta_encoding_</code>，并且当前待添加的block不是首个block，那么就可以改变<code>entry</code>的序列化方式，进一步压缩存储空间，如此就得到<code>delta_encoded_entry</code>；</p></li></ul><p>这一部分的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddIndexEntry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* last_key_in_current_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..续..</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">//!!! key</span></span><br><span class="line">   <span class="keyword">auto</span> sep = Slice(*last_key_in_current_block);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 要么 include_first_key_ 为false</span></span><br><span class="line">   <span class="comment">// 要么 include_first_key_ 为true，且 current_block_first_internal_key_ 不能为空</span></span><br><span class="line">   assert(!include_first_key_ || !current_block_first_internal_key_.empty());</span><br><span class="line">   <span class="comment">//!!! value</span></span><br><span class="line">   <span class="function">IndexValue <span class="title">entry</span><span class="params">(block_handle, current_block_first_internal_key_)</span></span>;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span> encoded_entry;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span> delta_encoded_entry;</span><br><span class="line">   <span class="comment">// 将 entry 的内容编码到 encoded_entry 中</span></span><br><span class="line">   <span class="comment">// 如果 include_first_key_ 为 true,</span></span><br><span class="line">   <span class="comment">// 则 encoded_entry 中的数据是 block_handle + current_block_first_internal_key_</span></span><br><span class="line">   entry.EncodeTo(&amp;encoded_entry, include_first_key_, <span class="literal">nullptr</span>);</span><br><span class="line">   <span class="keyword">if</span> (use_value_delta_encoding_ &amp;&amp; !last_encoded_handle_.IsNull()) &#123;</span><br><span class="line">     <span class="comment">// 此时 block 不是首个 block</span></span><br><span class="line">     <span class="comment">// 使用 delta eccoding 的方式</span></span><br><span class="line">     entry.EncodeTo(&amp;delta_encoded_entry, include_first_key_,</span><br><span class="line">                    &amp;last_encoded_handle_);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 此时 block 是首个 block 或者 use_value_delta_encoding_ 功能关闭了</span></span><br><span class="line">     <span class="comment">// BlockBuilder::Add() below won&#x27;t use delta-encoded slice.</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新最后添加的 handle</span></span><br><span class="line">   last_encoded_handle_ = block_handle;</span><br><span class="line">   <span class="function"><span class="keyword">const</span> Slice <span class="title">delta_encoded_entry_slice</span><span class="params">(delta_encoded_entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...next...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-添加-k-v"><a href="#3-添加-k-v" class="headerlink" title="3. 添加 {k, v}"></a>3. 添加 {k, v}</h4><p>到此，<code>key</code>已经获得，<code>value</code>也已经编码序列化完毕。</p><p>最后，根据``seperator_is_key_plus_seq_<code>选择将序列化结果存储到</code>index_block_builder_<code> 还是</code>index_block_builder_without_seq_` 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddIndexEntry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* last_key_in_current_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..续..</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果 use_value_delta_encoding_ 为 true,</span></span><br><span class="line">   <span class="comment">// 此时 delta_encoded_entry_slice 也不为空</span></span><br><span class="line">   <span class="comment">// 则 index_block_builder_ 也会使用进一步压缩value的存储空间</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 添加 &#123;k,v&#125;，即 &#123;sep, &#125; </span></span><br><span class="line">   index_block_builder_.Add(sep, encoded_entry, &amp;delta_encoded_entry_slice);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 不需要加上 seq</span></span><br><span class="line">   <span class="keyword">if</span> (!seperator_is_key_plus_seq_) &#123;</span><br><span class="line">     index_block_builder_without_seq_.Add(ExtractUserKey(sep), </span><br><span class="line">                                           encoded_entry,</span><br><span class="line">                                           &amp;delta_encoded_entry_slice);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 过了第一个key，就需要清除</span></span><br><span class="line">   current_block_first_internal_key_.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，一个<code>AddIndexEntry</code> 函数分析完毕，可以说是在尽可能的在压缩存储空间，关键的三个点：</p><ul><li><code>IndexShorteningMode</code>：用来确定待存储的<code>key</code>是否为最短；</li><li><code>seperator_is_key_plus_seq_</code>：存储key时，可以是否需要带上<code>&#123;seq, type&#125;；</code></li><li><code>use_value_delta_encoding_</code>：来确定是否需要进一步对<code>value</code> 进行<code>delta encoding</code>。</li></ul><p>下面，就来看看<code>::Finish</code> 函数。</p><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p><code>Finish</code>函数的语义很简单，就是将通过<code>AddIndexEntry</code> 添加的 <code>&#123;k, v&#125;</code>保存到<code>index_blocks-&gt;index_block_contents</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexBlocks</span> &#123;</span></span><br><span class="line">   Slice index_block_contents;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Slice&gt; meta_blocks;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/// @brief 将当前使用 @c AddIndexEntry 添加block handle, @c index_blocks 中</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> BlockHandle&amp; <span class="comment">/*last_partition_block_handle*/</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (seperator_is_key_plus_seq_) &#123;</span><br><span class="line">     index_blocks-&gt;index_block_contents = index_block_builder_.Finish();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     index_blocks-&gt;index_block_contents =</span><br><span class="line">         index_block_builder_without_seq_.Finish();</span><br><span class="line">   &#125;</span><br><span class="line">   index_size_ = index_blocks-&gt;index_block_contents.size();</span><br><span class="line">   <span class="keyword">return</span> Status::OK();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="HashIndexBuilder"><a href="#HashIndexBuilder" class="headerlink" title="HashIndexBuilder"></a>HashIndexBuilder</h2><p><code>HashIndexBuilder</code> 包含了了两部分：</p><ul><li><p>可用于二分查找的<code>primary index</code>，即类中的 <code>primary_index_builder_</code>;</p></li><li><p>用于构造二级hash index的metadata</p><p>这个metadata 由两部分 metablock 组成：</p><ul><li><code>prefix_block_</code>：这个 metablock 连续存储着前缀；</li><li><code>prefix_meta_block_</code>：这个metablock存储着<code>prefix_block_</code>的信息</li></ul></li></ul><p><font color=red> 两个之间的联系 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashIndexBuilder</span> :</span> <span class="keyword">public</span> IndexBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">HashIndexBuilder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> InternalKeyComparator* comparator,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> SliceTransform* hash_key_extractor,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> index_block_restart_interval, </span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> format_version,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="function"><span class="params">      BlockBasedTableOptions::IndexShorteningMode shortening_mode)</span></span></span><br><span class="line">      : IndexBuilder(comparator),</span><br><span class="line">        primary_index_builder_(comparator, </span><br><span class="line">                               index_block_restart_interval,</span><br><span class="line">                               format_version, </span><br><span class="line">                               use_value_delta_encoding,</span><br><span class="line">                               shortening_mode, </span><br><span class="line">                               <span class="literal">false</span> <span class="comment">/* include_first_key */</span>),</span><br><span class="line">        hash_key_extractor_(hash_key_extractor) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddIndexEntry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* last_key_in_current_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnKeyAdded</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> BlockHandle&amp; last_partition_block_handle)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">IndexSize</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> primary_index_builder_.IndexSize() </span><br><span class="line">       + prefix_block_.size() </span><br><span class="line">       + prefix_meta_block_.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">seperator_is_key_plus_seq</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> primary_index_builder_.seperator_is_key_plus_seq();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">FlushPendingPrefix</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ShortenedIndexBuilder primary_index_builder_;</span><br><span class="line">  <span class="keyword">const</span> SliceTransform* hash_key_extractor_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> prefix_block_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> prefix_meta_block_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> pending_block_num_ = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">uint32_t</span> pending_entry_index_ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> pending_entry_prefix_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint64_t</span> current_restart_index_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="AddIndexEntry-1"><a href="#AddIndexEntry-1" class="headerlink" title="AddIndexEntry"></a>AddIndexEntry</h3><p><code>HashIndexBuilder</code> 的 <code>restart interval == 1</code> ，因此每次调用<code>AddIndexEntry</code> 函数时 <code>++current_restart_index_</code>。</p><p>因此，<code>current_restart_index_</code> 可用于指示当前添加的<code>block</code>的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddIndexEntry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* last_key_in_current_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  ++current_restart_index_;</span><br><span class="line">  primary_index_builder_.AddIndexEntry(last_key_in_current_block,</span><br><span class="line">                                       first_key_in_next_block, </span><br><span class="line">                                       block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OnKeyAdded"><a href="#OnKeyAdded" class="headerlink" title="OnKeyAdded"></a>OnKeyAdded</h3><p><code>OnKeyAdded</code>函数，是个回调函数，即在每次添加 <code>key</code>的时候调用。</p><ul><li><p><code>pending_entry_prefix_</code>：是当前pending的前缀；</p><p>如果待加入的<code>key</code>的前缀 <code>key_prefix != pending_entry_prefix_</code>，则说明遇到新的前缀，那么就<code>pending_entry_prefix_</code> 要设置为新的前缀<code>key_prefix</code></p></li><li><p><code>pending_block_num_</code>：表征的是前缀是<code>pending_entry_prefix_</code>的key的数量；</p></li><li><p><code>pending_entry_index_</code>：当前<code>pending_entry_prefix_</code> 所属的<code>restart index</code>。</p><p>通过后面两个参数，就可以知道 <code>[pending_entry_index_, pending_entry_index_ + pending_block_num_)</code>范围内的key的前缀都是<code>pending_entry_prefix_</code>。</p></li></ul><p>此外，这里的<code>pending</code>的意思，还没有 <code>flush</code> 到 <code>prefix_block_</code> 和 <code>prefix_meta_block_</code> 中。</p><p>下面先来看看<code>onKeyAdd</code>函数的逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">OnKeyAdded</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> key_prefix = hash_key_extractor_-&gt;Transform(key);</span><br><span class="line">  <span class="comment">// 当前没有等待 flush 的 entry，那么此次添加的 key 就是 first_entry</span></span><br><span class="line">  <span class="keyword">bool</span> is_first_entry = pending_block_num_ == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_first_entry || pending_entry_prefix_ != key_prefix) &#123;</span><br><span class="line">    <span class="comment">// 如果是遇到新的前缀了，则 flush</span></span><br><span class="line">    <span class="keyword">if</span> (!is_first_entry) &#123;</span><br><span class="line">      FlushPendingPrefix();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 更新其他状态</span></span><br><span class="line">    pending_entry_prefix_ = key_prefix.ToString();</span><br><span class="line">    pending_block_num_ = <span class="number">1</span>;</span><br><span class="line">    pending_entry_index_ = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(current_restart_index_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/// 相同前缀，即 pending_entry_prefix_ == key_prefix</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> last_restart_index = pending_entry_index_ + pending_block_num_ - <span class="number">1</span>;</span><br><span class="line">    assert(last_restart_index &lt;= current_restart_index_);</span><br><span class="line">    <span class="keyword">if</span> (last_restart_index != current_restart_index_) &#123;</span><br><span class="line">      ++pending_block_num_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FlushPendingPrefix"><a href="#FlushPendingPrefix" class="headerlink" title="FlushPendingPrefix"></a>FlushPendingPrefix</h3><p>这里的 <code>flush</code>，即将 <code>pending_entry_prefix_</code> 及其元数据分别存储到<code>prefix_block_</code>、<code>prefix_meta_block_</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FlushPendingPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// prefix_block_ 添加 pending_entry_prefix_</span></span><br><span class="line">  prefix_block_.append(pending_entry_prefix_.data(),</span><br><span class="line">                       pending_entry_prefix_.size());</span><br><span class="line">  <span class="comment">// prefix_meta_block_ 存储前缀的元数据 </span></span><br><span class="line">  PutVarint32Varint32Varint32(</span><br><span class="line">      &amp;prefix_meta_block_,</span><br><span class="line">      <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(pending_entry_prefix_.size()), <span class="comment">// pending_entry_prefix_ 大小</span></span><br><span class="line">      pending_entry_index_, <span class="comment">// pending_entry_prefix_ 所属的 restart index</span></span><br><span class="line">      pending_block_num_);  <span class="comment">// 前缀 pending_entry_prefix_  的 key 数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish-1"><a href="#Finish-1" class="headerlink" title="Finish"></a>Finish</h3><p>当调用<code>::Finish</code> 函数时，就是为将之前添加的数据都序列化到 <code>index_blocks</code>中。此时有两部分需要序列化：</p><ul><li><code>primary index</code>： 即 <code>primary_index_builder_</code></li><li>元数据：即 <code>prefix_block_</code> 和 <code>prefix_meta_block_</code></li></ul><p>逻辑简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> BlockHandle&amp; last_partition_block_handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pending_block_num_ != <span class="number">0</span>) &#123;</span><br><span class="line">    FlushPendingPrefix();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先序列化已添加的数据</span></span><br><span class="line">  Status s = primary_index_builder_.Finish(index_blocks,</span><br><span class="line">                                           last_partition_block_handle);</span><br><span class="line">  <span class="comment">// 再添加元数据</span></span><br><span class="line">  index_blocks-&gt;meta_blocks.insert(</span><br><span class="line">      &#123;kHashIndexPrefixesBlock.c_str(), prefix_block_&#125;);</span><br><span class="line">  index_blocks-&gt;meta_blocks.insert(</span><br><span class="line">      &#123;kHashIndexPrefixesMetadataBlock.c_str(), prefix_meta_block_&#125;);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TopLevelIndex"><a href="#TopLevelIndex" class="headerlink" title="TopLevelIndex"></a>TopLevelIndex</h2><p>既然，已经有了上述两个<code>IndexBuilder</code>，那为啥还需要<code>PartitionedIndexBuilder</code>。</p><p>顾名思义，<code>Partition</code>，即分割的语义，由上面的源码分析可知，每次<code>IndexBuilder::Finish</code>函数都会将之前添加的<code>&#123;k, v&#125;</code>序列化并返回。那么反过来，当需要超找一个<code>key</code>时，是不是也要把之前的存储整个<code>IndexBuilder::Finish</code>返回的内容读取出来？</p><p>但是cache资源是有限的，你一次性把读取了太多数据，会导致其他cache中数据被挤出去。</p><p>因此，有了<code>PartitionedIndexBuilder</code>，即将一整个<code>Index</code> 分割为许多个。此时在硬盘的存储格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I I I I I I IP</span><br></pre></td></tr></table></figure><p>其中，<code>I</code> 是使用 <code>ShortenedIndexBuilder</code> 构建的 <code>partition index block</code>。<code>IP</code>，记录的是前面已构建的 <code>partitions</code>的元数据。</p><blockquote><p>  图？？？</p></blockquote><h2 id="PartitionedIndexBuilder"><a href="#PartitionedIndexBuilder" class="headerlink" title="PartitionedIndexBuilder"></a>PartitionedIndexBuilder</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionedIndexBuilder</span> :</span> <span class="keyword">public</span> IndexBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> PartitionedIndexBuilder* <span class="title">CreateIndexBuilder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> InternalKeyComparator* comparator,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> BlockBasedTableOptions&amp; table_opt)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PartitionedIndexBuilder</span><span class="params">(<span class="keyword">const</span> InternalKeyComparator* comparator,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> BlockBasedTableOptions&amp; table_opt,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">bool</span> use_value_delta_encoding)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~PartitionedIndexBuilder();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddIndexEntry</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* last_key_in_current_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> BlockHandle&amp; last_partition_block_handle)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">IndexSize</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> index_size_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">TopLevelIndexSize</span><span class="params">(<span class="keyword">uint64_t</span>)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> top_level_index_size_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">NumPartitions</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/// 用于 PartitionFilterBlock 中</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ShouldCutFilterBlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  <span class="comment">/// 用于 PartitionFilterBlock 中</span></span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">RequestPartitionCut</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">GetPartitionKey</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sub_index_last_key_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">seperator_is_key_plus_seq</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seperator_is_key_plus_seq_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">get_use_value_delta_encoding</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> use_value_delta_encoding_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">size_t</span> top_level_index_size_ = <span class="number">0</span>;<span class="comment">// Set after ::Finish is called</span></span><br><span class="line">  <span class="keyword">size_t</span> partition_cnt_ = <span class="number">0</span>;    <span class="comment">// Set after ::Finish is called</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成二级索引</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MakeNewSubIndexBuilder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Entry</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ShortenedIndexBuilder&gt; value; <span class="comment">// partition index</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;Entry&gt; entries_; </span><br><span class="line">  BlockBuilder index_block_builder_;              <span class="comment">// top-level index builder</span></span><br><span class="line">  BlockBuilder index_block_builder_without_seq_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// the active partition index builder</span></span><br><span class="line">  ShortenedIndexBuilder* sub_index_builder_;</span><br><span class="line">  <span class="comment">// the last key in the active partition index builder</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> sub_index_last_key_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FlushBlockPolicy&gt; flush_policy_;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">bool</span> finishing_indexes = <span class="literal">false</span>; <span class="comment">// Finish 函数已被调用但是尚未完成</span></span><br><span class="line">  <span class="keyword">const</span> BlockBasedTableOptions&amp; table_opt_;</span><br><span class="line">  <span class="keyword">bool</span> seperator_is_key_plus_seq_;</span><br><span class="line">  <span class="keyword">bool</span> use_value_delta_encoding_;</span><br><span class="line">  <span class="keyword">bool</span> partition_cut_requested_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">bool</span> cut_filter_block = <span class="literal">false</span>;</span><br><span class="line">  BlockHandle last_encoded_handle_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="AddIndexEntry-2"><a href="#AddIndexEntry-2" class="headerlink" title="AddIndexEntry"></a>AddIndexEntry</h3><p>在<code>PartitionedIndexBuilder</code>类中，有个内嵌类<code>PartitionedIndexBuilder::Entry</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">Entry</span> &#123;</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span> key;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ShortenedIndexBuilder&gt; value; <span class="comment">// partition index</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;Entry&gt; entries_; </span><br></pre></td></tr></table></figure><ul><li><code>key</code>字段，即<code>sub_index_last_key_</code>；</li><li><code>value</code>字段，指向的是即<code>sub_index_builder_</code>。</li></ul><p>因此，<code>entries_</code>的每一个元素都是一个<code>Partition</code>。<code>entries_</code> 有三种可能添加一个对象 <code>Entry(key, value)</code>：</p><ul><li>如果本次调用<code>AddIndexEntru</code>会导致<code>sub_index_builder_</code> 的大小超过了阈值，即<code>FlushBlockPolicy::Update</code> 返回true，那么就会将<code>&#123;sub_index_last_key_, sub_index_builder_&#125;</code> 添加到<code>entries_</code>，并重新将<code>sub_index_builder_ = nullptr</code>；</li><li>其他类，比如<code>PartitionFilterBlock</code>  发起请求；</li><li>这是最后一个block。如果添加的<code>block_handle</code>是最后一个，即 <code>first_key_in_next_block == nullptr</code>。</li></ul><p>下面，看代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartitionedIndexBuilder::AddIndexEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">string</span>* last_key_in_current_block,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> Slice* first_key_in_next_block, </span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> BlockHandle&amp; block_handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 最后一个blockhandle</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(first_key_in_next_block == <span class="literal">nullptr</span>)) &#123;  <span class="comment">// no more keys</span></span><br><span class="line">    <span class="keyword">if</span> (sub_index_builder_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      MakeNewSubIndexBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">    sub_index_builder_-&gt;AddIndexEntry(last_key_in_current_block,</span><br><span class="line">                                      first_key_in_next_block, </span><br><span class="line">                                      block_handle);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 sub_index_builder_-&gt;seperator_is_key_plus_seq_ 是 true</span></span><br><span class="line">    <span class="comment">// 而 seperator_is_key_plus_seq_ 是 false吗，两者不一致</span></span><br><span class="line">    <span class="comment">// 说明 sub_index_builder_ 的 seperator_is_key_plus_seq_ 发生了改变</span></span><br><span class="line">    <span class="comment">// 需要使得 sub_index_builder_ 的相应设置</span></span><br><span class="line">    <span class="keyword">if</span> (!seperator_is_key_plus_seq_ &amp;&amp;</span><br><span class="line">        sub_index_builder_-&gt;seperator_is_key_plus_seq_) &#123;</span><br><span class="line">      seperator_is_key_plus_seq_ = <span class="literal">true</span>;</span><br><span class="line">      flush_policy_.reset(FlushBlockBySizePolicyFactory::NewFlushBlockPolicy(</span><br><span class="line">          table_opt_.metadata_block_size, table_opt_.block_size_deviation,</span><br><span class="line">          sub_index_builder_-&gt;index_block_builder_));</span><br><span class="line">    &#125;</span><br><span class="line">    sub_index_last_key_ = <span class="built_in">std</span>::<span class="built_in">string</span>(*last_key_in_current_block);</span><br><span class="line">    entries_.push_back(</span><br><span class="line">        &#123;sub_index_last_key_,</span><br><span class="line">         <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ShortenedIndexBuilder&gt;(sub_index_builder_)&#125;);</span><br><span class="line">    sub_index_builder_ = <span class="literal">nullptr</span>;</span><br><span class="line">    cut_filter_block = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">    <span class="keyword">if</span> (sub_index_builder_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断添加 block_handle 之后是否需要刷新</span></span><br><span class="line">      <span class="comment">// 如果需要，在添加之前就先flush</span></span><br><span class="line"></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">      block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">      <span class="comment">// 判断是否需要 flush</span></span><br><span class="line">      <span class="keyword">bool</span> do_flush =</span><br><span class="line">          partition_cut_requested_ ||</span><br><span class="line">          flush_policy_-&gt;Update(*last_key_in_current_block, handle_encoding);</span><br><span class="line">      <span class="comment">// 需要刷新，则将之前的未 flush 的数据都存储到 entries_ 中</span></span><br><span class="line">      <span class="keyword">if</span> (do_flush) &#123;</span><br><span class="line">        entries_.push_back(</span><br><span class="line">            &#123;sub_index_last_key_,</span><br><span class="line">             <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ShortenedIndexBuilder&gt;(sub_index_builder_)&#125;);</span><br><span class="line">        cut_filter_block = <span class="literal">true</span>;</span><br><span class="line">        sub_index_builder_ = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sub_index_builder_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      MakeNewSubIndexBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑添加本次的数据 : block_handle</span></span><br><span class="line">    sub_index_builder_-&gt;AddIndexEntry(last_key_in_current_block,</span><br><span class="line">                                      first_key_in_next_block, </span><br><span class="line">                                      block_handle);</span><br><span class="line"></span><br><span class="line">    sub_index_last_key_ = <span class="built_in">std</span>::<span class="built_in">string</span>(*last_key_in_current_block);</span><br><span class="line">    <span class="keyword">if</span> (!seperator_is_key_plus_seq_ &amp;&amp;</span><br><span class="line">        sub_index_builder_-&gt;seperator_is_key_plus_seq_) &#123;</span><br><span class="line">      <span class="comment">// then we need to apply it to all sub-index builders and reset</span></span><br><span class="line">      <span class="comment">// flush_policy to point to Block Builder of sub_index_builder_ that store</span></span><br><span class="line">      <span class="comment">// internal keys.</span></span><br><span class="line">      seperator_is_key_plus_seq_ = <span class="literal">true</span>;</span><br><span class="line">      flush_policy_.reset(FlushBlockBySizePolicyFactory::NewFlushBlockPolicy(</span><br><span class="line">          table_opt_.metadata_block_size, table_opt_.block_size_deviation,</span><br><span class="line">          sub_index_builder_-&gt;index_block_builder_));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish-2"><a href="#Finish-2" class="headerlink" title="Finish"></a>Finish</h3><p>在<code>Partition</code>模式下，<code>Finish</code>函数的流程如下：</p><ul><li>每次调用<code>PartitionedIndexBuilder::Finish</code> 函数，会按照<code>FIFO</code>的原则，从<code>entries_</code>中弹出一个<code>sub_index_builder_</code>，并将其内容序列化到<code>index_blocks-&gt;index_block_contents</code> 中；</li><li>上层（即<code>TableBuilder</code>）会把<code>index_blocks</code>的内容存储到<code>SST</code>文件中，并把存储的位置和数据大小记录在 <code>last_partition_block_handle</code>中；</li><li>等下一次调用 <code>PartitionedIndexBuilder::Finish</code> 时，会把<code>last_partition_block_handle</code>序列化到<code>index_block_builder_</code>中</li><li>等 <code>PartitionedIndexBuilder::Finish</code> 函数返回<code>Status::OK()</code>，说明<code>entries_</code> 中的数据已全部存储到SST中。但是，此时<code>index_blocks</code> 中记录的是之前所有<code>sub_index_builer</code>的信息，即在SST中的存储位置和大小。</li></ul><p>也就是说，<code>PartitionedIndexBuilder</code>在SST文件中存储的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">partition_index_block_1</span><br><span class="line">...</span><br><span class="line">partition_index_block_N</span><br><span class="line">TopLevelIndexBlock</span><br></pre></td></tr></table></figure><p>下面，顺着注释来看看源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PartitionedIndexBuilder::Finish</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IndexBlocks* index_blocks, <span class="keyword">const</span> BlockHandle&amp; last_partition_block_handle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (partition_cnt_ == <span class="number">0</span>) &#123;</span><br><span class="line">    partition_cnt_ = entries_.size();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最后一个block已经被添加了</span></span><br><span class="line">  assert(sub_index_builder_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 重复调用 Finish 函数</span></span><br><span class="line">  <span class="keyword">if</span> (finishing_indexes == <span class="literal">true</span>) &#123;</span><br><span class="line">    Entry&amp; last_entry = entries_.front();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    last_partition_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_delta_encoding;</span><br><span class="line">    <span class="comment">// delta 编码</span></span><br><span class="line">    PutVarsignedint64(</span><br><span class="line">        &amp;handle_delta_encoding,</span><br><span class="line">        last_partition_block_handle.size() - last_encoded_handle_.size());</span><br><span class="line">    last_encoded_handle_ = last_partition_block_handle;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Slice <span class="title">handle_delta_encoding_slice</span><span class="params">(handle_delta_encoding)</span></span>;</span><br><span class="line">    <span class="comment">// 记录 &#123;key, last_partition_block_handle&#125;</span></span><br><span class="line">    index_block_builder_.Add(last_entry.key, </span><br><span class="line">                              handle_encoding,</span><br><span class="line">                             &amp;handle_delta_encoding_slice);</span><br><span class="line">    <span class="keyword">if</span> (!seperator_is_key_plus_seq_) &#123;</span><br><span class="line">      index_block_builder_without_seq_.Add(ExtractUserKey(last_entry.key),</span><br><span class="line">                                           handle_encoding,</span><br><span class="line">                                           &amp;handle_delta_encoding_slice);</span><br><span class="line">    &#125;</span><br><span class="line">    entries_.pop_front();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If there is no sub_index left, then return the 2nd level index.</span></span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(entries_.empty())) &#123;</span><br><span class="line">    <span class="comment">// 这里的 index_block 获得的才是 </span></span><br><span class="line">    <span class="keyword">if</span> (seperator_is_key_plus_seq_) &#123;</span><br><span class="line">      index_blocks-&gt;index_block_contents = index_block_builder_.Finish();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index_blocks-&gt;index_block_contents =</span><br><span class="line">          index_block_builder_without_seq_.Finish();</span><br><span class="line">    &#125;</span><br><span class="line">    top_level_index_size_ = index_blocks-&gt;index_block_contents.size();</span><br><span class="line">    index_size_ += top_level_index_size_;</span><br><span class="line">    <span class="keyword">return</span> Status::OK();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Finish the next partition index in line and Incomplete() to indicate we</span></span><br><span class="line">    <span class="comment">// expect more calls to Finish</span></span><br><span class="line">    Entry&amp; entry = entries_.front();</span><br><span class="line">    <span class="comment">// Apply the policy to all sub-indexes</span></span><br><span class="line">    entry.value-&gt;seperator_is_key_plus_seq_ = seperator_is_key_plus_seq_;</span><br><span class="line">    <span class="comment">// 这里为了获得当前block的内容</span></span><br><span class="line">    <span class="comment">// 并将其返回，返回的只是一个 partition</span></span><br><span class="line">    <span class="keyword">auto</span> s = entry.value-&gt;Finish(index_blocks);</span><br><span class="line">    index_size_ += index_blocks-&gt;index_block_contents.size();</span><br><span class="line">    finishing_indexes = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> s.ok() ? Status::Incomplete() : s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IndexBuilder&quot;&gt;&lt;a href=&quot;#IndexBuilder&quot; class=&quot;headerlink&quot; title=&quot;IndexBuilder&quot;&gt;&lt;/a&gt;IndexBuilder&lt;/h2&gt;&lt;p&gt;&lt;code&gt;IndexBuilder&lt;/code&gt; 是个基类</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>FilterBlock 源码分析</title>
    <link href="https://szza.github.io/2021/11/26/RocksDB/Table/builder/3_FilterBlock/"/>
    <id>https://szza.github.io/2021/11/26/RocksDB/Table/builder/3_FilterBlock/</id>
    <published>2021-11-26T06:15:35.000Z</published>
    <updated>2023-07-31T14:34:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rocksdb,为了加速查询，基于bloom filter 设计了Filter。</p><h2 id="FilterBlockBuilder"><a href="#FilterBlockBuilder" class="headerlink" title="FilterBlockBuilder"></a>FilterBlockBuilder</h2><p><code>FilterBlockBuilder</code> 是个基类，用于为特定的<code>table</code>构建filter，调用<code>::Finish</code>函数后会以字符串形式返回生成filter。它也有三个子类：</p><ul><li><code>BlockBasedFilterBlockBuilder</code></li><li><code>FullFilterBlockBuilder</code></li><li><code>PartitionedFilterBlockBuilder</code></li></ul><p><code>FilterBlockBuilder</code> 的成员函数的调用顺序，要符合正则表达式： <code>(StartBlock Add*)* Finish</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilterBlockBuilder</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FilterBlockBuilder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~FilterBlockBuilder() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  FilterBlockBuilder(<span class="keyword">const</span> FilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> FilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsBlockBased</span><span class="params">()</span> </span>= <span class="number">0</span>;                     <span class="comment">// If is blockbased filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span> </span>= <span class="number">0</span>;  <span class="comment">// Start new block filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key_without_ts)</span> </span>= <span class="number">0</span>;   <span class="comment">// Add a key to current filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;                    <span class="comment">// Empty == none added</span></span><br><span class="line">  <span class="comment">/// For reporting stats on how many entries the builder considered unique</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/// Generate Filter</span></span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> BlockHandle empty_handle;</span><br><span class="line">    Status dont_care_status;</span><br><span class="line">    <span class="keyword">auto</span> ret = Finish(empty_handle, &amp;dont_care_status);</span><br><span class="line">    assert(dont_care_status.ok());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="keyword">const</span> BlockHandle&amp; tmp, Status* status)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="BlockBasedFilterBlockBuilder"><a href="#BlockBasedFilterBlockBuilder" class="headerlink" title="BlockBasedFilterBlockBuilder"></a>BlockBasedFilterBlockBuilder</h2><p><code>BlockBasedFilterBlockBuilder</code> 调用<code>::Finish</code>函数最后生成的字符串数据格式，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filter_1</span><br><span class="line">filter_2</span><br><span class="line">...</span><br><span class="line">filter_N</span><br><span class="line">...</span><br><span class="line">filter_1_offset</span><br><span class="line">filter_2_offset</span><br><span class="line">...</span><br><span class="line">filter_N_offset</span><br></pre></td></tr></table></figure><p>下面先大致看下结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockBasedFilterBlockBuilder</span> :</span> <span class="keyword">public</span> FilterBlockBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BlockBasedFilterBlockBuilder(<span class="keyword">const</span> SliceTransform* prefix_extractor,</span><br><span class="line">                               <span class="keyword">const</span> BlockBasedTableOptions&amp; table_opt);</span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  BlockBasedFilterBlockBuilder(<span class="keyword">const</span> BlockBasedFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> BlockBasedFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsBlockBased</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key_without_ts)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start_.empty() &amp;&amp; filter_offsets_.empty();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> filter_bits_builder_-&gt;EstimateEntriesAdded();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="keyword">const</span> BlockHandle&amp; tmp, Status* status)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="keyword">using</span> FilterBlockBuilder::Finish;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddPrefix</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">GenerateFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> FilterPolicy* policy_;</span><br><span class="line">  <span class="keyword">const</span> SliceTransform* prefix_extractor_;</span><br><span class="line">  <span class="keyword">bool</span> whole_key_filtering_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> prev_prefix_start_;      <span class="comment">// 上次添加到 entries_ 中的 key_prefix 的起始地址</span></span><br><span class="line">  <span class="keyword">size_t</span> prev_prefix_size_;       <span class="comment">// 该 key_prefix 的大小</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> entries_;        <span class="comment">// 将所有的key打平后存储在 entries 中</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; start_;  <span class="comment">// 每个entry的的索引存储在 start_</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> result_;              <span class="comment">// Filter data computed so far</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Slice&gt; tmp_entries_;  <span class="comment">// policy_-&gt;CreateFilter() argument</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint32_t</span>&gt; filter_offsets_;</span><br><span class="line">  <span class="keyword">uint64_t</span> total_added_in_built_;  <span class="comment">// Total keys added to filters built so far</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p><code>BlockBasedFilterBlockBuilder</code> 在添加<code>key</code>时：</p><ul><li>如果能提取出待添加<code>key</code>的前缀，则会添加前缀</li><li>如果 <code>whole_key_filtering_  == true</code> ，则也会添加整个<code>key</code></li></ul><p>源码简单如斯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedFilterBlockBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key_without_ts)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是能提取出 key_without_ts 的前缀，则添加前缀</span></span><br><span class="line">  <span class="keyword">if</span> (prefix_extractor_ &amp;&amp; prefix_extractor_-&gt;InDomain(key_without_ts)) &#123;</span><br><span class="line">    AddPrefix(key_without_ts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否添加添加整个 key</span></span><br><span class="line">  <span class="keyword">if</span> (whole_key_filtering_) &#123;</span><br><span class="line">    AddKey(key_without_ts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddKey"><a href="#AddKey" class="headerlink" title="AddKey"></a>AddKey</h4><p>在 <code>BlockBasedFilterBlockBuilder</code> 中，<code>entries_</code> 用于存储每次添加的<code>key</code>，<code>start_</code> 存储这个<code>key</code>在<code>entries_</code>中偏移量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BlockBasedFilterBlockBuilder::AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  start_.push_back(entries_.size()); <span class="comment">// entries_.size() 即下一个 key 在 entries_ 中的起始偏移量</span></span><br><span class="line">  entries_.append(key.data(), key.size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddPrefix"><a href="#AddPrefix" class="headerlink" title="AddPrefix"></a>AddPrefix</h4><p>非首次添加前缀时，都会先获得上一次添加key的前缀如果本次与上次不同，才添加本次key的前缀。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BlockBasedFilterBlockBuilder::AddPrefix</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  Slice prev;</span><br><span class="line">  <span class="keyword">if</span> (prev_prefix_size_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 上一个添加的 key 的前缀</span></span><br><span class="line">    prev = Slice(entries_.data() + prev_prefix_start_, prev_prefix_size_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本次添加的key的前缀</span></span><br><span class="line">  Slice prefix = prefix_extractor_-&gt;Transform(key);</span><br><span class="line">  <span class="comment">// 如果当前前缀 prefix 和之前的 prev 不同，则插入</span></span><br><span class="line">  <span class="keyword">if</span> (prev.size() == <span class="number">0</span> || prefix != prev) &#123;</span><br><span class="line">    prev_prefix_start_ = entries_.size();<span class="comment">// 待插入的 key 在entries_中的起始地址</span></span><br><span class="line">    prev_prefix_size_ = prefix.size();    <span class="comment">// 待插入的key的前缀</span></span><br><span class="line">    AddKey(prefix);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StartBlock"><a href="#StartBlock" class="headerlink" title="StartBlock"></a>StartBlock</h3><p><code>StartBlock</code> 函数用于构建<code>filter block</code>。</p><p><code>BlockBasedFilterBlockBuilder</code> 是每 2kb的数据创建一个<code>filter block</code>，传入的参数<code>block_offset</code>是表示最终生成的<code>filter block</code> 在<code>result_</code>中的偏移量。</p><p>而 <code>filter_offsets_</code>中记录的是已有<code>filter block</code> 在<code>result_</code> 中的偏移量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kFilterBaseLg = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">size_t</span> kFilterBase = <span class="number">1</span> &lt;&lt; kFilterBaseLg; <span class="comment">// 2kb</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedFilterBlockBuilder::StartBlock</span><span class="params">(<span class="keyword">uint64_t</span> block_offset)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint64_t</span> filter_index = (block_offset / kFilterBase);</span><br><span class="line">  assert(filter_index &gt;= filter_offsets_.size());</span><br><span class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.size()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GenerateFilter"><a href="#GenerateFilter" class="headerlink" title="GenerateFilter"></a>GenerateFilter</h3><p>每个<code>filter block</code>的数据都记录在<code>entries_</code> 和 <code>start_</code>，当调用 <code>GenerateFilter</code> 函数时就会将<code>entries_</code> 、 <code>start_</code>中的数据添加到<code>result_</code>中，而这个<code>filter block</code> 的起始地址记录在<code>filter_offsets_</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedFilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> num_entries = start_.size();</span><br><span class="line">  <span class="keyword">if</span> (num_entries == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果这个 filter block 没有key，直接存储上次生成的滤波器的起始地址</span></span><br><span class="line">    filter_offsets_.push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(result_.size()));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  total_added_in_built_ += num_entries;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为便于下面使用 start_[i + 1] - start_[i] 计算每个entry的长度</span></span><br><span class="line">  start_.push_back(entries_.size());     </span><br><span class="line">  tmp_entries_.resize(num_entries);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_entries; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* base = entries_.data() + start_[i]; <span class="comment">// 每个entry的起始地址</span></span><br><span class="line">    <span class="keyword">size_t</span> length = start_[i + <span class="number">1</span>] - start_[i];      <span class="comment">// 这个entry的长度</span></span><br><span class="line">    tmp_entries_[i] = Slice(base, length);          <span class="comment">// slice</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// filter_offsets_  中保存着每个 filter block 的起始地址，即 result.size()</span></span><br><span class="line">  filter_offsets_.push_back(<span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(result_.size()));</span><br><span class="line">  <span class="comment">// 基于 tmp_entries 的内容创建 filter，结果存储至 result_</span></span><br><span class="line">  policy_-&gt;CreateFilter(&amp;tmp_entries_[<span class="number">0</span>], </span><br><span class="line">                        <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(num_entries),</span><br><span class="line">                        &amp;result_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清零，为下个 filter block 准备</span></span><br><span class="line">  tmp_entries_.clear();</span><br><span class="line">  entries_.clear();</span><br><span class="line">  start_.clear();</span><br><span class="line">  prev_prefix_start_ = <span class="number">0</span>;</span><br><span class="line">  prev_prefix_size_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p>在调用<code>::Finish</code>函数时，需要<code>result_</code>向<code>result_</code>中写入三部分：</p><ul><li>每个<code>key</code>的偏移量<code>KEY_OFFSET</code></li><li><code>key</code>的数量<code>FILTER_BLOCK_NUM</code></li><li>结束标志 <code>kFilterBaseLg</code></li></ul><p>代码简单如此。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">BlockBasedFilterBlockBuilder::Finish</span><span class="params">(<span class="keyword">const</span> BlockHandle&amp; <span class="comment">/*tmp*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Status* status)</span> </span>&#123;</span><br><span class="line">  *status = Status::OK();</span><br><span class="line">  <span class="keyword">if</span> (!start_.empty()) &#123;</span><br><span class="line">    GenerateFilter();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint32_t</span> array_offset = <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(result_.size());</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.size(); i++) &#123;</span><br><span class="line">    <span class="comment">// 把每个 filter block 的偏移量添加到result</span></span><br><span class="line">    PutFixed32(&amp;result_, filter_offsets_[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 filter block 的数量</span></span><br><span class="line">  PutFixed32(&amp;result_, array_offset);</span><br><span class="line">  <span class="comment">// 结束标志位</span></span><br><span class="line">  result_.push_back(kFilterBaseLg);</span><br><span class="line">  <span class="keyword">return</span> Slice(result_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FullFilterBlockBuilder"><a href="#FullFilterBlockBuilder" class="headerlink" title="FullFilterBlockBuilder"></a>FullFilterBlockBuilder</h2><p>他就是将全部的的key都放在了一起、。</p><blockquote><p>TODO：设计点</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FullFilterBlockBuilder</span> :</span> <span class="keyword">public</span> FilterBlockBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FullFilterBlockBuilder</span><span class="params">(<span class="keyword">const</span> SliceTransform* prefix_extractor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">bool</span> whole_key_filtering,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  FilterBitsBuilder* filter_bits_builder)</span></span>;</span><br><span class="line">  FullFilterBlockBuilder(<span class="keyword">const</span> FullFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> FullFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~FullFilterBlockBuilder() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsBlockBased</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; <span class="comment">// 区分 BlockBasedFilterBlockBuilder</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StartBlock</span><span class="params">(<span class="keyword">uint64_t</span>)</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> !any_added_; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key_without_ts)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span> FilterBlockBuilder::Finish;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="keyword">const</span> BlockHandle&amp; tmp, Status* status)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddPrefix</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">const</span> SliceTransform* <span class="title">prefix_extractor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prefix_extractor_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">last_prefix_str</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> last_prefix_str_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FilterBitsBuilder&gt; filter_bits_builder_;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">const</span> SliceTransform* prefix_extractor_;<span class="comment">// 前缀提取器</span></span><br><span class="line">  <span class="keyword">bool</span> whole_key_filtering_;</span><br><span class="line">  <span class="keyword">bool</span> last_whole_key_recorded_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> last_whole_key_str_;</span><br><span class="line">  <span class="keyword">bool</span> last_prefix_recorded_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> last_prefix_str_;</span><br><span class="line">  <span class="keyword">bool</span> last_key_in_domain_;</span><br><span class="line">  <span class="keyword">bool</span> any_added_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>[]&gt; filter_data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Add-1"><a href="#Add-1" class="headerlink" title="Add"></a>Add</h3><ol><li>根据<code>whole_key_filtering_</code> 来确定是否添加整个<code>key_without_ts</code> </li><li>根据<code>add_prefix</code>，来看是否添加<code>key_without_ts</code>的前缀</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FullFilterBlockBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key_without_ts)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> add_prefix =</span><br><span class="line">      prefix_extractor_ &amp;&amp; prefix_extractor_-&gt;InDomain(key_without_ts);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!last_prefix_recorded_ &amp;&amp; last_key_in_domain_) &#123;</span><br><span class="line">    AddKey(last_prefix_str_);</span><br><span class="line">    last_prefix_recorded_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (whole_key_filtering_) &#123;</span><br><span class="line">    <span class="comment">// 如果没前缀，则直接添加key</span></span><br><span class="line">    <span class="keyword">if</span> (!add_prefix) &#123;</span><br><span class="line">      AddKey(key_without_ts);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 第一个 key or 遇到新的 key</span></span><br><span class="line">      Slice last_whole_key = Slice(last_whole_key_str_);</span><br><span class="line">      <span class="keyword">if</span> (!last_whole_key_recorded_ ||</span><br><span class="line">          last_whole_key.compare(key_without_ts) != <span class="number">0</span>) &#123;</span><br><span class="line">        AddKey(key_without_ts);</span><br><span class="line">        last_whole_key_recorded_ = <span class="literal">true</span>;</span><br><span class="line">        last_whole_key_str_.assign(key_without_ts.data(),</span><br><span class="line">                                   key_without_ts.size());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (add_prefix) &#123;</span><br><span class="line">    last_key_in_domain_ = <span class="literal">true</span>;</span><br><span class="line">    AddPrefix(key_without_ts);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    last_key_in_domain_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddKey-1"><a href="#AddKey-1" class="headerlink" title="AddKey"></a>AddKey</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FullFilterBlockBuilder::AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  filter_bits_builder_-&gt;AddKey(key);</span><br><span class="line">  any_added_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddPrefix-1"><a href="#AddPrefix-1" class="headerlink" title="AddPrefix"></a>AddPrefix</h4><ul><li><p><code>last_prefix_str_</code>：记录上一次添加的前缀</p></li><li><p>如果<code>whole_key_filtering_ == true</code>，那么，从<code>FullFilterBlockBuilder::Add</code>函数运行至<code>FullFilterBlockBuilder::AddPrefix</code> 函数结束，添加的数据是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key_without_ts</span><br><span class="line">prefix</span><br></pre></td></tr></table></figure><p>但是如果<code>prefix</code>和上一个添加的前缀相同，则忽略本次的前缀，最终添加的内容只有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_without_ts</span><br></pre></td></tr></table></figure></li><li><p>如果<code>whole_key_filtering_ == false</code>，添加的数据只有<code>prefix</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FullFilterBlockBuilder::AddPrefix</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  assert(prefix_extractor_ &amp;&amp; prefix_extractor_-&gt;InDomain(key));</span><br><span class="line">  Slice prefix = prefix_extractor_-&gt;Transform(key);</span><br><span class="line">  <span class="keyword">if</span> (whole_key_filtering_) &#123;</span><br><span class="line"> <span class="comment">// 前一个添加的前缀</span></span><br><span class="line">    Slice last_prefix = Slice(last_prefix_str_);  <span class="comment">// 前缀</span></span><br><span class="line">    <span class="comment">// 遇到新的前缀</span></span><br><span class="line">    <span class="keyword">if</span> (!last_prefix_recorded_ || last_prefix.compare(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录前缀</span></span><br><span class="line">      AddKey(prefix);</span><br><span class="line">      last_prefix_recorded_ = <span class="literal">true</span>; </span><br><span class="line">      last_prefix_str_.assign(prefix.data(), prefix.size());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 直接添加 prefix</span></span><br><span class="line">    AddKey(prefix);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Finish-1"><a href="#Finish-1" class="headerlink" title="Finish"></a>Finish</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FullFilterBlockBuilder::Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  last_whole_key_recorded_ = <span class="literal">false</span>;</span><br><span class="line">  last_prefix_recorded_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice <span class="title">FullFilterBlockBuilder::Finish</span><span class="params">(<span class="keyword">const</span> BlockHandle&amp; <span class="comment">/*tmp*/</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Status* status)</span> </span>&#123;</span><br><span class="line">  Reset();</span><br><span class="line">  <span class="comment">// In this impl we ignore BlockHandle</span></span><br><span class="line">  *status = Status::OK();</span><br><span class="line">  <span class="keyword">if</span> (any_added_) &#123;</span><br><span class="line">    any_added_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> filter_bits_builder_-&gt;Finish(&amp;filter_data_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Slice();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PartitionedFilterBlockBuilder"><a href="#PartitionedFilterBlockBuilder" class="headerlink" title="PartitionedFilterBlockBuilder"></a>PartitionedFilterBlockBuilder</h2><p>对应于 <code>PartitionedIndexBuilder</code>，rocksdb 现在是一个<code>partition filter block</code>  对应一个<code>partition index block</code>。</p><p>因此，每生成一个 <code>partition filter block</code> 也会请求  <code>PartitionedIndexBuilder</code> 生成一个 <code>partition index block</code>，来保证一一对应。</p><p>两种原理都差不多。</p><p>在<code>PartitionedFilterBlockBuilder</code>内部，也有个<code>FilterEntry</code>结构体，类似于<code>PartitionedIndexBuilder::Entry</code>，每个<code>value</code>都是一个<code>filter</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionedFilterBlockBuilder</span> :</span> <span class="keyword">public</span> FullFilterBlockBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PartitionedFilterBlockBuilder</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> SliceTransform* prefix_extractor, </span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">bool</span> whole_key_filtering,</span></span></span><br><span class="line"><span class="function"><span class="params">      FilterBitsBuilder* filter_bits_builder, </span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">int</span> index_block_restart_interval,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="function"><span class="params">      PartitionedIndexBuilder* <span class="keyword">const</span> p_index_builder,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">uint32_t</span> partition_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~PartitionedFilterBlockBuilder();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="keyword">const</span> BlockHandle&amp; last_partition_block_handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                       Status* status)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  BlockBuilder index_on_filter_block_builder_;  <span class="comment">// top-level index builder</span></span><br><span class="line">  BlockBuilder index_on_filter_block_builder_without_seq_;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">FilterEntry</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key;</span><br><span class="line">    Slice filter;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">list</span>&lt;FilterEntry&gt; filters;      <span class="comment">// list of partitioned indexes and their keys</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;IndexBuilder&gt; value; <span class="comment">// 可以存储 PartitionedIndexBuilder</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>[]&gt;&gt; filter_gc;</span><br><span class="line">  <span class="keyword">bool</span> finishing_filters = <span class="literal">false</span>;      <span class="comment">// 为true，表示正调用 Finish 函数，尚未返回 Status::OK()</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">MaybeCutAFilterBlock</span><span class="params">(<span class="keyword">const</span> Slice* next_key)</span></span>;</span><br><span class="line">  </span><br><span class="line">  PartitionedIndexBuilder* <span class="keyword">const</span> p_index_builder_;</span><br><span class="line">  <span class="keyword">uint32_t</span> keys_per_partition_;<span class="comment">// 每个 partition 中 key 的数量</span></span><br><span class="line">  <span class="keyword">uint32_t</span> keys_added_to_partition_;<span class="comment">// 最近一个partion添加的key的数量</span></span><br><span class="line">  <span class="keyword">uint64_t</span> total_added_in_built_;  <span class="comment">// 总共添加的key的数量</span></span><br><span class="line">  BlockHandle last_encoded_handle_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="MaybeCutAFilterBlock"><a href="#MaybeCutAFilterBlock" class="headerlink" title="MaybeCutAFilterBlock"></a>MaybeCutAFilterBlock</h3><p><code>MaybeCutAFilterBlock</code> 函数，用于判断当前是否需要生成一个<code>filter block</code>： <strong>当前 <code>partition</code>添加的key的数量 <code>keys_added_to_partition_</code> 已经到达阈值 <code>keys_per_partition_</code></strong> 。</p><p>由于<code>partition filter block</code> 和 <code>partition index block</code> 的数目是一一对应的。因此，需要请求 <code>PartitionedIndexBuilder</code> 对象 <code>p_index_builder_</code>  也生成一个<code>partition index block</code>。此外，生成的<code>partition idnex block</code>  和 <code>partition filter block</code> 对应的key是相同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PartitionedIndexBuilder</span>:</span>:Entry &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> key;  <span class="comment">// sub_index_last_key_;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ShortenedIndexBuilder&gt; value; <span class="comment">// partition index block</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PartitionedFilterBlockBuilderFilterEntry</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> key;<span class="comment">// sub_index_last_key_</span></span><br><span class="line">  Slice filter;    <span class="comment">// partition filter block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>MaybeCutAFilterBlock</code> 的函数分为三步：</p><ol><li>如果当前 <code>partition filter block</code>的<code>keys_added_to_partition_</code>已达到阈值，则请求对应的<code>partiiton index block</code>也创建完毕，否则就阻塞等待；</li><li>将待添加的<code>next_key</code>的前缀<code>next_key_prefix</code>添加到<code>partition filer block</code>；</li><li>生成<code>partition filter block</code>，并添加到<code>filters</code> 中。</li></ol><p>顺着源码更加详细地去理解这个过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartitionedFilterBlockBuilder::MaybeCutAFilterBlock</span><span class="params">(<span class="keyword">const</span> Slice* next_key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 parition 的 key 达到阈值</span></span><br><span class="line">  <span class="keyword">if</span> (keys_added_to_partition_ == keys_per_partition_) &#123;</span><br><span class="line">    <span class="comment">// 请求 p_index_builder_ 生成一个 partition</span></span><br><span class="line">    p_index_builder_-&gt;RequestPartitionCut();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!p_index_builder_-&gt;ShouldCutFilterBlock()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// p_index_builder_ 已生成一个 partition</span></span><br><span class="line"> </span><br><span class="line">  filter_gc.push_back(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span>[]&gt;(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否需要添加 next_key 的前缀</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> maybe_add_prefix =</span><br><span class="line">      next_key &amp;&amp; prefix_extractor() &amp;&amp; prefix_extractor()-&gt;InDomain(*next_key);</span><br><span class="line">  <span class="keyword">if</span> (maybe_add_prefix) &#123;</span><br><span class="line">    <span class="keyword">const</span> Slice next_key_prefix = prefix_extractor()-&gt;Transform(*next_key);</span><br><span class="line">    <span class="comment">// 与之前的前缀不同，则添加</span></span><br><span class="line">    <span class="keyword">if</span> (next_key_prefix.compare(last_prefix_str()) != <span class="number">0</span>) &#123;</span><br><span class="line">      AddKey(next_key_prefix);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  total_added_in_built_ += filter_bits_builder_-&gt;EstimateEntriesAdded();</span><br><span class="line">  <span class="comment">// 生成一个 filter block</span></span><br><span class="line">  Slice filter = filter_bits_builder_-&gt;Finish(&amp;filter_gc.back());</span><br><span class="line">  <span class="comment">// index_key 是 partition index block 存储的时的 key</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span>&amp; index_key = p_index_builder_-&gt;GetPartitionKey();</span><br><span class="line">  <span class="comment">// &#123;index_key, PartitionFilter&#125;</span></span><br><span class="line">  filters.push_back(&#123;index_key, filter&#125;);</span><br><span class="line">  <span class="comment">// 当前 partition 已添加的key数清零</span></span><br><span class="line">  keys_added_to_partition_ = <span class="number">0</span>;</span><br><span class="line">  Reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddKey-2"><a href="#AddKey-2" class="headerlink" title="AddKey"></a>AddKey</h4><p>添加 <code>key</code> 至当前<code>partition filter block</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartitionedFilterBlockBuilder::AddKey</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  FullFilterBlockBuilder::AddKey(key);</span><br><span class="line">  keys_added_to_partition_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Add-2"><a href="#Add-2" class="headerlink" title="Add"></a>Add</h3><p>由于<code>PartitionedFilterBlockBuilder</code> 继承自<code>FullFilterBlockBuilder</code>，唯一的区别就在于将一整个<code>Filter Block</code>，划分为多个<code>partitions</code>。</p><p>因此，在每次<code>Add</code>新的<code>key</code>，都先判断下是是否要需要生成新的<code>partition filter block</code>，然后将<code>key</code>添加到当前<code>partiton filter block</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PartitionedFilterBlockBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  MaybeCutAFilterBlock(&amp;key);</span><br><span class="line">  FullFilterBlockBuilder::Add(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish-2"><a href="#Finish-2" class="headerlink" title="Finish"></a>Finish</h3><p>类似于<code>PartitionIndexBuiler</code>, 这里要将<code>fiters</code> 中记录的<code>partitions</code> 都写入到SST中，并记录下每个<code>partition</code> 在SST中的偏移量offset，根据<code>partiton</code>的大小size和offset生成 <code>TopLevelIndex</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">PartitionedFilterBlockBuilder::Finish</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> BlockHandle&amp; last_partition_block_handle, </span></span></span><br><span class="line"><span class="function"><span class="params">    Status* status)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (finishing_filters == <span class="literal">true</span>) &#123;</span><br><span class="line">    FilterEntry&amp; last_entry = filters.front();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">    last_partition_block_handle.EncodeTo(&amp;handle_encoding);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> handle_delta_encoding;</span><br><span class="line">    PutVarsignedint64(</span><br><span class="line">        &amp;handle_delta_encoding,</span><br><span class="line">        last_partition_block_handle.size() - last_encoded_handle_.size());</span><br><span class="line">    last_encoded_handle_ = last_partition_block_handle;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> Slice <span class="title">handle_delta_encoding_slice</span><span class="params">(handle_delta_encoding)</span></span>;</span><br><span class="line">    index_on_filter_block_builder_.Add(last_entry.key,  <span class="comment">// key 相同</span></span><br><span class="line">                                       handle_encoding,   <span class="comment">// block_handle</span></span><br><span class="line">                                       &amp;handle_delta_encoding_slice);</span><br><span class="line">    <span class="keyword">if</span> (!p_index_builder_-&gt;seperator_is_key_plus_seq()) &#123;</span><br><span class="line">      index_on_filter_block_builder_without_seq_.Add(</span><br><span class="line">          ExtractUserKey(last_entry.key), handle_encoding,</span><br><span class="line">          &amp;handle_delta_encoding_slice);</span><br><span class="line">    &#125;</span><br><span class="line">    filters.pop_front();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次调用 ::Finish 函数，此时没有 next_key，</span></span><br><span class="line">    <span class="comment">// 仅仅是为了生成最后一个 partition fiter block</span></span><br><span class="line">    MaybeCutAFilterBlock(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (UNLIKELY(filters.empty())) &#123;</span><br><span class="line">    *status = Status::OK();</span><br><span class="line">    <span class="keyword">if</span> (finishing_filters) &#123;</span><br><span class="line">       <span class="comment">/// 最后一次调用 ::Finish</span></span><br><span class="line">      total_added_in_built_ = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 返回partitions的元信息</span></span><br><span class="line">      <span class="keyword">if</span> (p_index_builder_-&gt;seperator_is_key_plus_seq()) &#123;</span><br><span class="line">        <span class="keyword">return</span> index_on_filter_block_builder_.Finish();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index_on_filter_block_builder_without_seq_.Finish();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This is the rare case where no key was added to the filter</span></span><br><span class="line">      <span class="keyword">return</span> Slice();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回当前 partition 的信息</span></span><br><span class="line">    *status = Status::Incomplete();</span><br><span class="line">    finishing_filters = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> filters.front().filter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Rocksdb,为了加速查询，基于bloom filter 设计了Filter。&lt;/p&gt;
&lt;h2 id=&quot;FilterBlockBuilder&quot;&gt;&lt;a href=&quot;#FilterBlockBuilder&quot; class=&quot;headerlink&quot; title=&quot;FilterBl</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>BlockBasedTableBuilder 源码分析</title>
    <link href="https://szza.github.io/2021/11/26/RocksDB/Table/builder/4_BlockBaseTableBuilder/"/>
    <id>https://szza.github.io/2021/11/26/RocksDB/Table/builder/4_BlockBaseTableBuilder/</id>
    <published>2021-11-26T06:15:35.000Z</published>
    <updated>2023-07-31T14:34:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BlockBasedTableBuilder-ParallelCompressionRep"><a href="#BlockBasedTableBuilder-ParallelCompressionRep" class="headerlink" title="BlockBasedTableBuilder::ParallelCompressionRep"></a>BlockBasedTableBuilder::ParallelCompressionRep</h2><p>先来看看<code>BlockBasedTableBuilder</code>中的多线程压缩部分 <code> BlockBasedTableBuilder::ParallelCompressionRep</code>。</p><p>以下代码不加说明，都是在类 <code>BlockBasedTableBuilder::ParallelCompressionRep</code> 里面。</p><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p>在 <code>class ParallelCompressionRep</code> 中，有个<code>class Keys</code>，这是一个为了提高内存利用率的类。涉及点：</p><ul><li>预分配 <code>kKeysInitSize</code>个元素的内存：若向<code>Keys</code>中添加的元素个数小于 <code>kKeysInitSize</code>，则使用可以使用预分配的内存，避免了动态内存分配；</li><li>每次<code>Keys::Clear()</code>的时候，并不是真的释放了之前的内存，仅仅是调整了计数器<code>size_</code>，即常见的『惰性删除』。</li></ul><p>这是常见而有效的设计，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Keys</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   Keys() : keys_(kKeysInitSize), size_(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(<span class="keyword">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (size_ == keys_.size()) &#123;</span><br><span class="line">       <span class="comment">// 说明 keys_的元素个数超过预分配</span></span><br><span class="line">       keys_.emplace_back(key.data(), key.size());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 使用预分配内存</span></span><br><span class="line">       keys_[size_].assign(key.data(), key.size());</span><br><span class="line">     &#125;</span><br><span class="line">     size_++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">SwapAssign</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&amp; keys)</span> </span>&#123;</span><br><span class="line">     size_ = keys.size();</span><br><span class="line">     <span class="built_in">std</span>::swap(keys_, keys);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 惰性删除</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123; size_ = <span class="number">0</span>; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">   <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="title">Back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> keys_[size_ - <span class="number">1</span>]; &#125;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> idx) &#123;</span><br><span class="line">     assert(idx &lt; size_);</span><br><span class="line">     <span class="keyword">return</span> keys_[idx];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">size_t</span> kKeysInitSize = <span class="number">32</span>;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; keys_;</span><br><span class="line">   <span class="keyword">size_t</span> size_;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Keys&gt; curr_block_keys;</span><br></pre></td></tr></table></figure><h3 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h3><p>在继续讲解之前，先讲解下Rocksdb保证多线程安全的队列。</p><p>在rocksdb中，是怎么保证多线程压缩的顺序性呢，依赖<code>WorkQueue</code>，<code>WorkQueue</code>其实就是个很简单的『生产-消费』多线程模型：写线程和多线程之间共享一个任务队列 <code>queue_</code>，以及保护这个共享队列<code>queue_</code>的互斥锁<code>mutex_</code>。</p><p><code>WorkQueue</code>在<code>::Finish</code>函数之后，就不可用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkQueue</span> &#123;</span></span><br><span class="line">  <span class="built_in">std</span>::mutex mutex_;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable readerCv_;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable writerCv_;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable finishCv_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; queue_;</span><br><span class="line">  <span class="keyword">bool</span> done_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> maxSize_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 必须在锁中调用这个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue_.size() &gt;= maxSize_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  WorkQueue(<span class="built_in">std</span>::<span class="keyword">size_t</span> maxSize = <span class="number">0</span>) : done_(<span class="literal">false</span>), maxSize_(maxSize) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(U&amp;&amp; item)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">waitUntilFinished</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 更改 queue_ 大小</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setMaxSize</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> maxSize)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">      maxSize_ = maxSize;</span><br><span class="line">     &#125;</span><br><span class="line">    writerCv_.notify_all();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p><code>push</code> 函数，向共享队列<code>queue_</code> 中添加一个任务，成功则返回true。如果已经调用了<code>::Finish</code> 函数，则返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">WorkQueue::push</span><span class="params">(U&amp;&amp; item)</span> </span>&#123;</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// 等待 queue_ 队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (full() &amp;&amp; !done_) &#123;</span><br><span class="line">      writerCv_.wait(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果调用了 Finish 函数</span></span><br><span class="line">    <span class="comment">// 则不再接受新的元素</span></span><br><span class="line">    <span class="keyword">if</span> (done_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加新的元素</span></span><br><span class="line">    queue_.push(<span class="built_in">std</span>::forward&lt;U&gt;(item));</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 通知读线程</span></span><br><span class="line">  readerCv_.notify_one();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p><code>pop</code>函数，按照FIFO规则从共享任务队列 <code>queue_</code> 中弹出一个待处理任务，并返回true。</p><p>如果已经调用了<code>::Finish</code> 函数，则返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"> <span class="function"><span class="keyword">bool</span> <span class="title">WorkQueue::pop</span><span class="params">(T&amp; item)</span> </span>&#123;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">// 等写线程添加元素</span></span><br><span class="line">     <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">     <span class="keyword">while</span> (queue_.empty() &amp;&amp; !done_) &#123;</span><br><span class="line">       readerCv_.wait(lock);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 如果已经调用了 ::Finish 函数</span></span><br><span class="line">     <span class="comment">// 则不再处理</span></span><br><span class="line">     <span class="keyword">if</span> (queue_.empty()) &#123;</span><br><span class="line">       assert(done_);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 弹出</span></span><br><span class="line">     item = queue_.front();</span><br><span class="line">     queue_.pop();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 通知写线程</span></span><br><span class="line">   writerCv_.notify_one();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="waitUntilFinished"><a href="#waitUntilFinished" class="headerlink" title="waitUntilFinished"></a>waitUntilFinished</h4><p><code>waitUntilFinished</code> 函数，用于阻塞等待 <code>WorkQueue::Finish</code> 函数调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitUntilFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (!done_) &#123;</span><br><span class="line">    finishCv_.wait(lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h4><p><code>::Finish</code> 函数调用后，<code>WorkQueue</code> 不再处理接受新的元素，也不再弹出旧的元素，<code>waitUntilFinished</code> 函数就能返回了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkQueue::finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    assert(!done_);</span><br><span class="line">    done_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  readerCv_.notify_all();</span><br><span class="line">  writerCv_.notify_all();</span><br><span class="line">  finishCv_.notify_all();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BlockRepSlot"><a href="#BlockRepSlot" class="headerlink" title="BlockRepSlot"></a>BlockRepSlot</h3><p><code>BlockRepSlot</code> 是基于<code>WorkQueue</code>实现的线程安全队列。</p><p>每个节点<code>BlockRep*</code>记录一个block的相关数据及其状态，那么就可以由写线程将<code>BlockRep</code>节点加入到<code>BlockRepSlot</code>中，压缩等工作线程从<code>BlockRepSlot</code>中通过<code>take</code>函数取出<code>BlockRep</code>节点，对其进行压缩等操作。</p><p>如此，就能完成多线程操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// BlockRep 记录一个 block 的数据及其相关信息</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">BlockRep</span> &#123;</span></span><br><span class="line">   Slice contents;                      <span class="comment">// 原始内容</span></span><br><span class="line">   Slice compressed_contents;                     <span class="comment">// 压缩内容</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; data;             <span class="comment">// 原始内容， 与 contents 区别</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; compressed_data;  <span class="comment">// 压缩之后的数据</span></span><br><span class="line">   CompressionType compression_type;              <span class="comment">// 压缩类型</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; first_key_in_next_block;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Keys&gt; keys;                    <span class="comment">// 此block的所有keys</span></span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;BlockRepSlot&gt; slot;            <span class="comment">// 所属的 BlockRepSlot  ???          </span></span><br><span class="line">   Status status;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockRepSlot</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   BlockRepSlot() : slot_(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 向 slot_ 中添加一</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Fill</span><span class="params">(T&amp;&amp; rep)</span> </span>&#123;</span><br><span class="line">     slot_.push(<span class="built_in">std</span>::forward&lt;T&gt;(rep));</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">Take</span><span class="params">(BlockRep*&amp; rep)</span> </span>&#123; slot_.pop(rep); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   WorkQueue&lt;BlockRep*&gt; slot_;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="FileSizeEstimator"><a href="#FileSizeEstimator" class="headerlink" title="FileSizeEstimator"></a>FileSizeEstimator</h3><p>当并行压缩开启时，类 <code>FileSizeEstimator</code> 用于计算输出文件大小。主要是有两个回调函数 <code>EmitBlock</code>  、<code>ReapBlock</code>：</p><ul><li><code>EmitBlock</code>：在添加到压缩线程之前调用</li><li><code>ReapBlock</code>：在压缩完成之后调用</li></ul><p><code>FileSizeEstimator</code> 的源码简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileSizeEstimator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FileSizeEstimator</span><span class="params">()</span></span></span><br><span class="line">      : raw_bytes_compressed(0),</span><br><span class="line">        raw_bytes_curr_block(<span class="number">0</span>),</span><br><span class="line">        raw_bytes_curr_block_set(<span class="literal">false</span>),</span><br><span class="line">        raw_bytes_inflight(<span class="number">0</span>),</span><br><span class="line">        blocks_inflight(<span class="number">0</span>),</span><br><span class="line">        curr_compression_ratio(<span class="number">0</span>),</span><br><span class="line">        estimated_file_size(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 当一个 block 要 emit to 压缩线程时，则计算一个文件大小</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EmitBlock</span><span class="params">(<span class="keyword">uint64_t</span> raw_block_size, <span class="keyword">uint64_t</span> curr_file_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 当一个 block 从压缩线程压缩完毕时</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReapBlock</span><span class="params">(<span class="keyword">uint64_t</span> compressed_block_size, <span class="keyword">uint64_t</span> curr_file_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 设置文件近似大小</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetEstimatedFileSize</span><span class="params">(<span class="keyword">uint64_t</span> size)</span> </span>&#123;</span><br><span class="line">    estimated_file_size.store(size, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 获得文件近似大小</span></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">GetEstimatedFileSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> estimated_file_size.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/// 设置block大小</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetCurrBlockRawSize</span><span class="params">(<span class="keyword">uint64_t</span> size)</span> </span>&#123;</span><br><span class="line">    raw_bytes_curr_block = size;</span><br><span class="line">    raw_bytes_curr_block_set = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uint64_t</span> raw_bytes_compressed;  <span class="comment">// 到目前为止压缩的字节，即这么多的字节是要要压缩的</span></span><br><span class="line">  <span class="keyword">uint64_t</span> raw_bytes_curr_block;  <span class="comment">// Size of current block being appended.</span></span><br><span class="line">  <span class="keyword">bool</span> raw_bytes_curr_block_set;  <span class="comment">// </span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; raw_bytes_inflight; <span class="comment">// 正在压缩，但尚未添加到sst文件的字节大小</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; blocks_inflight;    <span class="comment">// Number of blocks under compression and not appended yet.</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">double</span>&gt; curr_compression_ratio; <span class="comment">// 压缩率</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; estimated_file_size;  <span class="comment">// SST 文件的近似大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="EmitBlock"><a href="#EmitBlock" class="headerlink" title="EmitBlock"></a>EmitBlock</h4><p><code>EmitBlock</code>函数，在将一个待压缩的block发送给压缩线程之前调用，用于计算当所有block压缩完成后sst文件的近似大小。主要有三部分组成：</p><ol><li><code>curr_file_size</code>：已写入到sst的部分</li><li><code>new_raw_bytes_inflight</code>：当前正在压缩，还没写入sst的部分。这部分按照压缩率<code>curr_compression_ratio</code> 大致折算成最终写入sst的大小。</li><li><code>kBlockTrailerSize</code>：每个block都有<code>footer</code>，这部分不压缩，按照正在压缩的block数<code>new_blocks_inflight</code> 乘以每个<code>footer</code>的大小<code>kBlockTrailerSize</code>，即这部分写入sst的大小。</li></ol><p>源码简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param raw_block_size 待压缩的 block 大小</span></span><br><span class="line"><span class="comment">/// @param curr_file_size </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmitBlock</span><span class="params">(<span class="keyword">uint64_t</span> raw_block_size, <span class="keyword">uint64_t</span> curr_file_size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前正在压缩的字节数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> new_raw_bytes_inflight =</span><br><span class="line">        raw_bytes_inflight.fetch_add(raw_block_size,</span><br><span class="line">                                     <span class="built_in">std</span>::memory_order_relaxed) +</span><br><span class="line">        raw_block_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在压缩的block数据</span></span><br><span class="line">    <span class="keyword">uint64_t</span> new_blocks_inflight =</span><br><span class="line">        blocks_inflight.fetch_add(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    estimated_file_size.store(</span><br><span class="line">        curr_file_size +  <span class="comment">// 1. 已经写入 sst 的大小</span></span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(new_raw_bytes_inflight) * <span class="comment">// 2. 压缩完成的大小 = 当前正在压缩 * 压缩率</span></span><br><span class="line">                curr_compression_ratio.load(<span class="built_in">std</span>::memory_order_relaxed)) +</span><br><span class="line">            new_blocks_inflight * kBlockTrailerSize, <span class="comment">// 3. new_blocks_inflight * 脚注大小</span></span><br><span class="line">        <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="ReapBlock"><a href="#ReapBlock" class="headerlink" title="ReapBlock"></a>ReapBlock</h4><p><code>ReapBlock</code>，也是个回调函数 ，当一个block压缩完毕时调用，来更新当前压缩的状态：</p><ul><li><code>raw_bytes_compressed</code>：到目前为止，有多少字节的数据被压缩了；</li><li><code>curr_compression_ratio</code>：已压缩的字节数 / 当前对应的原始字节数</li><li>重新估算最终写入sst文件的大小</li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReapBlock</span><span class="params">(<span class="keyword">uint64_t</span> compressed_block_size, <span class="keyword">uint64_t</span> curr_file_size)</span> </span>&#123;</span><br><span class="line">    assert(raw_bytes_curr_block_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前一共被压缩的字节数</span></span><br><span class="line">    <span class="keyword">uint64_t</span> new_raw_bytes_compressed =</span><br><span class="line">        raw_bytes_compressed + raw_bytes_curr_block;</span><br><span class="line">    assert(new_raw_bytes_compressed &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新压缩率</span></span><br><span class="line">    <span class="comment">// 分子：压缩的字节，分母：原始字节</span></span><br><span class="line">    curr_compression_ratio.store(</span><br><span class="line">        (curr_compression_ratio.load(<span class="built_in">std</span>::memory_order_relaxed) *</span><br><span class="line">             raw_bytes_compressed +</span><br><span class="line">         compressed_block_size) /</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(new_raw_bytes_compressed),</span><br><span class="line">        <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    raw_bytes_compressed = new_raw_bytes_compressed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复</span></span><br><span class="line">    <span class="keyword">uint64_t</span> new_raw_bytes_inflight =</span><br><span class="line">        raw_bytes_inflight.fetch_sub(raw_bytes_curr_block,</span><br><span class="line">                                     <span class="built_in">std</span>::memory_order_relaxed) -</span><br><span class="line">        raw_bytes_curr_block;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> new_blocks_inflight =</span><br><span class="line">        blocks_inflight.fetch_sub(<span class="number">1</span>, <span class="built_in">std</span>::memory_order_relaxed) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算下文件大小</span></span><br><span class="line">    estimated_file_size.store(</span><br><span class="line">        curr_file_size +</span><br><span class="line">            <span class="keyword">static_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(</span><br><span class="line">                <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>&gt;(new_raw_bytes_inflight) * </span><br><span class="line">                curr_compression_ratio.load(<span class="built_in">std</span>::memory_order_relaxed)) +</span><br><span class="line">            new_blocks_inflight * kBlockTrailerSize,</span><br><span class="line">        <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    raw_bytes_curr_block_set = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ParallelCompressionRep"><a href="#ParallelCompressionRep" class="headerlink" title="ParallelCompressionRep"></a>ParallelCompressionRep</h3><p>为了更好地理解 <code>class ParallelCompressionRep</code>，下面在讲解源码时，会调整下不同字段的顺序。</p><p><code>ParallelCompressionRep</code>，使用顺序如下：</p><ul><li>在<code>ParallelCompressionRep</code>内部，会调用<code>ParallelCompressionRep::PrepareBlock</code>接口，准备此block的数据；</li><li>调用 <code>EmitBlock</code>函数发送给压缩线程；</li><li>当压缩完成，会调用<code>ParallelCompressionRep::ReapBlock</code>接口。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BlockBasedTableBuilder</span>:</span>:ParallelCompressionRep &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Keys</span>              &#123;</span> <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">BlockRepSlot</span>      &#123;</span> <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">BlockRep</span>         &#123;</span> <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">FileSizeEstimator</span> &#123;</span> <span class="comment">/***/</span> &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;BlockRep&gt;    BlockRepBuffer;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRep*&gt;     BlockRepPool;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRep*&gt;     CompressQueue;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRepSlot*&gt; WriteQueue;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 字段</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;Keys&gt;         curr_block_keys;      <span class="comment">// 当前block的key</span></span><br><span class="line">  BlockRepBuffer                block_rep_buf;        <span class="comment">// 记录各个block的数据状态</span></span><br><span class="line">  BlockRepPool                  block_rep_pool;       <span class="comment">// block_rep_pool 中记录的是 block_rep_buf</span></span><br><span class="line">  CompressQueue                 compress_queue;       <span class="comment">// 待压缩的任务队列</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;port::Thread&gt;     compress_thread_pool; <span class="comment">// 压缩线程</span></span><br><span class="line">  WriteQueue                    write_queue;          <span class="comment">// 写入文件的队列</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;port::Thread&gt; write_thread;    <span class="comment">// 写线程</span></span><br><span class="line">  FileSizeEstimator             file_size_estimator;  <span class="comment">// 评估文件大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待第一个 block 压缩完成</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="keyword">bool</span>&gt;             first_block_processed;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable       first_block_cond;</span><br><span class="line">  <span class="built_in">std</span>::mutex                    first_block_mutex;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ParallelCompressionRep</span><span class="params">(<span class="keyword">uint32_t</span> parallel_threads)</span></span></span><br><span class="line">      : curr_block_keys(new Keys()),</span><br><span class="line">        block_rep_buf(parallel_threads),</span><br><span class="line">        block_rep_pool(parallel_threads),</span><br><span class="line">        compress_queue(parallel_threads),</span><br><span class="line">        write_queue(parallel_threads),</span><br><span class="line">        first_block_processed(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; parallel_threads; i++) &#123;</span><br><span class="line">      block_rep_buf[i].contents = Slice();</span><br><span class="line">      block_rep_buf[i].compressed_contents = Slice();</span><br><span class="line">      block_rep_buf[i].data.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].compressed_data.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].compression_type = CompressionType();</span><br><span class="line">      block_rep_buf[i].first_key_in_next_block.reset(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].keys.reset(<span class="keyword">new</span> Keys());</span><br><span class="line">      block_rep_buf[i].slot.reset(<span class="keyword">new</span> BlockRepSlot());</span><br><span class="line">      block_rep_buf[i].status = Status::OK();</span><br><span class="line">      <span class="comment">// 放到线程池</span></span><br><span class="line">      <span class="comment">// 因此，block_rep_pool 中每个元素的生命周期是由 block_rep_buf 中的每个元素负责</span></span><br><span class="line">      <span class="comment">// block_rep_buf 中存储着原始数据</span></span><br><span class="line">      block_rep_pool.push(&amp;block_rep_buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/// 等待完成</span></span><br><span class="line">  ~ParallelCompressionRep() &#123; block_rep_pool.finish(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 使用在 non-buffered 模式</span></span><br><span class="line">  <span class="comment">/// 准备好一个 block，并准备发送给 压缩线程</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                         BlockBuilder* data_block)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Used in EnterUnbuffered</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="built_in">std</span>::<span class="built_in">string</span>* data_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* keys)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将 block 发送给 压缩线程</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 接受从压缩线程的结果</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ReapBlock</span><span class="params">(BlockRep* block_rep)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// 生成 block</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlockInternal</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">const</span> Slice* first_key_in_next_block)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="PrepareBlockInternal"><a href="#PrepareBlockInternal" class="headerlink" title="PrepareBlockInternal"></a>PrepareBlockInternal</h4><p>下面，先来讲讲怎么创建一个 <code>BlockRep</code>对象。</p><h5 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h5><p><code>block_rep_pool</code> 的意义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 block</span></span><br><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlockInternal</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> Slice* first_key_in_next_block)</span> </span>&#123;</span><br><span class="line">  BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 从 block_rep_pool 头部出来</span></span><br><span class="line">  block_rep_pool.pop(block_rep);</span><br><span class="line">  assert(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  assert(block_rep-&gt;data);</span><br><span class="line"></span><br><span class="line">  block_rep-&gt;compression_type = compression_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_key_in_next_block == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 表示最后一个block</span></span><br><span class="line">    block_rep-&gt;first_key_in_next_block.reset(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非最后一个block</span></span><br><span class="line">    block_rep-&gt;first_key_in_next_block-&gt;assign(</span><br><span class="line">        first_key_in_next_block-&gt;data(), first_key_in_next_block-&gt;size());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PrepareBlock"><a href="#PrepareBlock" class="headerlink" title="PrepareBlock"></a>PrepareBlock</h4><p>在将待压缩的block发送给压缩线程之前，要先准备好这个block。</p><p><code>PrepareBlock</code> 函数，即用于完成这个过程。</p><ul><li><code>compression_type</code>：压缩类型</li><li><code>first_key_in_next_block</code>：下一个block的第一个<code>key</code></li><li><code>data_block</code>：待压缩的block的数据部分</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                       BlockBuilder* data_block)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 block_req</span></span><br><span class="line">  BlockRep* block_rep =</span><br><span class="line">      PrepareBlockInternal(compression_type, first_key_in_next_block);</span><br><span class="line">  assert(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 将 data_block 中数据给 block_rep-&gt;data</span></span><br><span class="line">  data_block-&gt;SwapAndReset(*(block_rep-&gt;data));</span><br><span class="line">  <span class="comment">// 数据复制给 block_rep-&gt;contents</span></span><br><span class="line">  block_rep-&gt;contents = *(block_rep-&gt;data);</span><br><span class="line">  <span class="comment">// 再将当前block的数据给 block_rep-&gt;keys</span></span><br><span class="line">  <span class="built_in">std</span>::swap(block_rep-&gt;keys, curr_block_keys);</span><br><span class="line">  curr_block_keys-&gt;Clear();</span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PrepareBlock-1"><a href="#PrepareBlock-1" class="headerlink" title="PrepareBlock"></a>PrepareBlock</h4><p><code>PrepareBlock</code> 只是上述函数的重载。上述函数传入的是一个<code>BlockBuilder*</code>，这里只是把原本一个<code>BlockBuilder</code> 记录的数据分别传入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">string</span>* data_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;* keys)</span> </span>&#123;</span><br><span class="line">  BlockRep* block_rep =</span><br><span class="line">      PrepareBlockInternal(compression_type, first_key_in_next_block);</span><br><span class="line">  assert(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">std</span>::swap(*(block_rep-&gt;data), *data_block);</span><br><span class="line">  block_rep-&gt;contents = *(block_rep-&gt;data);</span><br><span class="line">  block_rep-&gt;keys-&gt;SwapAssign(*keys);</span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EmitBlock-1"><a href="#EmitBlock-1" class="headerlink" title="EmitBlock"></a>EmitBlock</h4><p>将上述准备好的block发送给压缩线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 block 发送给 压缩线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  assert(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  assert(block_rep-&gt;status.ok());</span><br><span class="line">  <span class="comment">// 将准备好的block加入工作队列</span></span><br><span class="line">  <span class="keyword">if</span> (!write_queue.push(block_rep-&gt;slot.get())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!compress_queue.push(block_rep)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等待压缩完成 </span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到 first_block_processed 为 true</span></span><br><span class="line">    first_block_cond.wait(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">return</span> first_block_processed.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReapBlock-1"><a href="#ReapBlock-1" class="headerlink" title="ReapBlock"></a>ReapBlock</h4><h5 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h5><p><code>ReapBlock</code>，当压缩完成时的回调函数。??? 应该是写入文件???</p><p>用于清除压缩数据，通知emit线程，可以继续压缩</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reap a block from compression thread</span></span><br><span class="line"><span class="comment">// 接受从压缩线程的结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReapBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  assert(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 清除压缩数据</span></span><br><span class="line">  block_rep-&gt;compressed_data-&gt;clear();</span><br><span class="line">  <span class="comment">// ??? </span></span><br><span class="line">  block_rep_pool.push(block_rep);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知 emit Block，可以继续压缩</span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    first_block_processed.store(<span class="literal">true</span>, <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    first_block_cond.notify_one();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BlockBasedTableBuilder"><a href="#BlockBasedTableBuilder" class="headerlink" title="BlockBasedTableBuilder"></a>BlockBasedTableBuilder</h2><p>初始化操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">BlockBasedTableBuilder::BlockBasedTableBuilder(</span><br><span class="line">    <span class="keyword">const</span> BlockBasedTableOptions&amp; table_options, <span class="keyword">const</span> TableBuilderOptions&amp; tbo,</span><br><span class="line">    WritableFileWriter* file) &#123;</span><br><span class="line">  <span class="function">BlockBasedTableOptions <span class="title">sanitized_table_options</span><span class="params">(table_options)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 压缩格式</span></span><br><span class="line">  <span class="keyword">if</span> (sanitized_table_options.format_version == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      sanitized_table_options.checksum != kCRC32c) &#123;</span><br><span class="line">    ROCKS_LOG_WARN(</span><br><span class="line">        tbo.ioptions.logger,</span><br><span class="line">        <span class="string">&quot;Silently converting format_version to 1 because checksum is &quot;</span></span><br><span class="line">        <span class="string">&quot;non-default&quot;</span>);</span><br><span class="line">    <span class="comment">// silently convert format_version to 1 to keep consistent with current</span></span><br><span class="line">    <span class="comment">// behavior</span></span><br><span class="line">    sanitized_table_options.format_version = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 rep_</span></span><br><span class="line">  rep_ = <span class="keyword">new</span> Rep(sanitized_table_options, tbo, file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// filter block 此时还没创建，初始化</span></span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    rep_-&gt;filter_builder-&gt;StartBlock(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成前缀</span></span><br><span class="line">  <span class="keyword">if</span> (table_options.block_cache_compressed.get() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    BlockBasedTable::GenerateCachePrefix&lt;Cache, FSWritableFile&gt;(</span><br><span class="line">        table_options.block_cache_compressed.get(), </span><br><span class="line">        file-&gt;writable_file(),</span><br><span class="line">        &amp;rep_-&gt;compressed_cache_key_prefix[<span class="number">0</span>],    <span class="comment">// 输出参数</span></span><br><span class="line">        &amp;rep_-&gt;compressed_cache_key_prefix_size,  <span class="comment">// 输出参数</span></span><br><span class="line">        tbo.db_session_id,</span><br><span class="line">        tbo.cur_file_num);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开启多线程压缩</span></span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;IsParallelCompressionEnabled()) &#123;</span><br><span class="line">    StartParallelCompression();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ParallelCompression"><a href="#ParallelCompression" class="headerlink" title="ParallelCompression"></a>ParallelCompression</h3><p>下面从压缩开始。</p><p>每个data_block在写入sst之前，如果设置了压缩，则都会经过一个压缩的过程。</p><h4 id="IsParallelCompressionEnabled"><a href="#IsParallelCompressionEnabled" class="headerlink" title="IsParallelCompressionEnabled"></a>IsParallelCompressionEnabled</h4><p>是否开启多线程压缩，则由 <code>CompressionOptions::parallel_threads</code> 字段的值指示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> BlockBasedTableBuilder::Rep::IsParallelCompressionEnabled() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> compression_opts.parallel_threads &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StartParallelCompression"><a href="#StartParallelCompression" class="headerlink" title="StartParallelCompression"></a>StartParallelCompression</h4><p>如果开启了多线程压缩，压缩流程如下：</p><ul><li>在每次压缩前，主线程，使用<code>ParallelCompressionRep::PrepareBlock</code>函数，准备好待压缩的block；</li><li>主线程调用<code>ParallelCompressionRep::EmitBlock</code>函数，将block送入压缩线程；</li><li>压缩线程再进行压缩</li><li>将压缩完毕的data_block，写入到sst文件中</li></ul><p>下面是开启多个压缩线程的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::StartParallelCompression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化 ParallelCompressionRep 对象</span></span><br><span class="line">  rep_-&gt;pc_rep.reset(</span><br><span class="line">      <span class="keyword">new</span> ParallelCompressionRep(rep_-&gt;compression_opts.parallel_threads));</span><br><span class="line">  rep_-&gt;pc_rep-&gt;compress_thread_pool.reserve(</span><br><span class="line">      rep_-&gt;compression_opts.parallel_threads);</span><br><span class="line">  <span class="comment">// 开启 parallel_threads 个压缩线程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">uint32_t</span> i = <span class="number">0</span>; i &lt; rep_-&gt;compression_opts.parallel_threads; i++) &#123;</span><br><span class="line">    rep_-&gt;pc_rep-&gt;compress_thread_pool.emplace_back([<span class="keyword">this</span>, i] &#123;</span><br><span class="line">      BGWorkCompression(*(rep_-&gt;compression_ctxs[i]),  <span class="comment">// 压缩上下文</span></span><br><span class="line">                          rep_-&gt;verify_ctxs[i].get()); <span class="comment">// 解压上下文</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开启 1 个写线程</span></span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_thread.reset(</span><br><span class="line">      <span class="keyword">new</span> port::Thread([<span class="keyword">this</span>] &#123; BGWorkWriteRawBlock(); &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BGWorkCompression"><a href="#BGWorkCompression" class="headerlink" title="BGWorkCompression"></a>BGWorkCompression</h5><p>压缩线程的入口函数，<code>BGWorkCompression</code> ，仅用于压缩<code>data_block</code>，他一直在等待主线程发送待压缩的block，然后取出来，进行压缩。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::BGWorkCompression</span><span class="params">(<span class="keyword">const</span> CompressionContext&amp; compression_ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                               UncompressionContext* verify_ctx)</span> </span>&#123;</span><br><span class="line">  ParallelCompressionRep::BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (rep_-&gt;pc_rep-&gt;compress_queue.pop(block_rep)) &#123;</span><br><span class="line">    assert(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    CompressAndVerifyBlock(block_rep-&gt;contents, </span><br><span class="line">                           <span class="literal">true</span>, <span class="comment">/* is_data_block*/</span></span><br><span class="line">                           compression_ctx, </span><br><span class="line">                           verify_ctx,</span><br><span class="line">                           block_rep-&gt;compressed_data.get(), <span class="comment">// 输出参数，unused ?</span></span><br><span class="line">                           &amp;block_rep-&gt;compressed_contents,  <span class="comment">// 保存压缩结果</span></span><br><span class="line">                           &amp;(block_rep-&gt;compression_type),   <span class="comment">// 压缩结果的字节数</span></span><br><span class="line">                           &amp;block_rep-&gt;status);              <span class="comment">// 压缩是否成功</span></span><br><span class="line">    <span class="comment">// 将压缩完毕的 block 加入到 block_rep-&gt;slot 中</span></span><br><span class="line">    <span class="comment">// 为后面写入sst准备</span></span><br><span class="line">    block_rep-&gt;slot-&gt;Fill(block_rep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CompressAndVerifyBlock"><a href="#CompressAndVerifyBlock" class="headerlink" title="CompressAndVerifyBlock"></a>CompressAndVerifyBlock</h5><p>CompressAndVerifyBlock` 函数，不仅尝试去压缩，而且会统计压缩过程中的一些信息。为便于下面的代码简洁，易于理解，把这部分去掉了，专注于功能。</p><p>sst是由一系列的<code>block</code>组成，每个<code>block</code>的格式都是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block_data: uint8[n] <span class="comment"># block 存储的数据</span></span><br><span class="line"><span class="built_in">type</span>: uint8          <span class="comment"># 压缩类型</span></span><br><span class="line">crc: uint32          <span class="comment"># 校验和</span></span><br></pre></td></tr></table></figure><p>顺序的压缩过程如下：</p><ol><li>当前待压缩的数据是<code>raw_block_contents</code>，其大小不能超过 <code>kCompressionSizeLimit</code> 限制；</li><li>先尝试调用 <code>CompressBlock</code> 函数压缩，结果保存至<code>block_contents</code>；</li><li>如果设置了校验压缩结果，即设置了 <code>table_options.verify_compression</code> 标志位，则会对<code>block_contents</code>进行解压，保存至<code>contents</code>，顺利的压缩，需要保证 <code>block_contents</code> 和 <code>contents</code> 相同；</li></ol><p>如果一切顺利，则：</p><ul><li> <code>block_contents</code> 中保存了<code>raw_block_contents</code>的压缩结果，</li><li><code>type</code> 保存了压缩类型；</li></ul><p>代码简洁后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::CompressAndVerifyBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; raw_block_contents, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">bool</span> is_data_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="keyword">const</span> CompressionContext&amp; compression_ctx, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                    UncompressionContext* verify_ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    <span class="built_in">std</span>::<span class="built_in">string</span>* compressed_output,  <span class="comment">// unused</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                                    Slice* block_contents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                    CompressionType* type, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                    Status* out_status)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="keyword">bool</span> is_status_ok = ok();</span><br><span class="line">  <span class="keyword">if</span> (!r-&gt;IsParallelCompressionEnabled()) &#123;</span><br><span class="line">    assert(is_status_ok);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *type = r-&gt;compression_type;</span><br><span class="line">  <span class="comment">// 采样多少个字节用于压缩</span></span><br><span class="line">  <span class="keyword">uint64_t</span> sample_for_compression = r-&gt;sample_for_compression;</span><br><span class="line">  <span class="comment">// 中止压缩</span></span><br><span class="line">  <span class="keyword">bool</span> abort_compression = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">StopWatchNano <span class="title">timer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      r-&gt;ioptions.clock,</span></span></span><br><span class="line"><span class="function"><span class="params">      ShouldReportDetailedTime(r-&gt;ioptions.env, r-&gt;ioptions.stats))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次压缩字节大小有限制</span></span><br><span class="line">  <span class="keyword">if</span> (is_status_ok &amp;&amp; raw_block_contents.size() &lt; kCompressionSizeLimit) &#123;</span><br><span class="line">    <span class="comment">// 1. 获取 compression_dict</span></span><br><span class="line">    <span class="keyword">const</span> CompressionDict* compression_dict;</span><br><span class="line">    <span class="keyword">if</span> (!is_data_block || r-&gt;compression_dict == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      compression_dict = &amp;CompressionDict::GetEmptyDict();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      compression_dict = r-&gt;compression_dict.get();</span><br><span class="line">    &#125;</span><br><span class="line">    assert(compression_dict != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="function">CompressionInfo <span class="title">compression_info</span><span class="params">(r-&gt;compression_opts, </span></span></span><br><span class="line"><span class="function"><span class="params">                                     compression_ctx,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     *compression_dict, </span></span></span><br><span class="line"><span class="function"><span class="params">                                     *type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     sample_for_compression)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sampled_output_fast;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> sampled_output_slow;</span><br><span class="line">    <span class="comment">/// 尝试将 @c raw_block_contents 进行压缩，并返回至 @c compressed_output</span></span><br><span class="line">    *block_contents = CompressBlock(raw_block_contents, </span><br><span class="line">                                    compression_info, </span><br><span class="line">                                    type,</span><br><span class="line">                                    r-&gt;table_options.format_version, </span><br><span class="line">                                    is_data_block <span class="comment">/* do_sample */</span>,</span><br><span class="line">                                    compressed_output, </span><br><span class="line">                                    &amp;sampled_output_fast, </span><br><span class="line">                                    &amp;sampled_output_slow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于一些压缩算法不太可靠，因此如果设置了 verify_compression</span></span><br><span class="line">    <span class="comment">// 则需要校验</span></span><br><span class="line">    <span class="keyword">if</span> (*type != kNoCompression &amp;&amp; r-&gt;table_options.verify_compression) &#123;</span><br><span class="line">      <span class="comment">// Retrieve the uncompressed contents into a new buffer</span></span><br><span class="line">      <span class="keyword">const</span> UncompressionDict* verify_dict;</span><br><span class="line">      <span class="keyword">if</span> (!is_data_block || r-&gt;verify_dict == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        verify_dict = &amp;UncompressionDict::GetEmptyDict();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        verify_dict = r-&gt;verify_dict.get();</span><br><span class="line">      &#125;</span><br><span class="line">      assert(verify_dict != <span class="literal">nullptr</span>);</span><br><span class="line">      BlockContents contents;</span><br><span class="line">      <span class="function">UncompressionInfo <span class="title">uncompression_info</span><span class="params">(*verify_ctx, </span></span></span><br><span class="line"><span class="function"><span class="params">                                           *verify_dict,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           r-&gt;compression_type)</span></span>;</span><br><span class="line">      Status stat = UncompressBlockContentsForCompressionType(</span><br><span class="line">          uncompression_info, block_contents-&gt;data(), block_contents-&gt;size(),</span><br><span class="line">          &amp;contents, r-&gt;table_options.format_version, r-&gt;ioptions);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stat.ok()) &#123;</span><br><span class="line">        <span class="comment">// 将解压的内容与压缩之前的源内容比较</span></span><br><span class="line">        <span class="keyword">bool</span> compressed_ok = contents.data.compare(raw_block_contents) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!compressed_ok) &#123;</span><br><span class="line">          <span class="comment">// 解压内容与原来的待压缩的内容，不匹配，终止压缩</span></span><br><span class="line">          abort_compression = <span class="literal">true</span>;</span><br><span class="line">          ROCKS_LOG_ERROR(r-&gt;ioptions.logger,</span><br><span class="line">                          <span class="string">&quot;Decompressed block did not match raw block&quot;</span>);</span><br><span class="line">          *out_status =</span><br><span class="line">              Status::Corruption(<span class="string">&quot;Decompressed block did not match raw block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解压失败，终止压缩</span></span><br><span class="line">        *out_status = Status::Corruption(<span class="built_in">std</span>::<span class="built_in">string</span>(<span class="string">&quot;Could not decompress: &quot;</span>) +</span><br><span class="line">                                         stat.getState());</span><br><span class="line">        abort_compression = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// block 内容太多，无法一次性压缩，也要终止压缩</span></span><br><span class="line">    <span class="keyword">if</span> (is_data_block) &#123;</span><br><span class="line">      r-&gt;uncompressible_input_data_bytes.fetch_add(raw_block_contents.size(),</span><br><span class="line">                                                   <span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    abort_compression = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 校验压缩结果</span></span><br><span class="line">  <span class="keyword">if</span> (abort_compression) &#123;</span><br><span class="line">    *type = kNoCompression;</span><br><span class="line">    *block_contents = raw_block_contents;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BGWorkWriteRawBlock"><a href="#BGWorkWriteRawBlock" class="headerlink" title="BGWorkWriteRawBlock"></a>BGWorkWriteRawBlock</h5><p>在<code>BGWorkCompression</code> 函数，我们可以看到，压缩线程主要有两个动作：</p><ul><li>先压缩 <code>data block</code>，并将相关信息记录在<code>block_rep</code>中</li><li>再将 <code>block_rep</code> 保存在 <code>block_rep-&gt;slot</code> 中</li></ul><p>此时呢，可以回顾下 <code>ParallelCompressionRep::EmitBlock</code> 函数，<code>block_rep-&gt;slot</code> 一开始就就加入到 <code>write_queue</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!write_queue.push(block_rep-&gt;slot.get())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!compress_queue.push(block_rep)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待压缩完成 </span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.load(<span class="built_in">std</span>::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到 ReapBlock 函数调用</span></span><br><span class="line">    first_block_cond.wait(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">return</span> first_block_processed.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这说明什么？</p><p>如果前面的压缩部分没有完成，则当执行到<code>BGWorkWriteRawBlock</code> 函数时，会一直阻塞在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot-&gt;Take(block_rep);</span><br></pre></td></tr></table></figure><p>无论前面的 <code>CompressAndVerifyBlock</code>函数是否压缩成功，都需要调用<code>ReapBlock</code> 函数，以防止<code>EmitBlock</code>处产生死锁。</p><p>Of Course，若前面压缩成功，则还大致需要执行以下流程：</p><ul><li>先将当前<code>block</code>中的每个key添加到 <code>filter_builder</code>、<code>index_builder</code>；</li><li>再生成 <code>filter_block</code>、<code>idnex_block</code>；</li><li>将block压缩后的数据写入sst</li></ul><p>下面来看看细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::BGWorkWriteRawBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  ParallelCompressionRep::BlockRepSlot* slot = <span class="literal">nullptr</span>;</span><br><span class="line">  ParallelCompressionRep::BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (r-&gt;pc_rep-&gt;write_queue.pop(slot)) &#123;</span><br><span class="line">    assert(slot != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 阻塞于此，直到压缩完成，Take 函数才能返回</span></span><br><span class="line">    slot-&gt;Take(block_rep);</span><br><span class="line">    assert(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!block_rep-&gt;status.ok()) &#123;</span><br><span class="line">      r-&gt;SetStatus(block_rep-&gt;status);</span><br><span class="line">      <span class="comment">// Flush() 中存在 Emit(), 需要 ReapBlock</span></span><br><span class="line">      block_rep-&gt;status = Status::OK();</span><br><span class="line">      r-&gt;pc_rep-&gt;ReapBlock(block_rep);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; block_rep-&gt;keys-&gt;Size(); i++) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; key = (*block_rep-&gt;keys)[i];</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> ts_sz =</span><br><span class="line">            r-&gt;internal_comparator.user_comparator()-&gt;timestamp_size();</span><br><span class="line">         <span class="comment">// 为后面创建 filter block 准备</span></span><br><span class="line">        r-&gt;filter_builder-&gt;Add(ExtractUserKeyAndStripTimestamp(key, ts_sz));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为后面创建 index block 准备</span></span><br><span class="line">      r-&gt;index_builder-&gt;OnKeyAdded(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为后续重新估算 sst 文件大小准备</span></span><br><span class="line">    r-&gt;pc_rep-&gt;file_size_estimator.SetCurrBlockRawSize(block_rep-&gt;data-&gt;size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将压缩后的数据写入sst</span></span><br><span class="line">    WriteRawBlock(block_rep-&gt;compressed_contents, <span class="comment">// 压缩的数据</span></span><br><span class="line">                 block_rep-&gt;compression_type,     <span class="comment">// 压缩类型</span></span><br><span class="line">                 &amp;r-&gt;pending_handle, </span><br><span class="line">                 <span class="literal">true</span> <span class="comment">/* is_data_block*/</span>,</span><br><span class="line">                 &amp;block_rep-&gt;contents);</span><br><span class="line">    <span class="keyword">if</span> (!ok()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于前面添加的key，生成 filter block</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      r-&gt;filter_builder-&gt;StartBlock(r-&gt;get_offset());</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;props.data_size = r-&gt;get_offset();</span><br><span class="line">    ++r-&gt;props.num_data_blocks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于前面添加的key， 生成 index block</span></span><br><span class="line">    <span class="keyword">if</span> (block_rep-&gt;first_key_in_next_block == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 最后一个data block</span></span><br><span class="line">      r-&gt;index_builder-&gt;AddIndexEntry(&amp;(block_rep-&gt;keys-&gt;Back()), <span class="literal">nullptr</span>,</span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非最后一个data block</span></span><br><span class="line">      Slice first_key_in_next_block =</span><br><span class="line">          Slice(*block_rep-&gt;first_key_in_next_block);</span><br><span class="line">      r-&gt;index_builder-&gt;AddIndexEntry(&amp;(block_rep-&gt;keys-&gt;Back()),</span><br><span class="line">                                      &amp;first_key_in_next_block,</span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 ParallelCompressionRep::EmitBlock</span></span><br><span class="line">    r-&gt;pc_rep-&gt;ReapBlock(block_rep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WriteRawBlock"><a href="#WriteRawBlock" class="headerlink" title="WriteRawBlock"></a>WriteRawBlock</h5><p>最后一步，就是要将压缩完的数据按照如下格式写入到sst文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block_data: uint8[n] <span class="comment"># block 存储的数据</span></span><br><span class="line"><span class="built_in">type</span>: uint8          <span class="comment"># 压缩类型</span></span><br><span class="line">crc: uint32          <span class="comment"># 校验和</span></span><br><span class="line">padding              <span class="comment"># 填充</span></span><br></pre></td></tr></table></figure><p>注意，<code>WriteRawBlock</code> 函数的传入的参数<code>handle</code> ，在函数返回时记录了关于block的两个元信息：</p><ul><li>此block在sst文件中存储的起始位置</li><li>此block压缩后的大小。</li></ul><p>这个参数，实际上由<code>Add（key, value）</code>函数中的<code>r-&gt;pending_handle</code>传入，后续写入<code>index builder</code>，建立<code>index block</code>，这个在后面会讲解。</p><p>下面，简洁了部分代码后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::WriteRawBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           CompressionType type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           BlockHandle* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">bool</span> is_data_block,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">const</span> Slice* raw_block_contents)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Status s = Status::OK();</span><br><span class="line">  IOStatus io_s = IOStatus::OK();</span><br><span class="line">  <span class="function">StopWatch <span class="title">sw</span><span class="params">(r-&gt;ioptions.clock, r-&gt;ioptions.stats, WRITE_RAW_BLOCK_MICROS)</span></span>;</span><br><span class="line">  <span class="comment">// 1. 初始化 handle</span></span><br><span class="line">  handle-&gt;set_offset(r-&gt;get_offset());     <span class="comment">// block 在sst文件中的offset</span></span><br><span class="line">  handle-&gt;set_size(block_contents.size()); <span class="comment">// 这个block 压缩后的大小</span></span><br><span class="line">  assert(status().ok());</span><br><span class="line">  assert(io_status().ok());</span><br><span class="line">  <span class="comment">// 2. 向sst文件中追加内容 block_contents</span></span><br><span class="line">  io_s = r-&gt;file-&gt;Append(block_contents); </span><br><span class="line">  <span class="comment">// 3. 下面写入footer</span></span><br><span class="line">  <span class="keyword">if</span> (io_s.ok()) &#123;</span><br><span class="line">    <span class="keyword">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;     <span class="comment">// 压缩类型</span></span><br><span class="line">    <span class="keyword">uint32_t</span> checksum = <span class="number">0</span>; <span class="comment">// 校验和</span></span><br><span class="line">    <span class="keyword">switch</span> (r-&gt;table_options.checksum) &#123;</span><br><span class="line">      <span class="comment">// 计算校验和</span></span><br><span class="line">      <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储校验和</span></span><br><span class="line">    EncodeFixed32(trailer + <span class="number">1</span>, checksum);</span><br><span class="line">    assert(io_s.ok());</span><br><span class="line">    TEST_SYNC_POINT_CALLBACK(</span><br><span class="line">        <span class="string">&quot;BlockBasedTableBuilder::WriteRawBlock:TamperWithChecksum&quot;</span>,</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(trailer));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入 footer</span></span><br><span class="line">    io_s = r-&gt;file-&gt;Append(Slice(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (s.ok() &amp;&amp; io_s.ok()) &#123;</span><br><span class="line">      <span class="comment">// 设置文件偏移量 : 当前偏移量 + block 数据大小 + footer </span></span><br><span class="line">      r-&gt;set_offset(r-&gt;get_offset() + block_contents.size() +</span><br><span class="line">                    kBlockTrailerSize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 填充</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;table_options.block_align &amp;&amp; is_data_block) &#123;</span><br><span class="line">        <span class="keyword">size_t</span> pad_bytes =</span><br><span class="line">            (r-&gt;alignment - ((block_contents.size() + kBlockTrailerSize) &amp; (r-&gt;alignment - <span class="number">1</span>))) &amp;</span><br><span class="line">            (r-&gt;alignment - <span class="number">1</span>);</span><br><span class="line">        io_s = r-&gt;file-&gt;Pad(pad_bytes);</span><br><span class="line">        <span class="keyword">if</span> (io_s.ok()) &#123;</span><br><span class="line">          <span class="comment">// 填充后，重新更新文件偏移量</span></span><br><span class="line">          r-&gt;set_offset(r-&gt;get_offset() + pad_bytes);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;SetIOStatus(io_s);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5. 这个时候再重新计算文件大小</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;IsParallelCompressionEnabled()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_data_block) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;file_size_estimator.ReapBlock(block_contents.size(),</span><br><span class="line">                                                   r-&gt;get_offset());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;file_size_estimator.SetEstimatedFileSize(r-&gt;get_offset());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r-&gt;SetIOStatus(io_s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!io_s.ok() &amp;&amp; s.ok()) &#123;</span><br><span class="line">    r-&gt;SetStatus(io_s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StopParallelCompression"><a href="#StopParallelCompression" class="headerlink" title="StopParallelCompression"></a>StopParallelCompression</h4><p>和启动多线程部分相应，停止压缩线程、写线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::StopParallelCompression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  rep_-&gt;pc_rep-&gt;compress_queue.finish();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : rep_-&gt;pc_rep-&gt;compress_thread_pool) &#123;</span><br><span class="line">    thread.join();</span><br><span class="line">  &#125;</span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_queue.finish();</span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_thread-&gt;join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>好嘞，终于到了这里。</p><p>经过前面压缩部分的铺垫，相信这里会让你更加易懂。</p><p>每个key的编码信息中，都包含着一个<code>value_type</code>信息，关于<code>value_type</code>，详细地后续再说，这里一点，<code>IsValueType</code> 返回值为true，表示这对<code>&#123;k, v&#125;</code>可以写入到sst文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IsValueType</span><span class="params">(ValueType t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt;= kTypeMerge || t == kTypeSingleDeletion || t == kTypeBlobIndex</span><br><span class="line">         || kTypeDeletionWithTimestamp == t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">IsExtendedValueType</span><span class="params">(ValueType t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> IsValueType(t) || t == kTypeRangeDeletion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlockBasedTableBuilder</code> 在添加<code>&#123;k, v&#125;</code>并写入到sst文件的过程，会经历三个阶段<code>State</code>。</p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">State</span> &#123;</span></span><br><span class="line">  kBuffered,</span><br><span class="line">  kUnbuffered,</span><br><span class="line">  kClosed,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>kBuffered</code>模式下，将待压缩、待写入sst文件的<code>data_block</code> 暂时缓存在<code>r-&gt;data_block_buffer</code>中。当缓存中的数据长度<code>r-&gt;data_begin_offset</code>超过限制<code>buffer_limit</code> 时，就会进入到<code>kUnbuffered</code>模式。</p><p>一旦进入到<code>kUnbuffered</code>，就不可逆转到<code>kBuffered</code>。最终只能在调用 <code>BlockBasedTableBuilder::Finish</code> 时进入<code>kClosed</code>模式。</p><h4 id="should-flush"><a href="#should-flush" class="headerlink" title="should_flush"></a>should_flush</h4><p>每个<code>BlockBasedTableBuilder</code>  中都有个刷新策略<code>r-&gt;flush_block_policy</code>：将当前<code>&#123;k, v&#125;</code>添加到 <code>r-&gt;data_block</code>，若会触发更新，则会先将当前 <code>r-&gt;data_block</code> 的数据进行<code>flush</code>：</p><ul><li>若 <code>r-&gt;data_begin_offset &lt; r-&gt;buffer_limit</code>：暂时缓存到  <code>r-&gt;data_block_buffer</code>中；</li><li>否则，会先压缩，再写入sst文件。</li></ul><p>此外，由于多线程的压缩、写入sst的过程在相应的子线程中完成，当没有开启多线程时，一些细节需要在主线程中单独进行处理，因此在下面的代码中会经常看到下面的代码结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (r-&gt;IsParallelCompressionEnabled()) &#123; </span><br><span class="line">&#125; else &#123; </span><br><span class="line">  &#x2F;&#x2F; 对单线程进行处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要理解了之前讲解的多线程逻辑，下面的<code>Add</code>函数会很好理解。</p><p>代码简略后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 向 cur_block 中添加 &#123;key, value&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::Add</span><span class="params">(<span class="keyword">const</span> Slice&amp; key, <span class="keyword">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(rep_-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  ValueType value_type = ExtractValueType(key);</span><br><span class="line">  <span class="keyword">if</span> (IsValueType(value_type)) &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要 flush</span></span><br><span class="line">    <span class="keyword">auto</span> should_flush = r-&gt;flush_block_policy-&gt;Update(key, value);</span><br><span class="line">    <span class="keyword">if</span> (should_flush) &#123;</span><br><span class="line">      assert(!r-&gt;data_block.empty());</span><br><span class="line">      r-&gt;first_key_in_next_block = &amp;key;</span><br><span class="line">      Flush();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从 kBuffer 模式进入 kUnbuffered 模式</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered </span><br><span class="line">          &amp;&amp; r-&gt;buffer_limit != <span class="number">0</span> </span><br><span class="line">          &amp;&amp;r-&gt;data_begin_offset &gt; r-&gt;buffer_limit) &#123;</span><br><span class="line">        EnterUnbuffered();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (ok() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;IsParallelCompressionEnabled()) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;curr_block_keys-&gt;Clear();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 单线程：在 index builder 中添加一个 &#123;k, pending_handle&#125; </span></span><br><span class="line">          <span class="comment">// 其中 pending_handle 记录了写入sst的位置及大小</span></span><br><span class="line">          r-&gt;index_builder-&gt;AddIndexEntry(&amp;r-&gt;last_key, </span><br><span class="line">                                          &amp;key,</span><br><span class="line">                                          r-&gt;pending_handle);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> PartitionedFilterBlockBuilder 需要在 key先添加到 index builder 之后，</span></span><br><span class="line">    <span class="comment">//       再添加到 PartitionedFilterBlockBuilder 中</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;IsParallelCompressionEnabled()) &#123;</span><br><span class="line">        r-&gt;pc_rep-&gt;curr_block_keys-&gt;PushBack(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 单线程：在 filter builder 中添加一个记录</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.user_comparator()-&gt;timestamp_size();</span><br><span class="line">          r-&gt;filter_builder-&gt;Add(ExtractUserKeyAndStripTimestamp(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前data_block的last_key</span></span><br><span class="line">    r-&gt;last_key.assign(key.data(), key.size());</span><br><span class="line">    <span class="comment">// 添加 &#123;k, v&#125; 到当前 data_block</span></span><br><span class="line">    r-&gt;data_block.Add(key, value);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">      <span class="comment">// Buffered keys will be replayed from data_block_buffers during</span></span><br><span class="line">      <span class="comment">// `Finish()` once compression dictionary has been finalized.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!r-&gt;IsParallelCompressionEnabled()) &#123;</span><br><span class="line">        <span class="comment">// 单线程</span></span><br><span class="line">        r-&gt;index_builder-&gt;OnKeyAdded(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NotifyCollectTableCollectorsOnAdd(key, value, r-&gt;get_offset(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_type == kTypeRangeDeletion) &#123;</span><br><span class="line">    r-&gt;range_del_block.Add(key, value);</span><br><span class="line">    NotifyCollectTableCollectorsOnAdd(key, value, r-&gt;get_offset(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assert(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 统计</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h4><p>在<code>Flush</code> 函数中，针对多线程和单线程两种模式：</p><ul><li>如果开启了多线程 &amp;&amp; 已经处于 <code>kUnbuffered</code> 模式，则调用多线程压缩、写入sst文件。</li><li>否则，直接调用单线程的压缩写入。</li></ul><p>下面来看看源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(rep_-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">if</span> (!ok()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.empty()) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (r-&gt;IsParallelCompressionEnabled() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">    <span class="comment">// 序列化 r-&gt;data_block 中的数据</span></span><br><span class="line">    r-&gt;data_block.Finish();</span><br><span class="line">    <span class="comment">// 利用 r-&gt;data_block 中的数据生成 block_rep</span></span><br><span class="line">    ParallelCompressionRep::BlockRep* block_rep = r-&gt;pc_rep-&gt;PrepareBlock(</span><br><span class="line">        r-&gt;compression_type, r-&gt;first_key_in_next_block, &amp;(r-&gt;data_block));</span><br><span class="line">    assert(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 此时，r-&gt;data_block 中是空的了</span></span><br><span class="line">    assert(r-&gt;data_block.emoty());</span><br><span class="line">    <span class="comment">// 在压缩前，估计下 sst 文件大小</span></span><br><span class="line">    r-&gt;pc_rep-&gt;file_size_estimator.EmitBlock(block_rep-&gt;data-&gt;size(),</span><br><span class="line">                                             r-&gt;get_offset());</span><br><span class="line">    <span class="comment">// 将 data_block 送入压缩线程，后台线程会压缩、写入sst文件</span></span><br><span class="line">    r-&gt;pc_rep-&gt;EmitBlock(block_rep);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 单线程压缩</span></span><br><span class="line">    WriteBlock(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle, <span class="literal">true</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WriteBlock"><a href="#WriteBlock" class="headerlink" title="WriteBlock"></a>WriteBlock</h5><p>调用 <code>WriteBlock</code> 函数，不仅会来自于上面的 <code>Flush</code> 函数，还有会后面的<code>WriteIndexBlock</code>、<code>EnterUnbuffered</code>函数等。因此，<code>WriteBlock</code> 函数做了统一接口，来应对 <code>State::kBuffered</code> 和 <code>State::kUnBuffered</code>两种状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::WriteBlock</span><span class="params">(BlockBuilder* block,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        BlockHandle* handle,  <span class="comment">// 正在pending的</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">bool</span> is_data_block)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 序列化 block 中的数据</span></span><br><span class="line">  block-&gt;Finish();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> raw_block_contents;</span><br><span class="line">  <span class="comment">// 将block序列化后的内容swap到 raw_block_contents 中</span></span><br><span class="line">  block-&gt;SwapAndReset(raw_block_contents);</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">    <span class="comment">// 只有 data_block 存在 kbuffered 模式</span></span><br><span class="line">    assert(is_data_block);</span><br><span class="line">    <span class="comment">// 将数据先写入 data_block_buffers</span></span><br><span class="line">    rep_-&gt;data_block_buffers.emplace_back(<span class="built_in">std</span>::move(raw_block_contents));</span><br><span class="line">    rep_-&gt;data_begin_offset += rep_-&gt;data_block_buffers.back().size();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="comment">// else 就是 KUnBuffer 模式 </span></span><br><span class="line">  WriteBlock(raw_block_contents, handle, is_data_block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="WriteBlock-1"><a href="#WriteBlock-1" class="headerlink" title="WriteBlock"></a>WriteBlock</h5><p>重载形式的<code>WriteBlock</code> ，只用于单线程压缩（没有写入sst文件的操作），且<code>BlockBasedTableBuilder</code>当前处于<code>kUnbuffered</code>模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 用于 kUnbuffered 模式：单线程压缩</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::WriteBlock</span><span class="params">(<span class="keyword">const</span> Slice&amp; raw_block_contents,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        BlockHandle* handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">bool</span> is_data_block)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(r-&gt;state == Rep::State::kUnbuffered);</span><br><span class="line">  Slice block_contents;</span><br><span class="line">  CompressionType type;</span><br><span class="line">  Status compress_status;</span><br><span class="line">  <span class="comment">// 进行压缩</span></span><br><span class="line">  CompressAndVerifyBlock(raw_block_contents, </span><br><span class="line">                         is_data_block,</span><br><span class="line">                         *(r-&gt;compression_ctxs[<span class="number">0</span>]), </span><br><span class="line">                         r-&gt;verify_ctxs[<span class="number">0</span>].get(),</span><br><span class="line">                         &amp;(r-&gt;compressed_output), </span><br><span class="line">                         &amp;(block_contents), </span><br><span class="line">                         &amp;type,</span><br><span class="line">                         &amp;compress_status);</span><br><span class="line">  r-&gt;SetStatus(compress_status);</span><br><span class="line">  <span class="comment">// 如果压缩不成功</span></span><br><span class="line">  <span class="keyword">if</span> (!ok()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="EnterUnbuffered"><a href="#EnterUnbuffered" class="headerlink" title="EnterUnbuffered"></a>EnterUnbuffered</h4><p><code>EnterUnbuffered</code>函数，将<code>BlockBasedTableBuilder</code>的状态，从<code>kBuffered</code>推向<code>kUnBuffered</code>，仅会执行一次。</p><p>那么这个函数的使命？</p><p>我们知道在 <code>kBuffered</code> 模式下，每次调用<code>Flush</code>函数时，都是将<code>r-&gt;data_block</code>的数据缓存到<code>r-&gt;data_block_buffers</code>。</p><p>当从<code>kBuffered</code>专向<code>kUnBuffered</code>时，很自然，就需要让<code>r-&gt;data_block_buffers</code> 中的数据也经历两个过程：</p><ul><li>压缩</li><li>写入sst</li></ul><p>带着这个思路，下面的代码就很好理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::EnterUnbuffered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(r-&gt;state == Rep::State::kBuffered);</span><br><span class="line">  r-&gt;state = Rep::State::kUnbuffered;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 获得 r-&gt;data_block_buffers[i] 的读迭代器</span></span><br><span class="line">  <span class="keyword">auto</span> get_iterator_for_block = [&amp;r](<span class="keyword">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; data_block = r-&gt;data_block_buffers[i];</span><br><span class="line">    assert(!data_block.empty());</span><br><span class="line"></span><br><span class="line">    Block reader&#123;BlockContents&#123;data_block&#125;&#125;;</span><br><span class="line">    DataBlockIter* iter = reader.NewDataIterator(r-&gt;internal_comparator.user_comparator(), </span><br><span class="line">                                                 kDisableGlobalSequenceNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到这个 data_block 的起始处</span></span><br><span class="line">    iter-&gt;SeekToFirst();</span><br><span class="line">    assert(iter-&gt;Valid());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataBlockIter&gt;(iter);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;DataBlockIter&gt; iter = <span class="literal">nullptr</span>, next_block_iter = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; ok() &amp;&amp; i &lt; r-&gt;data_block_buffers.size(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 初始化迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter = get_iterator_for_block(i);</span><br><span class="line">      assert(iter != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个 data_block 的迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.size()) &#123;</span><br><span class="line">      next_block_iter = get_iterator_for_block(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 data_block</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; data_block = r-&gt;data_block_buffers[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 下面对data_block进行压缩、写入***/</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;IsParallelCompressionEnabled()) &#123;</span><br><span class="line">      <span class="comment">/*** 开启了多线程压缩 ***/</span></span><br><span class="line">      </span><br><span class="line">      Slice first_key_in_next_block;</span><br><span class="line">      <span class="keyword">const</span> Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.size()) &#123;</span><br><span class="line">        assert(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">// 下一个 data_block 的第一个key</span></span><br><span class="line">        first_key_in_next_block = next_block_iter-&gt;key();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// r-&gt;first_key_in_next_block </span></span><br><span class="line">        <span class="comment">// 即处于 kUnBuffered 状态的 data_block 第一个key</span></span><br><span class="line">        first_key_in_next_block_ptr = r-&gt;first_key_in_next_block;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 迭代当前 data_block, 将所有的key，全部添加到 keys</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; keys;</span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;Valid(); iter-&gt;Next()) &#123;</span><br><span class="line">        keys.emplace_back(iter-&gt;key().ToString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 生成 block_req </span></span><br><span class="line">      ParallelCompressionRep::BlockRep* block_rep = r-&gt;pc_rep-&gt;PrepareBlock(</span><br><span class="line">          r-&gt;compression_type, first_key_in_next_block_ptr, &amp;data_block, &amp;keys);</span><br><span class="line"></span><br><span class="line">      assert(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="comment">// 在发送前，估计下sst文件大小</span></span><br><span class="line">      r-&gt;pc_rep-&gt;file_size_estimator.EmitBlock(block_rep-&gt;data-&gt;size(),</span><br><span class="line">                                               r-&gt;get_offset());</span><br><span class="line">      <span class="comment">// 发送至压缩线程</span></span><br><span class="line">      r-&gt;pc_rep-&gt;EmitBlock(block_rep);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*** 没有开启多线程压缩 ***/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// fileter block，index block</span></span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;Valid(); iter-&gt;Next()) &#123;</span><br><span class="line">        Slice key = iter-&gt;key();</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="keyword">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.user_comparator()-&gt;timestamp_size();</span><br><span class="line">          r-&gt;filter_builder-&gt;Add(ExtractUserKeyAndStripTimestamp(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;index_builder-&gt;OnKeyAdded(key);</span><br><span class="line">      &#125;</span><br><span class="line">      WriteBlock(Slice(data_block),</span><br><span class="line">                 &amp;r-&gt;pending_handle,  <span class="comment">// 记录了 data_block 在文件中的位置及其大小</span></span><br><span class="line">                 <span class="literal">true</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//! 此for循环，不包含最后一个data block</span></span><br><span class="line">      <span class="comment">//! 因此，在 ::Finish 函数中，需要为最后一个 data block 单独调用一次 AddIndexEntry</span></span><br><span class="line">      <span class="keyword">if</span> (ok() &amp;&amp; i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.size()) &#123;</span><br><span class="line">        assert(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        Slice first_key_in_next_block = next_block_iter-&gt;key();</span><br><span class="line"></span><br><span class="line">        Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line"></span><br><span class="line">        iter-&gt;SeekToLast();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> last_key = iter-&gt;key().ToString();</span><br><span class="line">        <span class="comment">// 添加一个 &#123;key, handle&#125;</span></span><br><span class="line">        r-&gt;index_builder-&gt;AddIndexEntry(&amp;last_key, first_key_in_next_block_ptr,</span><br><span class="line">                                        r-&gt;pending_handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** 遍历完当前 data_block ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::swap(iter, next_block_iter);</span><br><span class="line">  &#125; <span class="comment">// 遍历完所有的 data_block</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 清除数据</span></span><br><span class="line">  r-&gt;data_block_buffers.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p>在前文说过，一个table序列化到sst文件的格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beginning_of_file&gt;</span><br><span class="line">[data block 1]</span><br><span class="line">[data block 2]</span><br><span class="line">...</span><br><span class="line">[data block N]</span><br><span class="line">[meta block 1: filter block]                 </span><br><span class="line">[meta block 2: index block]</span><br><span class="line">[meta block 3: compression dictionary block]</span><br><span class="line">[meta block 4: range deletion block]        </span><br><span class="line">[meta block 5: stats block]</span><br><span class="line">...</span><br><span class="line">[meta block K: future extended block]</span><br><span class="line">[metaindex block]</span><br><span class="line">[Footer]</span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure><p>当调用<code>::Finish</code>函数时，<code>data block</code>部分已经构建完毕，下面就需要开始构建<code>meta block</code> 。</p><h4 id="MetaIndexBuilder"><a href="#MetaIndexBuilder" class="headerlink" title="MetaIndexBuilder"></a>MetaIndexBuilder</h4><p>前面的<code>filter block</code>、<code>index block</code>、<code>compression dictionary block</code>、<code>range deletion block</code>、<code>prop block</code>等记录着<code>data block</code>各种信息，我们把这些记录<code>data block</code>信息的<code>block</code>统一叫做<code>meta block</code>。所谓<code>meta</code>，即信息的信息。</p><p><code>MetaIndexBuilder</code>，则用于存储前面这些<code>meta block</code>在sst中的存储位置及其大小，最终用于构建整个<code>Table</code>的<code>footer</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MetaIndexBuilder</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  MetaIndexBuilder()</span><br><span class="line">  : meta_index_block_(<span class="keyword">new</span> BlockBuilder(<span class="number">1</span> <span class="comment">/* restart interval */</span>)) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  MetaIndexBuilder(<span class="keyword">const</span> MetaIndexBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MetaIndexBuilder&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MetaIndexBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 添加 &#123;k, v&#125;</span></span><br><span class="line">  <span class="comment">/// handle 中记录了指向的 meta block 在sst中的位置及其大小</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; key, <span class="keyword">const</span> BlockHandle&amp; handle)</span> </span>&#123; </span><br><span class="line">     <span class="built_in">std</span>::<span class="built_in">string</span> handle_encoding;</span><br><span class="line">     handle.EncodeTo(&amp;handle_encoding); <span class="comment">// 编码为字符串</span></span><br><span class="line">     meta_block_handles_.emplace(key, <span class="built_in">std</span>::move(handle_encoding));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将所有添加到 meta_block_handles_ 中的&#123;k, v&#125; 序列化后返回</span></span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span> </span>&#123; </span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; metablock : meta_block_handles_) &#123;</span><br><span class="line">       meta_index_block_-&gt;Add(metablock.first, metablock.second);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> meta_index_block_-&gt;Finish()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  stl_wrappers::KVMap meta_block_handles_;          <span class="comment">// 存着所有meta block的信息</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;BlockBuilder&gt; meta_index_block_;  <span class="comment">// 由这些meta block的元信息构建的block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了这个思路，下面，就可以先来看看整体代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BlockBasedTableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  assert(r-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">bool</span> empty_data_block = r-&gt;data_block.empty();</span><br><span class="line">  <span class="comment">// 在flush时，暗示最后一个data block</span></span><br><span class="line">  r-&gt;first_key_in_next_block = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// flush最后一个data block</span></span><br><span class="line">  Flush();</span><br><span class="line">  <span class="comment">// 如果状态不是 kUnBuffered，则直接进入</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">    EnterUnbuffered();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (r-&gt;IsParallelCompressionEnabled()) &#123;</span><br><span class="line">    StopParallelCompression();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对于单线程，EnterUnbuffered 函数没发为最后一个 data block 建立 index </span></span><br><span class="line">    <span class="comment">// 因此，需要手动添加</span></span><br><span class="line">    <span class="keyword">if</span> (ok() &amp;&amp; !empty_data_block) &#123;</span><br><span class="line">      r-&gt;index_builder-&gt;AddIndexEntry(&amp;r-&gt;last_key, </span><br><span class="line">                                     <span class="literal">nullptr</span> <span class="comment">/* no next data block */</span>, </span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 开始构建 meta-block</span></span><br><span class="line">  BlockHandle metaindex_block_handle, index_block_handle;</span><br><span class="line">  MetaIndexBuilder meta_index_builder;</span><br><span class="line">  WriteFilterBlock(&amp;meta_index_builder);</span><br><span class="line">  WriteIndexBlock(&amp;meta_index_builder, &amp;index_block_handle);</span><br><span class="line">  WriteCompressionDictBlock(&amp;meta_index_builder);</span><br><span class="line">  WriteRangeDelBlock(&amp;meta_index_builder);</span><br><span class="line">  WritePropertiesBlock(&amp;meta_index_builder);</span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="comment">// 将meta-block写入sst文件</span></span><br><span class="line">    WriteRawBlock(meta_index_builder.Finish(), kNoCompression,</span><br><span class="line">                  &amp;metaindex_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// metaindex_block_handle 记录着 meta-block的信息</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    WriteFooter(metaindex_block_handle, index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;state = Rep::State::kClosed;</span><br><span class="line">  r-&gt;SetStatus(r-&gt;CopyIOStatus());</span><br><span class="line">  Status ret_status = r-&gt;CopyStatus();</span><br><span class="line">  assert(!ret_status.ok() || io_status().ok());</span><br><span class="line">  <span class="keyword">return</span> ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteFilterBlock"><a href="#WriteFilterBlock" class="headerlink" title="WriteFilterBlock"></a>WriteFilterBlock</h4><p><code>WriteFilterBlock</code>函数的逻辑如下：</p><ul><li>如果不是 <code>PartitionFilterBuilder</code>，则直接将整个<code>FilterBuiler</code>构建的数据，在直接序列化后写入sst文件。</li><li>如果是<code>PartitionFilterBuilder</code>，则以<code>partition</code>为单位，逐个写入到sst文件；</li><li>等上述过程完毕，再将将此 <code>FilterBuilder</code> 的属性作为<code>&#123;k, v&#125;</code>添加到 <code>meta_index_builder</code>中：<ul><li><code>k</code>：是<code>FilterBuilderType.FilterPolicyName</code>；</li><li><code>v</code>：是写入sst文件的<code>filter block</code>的元信息。</li></ul></li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::WriteFilterBlock</span><span class="params">(MetaIndexBuilder* meta_index_builder)</span> </span>&#123;</span><br><span class="line">  BlockHandle filter_block_handle;</span><br><span class="line">  <span class="keyword">bool</span> empty_filter_block =</span><br><span class="line">      (rep_-&gt;filter_builder == <span class="literal">nullptr</span> || rep_-&gt;filter_builder-&gt;IsEmpty());</span><br><span class="line">  <span class="keyword">if</span> (ok() &amp;&amp; !empty_filter_block) &#123;</span><br><span class="line">    <span class="comment">// 添加的key数</span></span><br><span class="line">    rep_-&gt;props.num_filter_entries +=</span><br><span class="line">        rep_-&gt;filter_builder-&gt;EstimateEntriesAdded();</span><br><span class="line">    Status s = Status::Incomplete();</span><br><span class="line">    <span class="comment">// 如果是 PartitionFilterBuilder</span></span><br><span class="line">    <span class="comment">// 返回值是 IsIncomplete</span></span><br><span class="line">    <span class="keyword">while</span> (ok() &amp;&amp; s.IsIncomplete()) &#123;</span><br><span class="line">      <span class="comment">// 此处的 filter_block_handle 表示上一个partition的handle</span></span><br><span class="line">      Slice filter_content =</span><br><span class="line">          rep_-&gt;filter_builder-&gt;Finish(filter_block_handle, &amp;s);</span><br><span class="line">      assert(s.ok() || s.IsIncomplete());</span><br><span class="line">      rep_-&gt;props.filter_size += filter_content.size();</span><br><span class="line">      <span class="comment">// filter_content : 当前 filter partition 的内容</span></span><br><span class="line">      <span class="comment">// filter_block_handle : 记录该 partition 在sst中大小及偏移量</span></span><br><span class="line">      WriteRawBlock(filter_content, kNoCompression, &amp;filter_block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*** 全部写入sst ***/</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (ok() &amp;&amp; !empty_filter_block) &#123;</span><br><span class="line">    <span class="comment">// 获取 FilterBuilder 的名字</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> key;</span><br><span class="line">    <span class="keyword">if</span> (rep_-&gt;filter_builder-&gt;IsBlockBased()) &#123;</span><br><span class="line">      key = BlockBasedTable::kFilterBlockPrefix;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      key = rep_-&gt;table_options.partition_filters</span><br><span class="line">                ? BlockBasedTable::kPartitionedFilterBlockPrefix</span><br><span class="line">                : BlockBasedTable::kFullFilterBlockPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 FilterPolicy 的名字</span></span><br><span class="line">    key.append(rep_-&gt;table_options.filter_policy-&gt;Name());</span><br><span class="line">    <span class="comment">// 添加元信息</span></span><br><span class="line">    meta_index_builder-&gt;Add(key, filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteIndexBlock"><a href="#WriteIndexBlock" class="headerlink" title="WriteIndexBlock"></a>WriteIndexBlock</h4><p>由前文可知，<code>IndexBuiler</code>对外提供了两种：</p><ul><li>HashIndexBuilder</li><li>PartitionIndexBuiler</li></ul><p>无论是哪种，最后的<code>index block</code>结果都是由 <code>IndexBuilder::IndexBlocks::index_block_contents</code> 保存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndexBuilder</span>:</span>:IndexBlocks &#123;</span><br><span class="line">  Slice index_block_contents;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Slice&gt; meta_blocks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>区别在于：</p><ul><li><code>PartitionIndexBuiler</code> 有很多个partition，而且这个partition的数量和 PartitionFilterBuilder 中的 partition 的数量一致。而<code>HashIndexBuilder</code>可等效的看做只有一个partition；</li><li><code>IndexBuilder::IndexBlocks::meta_blocks</code> 字段仅有<code>HashIndexBuilder</code>使用。</li></ul><p>因此，<code>WriteIndexBlock</code> 函数的最终目的也是将所有<code>partitions</code>的内容写入sst。写入sst的所有信息都记录在<code>index_block_handle</code>中，这用于后续的<code>footer</code>。</p><p>下面，带着上述理解，并顺着代码注释来阅读源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param index_block_handle 用于记录 partition 的信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::WriteIndexBlock</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    MetaIndexBuilder* meta_index_builder, BlockHandle* index_block_handle)</span> </span>&#123;</span><br><span class="line">  IndexBuilder::IndexBlocks index_blocks;</span><br><span class="line">  <span class="comment">// 可等效看做获取 first partition 的内容</span></span><br><span class="line">  <span class="keyword">auto</span> index_builder_status = rep_-&gt;index_builder-&gt;Finish(&amp;index_blocks);</span><br><span class="line">  <span class="keyword">if</span> (index_builder_status.IsIncomplete()) &#123;</span><br><span class="line">    <span class="comment">// meta_blocks 仅用于 HashIndexBuilder，在 PartitionIndexBuilder 下不支持</span></span><br><span class="line">    assert(index_blocks.meta_blocks.empty());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ok() &amp;&amp; !index_builder_status.ok()) &#123;</span><br><span class="line">    rep_-&gt;SetStatus(index_builder_status);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="comment">// 这一部分是针对 HashIndexBuilder</span></span><br><span class="line">    <span class="comment">// item: &#123;name, content&#125;</span></span><br><span class="line">    <span class="comment">//  + &#123;hashindex.prefixes, prefix_block_&#125;</span></span><br><span class="line">    <span class="comment">//  + &#123;&quot;rocksdb.hashindex.metadata&quot;, prefix_meta_block_&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : index_blocks.meta_blocks) &#123;</span><br><span class="line">      BlockHandle block_handle;</span><br><span class="line">      WriteBlock(item.second, &amp;block_handle, <span class="literal">false</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line">      <span class="keyword">if</span> (!ok()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      meta_index_builder-&gt;Add(item.first, block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这一部分是通用的</span></span><br><span class="line">  <span class="keyword">if</span> (ok()) &#123;</span><br><span class="line">    <span class="comment">// first patition </span></span><br><span class="line">    <span class="keyword">if</span> (rep_-&gt;table_options.enable_index_compression) &#123;</span><br><span class="line">      WriteBlock(index_blocks.index_block_contents, index_block_handle, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      WriteRawBlock(index_blocks.index_block_contents, kNoCompression,</span><br><span class="line">                    index_block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面是针对 PartitionIndexBuiler </span></span><br><span class="line">  <span class="keyword">if</span> (index_builder_status.IsIncomplete()) &#123;</span><br><span class="line">    Status s = Status::Incomplete();</span><br><span class="line">    <span class="keyword">while</span> (ok() &amp;&amp; s.IsIncomplete()) &#123;</span><br><span class="line">      <span class="comment">// index_block_handle 表示上一个 partition</span></span><br><span class="line">      s = rep_-&gt;index_builder-&gt;Finish(&amp;index_blocks, *index_block_handle);</span><br><span class="line">      <span class="keyword">if</span> (!s.ok() &amp;&amp; !s.IsIncomplete()) &#123;</span><br><span class="line">        rep_-&gt;SetStatus(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将每个partition写入sst文件</span></span><br><span class="line">      <span class="keyword">if</span> (rep_-&gt;table_options.enable_index_compression) &#123;</span><br><span class="line">        WriteBlock(index_blocks.index_block_contents, index_block_handle,</span><br><span class="line">                   <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        WriteRawBlock(index_blocks.index_block_contents, kNoCompression,</span><br><span class="line">                      index_block_handle);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The last index_block_handle will be for the partition index block</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteFooter"><a href="#WriteFooter" class="headerlink" title="WriteFooter"></a>WriteFooter</h4><p>最后就是写入footer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BlockBasedTableBuilder::WriteFooter</span><span class="params">(BlockHandle&amp; metaindex_block_handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         BlockHandle&amp; index_block_handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="keyword">bool</span> legacy = (r-&gt;table_options.format_version == <span class="number">0</span>);</span><br><span class="line">  assert(r-&gt;table_options.checksum == kCRC32c ||</span><br><span class="line">         r-&gt;table_options.format_version != <span class="number">0</span>);</span><br><span class="line">  <span class="function">Footer <span class="title">footer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      legacy ? kLegacyBlockBasedTableMagicNumber : kBlockBasedTableMagicNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">      r-&gt;table_options.format_version)</span></span>;</span><br><span class="line">  footer.set_metaindex_handle(metaindex_block_handle);</span><br><span class="line">  footer.set_index_handle(index_block_handle);</span><br><span class="line">  footer.set_checksum(r-&gt;table_options.checksum);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> footer_encoding;</span><br><span class="line">  footer.EncodeTo(&amp;footer_encoding);</span><br><span class="line">  assert(ok());</span><br><span class="line">  <span class="comment">// 最后在此写入</span></span><br><span class="line">  IOStatus ios = r-&gt;file-&gt;Append(footer_encoding);</span><br><span class="line">  <span class="keyword">if</span> (ios.ok()) &#123;</span><br><span class="line">    r-&gt;set_offset(r-&gt;get_offset() + footer_encoding.size());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r-&gt;SetIOStatus(ios);</span><br><span class="line">    r-&gt;SetStatus(ios);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BlockBasedTableBuilder-ParallelCompressionRep&quot;&gt;&lt;a href=&quot;#BlockBasedTableBuilder-ParallelCompressionRep&quot; class=&quot;headerlink&quot; title=&quot;Bl</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>Footer 格式</title>
    <link href="https://szza.github.io/2021/11/25/RocksDB/Table/builder/5_Footer/"/>
    <id>https://szza.github.io/2021/11/25/RocksDB/Table/builder/5_Footer/</id>
    <published>2021-11-25T06:15:35.000Z</published>
    <updated>2023-07-31T14:34:32.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Footer</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructs a footer without specifying its table magic number.</span></span><br><span class="line">  <span class="comment">// In such case, the table magic number of such footer should be</span></span><br><span class="line">  <span class="comment">// initialized via @ReadFooterFromFile().</span></span><br><span class="line">  <span class="comment">// Use this when you plan to load Footer with DecodeFrom(). Never use this</span></span><br><span class="line">  <span class="comment">// when you plan to EncodeTo.</span></span><br><span class="line">  Footer() : Footer(kInvalidTableMagicNumber, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use this constructor when you plan to write out the footer using</span></span><br><span class="line">  <span class="comment">// EncodeTo(). Never use this constructor with DecodeFrom().</span></span><br><span class="line">  Footer(<span class="keyword">uint64_t</span> table_magic_number, <span class="keyword">uint32_t</span> version);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The version of the footer in this file</span></span><br><span class="line">  <span class="function"><span class="keyword">uint32_t</span> <span class="title">version</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> version_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The checksum type used in this file</span></span><br><span class="line">  <span class="function">ChecksumType <span class="title">checksum</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> checksum_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_checksum</span><span class="params">(<span class="keyword">const</span> ChecksumType c)</span> </span>&#123; checksum_ = c; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The block handle for the metaindex block of the table</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> BlockHandle&amp; <span class="title">metaindex_handle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> metaindex_handle_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_metaindex_handle</span><span class="params">(<span class="keyword">const</span> BlockHandle&amp; h)</span> </span>&#123; metaindex_handle_ = h; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The block handle for the index block of the table</span></span><br><span class="line">  <span class="function"><span class="keyword">const</span> BlockHandle&amp; <span class="title">index_handle</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> index_handle_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_index_handle</span><span class="params">(<span class="keyword">const</span> BlockHandle&amp; h)</span> </span>&#123; index_handle_ = h; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">uint64_t</span> <span class="title">table_magic_number</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> table_magic_number_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">EncodeTo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>* dst)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the current footer based on the input slice.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// REQUIRES: table_magic_number_ is not set (i.e.,</span></span><br><span class="line">  <span class="comment">// HasInitializedTableMagicNumber() is true). The function will initialize the</span></span><br><span class="line">  <span class="comment">// magic number</span></span><br><span class="line">  <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(Slice* input)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Encoded length of a Footer.  Note that the serialization of a Footer will</span></span><br><span class="line">  <span class="comment">// always occupy at least kMinEncodedLength bytes.  If fields are changed</span></span><br><span class="line">  <span class="comment">// the version number should be incremented and kMaxEncodedLength should be</span></span><br><span class="line">  <span class="comment">// increased accordingly.</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    <span class="comment">// Footer version 0 (legacy) will always occupy exactly this many bytes.</span></span><br><span class="line">    <span class="comment">// It consists of two block handles, padding, and a magic number.</span></span><br><span class="line">    kVersion0EncodedLength = <span class="number">2</span> * BlockHandle::kMaxEncodedLength + <span class="number">8</span>,</span><br><span class="line">    <span class="comment">// Footer of versions 1 and higher will always occupy exactly this many</span></span><br><span class="line">    <span class="comment">// bytes. It consists of the checksum type, two block handles, padding,</span></span><br><span class="line">    <span class="comment">// a version number (bigger than 1), and a magic number</span></span><br><span class="line">    kNewVersionsEncodedLength = <span class="number">1</span> + <span class="number">2</span> * BlockHandle::kMaxEncodedLength + <span class="number">4</span> + <span class="number">8</span>,</span><br><span class="line">    kMinEncodedLength = kVersion0EncodedLength,</span><br><span class="line">    kMaxEncodedLength = kNewVersionsEncodedLength,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">uint64_t</span> kInvalidTableMagicNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// convert this object to a human readable form</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ToString</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// REQUIRES: magic number wasn&#x27;t initialized.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set_table_magic_number</span><span class="params">(<span class="keyword">uint64_t</span> magic_number)</span> </span>&#123;</span><br><span class="line">    assert(!HasInitializedTableMagicNumber());</span><br><span class="line">    table_magic_number_ = magic_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return true if @table_magic_number_ is set to a value different</span></span><br><span class="line">  <span class="comment">// from @kInvalidTableMagicNumber.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">HasInitializedTableMagicNumber</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (table_magic_number_ != kInvalidTableMagicNumber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">uint32_t</span> version_;</span><br><span class="line">  ChecksumType checksum_;</span><br><span class="line">  BlockHandle metaindex_handle_;</span><br><span class="line">  BlockHandle index_handle_;</span><br><span class="line">  <span class="keyword">uint64_t</span> table_magic_number_ = <span class="number">0</span>;</span><br><span class="line">&#125;; <span class="comment">// class Footer</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Footer&quot;&gt;&lt;a href=&quot;#Footer&quot; class=&quot;headerlink&quot; title=&quot;Footer&quot;&gt;&lt;/a&gt;Footer&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>基于vscode 打造C++编码环境</title>
    <link href="https://szza.github.io/2021/03/09/Tools/vscode/"/>
    <id>https://szza.github.io/2021/03/09/Tools/vscode/</id>
    <published>2021-03-09T03:40:15.000Z</published>
    <updated>2021-03-12T08:17:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>本期分享下自己的C++编码环境。自己目前C++编码环境是基于vscode打造的，再通过vscode远程登录到Linux（remote Linux）。对于Linux环境，可选方式有两种：</p><ul><li>WSL（<strong>W</strong>indows <strong>S</strong>ubsystem <strong>L</strong>inux）</li><li>虚拟机</li></ul><p>WSL有诸多好处，它可以和WINDOWs-10更为紧密地联系在一起。比如，随处按下快捷键：<code>shift + 右击</code>，都可以开启 <code>linux shell</code>，然后使用linux的命令来操作WINDOWs。</p><p><img src="./images/1.jpg"></p><p><img src="/images/2.jpg"></p><p>但是WSL也有不足，其中关于调试网络的工具一般是用不了，比如有：<code>tcpdump</code>，这个bug自从WSL诞生至今尚未解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tcpdump</span></span><br><span class="line">tcpdump: socket: Socket type not supported  # 无法启动</span><br><span class="line"><span class="meta">$</span><span class="bash"> date</span></span><br><span class="line">Sun Mar  7 22:01:11 CST 2021</span><br></pre></td></tr></table></figure><p>此时就需要借用虚拟机来完成相关操作。我自己的使用场景：</p><ul><li>WSL能满足要求时，基本都用WSL</li><li>当WSL无法满足时，就使用虚拟机</li></ul><p>当然，嫌麻烦完全可以仅使用虚拟机，除了无法在WINDOWs-10随处开启 <code>Linux shell</code>外，基本无差别。下面讲解下vscode怎么联合WSL / 虚拟机打造C++编码环境。</p><h3 id="vscode-WSL"><a href="#vscode-WSL" class="headerlink" title="vscode +  WSL"></a>vscode +  WSL</h3><ol><li><p>安装WSL。在微软官方文档中有安装WSL的详细教程，照着步骤安装即可。地址：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;docs.microsoft.com&#x2F;zh-cn&#x2F;WINDOWs&#x2F;wsl&#x2F;install-win10</span><br></pre></td></tr></table></figure></li><li><p>vscode安装<code>Remote-WSL</code>插件。打开vscode，按快捷键：<code>ctr + shift + X</code> 或者直接点击左侧栏的<code>Extensions</code>，然后在插件商店里，搜索并安装  <code>Remote-WSL</code> 插件：</p><p><img src="/images/4.jpg"></p></li><li><p>在正式介绍之前，先介绍一个vscode的快捷键：<code>ctr + shift + p</code>。按下后，会显示出一个对话框（如下图），可以在里面输入一些命令来设置vscode的相关选项。</p><p><img src="/images/3.jpg"></p><p> 此时，在对话框中输入<code>Remote-WSL</code>，下方列表会显示相关的选项，选择第一个<code>Remote-WSL:New WINDOWs</code>：</p><p><img src="/images/5.jpg"></p><p>不需要任何配置、输入密码的过程，就自动进入<code>WSL</code>环境中：在左下角的状态栏中会有个<code>WSL:Ubuntu-x</code>的标志，表示你进入了WSL环境，此时按下快捷键：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr + &#96;   # 注意后面还有个 &#96;</span><br></pre></td></tr></table></figure><p>可以直接唤起终端，比如图中的<code>TERMINAL</code>：</p><p><img src="/images/6.jpg"></p></li><li><p>安装编译、调试等必要软件。到此，vscode环境已经基本配置完毕。此时WSL里什么软件也没有，连基本的make命令都不支持，需要自己手动安装C++编译器、调试器：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc&#x2F;g++ ： &#96;sudo apt install g++&#96;</span><br><span class="line">make：&#96;sudo apt install make&#96;</span><br><span class="line">cmake：&#96;sudo apt install cmake&#96;</span><br><span class="line">gdb：&#96;sudo apt install gdb&#96;</span><br></pre></td></tr></table></figure><p>由于vscode本身就可以当作一个终端来使用，因此进入WSL环境后，直接在vscode-terminal中输入上述安装命令。由于我已经安装了上述软件，因此继续安装会显示如下：</p><p><img src="/images/7.jpg"></p></li><li><p>创建文件夹。下面先写简单的demo测试下怎么继续使用。先创建一个名字是<code>demo</code> 的文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">szza@szza:~$ mkdir demo</span><br><span class="line">szza@szza:~$ <span class="built_in">cd</span> demo/</span><br><span class="line">szza@szza:~/demo$ </span><br></pre></td></tr></table></figure><p>那么怎么打开刚刚创建的<code>demo</code>文件夹？方法有两种：</p><p><strong>1）</strong> 直接点击vscode左侧的  <code>Open Folder</code>按钮，然后选择刚才创建的<code>/home/szza/demo</code>文件夹即可。</p><p><img src="/images/8.jpg"></p><p><strong>2）</strong> 按下快捷键<code>ctr + shift + P</code>，再输入 <code>Open Folder</code>，再选择<code>home/szza/demo</code>文件夹即可。</p><p><img src="/images/9.jpg"></p></li><li><p>安装C++相关插件。</p><ul><li>C/C++</li><li>C++ Intellisense</li><li>Visual Studio Intellisense</li><li>Visual Studio Intellisense Insider</li></ul><p><img src="/images/10.jpg"></p><p>这样在写C++代码时，才会智能提示、调整等一些列功能。上述是基本插件，其他的插件可以自己多去探索发现。写完一个demo，就可以直接在<code>TERMINAL</code>上运行编译，结果如下：</p><p><img src="/images/11.jpg"></p></li></ol><p>到此，从安装WSL到在WSL中编译运行一个cpp程序，大致讲解完毕，整个过程基本没有配置、便于使用。可能你发现了，是不是还缺少一个环节：debug。</p><p>由于在上面步骤【5】中，已经安装了<code>gdb</code>调试软件。如果你会gdb，那么就可以直接使用gdb进行调试了。如果不熟悉，可以自己先行学习，也可以等等我，关于gdb调试的文章我准备等毕业答辩结束再来做个专题吧。回想自己在阅读开源项目redis6.0、libuv时，都是靠gdb帮我理清了回调函数链路。</p><h3 id="虚拟机-vscode"><a href="#虚拟机-vscode" class="headerlink" title="虚拟机 +  vscode"></a>虚拟机 +  vscode</h3><p>继续提供一个【虚拟机+vscode】的方案，最终可以实现和WSL几乎一致的体验。顺便提一下，WINDOWs-10 20H1之前，是不允许同时开启WSL和虚拟机，必须要升级到WINDOWs-10 20H1版本及其之后，才能同时开启。</p><p>关于虚拟机，本文以Ubuntu为准。至于怎么安装虚拟机不介绍了，上网搜索一下即可。</p><h4 id="开启SSH服务"><a href="#开启SSH服务" class="headerlink" title="开启SSH服务"></a>开启SSH服务</h4><p>个人建议：图方便可以直接安装<code>Ubuntu-Studio 2020</code>，它包含了常用的编译器和软件，不用自己去下载和安装了，比较省事，相对也比较稳定。我自己安装的<code>Ubuntu-2020</code>简洁版的虚拟机经常断开链接，但是我同学的又没事。</p><p>查看虚拟机的IP地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.183.130  netmask 255.255.255.0  broadcast 192.168.183.255</span><br><span class="line">        inet6 fe80::e8ab:d905:32f5:729e  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:cb:4a:97  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 575  bytes 452238 (452.2 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 446  bytes 150254 (150.2 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 337  bytes 259455 (259.4 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 337  bytes 259455 (259.4 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>如果是安装的是简洁版，可能连<code>ifconfig</code>命令都不支持，那么需要安装网络工具：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt instal net-tools</span><br></pre></td></tr></table></figure><p>在安装<code>SSH</code>服务之前，先使用<code> ps  -e | grep ssh</code>命令查看自己的虚拟机上是否已经安装了<code>SSH</code>服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -e | grep ssh</span><br><span class="line">1017 ?        00:00:00 sshd<span class="comment"># OK</span></span><br><span class="line">1294 ?        00:00:00 ssh-agent</span><br><span class="line">1757 ?        00:00:00 sshd</span><br><span class="line">1836 ?        00:00:00 sshd</span><br></pre></td></tr></table></figure><p>否则，下面开始安装、启动SSH服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install openssh-server<span class="comment"># 安装SSH服务</span></span><br><span class="line">$ sudo service ssh start     <span class="comment"># 启动SSH服务</span></span><br></pre></td></tr></table></figure><p>对于之前没有开启SSH服务的，现在可以再次查看是否启动<code>SSH</code>服务了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -e | grep ssh</span><br><span class="line">1017 ?        00:00:00 sshd</span><br><span class="line">1294 ?        00:00:00 ssh-agent</span><br><span class="line">1757 ?        00:00:00 sshd</span><br><span class="line">1836 ?        00:00:00 sshd</span><br></pre></td></tr></table></figure><p>到此，SSH服务器已经开启，下面讲解怎么从vscode remote到虚拟机中。</p><h4 id="vscode链接虚拟机"><a href="#vscode链接虚拟机" class="headerlink" title="vscode链接虚拟机"></a>vscode链接虚拟机</h4><ol><li><p>在<code>Extensions</code>中，安装<code>Remote-SSH</code>插件</p></li><li><p>按住快捷键：<code>ctr + shift + P</code>，在对话中输入：<code>connect</code>，然后选择第一个<code>Remote-SSH:Connect to Host</code>选项即可：</p><p><img src="/images/12.jpg"></p></li><li><p>配置虚拟机的IP和端口。在步骤【2】后，会弹出下面的窗口。</p><ul><li>如果你已经连接过虚拟机，那么该虚拟机的IP地址会直接呈现下面。如果确定虚拟机是开启的，那么可以以直接连接即可。</li><li>否则，就需要添加新的虚拟机配置，有两种添加方法：<code>Add New SSH Host</code>选项是引导用户完成<code>Configure SSH Hosts...</code>选项，因此本文直接讲解<code>Configure SSH Hosts...</code>选项。这个选项是直接将虚拟<code>IP</code>地址到配置<code>C:\Users\szza\.ssh\config</code>文件中，极其方便。</li></ul><p><img src="/images/13.jpg"></p><p><img src="/images/14.jpg"></p><p>在<code>C:\Users\szza\.ssh\config</code>文件中，添加虚拟机的信息：</p><p><img src="/images/15.jpg"></p><p>设置好后，重复【2】的步骤，再次向虚拟机发起连接，就会发现自己新添加的虚拟机信息已经显示在下方了，直接点击连接即可：</p><p><img src="/images/16.jpg"></p><p>然后进入下面的界面，输入虚拟机的登录密码即可：</p><p><img src="/images/17.jpg"></p><p>输入完毕，则会进入虚拟机的Linux系统，到此连接任务就算完成了。至于该安装的软件和WSL的步骤【5】【6】【7】一致，按照步骤走即可。</p></li></ol><h4 id="免密登录虚拟机"><a href="#免密登录虚拟机" class="headerlink" title="免密登录虚拟机"></a>免密登录虚拟机</h4><p>vscode连接WSL是不需要输入密码，后续任何操作也不需要输入密码。但是vscode和虚拟机的任何操作每次都需要输入密码，就会很影响使用体验，下面讲解如何免密登录虚拟机。</p><p><strong>1）WINDOWs侧</strong></p><p>首先在WINDOWs上的vscode终端上，输入如下的命令，其中<code>&quot;这里任意输入&quot;</code>部分建议使用github账号的邮箱。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;这里任意输入&quot;</span></span><br></pre></td></tr></table></figure><p>一直按<code>enter</code>即可，最终会在<code>C:\Users\szza\.ssh</code>目录下，生成两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id_rsa</span><br><span class="line">id_rsa.pub</span><br></pre></td></tr></table></figure><p><strong>2） 虚拟机侧</strong></p><p>在vscode的虚拟终端中输入同样的命令，在<code>/home/codespace/.ssh</code>文件下也会生成<code>id_rsa</code> 和<code>id_rsa.pub</code>文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;这里任意输入&quot;</span></span><br></pre></td></tr></table></figure><p>然后在<code>/home/codespace/.ssh</code>文件下，新建一个文件，名字是<code>authorized_keys</code>，直接将WINDOWs侧目录<code>C:\Users\szza\.ssh</code>下的<code>id_rsa.pub</code>文件内容复制到<code>authorized_keys</code>中，整个免密设置就完成了。</p><p><strong>by the way</strong></p><p>如何将WINDOWs侧的<code>C:\Users\szza\.ssh\id_rsa.pub</code>文件内容复制到虚拟机的<code>/home/codespace/.ssh/authorized_keys</code>中？？？很简单，分别用vscode打开两个文件夹，然后直接复制即可，不需要安装<code>VMWare Tools</code>就能完成。</p><p><img src="/images/18.jpg"></p><p>这个方式，也适用于想将WINDOWs的文件传输到虚拟机中，用vscode打开WINDOWs侧的文件，另一个vscode连接上虚拟机并打开到相应的文件夹，直接复制文件。</p><p>到此，整个vscode免密登录虚拟机的过程讲解完毕，以后任何操作都不需要输入密码了。</p><h4 id="过程中可能出现的问题"><a href="#过程中可能出现的问题" class="headerlink" title="过程中可能出现的问题"></a>过程中可能出现的问题</h4><p>vscode +WSL一般都没啥问题，都是WINDOWs原生产品。在remote到虚拟机时，可能会出现问题，我之前遇到过vscode一直连接不上虚拟机，发现是WINDOWs自带的<code>SSH-Client</code>有问题，自己下载一个<code>git</code>客户端，然后重复上述配置，就完成了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本期分享下自己的C++编码环境。自己目前C++编码环境是基于vscode打造的，再通过vscode远程登录到Linux（remote Linux）。对于Linux环境，可选方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WSL（&lt;strong&gt;W&lt;/strong&gt;indows &lt;s</summary>
      
    
    
    
    <category term="工具使用" scheme="https://szza.github.io/categories/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
    
    <category term="必先利其器" scheme="https://szza.github.io/tags/%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>再探值与引用：函数模板的类型推导规则辨析</title>
    <link href="https://szza.github.io/2021/03/04/C++/ref/"/>
    <id>https://szza.github.io/2021/03/04/C++/ref/</id>
    <published>2021-03-04T08:21:51.000Z</published>
    <updated>2022-02-14T13:37:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <a href="https://szza.github.io/2021/03/04/C++/reference/">初探值与引用：学会正确地使用右值引用</a> 一文中，讲解了右值引用的正确用法。本节继续在前文基础上，讲解值与引用在模板函数中的关系。</p><p>在C++11中，有三种引用类型：</p><ul><li><code>const T&amp;</code>：const 左值引用</li><li><code>T&amp;</code>：非const的左值引用</li><li><code>T&amp;&amp;</code>：右值引用</li></ul><p>在非模板函数中，常常使用引用类型来作为参数类型，以避免不必要的赋值。但是在模板函数中，却并不总是建议使用引用类型作为模板参数类型，应优先选择值传递，除非遇到以下情况：</p><ul><li>对象不允许复制：即拷贝构造函数加上<code>=delete</code>或设置为<code>private</code>；</li><li>对象用于返回数据（<code>T&amp;</code>）；</li><li>转发引用（<code>T&amp;&amp;</code>）；</li><li>引用传递可以获得明显的性能提升。</li></ul><h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><p>引用传递是为了避免复制，但是值传递也不一定就会发生copy。</p><p>基于【初探右值引用】中的Foo类，有如下按值传递的模板函数<code>pass_by_value</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_value</span><span class="params">(Foo arg)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    pass_by_value(Foo&#123;<span class="number">100</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也许你认为<code>pass_by_value(Foo&#123;100&#125;);</code>会调用一次默认构造函数 + 一次<code>ctor</code>，但实际上在C++11之后，编译器发生了优化只是会调用一次默认构造函数，禁止了优化则会调用一次构造函数 + 一次<code>mtor</code>。输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> g++ reference.cc -o ref &amp;&amp; ./ref<span class="comment"># 默认情况</span></span></span><br><span class="line">default</span><br><span class="line"><span class="meta">$</span><span class="bash"> g++ -fno-elide-constructors reference.cc -o ref &amp;&amp; ./ref  <span class="comment"># 禁止编译器优化</span></span></span><br><span class="line">default</span><br><span class="line">mtor</span><br></pre></td></tr></table></figure><p>说明，当模板参数<code>T</code>具有移动构造函数时，即便是按照值传递也会优先调用移动构造函数，那么这种情况下值传递性能也并没有发生损失。</p><p>即使对于比较复杂的类型<code>std::string</code>，由于<code>std::string</code>也实现了移动构造函数，因此使用<code>std::string</code>来实例化<code>pass_by_value</code>函数也是一样的情况：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str&#123;<span class="string">&quot;hello Cpp&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">pass_by_value(<span class="built_in">std</span>::move(str));<span class="comment">// 默认优化；禁止优化则触发移动构造函数</span></span><br><span class="line">pass_by_value(<span class="built_in">std</span>::<span class="built_in">string</span>&#123;<span class="string">&quot;pass_by_move&quot;</span>&#125;); <span class="comment">// 默认优化；禁止优化则触发移动构造函数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;str.length()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;<span class="comment">// 输出 0 </span></span><br></pre></td></tr></table></figure><ul><li><p>对于纯右值<code>std::string&#123;&quot;pass_by_move&quot;&#125;</code>：传入<code>pass_value_by</code>函数时，无论是否开启优化，都不会产生性能损失。甚至在C++17中，强制实现优化，省去中间的移动构造函数，即不加 <code>-fno-elide-constructors</code> 编译标志都不会有移动构造的过程，仅一次默认构造函数，就类似上面<code>pass_by_value(Foo&#123;100&#125;);</code>输出。</p></li><li><p>对于已经存在的<code>std::string</code>对象<code>str</code>，如果确认不再使用<code>str</code>，则以<code>std::move(obj)</code>形式传入，告知编译器调用移动构造函数，因此也不会有性能损失。</p></li></ul><p><strong>by the way</strong></p><ul><li><p><code>std::move(str)</code>之后<code>str</code>的值就处于未定义状态，不可再使用，除非再次初始化。</p></li><li><p>如果 <code>str</code> 有<code>const</code>修饰，经过<code>std::move</code>转换也无法触发移动构造函数。为什么？</p><p>因为 <code>pass_by_value(std::string arg)</code>本质上就是如下一个初始化过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> str_const &#123;<span class="string">&quot;hello Cpp&quot;</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> arg&#123;<span class="built_in">std</span>::move(str_const)&#125;;</span><br></pre></td></tr></table></figure><p>没有加上<code>const</code>修饰时，<code>static_cast</code>是可以将左值<code>str</code>转化为右值，触发移动构造函数。</p><p>当加上<code>const</code>修饰时，<code>static_cast</code>就不管用了，因为这中间设计到了两个步骤：1）先将<code>const</code>修饰符去掉，这是<code>const_cast</code>的任务，不是<code>static_cast</code>的；2）才是将左值转换为右值。第一步就失败了。因此，加上const修饰时无法调用移动构造函数。</p><p>进一步，尝试如下类型转换，直接查看编译器错误，会报错：*error: binding reference of type ‘std::string&amp;&amp;’ to ‘const std::string’*。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv = <span class="built_in">std</span>::move(str_const);</span><br></pre></td></tr></table></figure><p>但是如果你将鼠标放在<code>pass_by_value(std::move(str_const));</code>函数上，可以发现IDE显示推断出来的类型是<code>std::string</code>。这又是为什么呢？？？</p><p>答案是类型退化，这是接下来<strong>类型退化</strong>知识。</p></li></ul><p>上述总结，在模板函数以值传递时，只有一种情况会产生复制：若对象<code>obj</code>已经存在，再调用<code>pass_by_value(obj)</code>才会产生复制，那么有没有可以解决的办法，由调用者决定不复制呢？答案是 <code>pass_by_value(std::ref(obj))</code>。</p><p>因此，在值传递时，调用者可以自主选择是否复制、移动，具有很大便利性。</p><p><strong>类型退化</strong></p><p>值传递还有一个重要特性，会导致参数类型<code>T</code>发生退化：</p><ul><li>C-style的裸数组、字符串常量会退化成指针</li><li>变量的<code>const</code>和<code>volatile</code>修饰符会自动消失，指针变量除外。</li><li><strong>引用会退化成普通类型</strong></li></ul><p>第二条也解释了为什么类型是<code>const std::string</code>的<code>str_const</code>传入<code>pass_by_value</code>函数后推断为<code>std::string</code>类型。</p><p>现有如下的demo：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span>  a = <span class="number">10</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span> b = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">char</span>* ch = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">int</span>*  pa = &amp;a;</span><br><span class="line">   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; str_const_ref = str_const;</span><br><span class="line"></span><br><span class="line"><span class="comment">// const 退化</span></span><br><span class="line">   pass_by_value(a);  <span class="comment">// 退化成：int</span></span><br><span class="line">   pass_by_value(b);  <span class="comment">// 退化成: char</span></span><br><span class="line">   <span class="comment">// 数组退化成指针</span></span><br><span class="line">   pass_by_value(<span class="built_in">array</span>); <span class="comment">// const int*</span></span><br><span class="line">   pass_by_value(ch);    <span class="comment">// const char*</span></span><br><span class="line"><span class="comment">// 指针的const不退化</span></span><br><span class="line">   pass_by_value(pa);    <span class="comment">// const int*</span></span><br><span class="line"><span class="comment">// 引用退化</span></span><br><span class="line">   pass_by_value(str_const_ref);<span class="comment">// !!! 退化成：const std::string&amp; --&gt; std::string</span></span><br></pre></td></tr></table></figure><ul><li><p><code>const</code>除了修饰指针，其余都会退化掉</p><p>但是可以发现特列：如果<code>const</code>修饰裸数组是不会退化的，这是为啥？因为裸数组会退化成指针，<code>const</code>修饰指针不会退化，使得<code>const</code>修饰数组时就推导出<code>const T*</code></p></li><li><p>引用会退化成普通类型。</p><p>即使是<code>const T&amp;</code>也会退化成<code>T</code></p></li></ul><p>思考下参数退化会带来什么问题？</p><h2 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h2><p>引用传递，与值传递则相反：</p><ul><li>任何情况下都不会造成copy</li><li>不会造成模板参数类型退化</li></ul><p>下面对三种引用类型进行说明。</p><h3 id="const-T-amp"><a href="#const-T-amp" class="headerlink" title="const T&amp;"></a>const T&amp;</h3><p><code>const T&amp;</code> 引用类型：既可以接受左值，也可以接受右值。</p><p>假定存在<code>pass_by_const_ref</code>函数，参数<code>arg</code>是<code>const T&amp;</code>引用类型，在函数内部打印传入的<code>arg</code>对象地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_const_ref</span><span class="params">(<span class="keyword">const</span> T&amp; arg)</span> </span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;arg&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Foo foo&#123;<span class="number">10</span>&#125;;<span class="comment">// 调用构造函数</span></span><br><span class="line">    pass_by_const_ref(foo);</span><br><span class="line">    pass_by_const_ref(<span class="built_in">std</span>::move(foo));</span><br><span class="line">    pass_by_const_ref(Foo&#123;<span class="number">100</span>&#125;); <span class="comment">// 调用构造函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的输出打印如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ g++ reference.cc -o ref &amp;&amp; .&#x2F;ref</span><br><span class="line">default</span><br><span class="line">0x7fffd68902c0</span><br><span class="line">0x7fffd68902c0</span><br><span class="line">default</span><br><span class="line">0x7fffd68902c4</span><br></pre></td></tr></table></figure><p>一共进行了两次构造函数，没有发生copy，符合预期。而且前两次调用<code>pass_by_const_ref</code>函数打印的地址都一致，是因为<code>arg</code>都是指向了<code>foo</code>，但是第三次调用打印的地址增加了4个字节，是因为临时对象<code>Foo&#123;100&#125;</code>和<code>foo</code>在同一个连续的栈空间中，而<code>Foo</code>类大小只有四个字节（只有一个<code>int</code>类型成员变量<code>num_</code>）。</p><p>因此，<code>const T&amp;</code>引用类型，无论传入左值还是右值，都不会发生copy。</p><p><strong>类型不退化</strong></p><p>同样以值传递中退化，传入<code>pass_bt_const_ref</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  pass_by_const_ref(str_const); <span class="comment">// const std::string&amp;</span></span><br><span class="line">  pass_by_const_ref(a);         <span class="comment">// const int&amp; </span></span><br><span class="line">  pass_by_const_ref(b);         <span class="comment">// const char&amp; </span></span><br><span class="line">  pass_by_const_ref(<span class="built_in">array</span>);     <span class="comment">// const int(&amp;)[4]</span></span><br><span class="line">  pass_by_const_ref(ch);        <span class="comment">// const char* const &amp;</span></span><br><span class="line">  pass_by_const_ref(pa);        <span class="comment">// const int* </span></span><br><span class="line">pass_by_const_ref(str_ref_const); <span class="comment">// const std::string&amp;</span></span><br></pre></td></tr></table></figure><p>分析如下：</p><ul><li><code>pass_by_const_ref</code>函数，传入<code>const std::string</code>类型的对象<code>str_const</code>时，<code>arg</code>推理为<code>const std::string&amp;</code>，没有发生类型退化。其中，<code>T</code>被推理为<code>std::string</code>，<code>const</code>由于出现在<code>pass_by_const_ref</code>函数的模板参数中，因此不会出现在<code>T</code>中；</li><li><code>array</code>也是被推断为<strong>固定长度类型</strong>的<code>const int[&amp;][4]</code>，而不是单纯的指针<code>const int*</code>；</li><li><code>ch</code>被推断为 <code>const char* const&amp;</code>：<code>ch</code>原本类型是<code>const char*</code>，表示无法修改<code>ch</code>指向的字符值，但是可以修改<code>ch</code>值，即可以执行<code>++ch</code>这类操作，而<code>pass_by_const_ref</code>函数给<code>ch</code>加上了一个<code>const</code>修饰，使得<code>ch</code>本身的值也无法修改，即<code>const char* const</code>。</li></ul><p>因此，<code>const T&amp;</code>，不会退化模板参数T的类型，反而会加强没有const修饰的输入参数的类型。</p><p><strong>by the way</strong></p><p>即使<code>pass_by_const_ref</code>函数，可以接受常量，比如<code>pass_by_const_ref(Foo&#123;100&#125;)</code>，但是如果<code>pass_by_const_ref</code>内部如下，最终触发的也是复制构造函数。</p><p>或者，<code>arg</code>被用于其他函数<code>xxxx_func(arg)</code>的参数，也是触发<code>const Foo&amp;</code>版本，而不是<code>Foo&amp;&amp;</code>函数版本。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_const_ref</span><span class="params">(<span class="keyword">const</span> T&amp; arg)</span> </span>&#123; </span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(arg)</span></span>;</span><br><span class="line">    <span class="comment">// xxx_func(arg);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T-amp"><a href="#T-amp" class="headerlink" title="T&amp;"></a>T&amp;</h3><p>假定有<code>pass_by_lv_ref</code>函数，以<code>T&amp;</code>为模板参数类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_lv_ref</span><span class="params">(T&amp; arg)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//...   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>T&amp;</code> 与 <code>const T&amp;</code>区别有两点：</p><ol><li><p><code>pass_by_lv_ref</code>函数可以修改<code>arg</code>参数，并且修改后的<code>arg</code>值可以传递给<code>pass_by_lv_ref</code>函数的调用者，避免了return返回。</p></li><li><p><code>T&amp;</code> 不能接受右值，但如果先以<code>const T</code>类型的变量<code>var</code>指向一个<code>T</code>类型的常量，再把<code>var</code>传递给<code>pass_by_ref</code>函数是允许的。</p><p> 如果直接给<code>pass_by_ref</code>函数传递右值，则报错：<em>error: cannot bind non-const lvalue reference of type ‘std::string&amp;’ to an rvalue of type ‘std::string’</em>。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    pass_by_lv_ref(<span class="built_in">std</span>::<span class="built_in">string</span>&#123;<span class="string">&quot;temp value&quot;</span>&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果传入 <code>pass_by_lv_ref</code>函数的参数就带有<code>const</code>修饰，那么将会把<code>arg</code>推导为<code>const</code>类型引用，且这个<code>const</code>修饰符是出现在<code>T</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pass_by_lv_ref(str_const);<span class="comment">// 推导为：const std::string&amp;</span></span><br><span class="line">pass_by_lv_ref(<span class="built_in">std</span>::move(str_const));  <span class="comment">// 推导为：const std::string&amp;</span></span><br></pre></td></tr></table></figure><p><font color=red>但是!!!</font> <code>pass_by_lv_ref</code>函数内部默认<code>arg</code>是可以修改的。当<code>pass_by_lv_ref</code>函数接受了const类型变量，<code>arg</code>被推导为<code>const T&amp;</code>，变成只能读，那么就会导致一个问题：如果在<code>pass_by_lv_ref</code>函数内部修改<code>str_const</code>、<code>ch</code>等const修饰的传入参数，将会编译报错。</p><p>怎么办？</p><p> 在C++20之前，使用<code>std::enable_if_t</code>，直接禁止给<code>pass_by_lv_ref</code>函数传入const类型变量。此时，给 <code>pass_by_lv_ref</code> 函数传递const类型变量，在IDE中这个函数下方出现红色波浪线，提示不存在这个函数，就不需要等到编译期才发现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt; !<span class="built_in">std</span>::is_const&lt;T&gt;::value&gt;&gt;</span><br><span class="line"><span class="keyword">void</span> pass_by_lv_ref(T&amp; arg) &#123; </span><br><span class="line"> <span class="comment">//...  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="T-amp-amp"><a href="#T-amp-amp" class="headerlink" title="T&amp;&amp;"></a>T&amp;&amp;</h3></li></ol><p><code>T&amp;&amp;</code>，即右值引用模板化，此时的类型推导原则是：<strong>引用折叠</strong>。</p><p>假定有<code>pass_by_perfect_ref</code>函数，如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_perfect_ref</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// ... std::forward&lt;T&amp;&amp;&gt;(arg)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>依赖于引用折叠，<code>pass_by_perfect_ref</code>函数能推导出任意类型的输入参数。此时在<code>pass_by_perfect_ref</code>函数内部就能知道传入的参数是什么类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pass_by_perfect_ref(str);           <span class="comment">// 左值推导为：string&amp;，</span></span><br><span class="line">pass_by_perfect_ref(str_const);     <span class="comment">// const 左值：const string&amp;    </span></span><br><span class="line">pass_by_perfect_ref(str_ref_const); <span class="comment">// const 左值：const string&amp;    </span></span><br><span class="line">pass_by_perfect_ref(<span class="built_in">std</span>::<span class="built_in">string</span>&#123;<span class="string">&quot;hello perfect_ref&quot;</span>&#125;); <span class="comment">// 右值：std::string&amp;&amp; </span></span><br><span class="line">pass_by_perfect_ref(<span class="built_in">std</span>::move(str));                   <span class="comment">// 右值：std::string&amp;&amp;</span></span><br></pre></td></tr></table></figure><p>一般地，当模板函数使用<code>T&amp;&amp;</code>作为参数类型时，函数内部需使用<code>std::forward&lt;T&amp;&amp;&gt;(arg)</code>来转发输入参数，目的就是为了保持住输入参数的原来类型。</p><p>下面先讲解下<code>forward</code>函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于接收 const T&amp;、T&amp;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(<span class="keyword">__t</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用于接收 T&amp;&amp;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;T&gt;::type&amp;&amp; <span class="keyword">__t</span>)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference&lt;T&gt;::value, </span><br><span class="line">                <span class="string">&quot;template argument substituting _Tp is an lvalue reference type&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp&amp;&amp;&gt;(<span class="keyword">__t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>当<code>forward</code>函数的输入参数是 <code>const T&amp;</code>类型时，</p><ul><li><code>std::remove_reference</code>函数会消去<code>T</code>的引用，变成<code>const T</code>，那么<code>forward</code>函数的<code>__t</code>类型即 <code>const T&amp;</code></li><li>再经过<code>static_cast&lt;const T&amp;&amp;&amp;&gt;(_t)</code>，其中目的类型是<code>const T&amp;&amp;&amp;</code>，经引用折叠变成<code>const T&amp;</code></li></ul><p>因此，当输入类型是<code>const T&amp;</code>时，输出还是这个类型</p></li><li><p>当<code>forward</code>函数的输入是<code>T&amp;</code>类型时，分析同上，输出还是<code>T&amp;</code></p></li><li><p>当<code>forward</code>函数的输入是<code>T</code>或者<code>T&amp;&amp;</code>类型时，经过<code>std::remove_reference</code>函数都会变成<code>T</code>类型，再经过<code>static_cast&lt;T&amp;&amp;&gt;</code>转换，都变成<code>T&amp;&amp;</code>。</p><p>右值传递到<code>pass_by_perfect_ref</code>函数时，<code>arg</code>指向的是右值，但<code>arg</code>本身是左值，如果不经过<code>std::forward</code>转换，<code>arg</code>将以左值角色参与后续操作，违背了调用者意图。</p></li></ol><p>因此<code>std::forward</code>函数，搭配模板使用时，比如上面的 <code>pass_by_perfect_ref</code> 函数，<code>arg</code>无论传递给<code>std::forward</code>什么类型，<code>std::forward</code>都能输出相同的类型。因此，<code>std::forward&lt;T&amp;&amp;&gt;(arg)</code>可以触发以<code>arg</code>对象为参数的最合适、正确的的函数，或者构造函数：</p><ul><li>如果<code>arg</code>是作为其他函数的参数，那么<code>std::forward&lt;T&amp;&amp;&gt;(arg)</code>则是为了调用该函数的正确模板</li><li>如果<code>arg</code>是作为同类型的构造函数的参数，那么<code>std::forward&lt;T&amp;&amp;&gt;(arg)</code>就是为了调用正确的构造函数版本。</li></ul><p>因此，对于下面的demo，<code>pass_by_perfect_ref</code>能正确推断出输入参数<code>arg</code>的类型，将<code>arg</code>传给<code>std::forward</code>时，仍然能保持原类型，这就保证了合理的调用后续函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pass_by_perfect_ref(str_const); <span class="comment">// const string&amp;    </span></span><br><span class="line">pass_by_perfect_ref(str);       <span class="comment">// string&amp;</span></span><br><span class="line">pass_by_perfect_ref(<span class="built_in">std</span>::<span class="built_in">string</span>&#123;<span class="string">&quot;hello perfeect ref&quot;</span>&#125;); <span class="comment">// std::string&amp;&amp; </span></span><br></pre></td></tr></table></figure><p><strong>by the way</strong></p><p>提一下，<code>std::forward</code>与<code>std::move</code>的区别，再理解下<code>std:forward</code>的完美转发的含义。</p><p>有<code>pass_by_perfect_ref</code>和<code>pass_by_move_ref</code>两个函数，内部分别是调用<code>std::forward</code>和<code>std::move</code>进行转发后，再用于构造<code>Foo</code>对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_perfect_ref</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; </span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="built_in">std</span>::forward&lt;T&amp;&amp;&gt;(arg))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_move_ref</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; </span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="built_in">std</span>::move(arg))</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于下面的函数调用，都是将左值<code>foo</code>作为传入参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Foo foo&#123;<span class="number">10</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    pass_by_perfect_ref(foo);</span><br><span class="line">    pass_by_move_ref(foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出却不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ reference.cc -o ref &amp;&amp; .&#x2F;ref</span><br><span class="line">default</span><br><span class="line">ctor</span><br><span class="line">mtor</span><br></pre></td></tr></table></figure><p><code>std::forward&lt;T&amp;&amp;&gt;(arg)</code> 输出后<code>arg</code>仍然是左值角色，最后调用的是<code>Foo</code>的复制构造函数，这也符合调用<code>pass_by_perfect_ref</code>函数调用者的预期，因为自己传入的就是<code>foo</code>，就是想要触发<code>ctor</code>。</p><p><code>std::move(arg)</code>输出后<code>arg</code>变成右值角色，最后调用的是<code>Foo</code>的移动构造函数，这会导致<code>pass_by_move_ref</code>函数的调用者传入的<code>foo</code>对象处于未定义状态，这符合调用者的预期吗？明显不是。</p><p>对于调用者而言，是否要触发移动构造函数，应该由于调用调用者自己掌控：</p><ul><li>想触发复制构造函数时，就如下（1）调用</li><li>想触发移动构造函数时，就如下（2）调用</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pass_by_perfect_ref(foo);<span class="comment">// (1)</span></span><br><span class="line">pass_by_perfect_ref(<span class="built_in">std</span>::move(foo)); <span class="comment">// (2)</span></span><br></pre></td></tr></table></figure><p>这也就是经常各个书籍上看到将<code>std::move</code>称为无条件转发，而<code>std::forward</code>是完美转发的理由。</p><p><strong>by the way, Again !!!</strong></p><p>还记得在本文开篇说，模板函数不选择值传递的四种情况之一是：<code>转发引用(T&amp;&amp;)</code>。现在理解了一点没有？</p><p>因为在<code>T&amp;&amp;</code>下，<code>pass_by_perfect_ref</code>可以推导出任意类型的输入参数，调用合适的函数版本。这一过程像值传递一样，完全可以由调用者掌握。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用者自己可以选择</span></span><br><span class="line">pass_by_perfect_ref(foo);</span><br><span class="line">pass_by_perfect_ref(<span class="built_in">std</span>::move(foo));</span><br><span class="line">pass_by_perfect_ref(FOO&#123;<span class="number">10</span>&#125;); </span><br></pre></td></tr></table></figure><p><strong>T&amp;&amp;也不会退化</strong></p><p>自然，<code>T&amp;&amp;</code>引用也不会发生类型退化，传入的裸数组参数<code>arg</code>是什么类型就会变成相应类型的引用，不会加强也不会退化，类似于<code>T&amp;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pass_by_perfect_ref(<span class="string">&quot;hello perfect_ref&quot;</span>);  <span class="comment">// const char (&amp;rhs)[18]</span></span><br><span class="line">pass_by_perfect_ref(<span class="built_in">array</span>);                <span class="comment">// const int (&amp;rhs)[4]</span></span><br></pre></td></tr></table></figure><p><strong>T&amp;&amp;的缺点</strong></p><p><code>T&amp;&amp;</code>就当真那么perfect？</p><p>如果你在 <code>pass_by_perfect_ref</code> 函数内部使用<code>T</code>定义一个对象，那么当 <code>pass_by_perfect_ref</code>函数传入一个左值时，<code>T</code>此时会被推断为<code>const T&amp;</code>或者<code>T&amp;</code>，由于引用未初始化而报错：<strong>error: ‘obj’ declared as reference but not initialized</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_perfect_ref</span><span class="params">(T&amp;&amp; arg)</span> </span>&#123; </span><br><span class="line">    T obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文，主要讲解了值传递和引用传递的优缺点，但还有一个遗留问题：当模板函数的传入参数类型是<strong>字符串常量和裸数组</strong>时，该如何更好地处理？</p><ul><li>值传递：字符串常量/数组会退化成指针，那如果想判断数组是否相等怎么办？</li><li>引用传递：字符串/数组会被推导出固定长度类型，比如上面的 <code>const int (&amp;rhs)[4]</code>，模板的灵活性不就丧失了？</li></ul><p>敬请期待下一次更新，奥里给！！！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;a href=&quot;https://szza.github.io/2021/03/04/C++/reference/&quot;&gt;初探值与引用：学会正确地使用右值引用&lt;/a&gt; 一文中，讲解了右值引用的正确用法。本节继续在前文基础上，讲解值与引用在模板函数中的关系。&lt;/p&gt;
&lt;p&gt;在</summary>
      
    
    
    
    <category term="深入了解 Modern C++" scheme="https://szza.github.io/categories/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>初探值与引用：学会正确地使用右值引用</title>
    <link href="https://szza.github.io/2021/03/04/C++/reference/"/>
    <id>https://szza.github.io/2021/03/04/C++/reference/</id>
    <published>2021-03-04T08:18:11.000Z</published>
    <updated>2022-02-14T13:37:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++11中引入了右值引用，一起 look、look，这到底是个啥。</p><h2 id="右值引用是右值？"><a href="#右值引用是右值？" class="headerlink" title="右值引用是右值？"></a>右值引用是右值？</h2><p>引用，就是为了避免复制而存在，而左值引用和右值引用是为了不同的对象存在：</p><ul><li>左值引用的对象是变量</li><li>右值引用的对象是常量</li></ul><p>最直观的使用如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp;  lr = a;       <span class="comment">// a 是个变量</span></span><br><span class="line"><span class="keyword">int</span>&amp;&amp; rv = <span class="number">10</span>;      <span class="comment">// 10 是常量</span></span><br></pre></td></tr></table></figure><p>可能老铁理不清：右值引用和右值到底是啥关系?</p><p>先说结论：<font color=red>无论左值引用还是右值引用，都是左值</font>，即上面的<code>lr</code>和<code>rv</code>是左值、是个变量，只是左值引用<code>lr</code>指向的是变量<code>a</code>，而右值引用<code>rv</code>指向常量10。</p><p>下面从demo中验证这一结论。假定有类<code>Foo</code>的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo(<span class="keyword">int</span> num=<span class="number">0</span>) : num_(num) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;default&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp; rhs) : num_(rhs.num_) &#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ctor&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Foo(Foo&amp;&amp; rhs) : num_(rhs.num_) &#123; </span><br><span class="line">        rhs.num_=<span class="number">0</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;mtor&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> num_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以类<code>Foo</code>为基础，针对下面的代码进行案例分析：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">foo</span><span class="params">(<span class="number">10</span>)</span></span>;                      <span class="comment">// 仅在此调用构造函数</span></span><br><span class="line"></span><br><span class="line">Foo&amp;  foo_lv_1 = foo;          <span class="comment">// (1) OK</span></span><br><span class="line"><span class="comment">// Foo&amp;&amp; foo_rv_1 = foo;       // (2): error</span></span><br><span class="line">Foo&amp;&amp; foo_rv_2 = <span class="built_in">std</span>::move(foo);<span class="comment">// (3) ok</span></span><br><span class="line">Foo&amp;&amp; foo_rv_3 = <span class="keyword">static_cast</span>&lt;Foo&amp;&amp;&gt;(foo);<span class="comment">// (4) 和(3)等价</span></span><br><span class="line"><span class="comment">// Foo&amp;&amp; foo_rv_4 = foo_rv_2; // (5):error</span></span><br><span class="line">Foo&amp;  foo_lv_2 = foo_rv_2;    <span class="comment">// (6) OK</span></span><br></pre></td></tr></table></figure><ul><li><code>(1)</code>是最常用的左值引用，肯定不会发生复制行为</li><li><code>(2)</code>会报错：<strong>error: cannot bind rvalue reference of type ‘Foo&amp;&amp;’ to lvalue of type ‘Foo’</strong>。正是因为<code>foo_rv_1</code>是个右值引用，只能指向常量，而<code>foo</code>是个变量、是个左值。</li><li><code>(2)</code>报错是因为不能隐式地将左值转换为右值，但可以使用<code>static_cast&lt;Foo&amp;&amp;&gt;</code>强制转换，这是编译器所允许的。<code>std::move</code>函数底层即是如此实现，因此(3)和(4)等价。</li><li><code>(5)</code>会和<code>(2)</code>有同样的<code>error</code>。因为<code>foo_rv_2</code>本质上是个左值，不能将<code>foo_rv_4</code>引用<code>foo_rv_2</code>。</li><li><code>(6)</code>正确。因为<code>foo_rv_2</code>本身就是个左值，<code>foo_lv_2</code>去引用一个左值变量并没有问题。</li></ul><p>因此上面的demo，只会在构造<code>foo</code>时调用一次构造函数。</p><p>此外，由于<code>foo_lv_1</code>、<code>foo_lv_2</code>及其<code>foo_rv_2</code>都指向<code>foo</code>，打印这三个变量地址会发现它们和<code>foo</code>的地址相同。说明不论左值引用还是右值引用都是左值这一事实。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印地址</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;&amp;foo &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; &amp;foo_lv &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;foo_rv_2&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;&amp;foo_lv_2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="number">0x7fffceb73864</span> <span class="number">0x7fffceb73864</span> <span class="number">0x7fffceb73864</span> <span class="number">0x7fffceb73864</span></span><br></pre></td></tr></table></figure><p><font color=red>注释：</font>上面的demo中出于演示，<code>foo</code>在(3)中移动到<code>foo_rv_2</code>后，仍继续在(4)中使用。实际上不应该继续使用，除非给它重新初始化。</p><h2 id="std-move"><a href="#std-move" class="headerlink" title="std::move"></a>std::move</h2><p>假定存在 <code>construct_foo_by</code> 函数，能根据传入的<code>Foo</code>对象的引用类型调用不同的构造函数构造Foo对象<code>foo</code>，那么应该如下设计：</p><ul><li><p>当 <code>construct_foo_by </code>函数传入的对象是个右值时，<code>construct_foo_by(Foo&amp;&amp; rhs) </code> 会被调用。<font color=red>但是!!!</font> 由上面的分析可知，尽管<code>rhs</code>是右值引用类型<code>Foo&amp;&amp;</code>，但却是左值，想调用<code>Foo</code>的移动构造函数，必须强制将<code>rhs</code>变成右值。因此，在<code>construct_foo_by </code>函数内部，需要调用<code>std::move</code>函数来完成这一转换。</p><p><font color=red>注释：</font>调用<code>construct_foo_by(Foo&amp;&amp; rhs)</code>函数前，入口函数<code>rhs</code>的初始化相当于是<code>Foo&amp;&amp; rhs = foo;</code>，因此<code>rhs</code>也是个变量。</p></li><li><p>当 <code>construct_foo_by</code> 函数传入的对象是非右值时，<code>rhs</code>就是个左值，<code>construct_foo_by</code>函数内部自然就会调用<code>Foo</code>的拷贝构造函数创建<code>foo</code>。</p></li></ul><p>整个demo实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_foo_by</span><span class="params">(Foo&amp;&amp; rhs)</span> </span>&#123; </span><br><span class="line">   <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="built_in">std</span>::move(rhs))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_foo_by</span><span class="params">(<span class="keyword">const</span> Foo&amp; rhs)</span> </span>&#123; </span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(rhs)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    construct_foo_by(foo);   <span class="comment">// 调用 ctor</span></span><br><span class="line">    construct_foo_by(Foo&#123;<span class="number">100</span>&#125;);<span class="comment">// 调用 mtor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，对于<code>main</code>函数中<code>construct_foo_by</code>的两次调用，输出如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ reference.cc -o ref &amp;&amp; .&#x2F;ref</span><br><span class="line">default</span><br><span class="line">ctor</span><br><span class="line">default</span><br><span class="line">mtor</span><br></pre></td></tr></table></figure><p>但是，如果将 <code>construct_foo_by(Foo&amp;&amp; rhs)</code>函数的实现修改为下面的版本，即内部不使用<code>std::move</code>函数对<code>rhs</code>进行转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct_foo_by</span><span class="params">(Foo&amp;&amp; rhs)</span> </span>&#123; </span><br><span class="line">   <span class="function">Foo <span class="title">foo</span><span class="params">(rhs)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，并不符合预期：本该调用<code>Foo</code>的移动构造函数来构造<code>foo</code>，却调用拷贝构造函数，就是因为<code>rhs</code>是左值，又没有经过<code>std::move</code>函数，最后触发了拷贝构造函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ reference.cc -o ref &amp;&amp; .&#x2F;ref</span><br><span class="line">default</span><br><span class="line">ctor</span><br><span class="line">default</span><br><span class="line">ctor</span><br></pre></td></tr></table></figure><h2 id="std-forward"><a href="#std-forward" class="headerlink" title="std::forward"></a>std::forward</h2><p>在上面的实例中，知道了 <strong>右值引用是左值</strong> 这一事实，也正因为这个问题，导致 <code>construct_foo_by(Foo&amp;&amp; rhs)</code>函数内部再次调用<code>std::move</code>函数将<code>rhs</code>强制性转换为右值。</p><p>那么有没有办法可以使得不重载<code>construct_foo_by</code>函数，也依然能够根据传入参数的类型调用合适的构造函数？Of Course，答案就是<code>std::forward</code>函数。</p><p>但是<code>std::forward</code>必须配合模板使用，因为只有在模板参数下<code>T&amp;&amp;</code>才能触发引用折叠。<code>T&amp;&amp;</code>和具体的<code>Foo&amp;&amp;</code>不同，后者是具体类别的右值引用，而<code>T&amp;&amp;</code>可以是<code>const Foo&amp;</code>、<code>Foo&amp;</code>，也可以是<code>Foo</code>：</p><ul><li>当输入的<code>rhs</code>是左值类型时，<code>T&amp;&amp;</code>会被推断为<code>Foo&amp;</code>，经过<code>std::forward&lt;T&amp;&amp;&gt;</code> 强制转换后是<code>Foo&amp;&amp;&amp;</code>，触发引用折叠后还是<code>Foo&amp;</code>，最后调用拷贝构造函数；</li><li>当输入的<code>rhs</code>是右值类型时，<code>T&amp;&amp;</code>会被推断为<code>Foo</code>，经过<code>std::forward&lt;Foo&amp;&amp;&gt;</code>强制类型转换后变为<code>Foo&amp;&amp;</code>，触发移动构造函数。</li></ul><p>注意：<code>std::forward</code>必须和模板搭配才能发挥完美转发的效果。<br>完整的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">create_foo_by</span><span class="params">(T&amp;&amp; rhs)</span> </span>&#123; </span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="built_in">std</span>::forward&lt;T&amp;&amp;&gt;(rhs))</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">foo</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    create_foo_by(foo);<span class="comment">// ctor</span></span><br><span class="line">    create_foo_by(Foo&#123;<span class="number">100</span>&#125;);<span class="comment">// mtor</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ reference.cc -o ref &amp;&amp; .&#x2F;ref</span><br><span class="line">default</span><br><span class="line">ctor</span><br><span class="line">default</span><br><span class="line">mtor</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++11中引入了右值引用，一起 look、look，这到底是个啥。&lt;/p&gt;
&lt;h2 id=&quot;右值引用是右值？&quot;&gt;&lt;a href=&quot;#右值引用是右值？&quot; class=&quot;headerlink&quot; title=&quot;右值引用是右值？&quot;&gt;&lt;/a&gt;右值引用是右值？&lt;/h2&gt;&lt;p&gt;引用，就</summary>
      
    
    
    
    <category term="深入了解 Modern C++" scheme="https://szza.github.io/categories/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>编译器优化之Copy elison、RVO</title>
    <link href="https://szza.github.io/2021/03/03/C++/RVO/"/>
    <id>https://szza.github.io/2021/03/03/C++/RVO/</id>
    <published>2021-03-03T04:47:23.000Z</published>
    <updated>2022-02-14T14:17:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++11以后，g++ 编译器默认开启复制省略（copy elison ）选项，可以在以值语义传递对象时避免触发复制、移动构造函数。copy elision 主要发生在两个场景：</p><ul><li>函数返回的是值语义时</li><li>函数参数是值语义时</li></ul><h3 id="返回值优化"><a href="#返回值优化" class="headerlink" title="返回值优化"></a>返回值优化</h3><p>返回值优化RVO（Return Value Optimization，RVO），即避免返回过程触发复制 / 移动构造函数。根据返回的值是否是匿名对象，可以分为两类：</p><ul><li>具名返回值优化 <code>NRVO</code> （Named Return Value Optimization，NRVO）</li><li> 匿名返回值优化 <code>URVO</code>（Unknown  Return Value Optimization，URVO ）</li></ul><p>二者的区别在于返回值是具名的局部变量（NRVO）还是无名的临时对象（URVO）。</p><p>假定现在有类<code>Foo</code>，实现了复制构造函数（<code>ctor</code>）、 移动构造函数（<code>mtor</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;default&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line"></span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp; rhs) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;ctor&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    Foo(Foo&amp;&amp; rhs) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;mtor&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在，有返回类型是<code>Foo</code>的 两个函数：<code>return_urvo_value</code> 和 <code>return_nrvo_value</code> ，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">return_urvo_value</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> Foo&#123;&#125;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Foo <span class="title">return_nrvo_value</span><span class="params">()</span> </span>&#123; </span><br><span class="line">  Foo local_obj;</span><br><span class="line">  <span class="keyword">return</span> local_obj; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照常规，<code>return_urvo_value</code>函数返回<code>Foo&#123;&#125;</code>应该触发<code>mtor</code>， <code>return_nrvo_value</code>函数返回<code>local_obj</code>应该触发<code>ctor</code>。真的如此吗？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">auto</span> x = return_urvo_value();</span><br><span class="line">  <span class="keyword">auto</span> y = return_nrvo_value();  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g++ rvo.cc  -o rvo &amp;&amp; .&#x2F;rvo</span><br><span class="line">default</span><br><span class="line">default</span><br></pre></td></tr></table></figure><p>输出结果，令人惊讶！竟然都只调用了一次默认构造函数。这是因为编译器默认开启了RVO，为了禁止这个优化策略，需要为编译加上  <em><code>-fno-elide-constructors</code></em>  选项，此时输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -fno-elide-constructors rvo.cc  -o rvo &amp;&amp; .&#x2F;rvo</span><br><span class="line">default</span><br><span class="line">mtor</span><br><span class="line">mtor</span><br><span class="line">default</span><br><span class="line">mtor</span><br><span class="line">mtor</span><br></pre></td></tr></table></figure><p>下面对输出结果，逐个分析。</p><h4 id="URVO"><a href="#URVO" class="headerlink" title="URVO"></a>URVO</h4><p>首先，<code>return_urvo_value</code>函数，触发两次移动构造函数，这很好理解：</p><ol><li>基于return的<code>Foo&#123;&#125;</code>构造<code>return_urvo_value</code>函数的返回值，触发一次；</li><li>基于<code>return_urvo_value</code>函数返回的右值构造<code>x</code>，触发一次。</li></ol><p><code>return_urvo_value</code>函数return的<code>Foo&#123;&#125;</code>，中间经过两次<code>mtor</code>，才将<code>Foo&#123;&#125;</code>的内部数据转移到了<code>x</code>。但是，这中间的两次<code>mtor</code>是可以避免的：由于return之后<code>Foo&#123;&#125;</code>就结束生命周期，那为什么不直接将<code>Foo&#123;&#125;</code>用于<code>x</code>呢？</p><p>因此，编译器默认开启RVO，省略中间两次调用<code>mtor</code>的过程，直接基于<code>return_urvo_value</code>函数中return的<code>Foo&#123;&#125;</code>构造<code>x</code>。此时，整个过程简化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo x&#123;&#125;; </span><br></pre></td></tr></table></figure><h4 id="NRVO"><a href="#NRVO" class="headerlink" title="NRVO"></a>NRVO</h4><p>但是!!!，<code>return_nrvo_value</code>函数，怎么也触发了两次<code>mtor</code>，而不是<code>ctor</code>+ <code>mtor</code>？</p><ol><li><p>这是因为 <code>local_obj</code> 是局部变量，<code>return_nrvo_value</code>函数执行return语句的同时，<code>local_obj</code>的生命周期也即将结束。既然如此，与其返回<code>local_obj</code>的副本，不如直接将<code>local_obj</code>返回回去，既避免了析构<code>local_obj</code>，也避免了重新分配<code>Foo</code>对象。</p></li><li><p>编译器默认开启RVO时，则可以完成上述优化。当编译加上 <em><code>-fno-elide-constructors</code></em>  标志禁止RVO优化时，那么编译器也会优先选择<code>mtor</code>，将<code>local_obj</code>的内部数据转移到<code>return_nrvo_value</code>的返回值中，最后用于构造<code>y</code>，避免重新为<code>local_obj</code>中的数据分配内存。</p></li></ol><p>因此，<code>return_nrvo_value</code>函数，即使禁止了RVO优化，也是触发两次移动构造函数，而不是一次复制构造、一次移动构造。为了验证确实是将<code>local_obj</code>的内部数据转移到了<code>y</code>，对<code>return_nrvo_value</code>函数修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">return_nrvo_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; local_vec&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;object address: &quot;</span>&lt;&lt; <span class="built_in">std</span>::addressof(local_vec)</span><br><span class="line">           &lt;&lt;<span class="string">&quot; |data address:&quot;</span> &lt;&lt; <span class="built_in">std</span>::addressof(local_vec[<span class="number">0</span>])&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> local_vec;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> y = return_nrvo_value(); </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;object address: &quot;</span>&lt;&lt; <span class="built_in">std</span>::addressof(y)</span><br><span class="line">           &lt;&lt;<span class="string">&quot; |data address:&quot;</span> &lt;&lt; <span class="built_in">std</span>::addressof(y[<span class="number">0</span>])&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分别开启<code>rvo</code>优化、禁止<code>rvo</code>优化，输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ g++  rvo.cc  -o rvo &amp;&amp; .&#x2F;rvo</span><br><span class="line">object address: 0x7ffffc262da0 |data address:0x7ffff55e9eb0</span><br><span class="line">object address: 0x7ffffc262da0 |data address:0x7ffff55e9eb0</span><br><span class="line"></span><br><span class="line">$ g++ -fno-elide-constructors rvo.cc  -o rvo &amp;&amp; .&#x2F;rvo</span><br><span class="line">object address: 0x7fffc9b6ee80 |data address:0x7fffc2969eb0</span><br><span class="line">object address: 0x7fffc9b6ef00 |data address:0x7fffc2969eb0</span><br></pre></td></tr></table></figure><p>从输出，可以看出：</p><ul><li>当开启RVO时，不仅<code>y</code>和<code>local_vec</code>指向的数据内存一致，<code>y</code>和<code>local_vec</code>对象本身地址都是一致，即<code>y</code>就是<code>local_vec</code>；</li><li>当使用 <em><code>-fno-elide-constructors</code></em> 禁止RVO时，<code>y</code>和 <code>local_vec</code> 仍指向同一片内存区，但是此时<code>y</code>的地址不是<code>local_vec</code>的地址，说明<code>local_vec</code>将数据转移到了<code>y</code>后，<code>local_Vec</code>本身还是析构了，而<code>y</code>是基于移动构造函数重新创建的对象。</li></ul><h4 id="C-17强制编译器实现-URVO"><a href="#C-17强制编译器实现-URVO" class="headerlink" title="C++17强制编译器实现 URVO"></a>C++17强制编译器实现 URVO</h4><p>在上面的demo中，<code>Foo</code>的<code>mtor</code>必须是可访问的，即移动构造函数没有加上<code>=delete</code>标志，也没有设置为<code>private</code>属性。到了C++17，时代变了，强制编译器实现RVO，就是即便你禁止了移动构造函数，对象也能具有URVO能力。比如，将上面的类<code>Foo</code>修改如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;default&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="comment">// 禁止复制、移动构造函数</span></span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    Foo(Foo&amp;&amp; rhs) =<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> x = return_urvo_value();</span><br><span class="line">    <span class="keyword">auto</span> y = return_nrvo_value(); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面分别在C++14、17的编译输出：</p><p>C++14编译输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std&#x3D;c++14  rvo.cc  -o rvo &amp;&amp; .&#x2F;rvo</span><br><span class="line">rvo.cc: In function ‘Foo return_urvo_value()’:</span><br><span class="line">rvo.cc:15:14: error: use of deleted function ‘Foo::Foo(Foo&amp;&amp;)’</span><br><span class="line">   15 |   return Foo&#123;&#125;;</span><br><span class="line">      |              ^</span><br><span class="line">rvo.cc:10:3: note: declared here</span><br><span class="line">   10 |   Foo(Foo&amp;&amp; rhs) &#x3D;delete;</span><br><span class="line">      |   ^~~</span><br><span class="line">rvo.cc: In function ‘Foo return_nrvo_value()’:</span><br><span class="line">rvo.cc:21:10: error: use of deleted function ‘Foo::Foo(const Foo&amp;)’</span><br><span class="line">   21 |   return local_obj;</span><br><span class="line">      |          ^~~~~~~~~</span><br><span class="line">rvo.cc:9:3: note: declared here</span><br><span class="line">    9 |   Foo(const Foo&amp; rhs) &#x3D; delete;</span><br><span class="line">      |   ^~~</span><br></pre></td></tr></table></figure><p>C++17编译输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std&#x3D;c++17  rvo.cc  -o rvo &amp;&amp; .&#x2F;rvo</span><br><span class="line">rvo.cc: In function ‘Foo return_nrvo_value()’:</span><br><span class="line">rvo.cc:21:10: error: use of deleted function ‘Foo::Foo(const Foo&amp;)’</span><br><span class="line">   21 |   return local_obj;</span><br><span class="line">      |          ^~~~~~~~~</span><br><span class="line">rvo.cc:9:3: note: declared here</span><br><span class="line">    9 |   Foo(const Foo&amp; rhs) &#x3D; delete;</span><br><span class="line">      |   ^~~</span><br></pre></td></tr></table></figure><p>从两编译输出可以看出，即使在<code>Foo</code>同时禁止复制、移动构造函数时，C++17编译器仍然能强实现NRVO，但是都不支持NRVO。但是如果仅禁止<code>Foo</code>的复制构造函数呢？注意，在禁止复制构造函数时，要主动实现移动构函数，否则效果和同时禁止<code>ctor</code>和<code>mtor</code>一样。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;default&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>; &#125;</span><br><span class="line">    <span class="comment">// 禁止复制、移动构造函数</span></span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">    Foo(Foo&amp;&amp; rhs) &#123; <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;mtor&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时输出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std&#x3D;c++17  rvo.cc  -o rvo &amp;&amp; .&#x2F;rvo</span><br><span class="line">default</span><br><span class="line">default</span><br><span class="line">$ g++ -std&#x3D;c++14  rvo.cc  -o rvo &amp;&amp; .&#x2F;rvo</span><br><span class="line">default</span><br><span class="line">default</span><br></pre></td></tr></table></figure><p>因此，可总结如下：当函数的返回类型是值类型时，</p><ol><li><p>URVO：在C++17之前，对象的<code>motor</code>必须是可访问的，才能开启URVO。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// return_urvo_value 导致编译失败</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() =<span class="keyword">default</span>;</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp; rhs) =<span class="keyword">default</span>;</span><br><span class="line">    Foo(Foo&amp;&amp; rhs) =<span class="keyword">delete</span>;<span class="comment">// mtor 不可访问</span></span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 编译通过</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() =<span class="keyword">default</span>;</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo&amp; rhs) =<span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>C++17开始，即使完全禁止了对象的<code>ctor</code>、<code>motr</code>，编译器一样可以实现URVO。</p></li><li><p>NRVO：对象的<code>mtor</code>必须可访问的，才能开启。</p></li></ol><h4 id="URVO-应用"><a href="#URVO-应用" class="headerlink" title="URVO 应用"></a>URVO 应用</h4><p>根据URVO特性，我么可以为 <code>std::unique_ptr</code>、 <code>std::atomic</code>等提供一个工厂函数 <code>make_instance</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">make_instance</span><span class="params">(Args&amp;&amp; ... args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> T &#123;<span class="built_in">std</span>::forward&lt;Args&gt;(args)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通类型</span></span><br><span class="line">    <span class="keyword">int</span> i   = make_instance&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line">    <span class="comment">// std::unique_ptr 实现了 移动构造函数，因此可以编译成功 </span></span><br><span class="line">    <span class="keyword">auto</span> up = make_instance&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt;(<span class="keyword">new</span> <span class="keyword">int</span>&#123; <span class="number">42</span> &#125;); </span><br><span class="line">    <span class="comment">// 禁止了复制构造函数，但是也没有实现移动构造函数，因此要到 C++17 才能编译过</span></span><br><span class="line">    <span class="keyword">auto</span> ai = make_instance&lt;<span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt;&gt;(<span class="number">42</span>);                  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的<code>make_instance</code>对于<code>std::unique_ptr</code>、<code>std::atomic</code>要求不同：</p><ul><li><p><code>std::unique_ptr</code>：虽然禁止了<code>ctor</code>，但实现<code>mtor</code>，因此它在C++11中可以开启NRVO。注意，在C++14中已经为<code>std::unique_ptr</code>提供了工厂函数<code>std::make_unique</code>，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 和 make_instance 如出一辙</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;_Tp&gt; <span class="title">make_unique</span><span class="params">(_Args &amp;&amp; ...__args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> _Tp(<span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>std::atomic</code>：同时禁止了<code>ctor</code>、<code>mtor</code>，因此必须等到 C++17，<code>make_instance</code>函数才能为<code>std::atmoic</code>创建对象。</p></li></ul><h3 id="函数值传递"><a href="#函数值传递" class="headerlink" title="函数值传递"></a>函数值传递</h3><p>在 [再探值与引用] 一文中，深度讲解了函数模板基于值传递和引用传递的优劣。在讲值传递时，未必总是发生复制行为：<code>pass_by_value</code>函数传入右值时，也会发生copy elision 行为，即使禁止编译器的copy elision 行为，也是优先调用对象的<code>mtor</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass_by_value</span><span class="params">(Foo foo)</span> </span>&#123; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> x = return_urvo_value();</span><br><span class="line">  <span class="keyword">auto</span> y = return_nrvo_value(); </span><br><span class="line"></span><br><span class="line">  pass_by_value(Foo&#123;&#125;);</span><br><span class="line">  pass_by_value(<span class="built_in">std</span>::move(x));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终的输出也是调用默认三次构造函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std&#x3D;c++11  rvo.cc  -o rvo &amp;&amp; .&#x2F;rvo</span><br><span class="line">default</span><br><span class="line">default</span><br><span class="line">default</span><br></pre></td></tr></table></figure><p>到此，copy elision 的两个主要应用场景基本分析结束。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;C++11以后，g++ 编译器默认开启复制省略（copy elison ）选项，可以在以值语义传递对象时避免触发复制、移动构造函数。copy elision 主要发生在两个场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数返回的是值语义时&lt;/li&gt;
&lt;li&gt;函数参数是值语义时&lt;/li&gt;</summary>
      
    
    
    
    <category term="深入了解 Modern C++" scheme="https://szza.github.io/categories/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>提高C++程序员的自我修养 from 剖析STL内存分配器</title>
    <link href="https://szza.github.io/2021/03/03/C++/allocator/"/>
    <id>https://szza.github.io/2021/03/03/C++/allocator/</id>
    <published>2021-03-03T01:38:49.000Z</published>
    <updated>2021-03-03T01:48:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本期主要讲解C++ STL中的内存分配器<code>std::allocator</code>及其特性萃取器<code>__gnu_cxx::__alloc_traits</code>。</p><p>为防止混淆，规定如下：</p><ul><li><code>allocator</code>：泛指内存分配器，仅仅是一个术语。</li><li><code>std::allocator</code>：是STL实现的内存分配器类<code>std::allocator</code>。</li></ul><h3 id="gnu-cxx-new-allocator"><a href="#gnu-cxx-new-allocator" class="headerlink" title="__gnu_cxx::new_allocator"></a>__gnu_cxx::new_allocator</h3><p>C++的默认的内存分配器<code>std::allocator</code>，继承至<code>__gnu_cxx::new_allocator</code>。而 <code>__gnu_cxx::new_allocator</code> 主要完成两个任务：</p><ul><li>分配对象内存、初始化对象</li><li>析构对象、释放对象内存</li></ul><p><code>__gnu_cxx::new_allocator</code> 是个空类，没有成员变量，主要有四种成员函数完成上述任务：</p><ul><li><code>allocate</code> 函数，用于分配内存</li><li><code>construct</code>函数，调用已分配内存对象的构造函数</li><li><code>destroy</code>函数，调用析构函数</li><li><code>deallocate</code>函数，用于释放内存</li></ul><p><code>__gnu_cxx::new_allocator</code>  的整体框架大致如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">new_allocator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">size_t</span>      size_type;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>   difference_type;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp*        pointer;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*  const_pointer;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp &amp;       reference;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp &amp; const_reference;</span><br><span class="line">  <span class="keyword">typedef</span> _Tp         value_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> new_allocator&lt;_Tp1&gt; other;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  new_allocator() _GLIBCXX_USE_NOEXCEPT &#123;&#125;</span><br><span class="line">  new_allocator(<span class="keyword">const</span> new_allocator &amp;) <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">  new_allocator(<span class="keyword">const</span> new_allocator&lt;_Tp1&gt; &amp;) <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line">  ~new_allocator() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type __n, <span class="keyword">const</span> <span class="keyword">void</span> * = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;(<span class="number">0</span>))</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer __p, size_type)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(_Up *__p, _Args &amp;&amp;...__args)</span> </span></span><br><span class="line"><span class="function">    <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(::<span class="keyword">new</span> ((<span class="keyword">void</span> *)__p)_Up(<span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)))</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(_Up *__p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(__p-&gt;~_Up()))</span></span>;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="allocate"><a href="#allocate" class="headerlink" title="allocate"></a>allocate</h4><p><code>allocate</code>函数，用于分配大小为<code>__n</code>个字节内存，返回值是分配所得内存的地址。</p><ul><li>如果待分配内存大小<code>__n</code>大于当前进程最大可用内存，那么就会抛出<code>bad_alloc</code>异常。</li><li>再调用<code>operator new</code>来分配内存。<code>operator new</code>对<code>malloc</code>作了一层简单的封装，等效于<code>malloc</code></li><li>将指向<code>operator new</code>的返回值类型转换为此次分配对象<code>_Tp</code>的指针类型。</li></ul><p>整个过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">pointer <span class="title">allocate</span><span class="params">(size_type __n, <span class="keyword">const</span> <span class="keyword">void</span> * = <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span> *&gt;(<span class="number">0</span>))</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (__n &gt; <span class="keyword">this</span>-&gt;max_size())</span><br><span class="line">        <span class="built_in">std</span>::__throw_bad_alloc();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_aligned_new</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">alignof</span>(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="keyword">align_val_t</span> __al = <span class="built_in">std</span>::<span class="keyword">align_val_t</span>(<span class="keyword">alignof</span>(_Tp));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp *&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(__n * <span class="keyword">sizeof</span>(_Tp), __al));</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp *&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(__n * <span class="keyword">sizeof</span>(_Tp)));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="deallocate"><a href="#deallocate" class="headerlink" title="deallocate"></a>deallocate</h4><p><code>deallocate</code>函数，使用<code>operator delete</code>来释放地址<code>__p</code>指向的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(pointer __p, size_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __cpp_aligned_new</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">alignof</span>(_Tp) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__)</span><br><span class="line">      &#123;</span><br><span class="line">        ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(__p, <span class="built_in">std</span>::<span class="keyword">align_val_t</span>(<span class="keyword">alignof</span>(_Tp)))</span></span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(__p)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="construct"><a href="#construct" class="headerlink" title="construct"></a>construct</h4><p>上面的<code>allocate</code>函数相当于<code>malloc</code>函数，只是分配<code>__n</code>个字节的内存，但是并未对这片内存进行初始化。对<code>allocate</code> 函数分配的内存<code>__p</code>进行初始化的任务，交给<code>construct</code>函数来完成。</p><p><code>constuct</code>函数，使用了<code>new</code>表达式的另一种形式，叫做<code>placement new</code>，使用方式如下注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">construct</span><span class="params">(_Up *__p, _Args &amp;&amp;...__args)</span> </span></span><br><span class="line"><span class="function">  <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(::<span class="keyword">new</span> ((<span class="keyword">void</span> *)__p)_Up(<span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 表示在 地址 _p 上调用对象 _Up的构造函数</span></span><br><span class="line">    <span class="comment">// 其中，__args是构造函数的参数</span></span><br><span class="line">    ::<span class="keyword">new</span> ((<span class="keyword">void</span> *)__p) _Up(<span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h4><p><code>deallocate</code>函数，是完成了释放内存，但是在释放内存之前一般需要先调用对象的析构函数，完成相关的资源的释放、关闭操作。因此在<code>destoy</code>函数中，直接调用了类型<code>_Up</code>的析构函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">(_Up *__p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(__p-&gt;~_Up()))</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">   __p-&gt;~_Up();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="std-allocator"><a href="#std-allocator" class="headerlink" title="std::allocator"></a>std::allocator</h3><p>类<code>std::allocator</code> 继承<code>__gnu_cxx::new_allocator</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">using</span> __allocator_base = __gnu_cxx::new_allocator&lt;_Tp&gt;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">allocator</span> :</span> <span class="keyword">public</span> __allocator_base&lt;_Tp&gt;</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span>      size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>   difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp*        pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp*  const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp;        reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> _Tp&amp;  const_reference;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp         value_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> allocator&lt;_Tp1&gt; other;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    allocator() <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line">    allocator(<span class="keyword">const</span> allocator &amp;__a) <span class="keyword">noexcept</span> : __allocator_base&lt;_Tp&gt;(__a) &#123;&#125;</span><br><span class="line">    allocator &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> allocator &amp;) = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">    allocator(<span class="keyword">const</span> allocator&lt;_Tp1&gt; &amp;) _GLIBCXX_NOTHROW</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    ~allocator() _GLIBCXX_NOTHROW &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">    <span class="comment">// Inherit everything else.</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h4 id="rebind"><a href="#rebind" class="headerlink" title="rebind"></a>rebind</h4><p>在<code>__gnu_cxx::new_allocator</code>、<code>std::allocator</code>中都有一个<code>rebind</code>函数，其主要作用：获得类型<code>_Tp1</code>的内存分配器<code>allocator&lt;_Tp1&gt;</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line">   <span class="keyword">typedef</span> allocator&lt;_Tp1&gt; other;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>这个函数在容器中被STL中被广泛使用。比如，在<code>std::list&lt;_Tp, std::allocator&lt;_Tp&gt;&gt;</code>中，<code>std::allocator</code>不仅要为<code>_Tp</code>类型的对象分配内存，还要为存储<code>_Tp</code>对象的节点<code>list_node&lt;_Tp&gt;</code>分配内存。但是<code>std::list&lt;_Tp, std::allocator&lt;_Tp&gt;&gt;</code>的类模板参数中只是传入了用于分配<code>_Tp</code>类型的内存分配器<code>std::allocator&lt;_Tp&gt;</code>，那么怎么获得<code>list_node&lt;_Tp&gt;</code>类型的内存分配器呢？</p><p>答案就是依靠<code>rebind</code>函数：<code>allocator&lt;_Tp&gt;::rebind&lt;list_node&lt;_Tp&gt;&gt;::other</code>，获得的就是用于分配<code>list_node&lt;_Tp&gt;</code>类型的内存分配器 <code>allocator&lt;list_node&lt;_Tp&gt;&gt;</code>。</p><p>在<code>list</code>中的实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">List_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 用于分配 _Tp 类型的内存分配器: _Tp_alloc_type</span></span><br><span class="line">  <span class="comment">// _Tp_alloc_type 实际上就是 std::allocator</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> __gnu_cxx::__alloc_traits&lt;_Alloc&gt;::<span class="keyword">template</span> rebind&lt;_Tp&gt;::other _Tp_alloc_type;</span><br><span class="line">  <span class="comment">// 用于分配 List_node&lt;_Tp&gt; 类型的内存分配器：_Node_alloc_type</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> _Tp_alloc_traits::<span class="keyword">template</span> rebind&lt;_List_node&lt;_Tp&gt; &gt;::other _Node_alloc_type;        </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;_Tp&gt; &gt;</span><br><span class="line">class <span class="built_in">list</span> : <span class="keyword">protected</span> _List_base&lt;_Tp, _Alloc&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _List_node&lt;_Tp&gt; _Node;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="std-allocator-traits-base"><a href="#std-allocator-traits-base" class="headerlink" title="std::__allocator_traits_base"></a>std::__allocator_traits_base</h3><p>上面的<code>list</code>中使用到了用于萃取内存分配器属性的类<code>__gnu_cxx::__alloc_traits</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__gnu_cxx::__alloc_traits 继承自 <span class="built_in">std</span>::allocator_traits</span><br><span class="line"><span class="built_in">std</span>::allocator_traits   继承自 <span class="built_in">std</span>::__allocator_traits_base</span><br></pre></td></tr></table></figure><p>类<code>__allocator_traits_base</code>，用于获取内存分配器<code>_Alloc</code>的属性，这个分配器<code>_Alloc</code>不一定是上面所述的<code>std::allocator</code>，可以是自定义的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">allocator_traits_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,</span><br><span class="line">            <span class="keyword">typename</span> _Up,</span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">  struct __rebind : __replace_first_arg&lt;_Tp, _Up&gt;</span><br><span class="line">  &#123; &#125;;  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// __rebind 特化版本：当分配器 _Tp 有成员函数 rebind 时调用此特化版本</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up&gt;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">rebind</span>&lt;</span>_Tp,</span><br><span class="line">                  _Up,</span><br><span class="line">                  <span class="keyword">__void_t</span>&lt;<span class="keyword">typename</span> _Tp::<span class="keyword">template</span> rebind&lt;_Up&gt;::other&gt;&gt;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">using</span> type = <span class="keyword">typename</span> _Tp::<span class="keyword">template</span> rebind&lt;_Up&gt;::other;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __pointer = <span class="keyword">typename</span> _Tp::pointer;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __c_pointer = <span class="keyword">typename</span> _Tp::const_pointer;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __v_pointer = <span class="keyword">typename</span> _Tp::void_pointer;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __cv_pointer = <span class="keyword">typename</span> _Tp::const_void_pointer;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __pocca = <span class="keyword">typename</span> _Tp::propagate_on_container_copy_assignment;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __pocma = <span class="keyword">typename</span> _Tp::propagate_on_container_move_assignment;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __pocs  = <span class="keyword">typename</span> _Tp::propagate_on_container_swap;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt; <span class="keyword">using</span> __equal = <span class="keyword">typename</span> _Tp::is_always_equal;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="rebind-1"><a href="#rebind-1" class="headerlink" title="__rebind"></a>__rebind</h4><p>类<code>__allocator_traits_base</code> 中最重要的是成员函数<code>__rebind</code>。 <code>__rebind</code>的模板参数<code>_Tp</code>是分配器类型，根据<code>_Tp</code>来实现重载：</p><ul><li><p>当传入的内存分配器类型<code>_Tp</code>，实现了<code>rebind</code>成员函数时，比如上面的<code>std::allocator</code>，那么就调用<code>__rebind</code>的特化版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">rebind</span>&lt;</span>_Tp,</span><br><span class="line">                _Up,</span><br><span class="line">                <span class="keyword">__void_t</span>&lt;<span class="keyword">typename</span> _Tp::<span class="keyword">template</span> rebind&lt;_Up&gt;::other&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> type = <span class="keyword">typename</span> _Tp::<span class="keyword">template</span> rebind&lt;_Up&gt;::other;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以<code>std::allocator&lt;int&gt;</code>为例，获取<code>Node&lt;int&gt;</code>类型的内存分配器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__allocator_traits_base::__rebind&lt;<span class="built_in">std</span>::allocator&lt;<span class="keyword">int</span>&gt;, Node&lt;<span class="keyword">int</span>&gt;&gt;::type  </span><br><span class="line"><span class="comment">// 等价于 </span></span><br><span class="line"><span class="built_in">std</span>::allocator&lt;Node&lt;<span class="keyword">int</span>&gt;&gt;</span><br></pre></td></tr></table></figure></li><li><p>当传入的分配器<code>_Tp</code>没有实现<code>rebind</code>成员函数时，就调用普通<code>__rebind</code>版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Tp需要是分配器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp,</span><br><span class="line">          <span class="keyword">typename</span> _Up,</span><br><span class="line">          <span class="keyword">typename</span> = <span class="keyword">void</span>&gt;</span><br><span class="line">struct __rebind : __replace_first_arg&lt;_Tp, _Up&gt;</span><br><span class="line">&#123; &#125;;  </span><br></pre></td></tr></table></figure><p>其中<code>__replace_first_arg</code>实现如下。此时，需要自定义一个内存分配器模板<code>_Template</code>，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Up&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">replace_first_arg</span></span></span><br><span class="line"><span class="class">&#123;</span> &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// _Template 是个类模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> _<span class="title">Template</span>, </span></span><br><span class="line"><span class="class">          <span class="title">typename</span> _<span class="title">Up</span>,</span></span><br><span class="line"><span class="class">          <span class="title">typename</span> _<span class="title">Tp</span>, </span></span><br><span class="line"><span class="class">          <span class="title">typename</span>... _<span class="title">Types</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">replace_first_arg</span>&lt;</span>_Template&lt;_Tp, _Types...&gt;, _Up&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">using</span> type = _Template&lt;_Up, _Types...&gt;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><strong>by the way</strong></p><p>在此，补充点模板的一点知识：</p><ol><li><p>模板参数模板</p><p>在<code>__replace_first_arg</code>类中，使用了一个类模板参数模板<code>_Template</code>，这表示模板参数<code>_Template</code>本身就是个类模板。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>, <span class="keyword">typename</span>...&gt; <span class="class"><span class="keyword">class</span> _<span class="title">Template</span></span></span><br></pre></td></tr></table></figure></li><li><p><code>::template</code></p><p>在<code>__rebind</code>函数体中，在<code>::</code>后面有个<code>template</code>关键字，这是用于告诉编译器 <code>template</code>后面的 <code>&lt;</code> 不是比较符号，而是模板参数符号。就是类似于<code>_Tp</code>前面的<code>typename</code>是告诉编译器<code>::</code>后面的是类成员函数，而不是<code>static</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> type = <span class="keyword">typename</span> _Tp::<span class="keyword">template</span> rebind&lt;_Up&gt;::other;</span><br></pre></td></tr></table></figure><h4 id="alloc-rebind"><a href="#alloc-rebind" class="headerlink" title="__alloc_rebind"></a>__alloc_rebind</h4></li></ol><p>全局函数<code>__alloc_rebind</code>，是<code>std::__allocator_traits_base</code>的wrapper，用于获取为<code>_Up</code>类型分配内存的内存分配器<code>_Alloc&lt;_Up&gt;</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span> _Up&gt;</span><br><span class="line"><span class="keyword">using</span> __alloc_rebind = <span class="keyword">typename</span> __allocator_traits_base::<span class="keyword">template</span> __rebind&lt;_Alloc, _Up&gt;::type;</span><br></pre></td></tr></table></figure><h3 id="std-allocator-traits"><a href="#std-allocator-traits" class="headerlink" title="std::allocator_traits"></a>std::allocator_traits</h3><p>类<code>std::allocator_traits</code>，继承于<code>std::__allocator_traits_base</code>，用于获取内存分配器<code>allocator</code>的各个属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Alloc&gt;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">allocator_traits</span> :</span> __allocator_traits_base</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">typedef</span> _Alloc allocator_type;  <span class="comment">/// The allocator type</span></span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">typename</span> _Alloc::value_type value_type;  <span class="comment">/// The allocated type</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>当<code>_Alloc</code>是<code>std::allocator</code>时，有个特化版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">allocator_traits</span>&lt;</span>allocator&lt;_Tp&gt;&gt;</span><br><span class="line"> &#123;</span><br><span class="line">   <span class="keyword">using</span> allocator_type = allocator&lt;_Tp&gt;;  <span class="comment">// 分配器类型</span></span><br><span class="line">   <span class="keyword">using</span> value_type = _Tp;                 <span class="comment">// 待分配内存的对象类型</span></span><br><span class="line">   <span class="keyword">using</span> pointer = _Tp *;                 <span class="comment">// 对象指针</span></span><br><span class="line">   <span class="keyword">using</span> const_pointer = <span class="keyword">const</span> _Tp *;</span><br><span class="line"><span class="comment">//...  using </span></span><br><span class="line">   <span class="keyword">using</span> is_always_equal = true_type;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用allocator为_Up分配内存</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">   <span class="keyword">using</span> rebind_alloc = allocator&lt;_Up&gt;;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">   <span class="keyword">using</span> rebind_traits = allocator_traits&lt;allocator&lt;_Up&gt;&gt;;</span><br><span class="line">     </span><br><span class="line">   <span class="comment">// 下面是 std::allocator&lt;_Tp&gt; 成员函数的 wrapper</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> pointer <span class="title">allocate</span><span class="params">(allocator_type &amp;__a, size_type __n)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> __a.allocate(__n);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> pointer <span class="title">allocate</span><span class="params">(allocator_type &amp;__a, size_type __n, const_void_pointer __hint)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> __a.allocate(__n, __hint);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(allocator_type &amp;__a, pointer __p, size_type __n)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     __a.deallocate(__p, __n);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(allocator_type &amp;__a, _Up *__p, _Args &amp;&amp;...__args)</span> </span></span><br><span class="line"><span class="function">               <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(__a.construct(__p, <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)))</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     __a.construct(__p, <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(allocator_type &amp;__a, _Up *__p)</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(__a.destroy(__p)))</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     __a.destroy(__p);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">static</span> size_type <span class="title">max_size</span><span class="params">(<span class="keyword">const</span> allocator_type &amp;__a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> __a.max_size();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="gnu-cxx-alloc-traits"><a href="#gnu-cxx-alloc-traits" class="headerlink" title="__gnu_cxx::__alloc_traits"></a>__gnu_cxx::__alloc_traits</h3><p><code>__gnu_cxx::__alloc_traits</code>类，也大都是<code>std::allocator_traits</code>的wrapper，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Alloc, <span class="keyword">typename</span> = <span class="keyword">typename</span> _Alloc::value_type&gt;</span><br><span class="line">struct __alloc_traits : <span class="built_in">std</span>::allocator_traits&lt;_Alloc&gt; &#123; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> _Alloc  allocator_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::allocator_traits&lt;_Alloc&gt;        _Base_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::value_type      value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::pointer         pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::const_pointer   const_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::size_type       size_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::difference_type difference_type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> value_type &amp;       reference;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">const</span> value_type&amp;  const_reference;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> _Base_type::allocate;</span><br><span class="line">    <span class="keyword">using</span> _Base_type::construct;</span><br><span class="line">    <span class="keyword">using</span> _Base_type::deallocate;</span><br><span class="line">    <span class="keyword">using</span> _Base_type::destroy;</span><br><span class="line">    <span class="keyword">using</span> _Base_type::max_size;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当 _Ptr 不是个标准指针，但是 _Ptr 和 value_type* 相同</span></span><br><span class="line">    <span class="comment">// __is_custom_pointer 才是 true，即 _Ptr 是个自定义指针</span></span><br><span class="line">    <span class="comment">// 即 _Ptr 可转换为 pointer</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">    <span class="keyword">using</span> __is_custom_pointer </span><br><span class="line">        = <span class="built_in">std</span>::__and_&lt;<span class="built_in">std</span>::is_same&lt;pointer, _Ptr&gt;, <span class="built_in">std</span>::__not_&lt;<span class="built_in">std</span>::is_pointer&lt;_Ptr&gt;&gt;&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// overload construct for non-standard pointer types</span></span><br><span class="line">    <span class="comment">// 重载非标准类型的指针，调用构造函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;__is_custom_pointer&lt;_Ptr&gt;::value&gt;::type</span><br><span class="line">    construct(_Alloc &amp;__a, _Ptr __p, _Args &amp;&amp;...__args) <span class="keyword">noexcept</span>(...) <span class="comment">// 省略了noexcept中的表达式</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 使用分配器 __a , 在地址 __p 调用构造函数</span></span><br><span class="line">      _Base_type::construct(__a, </span><br><span class="line">                            <span class="built_in">std</span>::__to_address(__p),</span><br><span class="line">                            <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overload destroy for non-standard pointer types</span></span><br><span class="line">    <span class="comment">// 重载非标准类型指针，调用析构函数</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Ptr&gt;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;__is_custom_pointer&lt;_Ptr&gt;::value&gt;::type</span><br><span class="line">    destroy(_Alloc &amp;__a, _Ptr __p) <span class="keyword">noexcept</span>(...) </span><br><span class="line">    &#123;</span><br><span class="line">      _Base_type::destroy(__a, <span class="built_in">std</span>::__to_address(__p));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** 对于标准的指针，会直接调用父类的constuct、destroy ***/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// wrapper</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> <span class="keyword">typename</span> _Base_type::<span class="keyword">template</span> rebind_alloc&lt;_Tp&gt; other;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体来说，<code>__gnu_cxx::__alloc_traits</code>提供了一个顶层的内存分配器萃取器，可以使用 <code>_Alloc</code> 的 <code>allocate</code>、 <code>deallocate</code>、<code>construct</code> 以及 <code>destroy </code>等函数来完成对象构造和析构等任务。</p><p>而类<code>std::allocator_traits</code> 是底层直接获取内存分配器<code>_Alloc</code>属性的类，其中<code>std::allocator_traits</code>有个特化版本，即使<code>_Alloc</code>是<code>std::allocator</code>，因为<code>std::allocator</code>是STL的容器默认的内存分配器。</p><p>如果想将自定义的内存分配器<code>Custome_Alloc</code>融入到STL体系中，那么也需要像<code>std::allocator</code>一样完成相应的接口设计、以及<code>rebind</code>函数。这样，容器就能通过<code>__gnu_cxx::__alloc_traits&lt;Custome_Alloc&gt;</code>使用自定义的内存分配器<code>Custome_Alloc</code>。</p><p>好嘞，到此完成了本期的目标，即讲解完毕C++ STL内存分配器的设计。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本期主要讲解C++ STL中的内存分配器&lt;code&gt;std::allocator&lt;/code&gt;及其特性萃取器&lt;code&gt;__gnu_cxx::__alloc_traits&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;为防止混淆，规定如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;alloc</summary>
      
    
    
    
    <category term="深入了解 Modern C++" scheme="https://szza.github.io/categories/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>C++ &amp; Linux 后端：学习开源项目</title>
    <link href="https://szza.github.io/2021/03/01/Path/2/"/>
    <id>https://szza.github.io/2021/03/01/Path/2/</id>
    <published>2021-03-01T07:29:47.000Z</published>
    <updated>2022-02-14T13:27:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前文【C++ &amp; Linux后端进BAT的学习路线】中，讲述了C++后端的学习路线。进一步，本文讲解两个问题：</p><ul><li>怎么阅读学习C++源码</li><li>学习哪些C++项目</li></ul><h2 id="怎么学习"><a href="#怎么学习" class="headerlink" title="怎么学习"></a>怎么学习</h2><p>在介绍具体的C++项目之前，先介绍我自己学习开源项目、阅读源码的方式：</p><ol><li>首先！！！要学会使用这个项目。以STL为例，应该极少有人学习STL是直接从阅读STL源码开始的，基本都是从学习<code>std::vector</code>、<code>std::list</code>等容器的使用方式开始。当你能熟练使用了，才有会更好的基础来对内部实现一探究竟。</li><li>再看看有没有相关书籍、博客介绍源码的，如果有则可以参考。一般比较好的项目都会有相应的博客、书籍。</li><li>掌握<code>gdb</code>，能对源码更深层次的学习，让gdb来帮助你学习。当然，你也选择个人喜好的其他工具。</li></ol><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><p>下面介绍的项目前后紧密联系，不断进阶，对自身能力的提升也呈螺旋式上升。</p><h3 id="Nanolog"><a href="#Nanolog" class="headerlink" title="Nanolog"></a>Nanolog</h3><p>日志功能，是稍微大点型项目的必备功能，自然也是后端项目的必备。</p><p><code>GitHub</code>上有个纳秒级低延迟项目：<code>Nanolog</code>。不过这项目有两个版本，原版本是基于C++17实现的<a href="https://github.com/PlatformLab/NanoLog">Nanolog-17</a>，还有个C++11的实现的<a href="https://github.com/Iyengar111/NanoLog">Nanolog-11</a>。他们是基于<code>std::atomic</code>实现的高性能多线程无锁日志。仔细研究一番，值得写入简历。</p><p><strong>by the way</strong></p><p>看一项目，不能就光看懂完事，要对他的一些指标进行考核，比如<a href="https://github.com/PlatformLab/NanoLog">Nanolog</a>中有<code>benchmark</code>，进行性能测试。对一个项目你需要了解的层次：</p><ul><li>内部实现原理：怎么实现无锁多线程，怎么保证数据同步之类。</li><li>性能：这个很重要，面试的过程中，涉及到项目几乎都会问。</li></ul><p>你还需要知道你在复写这个项目时，遇到了哪些问题。毕竟看懂不代表是你的，只有你真的能写出来，调试过其中的问题，才能理解的更加深刻。</p><h3 id="libuv"><a href="#libuv" class="headerlink" title="libuv"></a>libuv</h3><p><code>libevent</code>或者<code>libuv</code>，非常好的事件库，代码量相对较少：</p><ul><li>二者整体设计上也是符合《Linux高性能服务器编程》书中设计</li><li><code>libuv</code>对于慢速任务有独特的处理，能增加你对多线程编程的理解：多线程对IO密集型任务有效，但是对资源密集型，增加线程数是无效的，可以看看libuv是怎么处理的。</li><li>此外，<code>libevent</code>的C++版本就是<code>muduo</code></li></ul><p>我个人阅读的是<code>muduo</code>和<code>libuv</code>。此外，<code>muduo</code>作者陈硕还有一本书籍《Linux多线程服务端》讲解了设计一个多线程服务器的要点。</p><p><strong>by the way</strong></p><p><code>libuv</code>/<code>muduo</code>这类项目，一开始阅读的时候，最大困难在于理解回调函数机制。他们的处理流程大致如下：</p><ol><li>先注册可读、可写事件；</li><li>再等待可读、可写事件触发；</li><li>触发后，在回调函数中处理相应的读写事件。</li></ol><p>有的回调函数链可能会很长，难以理解，这个时候就需要gdb帮你理清这个链路。因此，在学习开源库之前，建议先学习下gdb调试。有时间，我也还准备写个使用gdb阅读开源项目的文档，或者录制个视频。</p><p>如果<code>libuv</code>熟悉了，可以基于<code>libuv</code>写个<code>webserver</code>也不错。记住：</p><ul><li>要记录过程中遇到的问题；</li><li>写完做个压力测试。</li></ul><p>推荐项目：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uv-cpp:  https:<span class="comment">//github.com/wlgq2/uv-cpp</span></span><br></pre></td></tr></table></figure><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>RPC（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），即远程过程调用。可以通俗地理解为服务器为客户端提供服务。比如Redis，由客户端向Redis服务器发起请求，server在接受到请求后进行处理，最后把结果返回给客户端。</p><p>RPC框架的源码一般比较多，比如gRPC、bRPC等，但是一开始学习RPC会找不到重点，gRPC、bRPC代码量也会很大。在校招时间允许的范围内，先选择一个熟练使用。</p><p>有个更加简单的RPC项目<code>libjson-rpc</code>，可以帮助你理解RPC：</p><ul><li><a href="https://github.com/cinemast/libjson-rpc-cpp">libjson-rpc</a><ul><li>底层负责网络通信的网络库设计，比如上面的libuv、muduo等</li><li>传输协议的前后的序列化方式</li><li>服务器怎么处理数据，怎么确定一个请求执行什么操作</li></ul></li><li><a href="https://github.com/miloyip/json-tutorial">json-tutorials</a>  教程详细讲述了怎么设计一个json解析器、生成器，不过是C语言版本。对应的C++是 <a href="https://github.com/Tencent/rapidjson">rapidJson</a>，作者是同一个人。</li></ul><p><strong>推荐项目</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//github.com/szza/jrpc</span></span><br></pre></td></tr></table></figure><p>这个项目两个好处：</p><ul><li>传承至<code>libjson-rpc</code>和<code>muduo</code>，如果遵循上面的建议，那么<code>jrpc</code>会非常好懂。</li><li>底层的网络通信基于c++11设计，更加方便理解。</li><li>中间的Json设计，基于<a href="https://github.com/miloyip/json-tutorial">json-tutorials</a> 改进，也是<code>rapidJson</code>的简化</li><li>里面还有文档专门描述了这个RPC的过程。</li></ul><p>你甚至可以将<code>Nanolog</code>融入到这个项目中，实现日志功能。因此，这个项目不仅能让你理解RPC，还能把之前学的项目串联起来，融为一体，颇为丰富。</p><p><strong>protobuf</strong></p><p>如果时间有余，可以看看<code>protobuf</code>使用。</p><h3 id="coroutine"><a href="#coroutine" class="headerlink" title="coroutine"></a>coroutine</h3><p>libuv、muduo、redis等都是基于事件驱动的回调函数机制，你学完也肯会觉得回调函数这种机制链比较复杂。在golang中有了coroutine（协程）后，C++中也开始有了coroutine库，使用<strong>同步思想完成异步任务</strong>。经历过前面的项目，会更加深刻的感受到 coroutine 的便利。</p><p>此时，如果还有余力，可以看看怎么实现一个协程库。刚开始可以从云风的<a href="https://github.com/cloudwu/coroutine/">coroutine</a>项目开始，他用的是Linux下封装的<code>ucontext</code>函数簇，实现了一个共享栈协程模型，学完要知道：</p><ul><li>协程怎么切换的</li><li>协程之间怎么调度的</li></ul><p>如果上面都完成了，有能力可以去看看<a href="https://github.com/apache/incubator-brpc">bRPC</a>的怎么实现的bthread，bthread是一个多线程多协程模型，相对复杂，bRPC就是基于<code>bthread</code>建立起来的。在bRPC有详细的官网文档可以参考，可以看看里面的设计思想。</p><p><strong>by the way</strong></p><p>最后建议一点，在有限的时间内，没有必要去实现 <code>STL</code> 这类项目，因为STL的各个数据结构原理本身不难，但是如果你尝试去实现他却很难，因为STL里涉及到大量的元编程，元编程属于黑魔法，用人脑完成编译器的任务，除了在学习的时候会用到，估计这辈子在公司里都用不到。</p><p>有这个时间，不如去看看facebook的C++库<a href="https://github.com/facebook/folly">folly</a>。</p><p>上面一个流程，是比较完整的C++后端进阶流程，也是自己之前学习的方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前文【C++ &amp;amp; Linux后端进BAT的学习路线】中，讲述了C++后端的学习路线。进一步，本文讲解两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;怎么阅读学习C++源码&lt;/li&gt;
&lt;li&gt;学习哪些C++项目&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;怎么学习&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="后端路线" scheme="https://szza.github.io/tags/%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>C++ &amp; Linux 后端：进BAT的学习路线</title>
    <link href="https://szza.github.io/2021/03/01/Path/1/"/>
    <id>https://szza.github.io/2021/03/01/Path/1/</id>
    <published>2021-03-01T07:29:46.000Z</published>
    <updated>2022-02-14T13:29:38.000Z</updated>
    
    <content type="html"><![CDATA[<p>我是2019年8月全面开始学习C++，之前只是有一点C++的基础，仅看过《C++ prime Plus 第六版》，2020年参加7月参加校招，并且取得几个大厂的Offer，下面是我几个月的学习路线。</p><p>C++，相对别的语言学习门槛会高一点，主要原因是学习路线不明确，没有像Java那么多资料。但<strong>在大厂里</strong>C++岗位不比java少多少，比如腾讯、百度、阿里云、网易、华为等。下面介绍下自己学习C++ &amp; Linux 后端的路线，以及自己的看书方式，供参考。</p><p>Cpper雄起！！！</p><h2 id="C-基础"><a href="#C-基础" class="headerlink" title="C++基础"></a>C++基础</h2><p>如果刚接触C++，建议去B站搜C++视频辅助《C++ prime 第五版》一起学习。</p><ul><li>b站黑马程序员的C++学习视频</li><li>《C++ prime 第五版》</li></ul><p>关于《C++ prime 第五版》与 《C++ prime <strong>Plus</strong> 第六版》的选择问题：如果只能选择一本，个人建议选《C++ prime 第五版》。</p><ul><li>《C++ prime 第五版》：这本书对于刚入门的学生可能有点难，因为有些章节的知识存在一些跳跃性。但是讲解的比较透彻、深入，因此需要配合视频一起学习。但是，看完一遍后就可以将其作为字典、工具书，以后遇到不懂的地方来看，总是能给你启发。</li><li>《C++ prime <strong>Plus</strong> 第六版》：这本书，讲解比较连贯，没有跳跃性。但是主体基本是以C++98/03进行讲解，而关于C++11的知识大都在附录，且属于一笔带过存在，讲解的不够透彻。当时自己看完这本书，后来又重新买了本《C++ prime 第五版》，看完才算C++入门了。</li></ul><p>根据自身喜好选一本，无论哪本都建议配合视频，因为光看书太枯燥了。而且如果时间不充足，不建议逐章节阅读，比如你之前有C语言基础，那么就可以直接从C++部分开始。</p><h2 id="C-11"><a href="#C-11" class="headerlink" title="C++11"></a>C++11</h2><p>C++11对C++进行了较大的更新，不仅能帮助你更安全、更方便地使用C++，而且校招考察的也较多，建议看看、学习下。关于C++11的知识建议阅读下面三本书：</p><ul><li>《深入理解C++11：C++11新特性解析与应用》</li><li>《Effective Modern C++》</li><li>《modern C++ tutorials》</li></ul><p>注意，如果时间不充足，看书不用按照顺序看，可以先把重要的知识点看完，再看别的小的点。</p><h2 id="C-进阶"><a href="#C-进阶" class="headerlink" title="C++进阶"></a>C++进阶</h2><p>下面这三本书，主要是关于C++的对象模型、C++的使用建议、STL底层实现等方面，用于提升C++内功：</p><ul><li><p>《深度探索C++对象模型》 </p><p>这本书虽然是很早的书，但是里面的内容依然适用，能极大地提升C++的内功。时间不够，可只看前四章。</p></li><li><p>《effective c++》/ 《more effective C++》</p><p>可以让你知道怎么正确并且更好地使用C++技术。</p></li><li><p>《STL源码剖析》</p><p>建议看看，能让你深入了解STL的实现原理，不仅仅是各个数据结构是怎么实现的，还涉及到一些设计模式、模板的知识。</p></li></ul><p>上面有些知识过于硬核，也都是<strong>侯捷老师</strong>翻译的，如果觉得枯燥了点，可以搭配侯捷老师的视频一起学习：</p><ul><li><a href="https://www.bilibili.com/video/BV1o4411A7dg/?spm_id_from=333.788.recommend_more_video.2">C++标准 11-14</a></li><li><a href="https://www.bilibili.com/video/BV1b4411977J/?spm_id_from=333.788.recommend_more_video.1">内存管理</a></li><li><a href="https://www.bilibili.com/video/BV1yo4y1o7yA/?spm_id_from=333.788.recommend_more_video.0">C++标准库 体系结构与内核分析</a></li></ul><p>到此，C++知识基本已经完结，可能有人觉得还没涉及到C++模板的知识。但是在上面的推荐的知识中，已经包含了常用的模板使用技术，更加深入的<strong>元编程</strong>属于黑魔法级别，不会有公司使用的。</p><p>当然，如果对模板、元编程非常有兴趣，可以看看：</p><ul><li>《C++模板 第二版》（目前还没有中文版）</li></ul><p>那么下面就要进入语言基础之外的体系了。</p><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>对于C/C++程序员，更加推荐 两本书：《深入理解计算机系统》 和 《程序员的自我修养-链接、装载》。这两本书能站在编译器的角度看待C/C++语言规则，校招问的也比较多，比如<code>new</code>是在底层是怎么一个过程？如果校招准备时间不够，可以不看 《程序员的自我修养-链接、装载》。</p><ul><li>《深入理解计算机系统》：重点章节：2，3，5，7，9</li><li>《程序员的自我修养-链接、装载》</li></ul><p>如果时间有余，则可以进一步看《操作系统精髓与设计原理  第8版》，如果是非科班可以和<a href="https://www.bilibili.com/video/BV1YE411D7nH?from=search&seid=18413025192457118772">王道考研-操作系统</a>一起食用更佳。</p><ul><li>《操作系统精髓与设计原理  第8版》： 时间不足章节选看</li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>好嘞，到这里真正开始进入到Linux后端开发了。需要先学习Linux的系统编程、网络编程知识，毫无疑问两本书：</p><ul><li><code>APUE</code>  – 《UNIX环境高级编程》 重点章节：3,4,5,7,8,10,11,12。</li><li><code>UNP</code> –《UNIX网络编程》前面8章及11，14，16，26。整个书只看 <code>TCP/UDP</code> </li></ul><p>但有个难题，这两本书太厚了，对于初学者不友好，一开始看可能陷入无法理解的细节中。自己的方法是：</p><ul><li>先看上面列举出的重点章节，其余章节用到了再看；</li><li>配合视频：我自己看的是<a href="https://www.bilibili.com/video/BV1dt411f7TZ?from=search&seid=7353292615540783179">黑马Linux全套视频</a> 及 <a href="https://www.bilibili.com/video/BV1eb411F74G">Linux网络编程视频</a>，我也是跳着看的。后者音质可能不太好，看自己能不能接受。</li></ul><p>至于搭建linux环境，有两个方法：</p><ul><li>windows里下载wsl2，然后 vscode下载个<code>Remote-WSL</code>插件，vscode直接登录到wsl里，好用到爆炸！！！</li><li>但是<code>wsl2</code>有几个缺陷，和调试网络有关的功能用不了，比如<code>tcpdump</code>等。那么此时可以开启一个虚拟机，vscode下载<code>Remote SSH</code>插件远程登录即可。</li></ul><p>如果只是日常开发，建议选择wsl，比较方便，调试网络之类的选择虚拟机。</p><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><p>如果上面都已经看完，则表示已经具备 C++ &amp; Linux 后端开发的基础了，那么下面可以开始学习服务器开发了：</p><ul><li>《Linux高性能服务器编程》</li><li><a href="https://github.com/chenshuo/muduo">开源项目-《Muduo》</a>及<a href="https://www.bilibili.com/video/BV11b411q7zr">Muduo讲解视频</a></li></ul><p>游双老师的《Linux高性能服务器编程》，这本书剖析了设计一个服务器的各个要点，其中的点面试也经常考，比如<code>epoll</code>的ET模式能使用阻塞IO吗？这本书强势推荐。</p><p>而陈硕老师的<code>muduo</code>项目，其设计上也符合《Linux高性能服务器编程》上的设计，b站有老师逐行代码讲解了<code>muduo</code>，不过这个视频噪音大了一点，我坚持看完了收获颇大。</p><p>补充：有人可能觉得，muduo项目烂大街，但是你真的把里面的设计原理搞懂了吗？比如著名的<code>libuv</code>和<code>redis</code>的服务器相关的设计和<code>muduo</code>的设计完全一致，如果你搞懂了以后看redis源码也很轻松。其次有时间可以看看<code>libuv</code>，代码量不多，里面的多线程设计也具有参考价值。</p><h2 id="后端进阶"><a href="#后端进阶" class="headerlink" title="后端进阶"></a>后端进阶</h2><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>如果到此，你还使时间充足，想要冲刺核心部门，那么可以学习RPC的相关知识。你可以从<code>jsonrpc</code>开始学习json是怎么实现的，进阶一点你可以看看<code>brpc</code>的设计方式，比如它的协程是怎么设计的。</p><ul><li><a href="https://github.com/cinemast/libjson-rpc-cpp">libjson</a></li><li><a href="https://github.com/apache/incubator-brpc">brpc</a></li></ul><p>RPC就避免不了序列化协议部分，关于这个常用的有： <code>protobuff</code>, <code>json</code>，<code>xml</code> 。</p><ul><li><code>protobuf</code>：可以看看 <code>protobuff</code> 怎么使用。</li><li><code>json</code>：可以自己写个解析器，<a href="https://github.com/miloyip/json-tutorial">json-tutorials</a>详细分解了json的设计流程，看完基本就懂了。</li></ul><p>对于协议部分，要明白各个之间的区别、优劣势。</p><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>如果有时间，真的充足！！！可以看看redis的源码，Redis源码，个人觉得可以分为三个部分来看：</p><ol><li><p>服务器设计：这部分的主要内容就是：1）redis怎么接受客户端的输入、解析成指令；2）执行指令；3）怎么将指令结果返回给客户端。</p><p><code>aeEventLoop</code>的设计和 《Linux高性能服务器编程》讲解的总体类似，输入输出缓冲区的设计和muduo讲解的基本一致，也有应用层的流量控制。</p></li><li><p>数据结构设计：各个数据结构的设计，怎么融合到<code>aeEventLoop</code>中，成为服务器的一部分，实现了各个指令功能。</p></li><li><p>分布式设计：1）主从同步replication；2）<code>sentinel</code>模式：用于解决主从同步中的主服务宕机怎么办，故障转移等；3）集群。</p></li></ol><p>Redis整个设计大致如上，如果想在秋招之前学习下，建议看下第一部分。第二部分时间仍然有剩余可以看下。推荐的书籍：</p><ul><li>《Redis设计与实现》</li><li>《Redis 5设计与源码分析》</li></ul><p>两本侧重点不同，前者侧重讲解原理，分析的比较清楚，只是代码是python的伪代码。后者结合redis的源码。结合看比较好。</p><p>最后，学习redis不能光看书和代码，要先学会使用！！！再去看，有几个网址可以看看</p><ul><li><a href="http://doc.redisfans.com/">Redis中文指令参考</a>：这是中文的，对于初学很友好</li><li><a href="https://redis.io/commands">Redis指令官网</a>：官网，实时更新，如果上面中文网页没有的知识，可以来这看。</li></ul><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>如果你的时间充足：</p><ul><li>《算法》</li><li>清华大学邓俊辉老师的《数据结构与算法》。</li></ul><h3 id="leetcode-刷题"><a href="#leetcode-刷题" class="headerlink" title="leetcode 刷题"></a>leetcode 刷题</h3><ul><li> Leetcode，时间充足刷前300道，至少200道，建议把《Leetcode精选TOP面试题》刷完</li><li>剑指offer 至少2遍，要非常熟悉里面的题目，因为这真能让你获得offer</li></ul><p>是否要购买Leetcode会员，能把前面的300道题目写完足够。如果300道写完，可以到牛客网继续刷真题，因为面试时的面试题是要处理输<br>入输出的，秋招时很多人因为不能熟练处理输入输出导致无法ac。如果还想买，建议和同学一起买，更加便宜。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>如果你时间充足，可以看看《TCP/IP 卷一》，时间不充足就不要看了。因为上面的书籍上、代码里都包含了常用的TCP/IP知识。</p><p>建议掌握以下Linux 命令，帮助你分析网络通信：</p><ul><li><code>tcpdump</code></li><li><code>lsof</code></li><li><code>netstat</code></li><li><code>netcat</code></li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>学会使用，cmake、gdb。</p><ul><li>cmake：如果你看了muduo的讲解视频，里面在讲解muduo的同时了怎么使用cmake</li><li><code>gdb</code>：建议学学，不仅有利于秋招，也能帮助自己学习源代码、调试</li></ul><h2 id="最后几点建议"><a href="#最后几点建议" class="headerlink" title="最后几点建议"></a>最后几点建议</h2><p>最后几点建议：</p><ul><li>要学会<code>markdown</code> 的使用，记录笔记</li><li>创建github账号，更新你的项目</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我是2019年8月全面开始学习C++，之前只是有一点C++的基础，仅看过《C++ prime Plus 第六版》，2020年参加7月参加校招，并且取得几个大厂的Offer，下面是我几个月的学习路线。&lt;/p&gt;
&lt;p&gt;C++，相对别的语言学习门槛会高一点，主要原因是学习路线不明</summary>
      
    
    
    
    
    <category term="后端路线" scheme="https://szza.github.io/tags/%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%BA%BF/"/>
    
  </entry>
  
  <entry>
    <title>从std::thread开始，迈入多线程编程的大门</title>
    <link href="https://szza.github.io/2021/03/01/thread/thread/"/>
    <id>https://szza.github.io/2021/03/01/thread/thread/</id>
    <published>2021-03-01T07:29:45.000Z</published>
    <updated>2023-07-31T14:53:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>经过千呼万唤，终于在C++11中，引入了线程库<code>std::thread</code>。本文要完成两个目标：</p><ul><li>如何使用<code>std::thread</code>创建线程</li><li>深入剖析<code>std::thread</code>的设计原理</li></ul><h2 id="使用std-thread"><a href="#使用std-thread" class="headerlink" title="使用std::thread"></a>使用std::thread</h2><p>在如下的demo中，在主线程中使用<code>std::thread</code>创建3个子线程，线程入口函数是<code>do_some_word</code>，在主线程运行结束前等待子线程结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;thread: &quot;</span>&lt;&lt;num&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> threadNums =<span class="number">3</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threadList;</span><br><span class="line">    threadList.reserve(threadNums);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 创建 threadNums 个线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx &lt; threadNums; ++idx) &#123; </span><br><span class="line">      threadList.emplace_back(<span class="built_in">std</span>::thread&#123;do_some_work, idx&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;work in main thread&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2 终止 threadNums 个线程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> idx=<span class="number">0</span>; idx &lt; threadNums; ++idx) &#123; </span><br><span class="line">      threadList[idx].join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;main thread end&quot;</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在demo中，在构造线程对象<code>std::thread&#123;do_some_work, idx&#125;</code>的时候，还是建议使用<code>&#123;&#125;</code>而不是<code>()</code>，以防止编译器产生错误的决议，具体原因可以参考前文【 别再徘徊于{}与()之间了，来学习正确用法】。</p><p>三个子线程共享输出缓冲区<code>std::cout</code>，此时没有采取任何机制保护线程间共享数据，因此上面demo的输出可能不符合你的预期，即很可能不是按照如下格式输出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">thread: <span class="number">1</span></span><br><span class="line">thread: <span class="number">2</span></span><br><span class="line">thread: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>实际上的输出，可能会非常混乱：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -g thread_unitest.cc  -o thread -lpthread &amp;&amp; ./thread</span><br><span class="line">  thread: thread: <span class="number">12</span><span class="comment">// 两个线程的输出融合在一起了，</span></span><br><span class="line">  </span><br><span class="line">      </span><br><span class="line">  work in main thread</span><br><span class="line">  thread: <span class="number">0</span>   <span class="comment">// 最先启动的线程，却最后输出</span></span><br><span class="line">  main thread end   <span class="comment">// 子线程都已中止</span></span><br></pre></td></tr></table></figure><p>从输出可以看出：</p><ul><li>先创建的线程，未必就先运行；</li><li>而且几个线程之间是互相抢档CPU资源的。</li></ul><p>线程间数据共享问题及其应对措施，留到后文讲解，下面讲解<code>std::thread</code>的设计。</p><h2 id="深入剖析-std-thread"><a href="#深入剖析-std-thread" class="headerlink" title="深入剖析 std::thread"></a>深入剖析 std::thread</h2><p>在<code>g++</code>中，<code>thread</code>是基于<code>pthread</code>实现的。本次主要从以下三个方面分析<code>std::thread</code>：</p><ul><li><code>std::thread</code>对象不可复制，只具有移动属性</li><li>每个线程具有唯一的标志，即线程id</li><li>创建子线程<h3 id="移动属性"><a href="#移动属性" class="headerlink" title="移动属性"></a>移动属性</h3>有很多书籍说，<code>std::thread</code>对象的所有权只能传递不能复制。实际上，就是<code>std::thread</code>对象，只具有移动属性，不具有复制属性。<code>std::thread</code>的构造函数如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  id_M_id;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  thread() <span class="keyword">noexcept</span> = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, </span><br><span class="line">           <span class="keyword">typename</span>... _Args,</span><br><span class="line">           <span class="keyword">typename</span> = _Require&lt;__not_same&lt;_Callable&gt;&gt;&gt;</span><br><span class="line">  <span class="keyword">explicit</span> thread(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args) &#123;</span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~thread() &#123;</span><br><span class="line">    <span class="keyword">if</span> (joinable())</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">terminate</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 禁止复制</span></span><br><span class="line">  thread(<span class="keyword">const</span> thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  thread&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> thread&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::thread 只具有移动属性</span></span><br><span class="line">  thread(thread&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123; swap(<span class="keyword">__t</span>); &#125;</span><br><span class="line"></span><br><span class="line">  thread&amp; <span class="keyword">operator</span>=(thread&amp;&amp; <span class="keyword">__t</span>) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (joinable())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">terminate</span>();</span><br><span class="line">    swap(<span class="keyword">__t</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以发现，<code>std::thread</code>禁止了复制构造函数、复制赋值表达式，只留下了移动构造函数、赋值，使得<code>std::thread</code>对象只能移动，不能复制。这就是本文开篇demo中使用<code>emplace_back</code>函数添加<code>std::thread</code>对象的原因，防止触发复制构造函数。</li></ul><p>向<code>threadList</code>中添加<code>std::thread</code>对象，有如下三种方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">threadList.emplace_back(<span class="built_in">std</span>::thread&#123;do_some_work, idx&#125;);<span class="comment">// 1) ok </span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::thread trd&#123;do_some_work, idx&#125;;</span><br><span class="line">threadList.push_back(trd);   <span class="comment">// 2) error</span></span><br><span class="line">threadList.push_back(<span class="built_in">std</span>::move(td));<span class="comment">// 3) ok</span></span><br><span class="line">threadList.emplace_back(<span class="built_in">std</span>::move(td)); <span class="comment">// 4) ok</span></span><br></pre></td></tr></table></figure><p>注意：当<code>push_back</code>接受的是右值时，底层调用的还是<code>emplace_back</code>函数，因此，<code>3)</code>和<code>4)</code>算是等价。</p><h3 id="std-thread-id"><a href="#std-thread-id" class="headerlink" title="std::thread::id"></a>std::thread::id</h3><p>观察可发现，在<code>std::thread</code>对象中，只有一个成员变量<code>_M_id</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id_M_id;</span><br></pre></td></tr></table></figure><p>这个类<code>id</code>全称是<code> std::thread::id</code>，实现如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">pthread_t</span> native_handle_type;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">id</span> &#123;</span> </span><br><span class="line"></span><br><span class="line">  native_handle_type_M_thread;  <span class="comment">// _M_thread 即 pthread_t 对象，线程的唯一辨识标志</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  id() <span class="keyword">noexcept</span> : _M_thread() &#123; &#125;  <span class="comment">// _M_thread 默认值是 0</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">id</span><span class="params">(native_handle_type __id)</span> : _<span class="title">M_thread</span><span class="params">(__id)</span> </span>&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">thread</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">hash</span>&lt;</span>thread::id&gt;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为 std::thread::id 对象重载了 == 运算</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(thread::id __x, thread::id __y) <span class="keyword">noexcept</span>;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(thread::id __x,  thread::id __y) <span class="keyword">noexcept</span>;</span><br><span class="line">  <span class="comment">// 为 std::thread::id 对象重载了 &lt;&lt; 操作</span></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">CharT</span>, <span class="keyword">class</span> _<span class="title">Traits</span>&gt;</span></span><br><span class="line">  <span class="keyword">friend</span> basic_ostream&lt;_CharT, _Traits&gt;&amp;</span><br><span class="line">  <span class="keyword">operator</span>&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __out, thread::id __id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，这个<code> std::thread::id</code>实际上，就是封装了<code>pthread_t</code>对象，用作每个线程标志。</p><ul><li><p>在构造<code> std::thread</code>对象的时候，如果没有设置线程入口函数，则线程<code>_M_id._M_thread</code>的值是0。</p><p>比如下面的demo中，<code>trd</code>没有设置线程入口函数，<code>trd</code>调用默认构造函数时，<code>trd</code>的<code>_M_id._M_thread</code>会被初始化为0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::thread trd;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;trd.get_id()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，打印线程标志<code>trd.get_id()</code>，输出的是却不是0。这仅仅是<code>std::thread::id</code>在重载<code>&lt;&lt;</code>操作符时的设定，用于提示调用者线程没有启动。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++  thread_.cc -o thread_ &amp;&amp; ./thread_</span><br><span class="line">thread::id of a non-executing thread</span><br></pre></td></tr></table></figure><p>可以到<code>std::thread::id</code>重载的<code>&lt;&lt;</code>操作符的函数中一探究竟：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> _<span class="title">CharT</span>, <span class="keyword">class</span> _<span class="title">Traits</span>&gt;</span></span><br><span class="line"><span class="keyword">inline</span> basic_ostream&lt;_CharT, _Traits&gt;&amp; <span class="keyword">operator</span>&lt;&lt;(basic_ostream&lt;_CharT, _Traits&gt;&amp; __out, thread::id __id) &#123;</span><br><span class="line">  <span class="comment">// 线程未启动 </span></span><br><span class="line">  <span class="keyword">if</span> (__id == thread::id())</span><br><span class="line">    <span class="keyword">return</span> __out &lt;&lt; <span class="string">&quot;thread::id of a non-executing thread&quot;</span>;</span><br><span class="line">  <span class="comment">// 线程成功启动</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> __out &lt;&lt; __id._M_thread;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// id的相等判断 </span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(thread::id __x, thread::id __y) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> __x._M_thread == __y._M_thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，判断一个线程是否启动，可如下检测：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">thread_is_active</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::thread::id&amp; thread_id)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> thread_id != <span class="built_in">std</span>::thread::id();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置了线程入口函数，<code>_M_id._M_thread</code>才会有值显示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::thread trd&#123;[]&#123;<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;wok in sub-thread\n&quot;</span>;&#125;&#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;trd.get_id()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  trd.join();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出的是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++  thread_.cc -o thread_ -lpthread &amp;&amp; ./thread_</span><br><span class="line"><span class="number">139794901763840</span></span><br><span class="line">wok in sub-thread</span><br></pre></td></tr></table></figure><p>当设置了显示入口函数时，<code>_M_id._M_thread</code>才是线程的<code>tid</code>值，由<code>pthread_create(&amp;tid, NULL, ...)</code>函数设置。</p></li></ul><p><strong>by the way</strong></p><p>在创建<code>std::thread</code>对象<code>trd</code>时，如果设置了线程入口函数，那么就必须使用<code>trd.join()</code>或者<code>trd.detach()</code>来表达子线程与主线程的运行关系，否则在<code>std::thread</code>对象析构时，整个程序会被<code> std::terminate()</code>中止。</p><p>没有设置线程入口函数，<code>trd.joinable()</code>返回值就是<code>false</code>，因此不会触发<code>std::terminate()</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~thread() &#123;</span><br><span class="line">  <span class="keyword">if</span> (joinable())</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">terminate</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建子线程"><a href="#创建子线程" class="headerlink" title="创建子线程"></a>创建子线程</h3><p>当构造<code>std::thread</code>对象时，设置了线程入口函数，会在相匹配的构造函数里调用<code>pthread_create</code>函数创建子线程。先看整体实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// std::thread 构造函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, </span><br><span class="line">            <span class="keyword">typename</span>... _Args,</span><br><span class="line">            <span class="keyword">typename</span> = _Require&lt;__not_same&lt;_Callable&gt;&gt;&gt;</span><br><span class="line">   <span class="keyword">explicit</span> thread(_Callable&amp;&amp; __f, _Args&amp;&amp;... __args)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">static_assert</span>( __is_invocable&lt;<span class="keyword">typename</span> decay&lt;_Callable&gt;::type, </span><br><span class="line">                                     <span class="keyword">typename</span> decay&lt;_Args&gt;::type...&gt;::value,</span><br><span class="line">                     <span class="string">&quot;std::thread arguments must be invocable after conversion to rvalues&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Create a reference to pthread_create, not just the gthr weak symbol.</span></span><br><span class="line">       <span class="keyword">auto</span> __depend = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>(*)()&gt;(&amp;pthread_create);</span><br><span class="line">       <span class="comment">// 启动线程</span></span><br><span class="line">       _M_start_thread(_S_make_state(__make_invoker(<span class="built_in">std</span>::forward&lt;_Callable&gt;(__f), </span><br><span class="line">                                                    <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...)),</span><br><span class="line">                       __depend);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>再细看构造函数执行流程：</p><ol><li><p>在编译期判断构造<code>std::thread</code>对象时设置的线程入口函数<code>__f</code>及其参数<code>__args</code>能否调用。</p><p>比如，下面的demo中，线程入口函数<code>thread_func</code>有个<code>int</code>类型的参数<code>arg</code>，如果传入的参数<code>__args</code>无法隐式转换为<code>int</code>类型，或者没有设置<code>__args</code>，都会触发<code>std::thread</code>构造函数中的静态断言<code>static_assert</code>，报错：<em>error: static assertion failed: std::thread arguments must be invocable after conversion to rvalues</em> 。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;   &#125;</span><br><span class="line">   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread trd_1&#123;thread_func, <span class="string">&quot;str&quot;</span>&#125;;  <span class="comment">// arg类型不对</span></span><br><span class="line">    <span class="built_in">std</span>::thread trd_2&#123;thread_func&#125;;    <span class="comment">// 缺少 arg</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将线程入口函数<code>__f</code>及其参数<code>__args</code>进一步封装起来。</p><p>这里是使用<code>__make_invoker</code>完成的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__make_invoker(<span class="built_in">std</span>::forward&lt;_Callable&gt;(__f), <span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...))</span><br></pre></td></tr></table></figure><p><code>__make_invoker</code>的作用是返回一个<code>_Invoker</code>对象，<code>_Invoker</code>是个仿函数，通过<code>_Invoker()</code>就可以以指定的参数<code>__args</code>直接执行线程入口函数<code>__f</code>。类似于<code>std::bind</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_num</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// wrapper</span></span><br><span class="line">  <span class="keyword">auto</span> invoker =  <span class="built_in">std</span>::bind(print_num, <span class="number">-9</span>);</span><br><span class="line">  <span class="comment">// 直接调用 invoker() 就可以以指定参数 -9 调用 print_num</span></span><br><span class="line">  invoker();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动子线程</p><p>在调用<code>_M_start_thread</code>函数启动子线程前，执行过程：创建 <code>_State_ptr</code>的对象，来封装<code>_Invoker</code>对象，再传递给<code>_M_start_thread</code>函数。这个过程，由<code>_S_make_state</code>函数完成，<code>_S_make_state</code>最终返回<code>_State_ptr</code>对象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">State</span> &#123;</span></span><br><span class="line">    <span class="keyword">virtual</span> ~_State();          <span class="comment">// 虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">void</span> _M_run() = <span class="number">0</span>;  <span class="comment">// 线程运行函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">using</span> _State_ptr = <span class="built_in">unique_ptr</span>&lt;_State&gt;;<span class="comment">// 父类指针</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 子类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">State_impl</span> :</span> <span class="keyword">public</span> _State &#123;</span><br><span class="line">    _Callable_M_func;<span class="comment">// 线程入口函数</span></span><br><span class="line">   </span><br><span class="line">    _State_impl(_Callable&amp;&amp; __f) : _M_func(<span class="built_in">std</span>::forward&lt;_Callable&gt;(__f))</span><br><span class="line">    &#123; &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">void</span> _M_run() &#123; _M_func(); &#125; <span class="comment">// 执行线程入口函数</span></span><br><span class="line">&#125;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 传入_Invoker对象，返回 _State_ptr 对象</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable&gt;</span><br><span class="line"><span class="keyword">static</span> _State_ptr _S_make_state(_Callable&amp;&amp; __f)  &#123;</span><br><span class="line">    <span class="keyword">using</span> _Impl = _State_impl&lt;_Callable&gt;;</span><br><span class="line">    <span class="comment">// 使用子类对象来初始化父类</span></span><br><span class="line">    <span class="keyword">return</span> _State_ptr&#123;<span class="keyword">new</span> _Impl&#123;<span class="built_in">std</span>::forward&lt;_Callable&gt;(__f)&#125;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_S_make_state</code>函数，将线程入口函数<code>__f</code>及其参数<code>__args</code>封装到<code>_State_ptr</code>对象<code>_State_ptr_obj</code>中， 这样最后可以通过<code>_State_ptr_obj-&gt;_M_run()</code>来调用<code>__f</code>。</p><p>下面到了<code>_M_start_thread</code>函数了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> thread::_M_start_thread(_State_ptr state, <span class="keyword">void</span> (*)())</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">const</span> <span class="keyword">int</span> err = __gthread_create(&amp;_M_id._M_thread,</span><br><span class="line">                                        &amp;execute_native_thread_routine, <span class="comment">// 线程执行函数</span></span><br><span class="line">                                        state.get());</span><br><span class="line">       <span class="keyword">if</span> (err)</span><br><span class="line">         __throw_system_error(err);</span><br><span class="line">       state.release();</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 内部调用的是 pthread_create 函数</span></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __gthread_create(<span class="keyword">pthread_t</span> *__threadid, <span class="keyword">void</span> *(*__func) (<span class="keyword">void</span>*), <span class="keyword">void</span> *__args)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> pthread_create(__threadid, <span class="literal">NULL</span>, __func, __args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 内部执行线程入口函数</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">execute_native_thread_routine</span><span class="params">(<span class="keyword">void</span>* __p)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       thread::_State_ptr <span class="keyword">__t</span>&#123;<span class="keyword">static_cast</span>&lt;thread::_State*&gt;(__p)&#125;;</span><br><span class="line">       <span class="keyword">__t</span>-&gt;_M_run();<span class="comment">// 运行线程入口函数</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>因此，在执行完<code>_M_start_thread</code>函数后，才具有<code>_M_start_thread !=0</code>。</p></li></ol><p>好，到此为此已实现了本文开篇提出的两个目标，下一篇将继续讲解线程间共享数据的访问。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;经过千呼万唤，终于在C++11中，引入了线程库&lt;code&gt;std::thread&lt;/code&gt;。本文要完成两个目标：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如何使用&lt;code&gt;std::thread&lt;/code&gt;创建线程&lt;/li&gt;
&lt;li&gt;深入剖析&lt;code&gt;std::thread&lt;/</summary>
      
    
    
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>剖析 std::unordered_map 插入节点过程</title>
    <link href="https://szza.github.io/2021/03/01/C++/2_/"/>
    <id>https://szza.github.io/2021/03/01/C++/2_/</id>
    <published>2021-03-01T07:15:07.000Z</published>
    <updated>2022-02-20T07:23:08.000Z</updated>
    
    <content type="html"><![CDATA[<p>观前提醒，横屏有助于提升阅读体验。</p><p>上一节<a href="">剖析 std::unordered_map 具有O(1)时间复杂度的原理</a>中讲解了<code>std::unordered_map</code>应对hash冲突、退化，实现O(1)时间复杂度的原理。这一节从源码角度看看它底层实现细节。</p><p>在本节，由于C++的STL中模板参数较多，为便于描述：</p><ul><li>将模板参数较多的返回类型使用<code>auto</code>替代</li><li>将类的成员函数实现中的类模板参数以<code>...</code>替代</li></ul><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><p>下面从<code>insert</code>方法开始：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash_map;</span><br><span class="line">    hash_map.insert(&#123;<span class="number">1</span>, <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>insert</code>函数，内部是调用<code>_Hashtable</code>对象<code>_M_h.insert(...)</code>来实现的。为避免不必要的复制，会使用移动语义将<code>&#123;1,1&#125;</code>作为<code>_M_h.inser</code>的参数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;iterator, bool&gt;  insert(value_type&amp;&amp; __x) &#123; </span><br><span class="line">     <span class="keyword">return</span> _M_h.insert(<span class="built_in">std</span>::move(__x)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_M_h.insert</code>函数是由<code>_Hashtable</code>的父类<code>_Insert</code> 实现，因此该<code>hash_map.insert(...)</code>函数实际上调用的是<code>hashtable_policy.h/_Insert::insert(...)</code>方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;...&gt;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> _<span class="title">Insert</span>&lt;</span>...&gt; &#123; </span><br><span class="line">     <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Pair, <span class="keyword">typename</span> = _IFconsp&lt;_Pair&gt;&gt;</span><br><span class="line">    __ireturn_type insert(_Pair&amp;&amp; __v) </span><br><span class="line">     &#123;</span><br><span class="line">      __hashtable&amp; __h = <span class="keyword">this</span>-&gt;_M_conjure_hashtable();<span class="comment">// 从父类转换为子类</span></span><br><span class="line">      <span class="keyword">return</span> __h._M_emplace(__unique_keys(), <span class="built_in">std</span>::forward&lt;_Pair&gt;(__v));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>函数<code>__unique_keys()</code>的值是<code>std::true_type</code>类型，其值在<code>std::unordered_map</code>初始化时就已确定，是用于区分 <code>std:;unordered_map</code> 和  <code>std::unordered_multimap</code>：</p><ul><li> 对于 <code>std::unordered_map</code>，<code>__unique_keys</code> 是<code>std::true_type</code>类型</li><li> 对于 <code>std::unordered_multimap</code>，<code>__unique_keys</code> 是<code>std::false_type</code>类型</li></ul><p>因此，<code>__unique_keys()</code>默认构造函数，就能确定当前是哪种类型。 其初始化过程见下四步：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">bool</span> _Cache_hash_code, <span class="keyword">bool</span> _Constant_iterators, <span class="keyword">bool</span> _Unique_keys&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">Hashtable_traits</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">using</span> __hash_cached = __bool_constant&lt;_Cache_hash_code&gt;;</span><br><span class="line">    <span class="keyword">using</span> __constant_iterators = __bool_constant&lt;_Constant_iterators&gt;;</span><br><span class="line">    <span class="keyword">using</span> __unique_keys = __bool_constant&lt;_Unique_keys&gt;;<span class="comment">//1) 在此定义</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">bool</span> _Cache&gt;</span><br><span class="line"><span class="keyword">using</span> __umap_traits = __detail::_Hashtable_traits&lt;_Cache, <span class="literal">false</span>, <span class="literal">true</span>&gt;; <span class="comment">// 2) 特化为 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key,</span><br><span class="line">         <span class="keyword">typename</span> _Tp,</span><br><span class="line">         <span class="keyword">typename</span> _Hash  = hash&lt;_Key&gt;,</span><br><span class="line">         <span class="keyword">typename</span> _Pred  = <span class="built_in">std</span>::equal_to&lt;_Key&gt;,</span><br><span class="line">         <span class="keyword">typename</span> _Alloc = <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">const</span> _Key, _Tp&gt; &gt;,</span><br><span class="line">         <span class="keyword">typename</span> _Tr    = __umap_traits&lt;__cache_default&lt;_Key, _Hash&gt;::value&gt;&gt; <span class="comment">//3) 特化后在此传入</span></span><br><span class="line"><span class="keyword">using</span> __umap_hashtable = _Hashtable&lt;_Key, </span><br><span class="line">                                    <span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">const</span> _Key, _Tp&gt;,</span><br><span class="line">                                    _Alloc, </span><br><span class="line">                                    __detail::_Select1st,</span><br><span class="line">                                    _Pred, </span><br><span class="line">                                    _Hash,</span><br><span class="line">                                    __detail::_Mod_range_hashing,</span><br><span class="line">                                    __detail::_Default_ranged_hash,</span><br><span class="line">                                    __detail::_Prime_rehash_policy, </span><br><span class="line">                                    _Tr&gt;;  </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Key, </span><br><span class="line"><span class="keyword">typename</span> _Tp,</span><br><span class="line"><span class="keyword">typename</span> _Hash  = hash&lt;_Key&gt;,</span><br><span class="line"><span class="keyword">typename</span> _Pred  = equal_to&lt;_Key&gt;,</span><br><span class="line"><span class="keyword">typename</span> _Alloc = allocator&lt;<span class="built_in">std</span>::<span class="built_in">pair</span>&lt;<span class="keyword">const</span> _Key, _Tp&gt;&gt;&gt;</span><br><span class="line">class <span class="built_in">unordered_map</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typedef</span> __umap_hashtable&lt;_Key, _Tp, _Hash, _Pred, _Alloc&gt;  _Hashtable;</span><br><span class="line">  _Hashtable _M_h;   <span class="comment">// 4) 此时  __unique_keys() 即 std::true_type 类型</span></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hashtable-M-emplace"><a href="#Hashtable-M-emplace" class="headerlink" title="_Hashtable::_M_emplace"></a>_Hashtable::_M_emplace</h3><p>因此，<code>insert</code>函数内部将会调用如下实例化版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__h._M_emplace(<span class="built_in">std</span>::true_type, <span class="built_in">std</span>::forward&lt;_Pair&gt;(__v));</span><br></pre></td></tr></table></figure><p><code>_M_emplace</code>函数的执行步骤如下：</p><ol><li>构造新的节点<code>__node</code>：先为新的节点分配内存，并以传入的参数调用构造函数</li><li>使用<code>__node-&gt;key</code>的来计算hashcode</li><li>根据hashcode计算将要插入的桶索引<code>__bkt</code></li><li>为了确保<code>__node</code>这个节点在<code>_Hashtable</code>中并没有存储过，因此要先在桶的链表中查找<ul><li>如果找到，则不插入</li><li>如果没有找到，则调用 <code>_M_insert_unique_node</code> 函数插入节点。在此过程中可能会发送 Rehash行为</li></ul></li></ol><p>先看整个流程，再分叙各个细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> _Hashtable&lt;_...&gt;::_M_emplace(<span class="built_in">std</span>::true_type, _Args &amp;&amp; ...__args) &#123;</span><br><span class="line">    <span class="comment">// 分配节点</span></span><br><span class="line">    __node_type *__node = <span class="keyword">this</span>-&gt;_M_allocate_node(<span class="built_in">std</span>::forward&lt;_Args&gt;(__args)...);</span><br><span class="line">    <span class="comment">// 取出节点的 key</span></span><br><span class="line">    <span class="keyword">const</span> key_type &amp;__k = <span class="keyword">this</span>-&gt;_M_extract()(__node-&gt;_M_v()); </span><br><span class="line">    <span class="comment">// 键对应的 hashcode</span></span><br><span class="line">    __hash_code __code;                                         </span><br><span class="line">    __try &#123;</span><br><span class="line">        __code = <span class="keyword">this</span>-&gt;_M_hash_code(__k);</span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_M_deallocate_node(__node);</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点对应的桶索引</span></span><br><span class="line">    size_type __bkt = _M_bucket_index(__k, __code);    </span><br><span class="line">    <span class="keyword">if</span> (__node_type *__p = _M_find_node(__bkt, __k, __code)) &#123;</span><br><span class="line">        <span class="comment">// 如果在 _M_bucket 中已经有这个 __node， 则不插入</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_M_deallocate_node(__node);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">make_pair</span>(iterator(__p), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 插入新节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">make_pair</span>(_M_insert_unique_node(__bkt, __code, __node), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hashtable-M-find-node"><a href="#Hashtable-M-find-node" class="headerlink" title="_Hashtable::_M_find_node"></a>_Hashtable::_M_find_node</h3><p><code>_M_find_node</code> 函数，在<code>_M_bucket[__btk]</code>指向的链表中查找是否有hashcode是<code>__code</code>的键<code>__k</code> ，时间复杂度是O(N)。其内部是调用<code>_M_find_before_node</code>函数来查找待插入节点<code>__node</code>：</p><ul><li>如果已存在<code>__node</code>，则<code>_M_find_before_node</code> 函数返回<code>__node</code>的前一个位置，</li><li>否则返回<code>nullptr</code></li></ul><p><code>_M_find_node</code> 函数实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__node_type* _M_find_node(size_type __bkt, <span class="keyword">const</span> key_type &amp;__key, __hash_code __c) <span class="keyword">const</span> &#123;</span><br><span class="line">    __node_base *__before_n = _M_find_before_node(__bkt, __key, __c);</span><br><span class="line">    <span class="keyword">if</span> (__before_n)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;__node_type *&gt;(__before_n-&gt;_M_nxt);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_M_find_before_node</code> 函数，即在<code>_M_buckets[__btk]</code>中查找是否存在<code>__node</code>，由<code>_M_equals</code>函数判断两个节点是否相同。如果遍历完整个链表也没发现存在<code>__node</code>，则返回<code>nullptr</code>。</p><p>其中，当前节点不存在此链表，有两种可能：</p><ul><li><p><code>_M_bucket_index(__p-&gt;_M_next()) != __n</code>：表示下一个节点的位置不位于当前桶中。</p><p>这是因为，为了能遍历<code>std::unordered_map</code>，每个桶<code>_M_bucket[__btk]</code>指向的链表的最后一个节点，是另一个桶的哨兵节点（这在后面<strong>R</strong>ehash函数中会更加详细的说明），当<code>_M_bucket_index(__p-&gt;_M_next()) != __n</code>时，即当前链表中不存在<code>__node</code>节点。</p></li><li><p><code>__p-&gt;_M_nxt  == nullptr</code>：这个整个<code>_Hashtable</code>的最后一节点</p></li></ul><p>因此，当没有<code>load_factor &lt;= max_load_factor</code>限制，这个链表可能会很长，使得<code>_Hashtable</code>的时间复杂度恶化至<code>O(N)</code>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> _Hashtable&lt;...&gt;::_M_find_before_node(size_type __n, <span class="keyword">const</span> key_type&amp; __k, __hash_code __code)&#123;</span><br><span class="line">       __node_base *__prev_p = _M_buckets[__n]; <span class="comment">// 每个桶的哨兵节点</span></span><br><span class="line">       <span class="comment">// 这是个空桶，则直接return</span></span><br><span class="line">       <span class="keyword">if</span> (!__prev_p) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 从首节点开始遍历</span></span><br><span class="line">       <span class="keyword">for</span> (__node_type *__p = <span class="keyword">static_cast</span>&lt;__node_type *&gt;(__prev_p-&gt;_M_nxt);;__p = __p-&gt;_M_next()) &#123;</span><br><span class="line">           <span class="comment">// 已存在键__k的节点，直接返回前一个节点</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_M_equals(__k, __code, __p))</span><br><span class="line">               <span class="keyword">return</span> __prev_p;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 如果 __p-&gt;_M_next == nullptr，或者不在当前桶了，</span></span><br><span class="line">           <span class="comment">// 直接break，返回 nullptr</span></span><br><span class="line">           <span class="keyword">if</span> (!__p-&gt;_M_nxt || _M_bucket_index(__p-&gt;_M_next()) != __n)</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           __prev_p = __p;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>视线再回到<code>_Hashtable&lt;...&gt;::_M_emplace</code>函数：</p><ul><li>如果已经存在待插入节点<code>__node</code>，则直接返回<code>std::make_pair(iterator(__p), false);</code>，<code>iterator(__p)</code>指向<code>__node</code>的位置</li><li>如果不存在，则先调用<code>_M_insert_unique_node</code>函数，将<code>__node</code>插入到<code>_Hashtable</code>中，再返回<code>std::make_pair(iterator(__p), true);</code>，其中<code>iterator(__p)</code>是<code>_M_insert_unique_node</code>函数的返回值。</li></ul><p><code>_M_emplace</code>函数剩余过程如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> _Hashtable&lt;_...&gt;::_M_emplace(<span class="built_in">std</span>::true_type, _Args &amp;&amp; ...__args) &#123;  </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 如果在 _M_bucket 中已经有这个 __node， 则不插入</span></span><br><span class="line">    <span class="keyword">if</span> (__node_type* __p = _M_find_node(__bkt, __k, __code)) &#123;</span><br><span class="line">        <span class="comment">// There is already an equivalent node, no insertion</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;_M_deallocate_node(__node);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">make_pair</span>(iterator(__p), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入节点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">make_pair</span>(_M_insert_unique_node(__bkt, __code, __node), <span class="literal">true</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Hashtable-M-insert-unique-node"><a href="#Hashtable-M-insert-unique-node" class="headerlink" title="_Hashtable::_M_insert_unique_node"></a>_Hashtable::_M_insert_unique_node</h3><p>当决定要插入一个节点时，如下步骤：</p><ul><li>先调用<code>_M_need_rehash</code>函数，判断<code>_Hashtable</code>是否要<code>Rehash</code><ul><li>如果需要，则调用<code>_M_rehash</code>函数进行<code>Rehash</code>，然后重新计算要插入的桶索引<code>__btk</code></li><li>如果不需要，则直接使用原来的桶索引<code>__btk</code></li></ul></li><li>将待插入节点<code>__node</code>插入到桶<code>_M_bucket[__btk]</code>的头部</li><li>更新一些参数</li><li>将<code>__node</code>迭代器，返回给 <code>_M_emplace</code> 函数，使其进一步返回<code>std::make_pair(iterator(__node), true);</code></li></ul><p>插入一个节点的流程如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> _Hashtable&lt;...&gt;::_M_insert_unique_node(size_type  __bkt, </span><br><span class="line">                                            __hash_code __code, </span><br><span class="line">                                            __node_type* __node, </span><br><span class="line">                                            size_type  __n_elt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> __rehash_state &amp;__saved_state = _M_rehash_policy._M_state();</span><br><span class="line">    <span class="keyword">auto</span> __do_rehash = _M_rehash_policy._M_need_rehash(_M_bucket_count,</span><br><span class="line">                                                       _M_element_count,</span><br><span class="line">                                                       __n_elt);</span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="comment">// 如果确实需要rehash</span></span><br><span class="line">        <span class="keyword">if</span> (__do_rehash.first) &#123;</span><br><span class="line">            _M_rehash(__do_rehash.second, __saved_state);</span><br><span class="line">            <span class="comment">// 重新计算当前待插入节点的桶索引</span></span><br><span class="line">            __bkt = _M_bucket_index(<span class="keyword">this</span>-&gt;_M_extract()(__node-&gt;_M_v()), __code); </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;_M_store_code(__node, __code); <span class="comment">// __node-&gt;_M_hash_code = __code                  </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在 _M_bucket[__bkt] 前面插入</span></span><br><span class="line">        _M_insert_bucket_begin(__bkt, __node);</span><br><span class="line">        ++_M_element_count;</span><br><span class="line">        <span class="keyword">return</span> iterator(__node);</span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;_M_deallocate_node(__node);</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Power-rehash-policy-M-need-rehash"><a href="#Power-rehash-policy-M-need-rehash" class="headerlink" title="_Power_rehash_policy::_M_need_rehash"></a>_Power_rehash_policy::_M_need_rehash</h4><p><code>_M_need_rehash</code> 函数，判断是否需要<code>Rehash</code>，其函数的参数含义如下：</p><ul><li><code>__n_bkt</code>：<code>_Hashtable</code>的桶的个数</li><li><code>__n_elt</code>：<code>_Hashtable</code>的元素个数</li><li><code>__n_ins</code>：此次要插入的节点数</li></ul><p><code>__n_elt + __n_ins</code> 则是此次插入完成后<code>_Hashtable</code>的节点数。那么根据最大负载因子<code>max_load_factor</code>，可以计算出存储<code>__n_elt + __n_ins</code> 个节点需要的至少需要的桶数是 <code>__min_btks</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span> __min_bkts = (__n_elt + __n_ins) / (<span class="keyword">long</span> <span class="keyword">double</span>)_M_max_load_factor; <span class="comment">// 新的桶个数</span></span><br></pre></td></tr></table></figure><p>进一步，如果这个至少需要的桶数<code>__min_btks &gt;= __n_btks</code>，则表示当前桶容量不够，无法满足<code>load_factor &lt;= max_load_factor</code>的限制条件，就需要对<code>_Hashtable</code>执行<strong>R</strong>ehash，返回<code>std::make_pair(true, count)</code>，<code>count</code>是新的桶数。</p><p>如果以上条件都不满足，不需要<strong>R</strong>ehash，则直接返回<code>std::make_pair(false, 0)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> _M_need_rehash(<span class="built_in">std</span>::<span class="keyword">size_t</span> __n_bkt, <span class="built_in">std</span>::<span class="keyword">size_t</span> __n_elt, <span class="built_in">std</span>::<span class="keyword">size_t</span> __n_ins) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="comment">// 需要 rehash</span></span><br><span class="line">    <span class="keyword">if</span> (__n_elt + __n_ins &gt;= _M_next_resize) &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">double</span> __min_bkts = (__n_elt + __n_ins) / (<span class="keyword">long</span> <span class="keyword">double</span>)_M_max_load_factor; </span><br><span class="line">        <span class="keyword">if</span> (__min_bkts &gt;= __n_bkt)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">make_pair</span>(<span class="literal">true</span>,</span><br><span class="line">                                  _M_next_bkt(<span class="built_in">std</span>::max&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt;(__builtin_floor(__min_bkts) + <span class="number">1</span>,</span><br><span class="line">                                                                    __n_bkt * _S_growth_factor)));</span><br><span class="line"></span><br><span class="line">        _M_next_resize = __builtin_floor(__n_bkt * (<span class="keyword">long</span> <span class="keyword">double</span>)_M_max_load_factor);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">make_pair</span>(<span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">make_pair</span>(<span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hashtable-M-rehash"><a href="#Hashtable-M-rehash" class="headerlink" title="_Hashtable::_M_rehash"></a>_Hashtable::_M_rehash</h4><p><code>_M_rehash</code>函数，内部是调用<code>_M_rehash_aux</code>实现的，<code>__unique_keys()</code>由前面可知，在<code>std::unordered_map</code>中初始化为<code>std::true_type</code>类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">void</span>  _Hashtable&lt;...&gt;::_M_rehash(size_type __n, <span class="keyword">const</span> __rehash_state &amp;__state) &#123;</span><br><span class="line">    __try &#123;</span><br><span class="line">        _M_rehash_aux(__n, __unique_keys());</span><br><span class="line">    &#125;</span><br><span class="line">    __catch(...)&#123;</span><br><span class="line">        _M_rehash_policy._M_reset(__state);</span><br><span class="line">        __throw_exception_again;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hashtable-M-rehash-aux"><a href="#Hashtable-M-rehash-aux" class="headerlink" title="_Hashtable::_M_rehash_aux"></a>_Hashtable::_M_rehash_aux</h4><p><code>_M_rehash_aux</code>函数，执行步骤如下：</p><p><strong>1) 分配内存</strong></p><p>为<code>__n</code>个新桶分配内存<code>__new_buckets</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Hashtable&lt;&gt;::_M_rehash_aux(size_type __n, <span class="built_in">std</span>::true_type) &#123;</span><br><span class="line">     __bucket_type *__new_buckets = _M_allocate_buckets(__n); <span class="comment">// 分配 n 个新的桶</span></span><br><span class="line">     __node_type *__p = _M_begin();                           <span class="comment">// 旧桶的哨兵节点</span></span><br><span class="line">    </span><br><span class="line">     _M_before_begin._M_nxt = <span class="literal">nullptr</span>;<span class="comment">// 初始化</span></span><br><span class="line">     <span class="built_in">std</span>::<span class="keyword">size_t</span> __bbegin_bkt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2) 数据迁移</strong></p><p>将旧桶<code>__M_bucket</code>中的节点数据重新插入到<code>__new_buckets</code>中，在插入的过程中需要维持<code>__new_buckets</code>各个桶之间的联系，即当前空桶指向的链表的最后一个节要指向前一个空桶的哨兵节点。没明白吗？不急，往下看。</p><p><code>_Hashtable</code>有一个哨兵节点<code>_M_before_begin</code>， 它总是最后一个插入节点的空桶的哨兵节点：当一个节点<code>__p</code>要插入一个空桶<code>__new_buckets[__btk]</code>时，<code>_M_before_begin</code>就会指向变成<code>__new_buckets[__btk]</code>的哨兵节点，即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__new_buckets[__btk] = &amp;_M_before_begin; </span><br></pre></td></tr></table></figure><p><code>_Hashtable</code>需要借助 <code>_M_before_begin</code> 节点在当前空桶和上一个空桶之间建立联系，那么当数据插入完毕，整个<code>_Hashtable</code>才能变成一条<font color=red>“链表”</font>：<code>_M_before_begin._M_nxt</code>指向的就是最后一个空桶的首届点，从<code>_M_before_begin._M_nxt</code>开始遍历，最后一个节点的<code>__lastNode-&gt;_M_next</code>即<code>nullptr</code>。</p><p><code>begin()</code>和<code>end()</code>迭代器即如此实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Hashtable::begin()</span></span><br><span class="line"><span class="function">iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> iterator(_M_begin());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">__node_type* _M_begin() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;__node_type *&gt;(_M_before_begin._M_nxt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// _Hashtable::end()</span></span><br><span class="line"> <span class="function">iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> iterator(<span class="literal">nullptr</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>下面是最精彩的部分！！！</p><p><strong>空桶中插入节点</strong></p><p>当待插入节点<code>__p</code>将要插入到一个空桶时，那么需要在这个空桶和上一个空桶（已经不是空桶了）之间建立联系，建立步骤如下三步：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__p-&gt;_M_nxt = _M_before_begin._M_nxt;  <span class="comment">// 1</span></span><br><span class="line">_M_before_begin._M_nxt = __p;  <span class="comment">// 2</span></span><br><span class="line">_new_buckets[__bkt] = &amp;_M_before_begin;  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><ul><li><p>由于采用头部插入法在每个链表中插入新节点，因此第一个插入到空桶<code>_new_buckets[__bkt]</code>的节点<code>__p</code>将会成为这个链表的最后一个节点。因此第一步的代码，就实现了让空桶<code>_new_buckets[__bkt]</code>的最后一个节点指向前一个空桶的首节点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__p-&gt;_M_nxt = _M_before_begin._M_nxt; <span class="comment">// 前一个空桶的哨兵节点是_M_before_begin</span></span><br></pre></td></tr></table></figure></li><li><p><code>_M_before_begin</code> 总是作为哨兵节点，当有一个节点<code>__p</code>插入空桶时，<code>_M_before_begin</code>就将作为新空桶的哨兵节点，那么<code>_M_before_begin-&gt;next</code>就应该是此刻空桶<code>__new_buckets[__btk]</code>第一个节点，即<code>__p</code>，因此就有了第2、3步。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_M_before_begin._M_nxt = __p; <span class="comment">// 指向第一个节点</span></span><br><span class="line">_new_buckets[__bkt] = &amp;_M_before_begin;  <span class="comment">// 将 _M_before_begin 作为哨兵节点</span></span><br></pre></td></tr></table></figure><p>那还有什么没有完成？</p><p><code>_M_before_begin</code>已经是当前空桶的哨兵节点，那么前一个空桶的哨兵节点就不能再是<code>_M_before_begin</code>。由于在上面的第一步中，将<code>__p-&gt;next</code>指向了前一个空桶的首节点，则顺理成章地将<code>__p</code>变成前一个空桶的哨兵节点。</p><p>当然，当<code>__p</code>是整个<code>_Hashtable</code>的第一个节点，那么当前空桶就是第一个空桶，此时<code>__p-&gt;_M_next</code>就是<code>nullptr</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (__p-&gt;_M_nxt)</span><br><span class="line">    __new_buckets[__bbegin_bkt] = __p;<span class="comment">// 将 __p 作为前一个桶的哨兵节点</span></span><br><span class="line">__bbegin_bkt = __bkt;   <span class="comment">// __bbegin_bkt 记录前一个空桶索引</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>非空桶中插入节点</strong></p><p>如果<code>_new_buckets[__btk]</code> 中已经有节点，则直接在头部插入即可，没有复杂性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__p-&gt;_M_nxt = __new_buckets[__bkt]-&gt;_M_nxt;</span><br><span class="line">_new_buckets[__bkt]-&gt;_M_nxt = __p;</span><br></pre></td></tr></table></figure><p><strong>3） 数据迁移完成</strong></p><p>当数据迁移完成，即<code>_M_buckets</code>中节点全更新到<code>_new_buckets</code>中，需要释放<code>_M_buckets</code>的内存，并且将<code>_M_buckets</code>指向<code>_new_buckts</code>，再更新其他参数即可。</p><p>完整的代码细节过程如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _Hashtable&lt;&gt;::_M_rehash_aux(size_type __n, <span class="built_in">std</span>::true_type) &#123;</span><br><span class="line">     __bucket_type *__new_buckets = _M_allocate_buckets(__n); <span class="comment">// 分配 n 个新的桶</span></span><br><span class="line">     __node_type *__p = _M_begin();                           <span class="comment">// 旧桶的哨兵节点</span></span><br><span class="line">     _M_before_begin._M_nxt = <span class="literal">nullptr</span>;</span><br><span class="line">     <span class="built_in">std</span>::<span class="keyword">size_t</span> __bbegin_bkt = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将旧桶中的节点迁移至新桶中</span></span><br><span class="line">     <span class="keyword">while</span> (__p) &#123;</span><br><span class="line">         __node_type* __next = __p-&gt;_M_next();</span><br><span class="line">         <span class="comment">// 节点 p 在新桶中的索引</span></span><br><span class="line">         <span class="built_in">std</span>::<span class="keyword">size_t</span> __bkt = __hash_code_base::_M_bucket_index(__p, __n); </span><br><span class="line">         <span class="comment">// __new_buckets[__bkt] 是个空桶插入新节点</span></span><br><span class="line">         <span class="keyword">if</span> (!__new_buckets[__bkt]) &#123;</span><br><span class="line">             __p-&gt;_M_nxt = _M_before_begin._M_nxt;  </span><br><span class="line">             _M_before_begin._M_nxt = __p;</span><br><span class="line">             __new_buckets[__bkt] = &amp;_M_before_begin;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">if</span> (__p-&gt;_M_nxt)</span><br><span class="line">                 __new_buckets[__bbegin_bkt] = __p;</span><br><span class="line">             __bbegin_bkt = __bkt;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="comment">// 非空桶，则直接在头部插入</span></span><br><span class="line">             __p-&gt;_M_nxt = __new_buckets[__bkt]-&gt;_M_nxt;</span><br><span class="line">             __new_buckets[__bkt]-&gt;_M_nxt = __p;</span><br><span class="line">         &#125;</span><br><span class="line">         __p = __next;  <span class="comment">// 迭代</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 释放旧桶及更新参数</span></span><br><span class="line">     _M_deallocate_buckets();</span><br><span class="line">     _M_bucket_count = __n;</span><br><span class="line">     _M_buckets = __new_buckets;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>至此，已完全讲解了<code>hash_map</code>是如何插入一个节点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;观前提醒，横屏有助于提升阅读体验。&lt;/p&gt;
&lt;p&gt;上一节&lt;a href=&quot;&quot;&gt;剖析 std::unordered_map 具有O(1)时间复杂度的原理&lt;/a&gt;中讲解了&lt;code&gt;std::unordered_map&lt;/code&gt;应对hash冲突、退化，实现O(1)时间复杂度</summary>
      
    
    
    
    <category term="深入了解 Modern C++" scheme="https://szza.github.io/categories/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
</feed>
