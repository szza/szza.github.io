<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>szza</title>
  
  <subtitle>look code art</subtitle>
  <link href="https://szza.github.io/atom.xml" rel="self"/>
  
  <link href="https://szza.github.io/"/>
  <updated>2023-08-01T02:21:00.251Z</updated>
  <id>https://szza.github.io/</id>
  
  <author>
    <name>fibonaccii</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WAL、MemTable 的生命周期管理(3)</title>
    <link href="https://szza.github.io/2022/01/16/rocksdb/WritePath/WAL_3/"/>
    <id>https://szza.github.io/2022/01/16/rocksdb/WritePath/WAL_3/</id>
    <published>2022-01-16T06:15:35.000Z</published>
    <updated>2023-08-01T02:21:00.251Z</updated>
    
    <content type="html"><![CDATA[<p>本文是 WAL/MemTable 生命周期的完结篇，主要关注 FlushJob 执行流程以及如何确定哪些 WAL/MmmTable 可以安全地删除。</p><h2 id="PickMemTable"><a href="#PickMemTable" class="headerlink" title="PickMemTable"></a>PickMemTable</h2><p>FlushJob 首先需要从 <em>ColumnFamilyData::imm_</em> 中挑选出本次所需的 <em>FlushJob::mems_</em> ，这部分功能由 <code>PickMemTable</code> 函数实现。最大可以选择的 MemTable::id_ 是 <em>max_memtable_id_</em> ，该参数值的设置见由上一节 <a href="https://mp.weixin.qq.com/s/PRobNfBcDZ3HnOzKTKTQOg">WAL、MemTable 的生命周期管理(2)</a>。</p><p>每个 FlushJob 选中的 <em>mems_</em> 是基于 MemTable 的创建时间排序，即 <code>mems_[0]</code> 是最早创建的，<code>mems.back()</code> 是最晚创建的。具体从 imm_ 获取 <em>mems_</em> 的逻辑由 <code>PickMemtablesToFlush</code> 函数实现。</p><p>每次 Flush 操作都产生一个 VersionEdit。FlushJob 将 VersionEdit 信息记录在 <code>mems_[0]-&gt;edit_</code> 中，edit_ 中 <code>log_number_</code> 主要是用于追踪 WAL 的生命周期，其值是<code>max_next_log_number</code>，如何与WAL生命周期产生联系可见后文分析。</p><p>此外，<code>FlushJob::meta_</code> 中记录着成功 Flush 后生成的 level0 SST 文件的元信息数据。</p><p>PickMemTable 核心代码逻辑如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlushJob::PickMemTable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  pick_memtable_called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> max_next_log_number = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Save the contents of the earliest memtable as a new Table</span></span><br><span class="line">  cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">PickMemtablesToFlush</span>(max_memtable_id_, &amp;mems_,</span><br><span class="line">                                    &amp;max_next_log_number);</span><br><span class="line">  <span class="keyword">if</span> (mems_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  MemTable* m = mems_[<span class="number">0</span>];</span><br><span class="line">  edit_ = m-&gt;<span class="built_in">GetEdits</span>();</span><br><span class="line">  edit_-&gt;<span class="built_in">SetPrevLogNumber</span>(<span class="number">0</span>);</span><br><span class="line">  edit_-&gt;<span class="built_in">SetLogNumber</span>(max_next_log_number);</span><br><span class="line">  edit_-&gt;<span class="built_in">SetColumnFamily</span>(cfd_-&gt;<span class="built_in">GetID</span>());</span><br><span class="line"></span><br><span class="line">  meta_.fd = <span class="built_in">FileDescriptor</span>(versions_-&gt;<span class="built_in">NewFileNumber</span>(), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  meta_.epoch_number = cfd_-&gt;<span class="built_in">NewEpochNumber</span>();</span><br><span class="line"></span><br><span class="line">  base_ = cfd_-&gt;<span class="built_in">current</span>();</span><br><span class="line">  base_-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PickMemtablesToFlush"><a href="#PickMemtablesToFlush" class="headerlink" title="PickMemtablesToFlush"></a>PickMemtablesToFlush</h3><p>SwitchMemTable 函数在调用 <code>MemTableList::Add</code> 函数向 imm_ 中插入新的 ImmtableMemTable 时，是在 <code>current-&gt;memlist_</code> 头部插入节点，因此 memlist_ 尾部是最旧的 ImmutableMemTable，头部是最新的。因此需要逆序遍历 memlist_，才能获得按照 MemTable 创建顺序的 <code>FlushJob::mems_</code>。</p><p>当前可能多个 FlushJob 在并发地执行，因此从 <code>current-&gt;memtables_</code> 选择 MemTable 时，需要过滤掉不符合条件的:</p><ul><li><p>MemTable::id_ &lt; max_memtable_id</p></li><li><p>MemTable::flush_in_progress_ 为 false: 即当前没有被其他 FlushJob 选中</p><p>由于 Flush MemTable 以及后续的 COMMIT 操作都需要保持顺序，因此，如果发现 flush_in_progress_ 为 true，则中断本次 Pick 操作，这样能保证选中的 <code>mems_</code> 是连续创建的。</p><p>在 SwitchMemTable 函数中，将 old_mem 添加到 <code>current-&gt;memlist_</code> 之前会先调用 <code>MemTableList::FlushRequested</code>，将 <em>flush_requested_</em> 设置为 true，表示该 CF 的 memlist_ 当前等待 Flush 操作。接着在 <code>MemTable::Add</code> 函数中会递增 <em>num_flush_not_started_</em> ，表示 memlist_ 中尚未被 Picked 的 MemTable 数量。</p></li></ul><p>当 flush_requested_ 为 true 并且 num_flush_not_started_ &gt; 0，则 <code>IsFlushPending</code> 返回 true，则该 CF 可以触发下一次 FlushJob。</p><p>直到 <code>PickMemtablesToFlush</code> 函数执行完，如果 <em>num_flush_not_started_</em> 为 0， 会将 <code>flush_requested_</code> 设置为 false，表示已经所有待 Picked 的 MemTable 都已选中了，准备进行 Flush。如果后续 Flush 流程失败，会调用 <code>RollbackMemtableFlush</code> 函数进行回滚，恢复状态。</p><p>最后，有个基于 RAII 设计的类 <code>AutoThreadOperationStageUpdater</code>，用来表征当前 FlushJob 线程的执行状态。 该函数核心代码及注释如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTableList::PickMemtablesToFlush</span><span class="params">(<span class="type">uint64_t</span> max_memtable_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        autovector&lt;MemTable*&gt;* ret,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">uint64_t</span>* max_next_log_number)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_PICK_MEMTABLES_TO_FLUSH)</span></span>;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span>&amp; memlist = current_-&gt;memlist_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = memlist.<span class="built_in">rbegin</span>(); it != memlist.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">    MemTable* m = *it;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过滤超过 max_memtable_id 的 MemTable</span></span><br><span class="line">    <span class="keyword">if</span> (m-&gt;<span class="built_in">GetID</span>() &gt; max_memtable_id) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;flush_in_progress_) &#123;</span><br><span class="line">      <span class="comment">// 还没被添加到某个 Flush 任务中</span></span><br><span class="line">      num_flush_not_started_--;</span><br><span class="line">      <span class="keyword">if</span> (num_flush_not_started_ == <span class="number">0</span>) &#123;</span><br><span class="line">        imm_flush_needed.<span class="built_in">store</span>(<span class="literal">false</span>, std::memory_order_release);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置标志位: 表示被 Picked</span></span><br><span class="line">      m-&gt;flush_in_progress_ = <span class="literal">true</span>;  </span><br><span class="line">      <span class="keyword">if</span> (max_next_log_number) &#123;</span><br><span class="line">        *max_next_log_number =</span><br><span class="line">            std::<span class="built_in">max</span>(m-&gt;<span class="built_in">GetNextLogNumber</span>(), *max_next_log_number);</span><br><span class="line">      &#125;</span><br><span class="line">      ret-&gt;<span class="built_in">push_back</span>(m);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!ret-&gt;<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="comment">// 遇到已经被其他 Flush 线程选中的 memtable，中断</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (num_flush_not_started_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// start-flush request is complete</span></span><br><span class="line">    flush_requested_ = <span class="literal">false</span>;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RollbackMemtableFlush"><a href="#RollbackMemtableFlush" class="headerlink" title="RollbackMemtableFlush"></a>RollbackMemtableFlush</h3><p>如果后续的 Flush 任务执行失败，<em>mems_</em> 不会从 <code>memlist_</code> 中删除，则只需要把 PickMemtablesToFlush 中修改的状态重置即可，等待下一次 Flush。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MemTableList::RollbackMemtableFlush</span><span class="params">(<span class="type">const</span> autovector&lt;MemTable*&gt;&amp; mems,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         <span class="type">uint64_t</span> <span class="comment">/*file_number*/</span>)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_MEMTABLE_ROLLBACK)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重置状态</span></span><br><span class="line">  <span class="keyword">for</span> (MemTable* m : mems) &#123;</span><br><span class="line">    m-&gt;flush_in_progress_ = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;flush_completed_ = <span class="literal">false</span>;</span><br><span class="line">    m-&gt;edit_.<span class="built_in">Clear</span>();</span><br><span class="line">    num_flush_not_started_++;</span><br><span class="line">  &#125;</span><br><span class="line">  imm_flush_needed.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FlushJob-Run"><a href="#FlushJob-Run" class="headerlink" title="FlushJob::Run"></a>FlushJob::Run</h2><p>FlushJob 目前（branch-8.2.fb）有两种实现：</p><ul><li>默认将 MemTables 中的数据写入 level0，</li><li>设置 <em>experimental_mempurge_threshold &gt; 0</em>，开启内存裁剪（Memory Purge）。</li></ul><p>本文只讲解默认实现，MemoryPurge 后续有空再说。默认的 FlushJob::Run 流程主要有两个部分：</p><ol><li>根据选中的 <em>mems_</em> 生成 SST 并写入 level0，由 <code>file_meta</code> 记录该 SST 文件元数据</li><li>如果 step(1) 成功则更新 CF 的 version，并将本次更新记录 <em>FlushJob::edit_</em> 序列化后写入到 MANIFEST 中</li><li>如果 step(1) 不成功，则 <code>RollbackMemtableFlush</code> 进行回滚。</li></ol><p><code>FlushJob::Run</code> 核心代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FlushJob::Run</span><span class="params">(LogsWithPrepTracker* prep_tracker, FileMetaData* file_meta,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">bool</span>* switched_to_mempurge)</span> </span>&#123;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_run</span><span class="params">(ThreadStatus::STAGE_FLUSH_RUN)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (mems_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 1. 将 mems_ 写入 level0</span></span><br><span class="line">  Status s = <span class="built_in">WriteLevel0Table</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 2. 判断 Flush 结果</span></span><br><span class="line">  <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">RollbackMemtableFlush</span>(mems_, meta_.fd.<span class="built_in">GetNumber</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (write_manifest_) &#123;</span><br><span class="line">    <span class="comment">// Replace immutable memtable with the generated Table</span></span><br><span class="line">    s = cfd_-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">TryInstallMemtableFlushResults</span>(</span><br><span class="line">        cfd_, mutable_cf_options_, mems_, prep_tracker, versions_, db_mutex_,</span><br><span class="line">        meta_.fd.<span class="built_in">GetNumber</span>(), &amp;job_context_-&gt;memtables_to_free, db_directory_,</span><br><span class="line">        log_buffer_, &amp;committed_flush_jobs_info_, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; file_meta != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    *file_meta = meta_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteLevel0Table"><a href="#WriteLevel0Table" class="headerlink" title="WriteLevel0Table"></a>WriteLevel0Table</h3><p>WriteLevel0Table 核心部分主要有三个部分，每个部分都很复杂，值得单独开一期讲解，这里主要讲解下每个部分的作用：</p><ul><li><p>NewMergingIterator: 用于将输入的多个 MemTable/SST 合并成一个有序的数据流</p><p>在 <code>merger_test.cc</code> 的测试用例中，对于多批次随机数据，<code>NewMergingIterator</code> 合并多个数据流后表现和 <code>VectorIterator</code> 表现的一致，都是有序输出。</p><p>多批输入数据流打平后再输入给 VectorIterator，在 VectorIterator 构造函数中对输入的数据流基于 <code>std::sort</code> 排序，因此 VectorIterator 的输出是全局有序的。而 NewMergingIterator 的输出和 VectorIterator 是一致的，则说明 NewMergingIterator 的作用是合并输入流并使输出有序，不过更加高效。</p></li><li><p>range_del_iter</p><p>NewMergingIterator 只是将输入数据排序好，但是通常上层应用也会进行删除操作。在 MemTable 中，专门为 <em>DeleteRange</em> 操作单独分配了个 range_del_table_。当插入数据是 kTypeRangeDeletion 类型时，则将数据写入 range_del_table_。因此，在遍历 MemTable 时，也需要考虑 range_del_iter 来过滤那些已经被删除的数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in MemTable::Add function</span></span><br><span class="line">std::unique_ptr&lt;MemTableRep&gt;&amp; table =</span><br><span class="line">    type == kTypeRangeDeletion </span><br><span class="line">    ? range_del_table_ </span><br><span class="line">    : table_;</span><br></pre></td></tr></table></figure><p>关于 range_delete 操作的详细设计可以参考 <a href="https://github.com/facebook/rocksdb/wiki/DeleteRange-Implementation">DeleteRange-Implementation</a>，后续有时间再讲解其中细节。</p></li><li><p>BuildTable</p><p>内部流程：<code>CompactionIterator</code> 基于 {NewMergingIterator, range_del_iter} 过滤已删除数据并输出全局有序的数据，可以通过 CompactionIterator::Next 进行迭代遍历，获得输出 <code>&#123;key, value&#125;</code>，再用 TableBuilder::Add 函数将该 {key, value} 添加到 level0 的新 SST 文件中。运行结束，新生成的 level0 SST 的元信息保存在 <em>meta_</em> 中。</p></li></ul><p>实际上，Compaction 的核心流程也是这三个部分，逻辑流程都是一样的，后续会专注分析每个具体的部分。<code>WriteLevel0Table</code> 核心流程如下代码注释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">FlushJob::WriteLevel0Table</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_FLUSH_WRITE_L0)</span></span>;</span><br><span class="line">  db_mutex_-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  std::vector&lt;BlobFileAddition&gt; blob_file_additions;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">auto</span> write_hint = cfd_-&gt;<span class="built_in">CalculateSSTWriteHint</span>(<span class="number">0</span>);</span><br><span class="line">    Env::IOPriority io_priority = <span class="built_in">GetRateLimiterPriorityForWrite</span>();</span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    std::vector&lt;InternalIterator*&gt; memtables;</span><br><span class="line">    std::vector&lt;std::unique_ptr&lt;FragmentedRangeTombstoneIterator&gt;&gt;</span><br><span class="line">        range_del_iters;</span><br><span class="line">    ReadOptions ro;</span><br><span class="line">    ro.total_order_seek = <span class="literal">true</span>;</span><br><span class="line">    ro.io_activity = Env::IOActivity::kFlush;</span><br><span class="line">    Arena arena;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 从 MemTables 构建 range_delete_iter，获悉哪些 keys 已被删除</span></span><br><span class="line">    <span class="keyword">for</span> (MemTable* m : mems_) &#123;</span><br><span class="line">      <span class="keyword">auto</span>* range_del_iter = m-&gt;<span class="built_in">NewRangeTombstoneIterator</span>(</span><br><span class="line">          ro, kMaxSequenceNumber, <span class="literal">true</span> <span class="comment">/* immutable_memtable */</span>);</span><br><span class="line">      <span class="keyword">if</span> (range_del_iter != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        range_del_iters.<span class="built_in">emplace_back</span>(range_del_iter);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 2. 合并多个 memtable 迭代器，使得 memtables 能有序输出</span></span><br><span class="line">      <span class="function">ScopedArenaIterator <span class="title">iter</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          NewMergingIterator(&amp;cfd_-&gt;internal_comparator(), memtables.data(),</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">static_cast</span>&lt;<span class="type">int</span>&gt;(memtables.size()), &amp;arena))</span></span>;</span><br><span class="line">      <span class="type">int64_t</span> _current_time = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">auto</span> status = clock_-&gt;<span class="built_in">GetCurrentTime</span>(&amp;_current_time);</span><br><span class="line">      <span class="type">const</span> <span class="type">uint64_t</span> current_time = <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(_current_time);</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> oldest_key_time = mems_.<span class="built_in">front</span>()-&gt;<span class="built_in">ApproximateOldestKeyTime</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// It&#x27;s not clear whether oldest_key_time is always available. In case</span></span><br><span class="line">      <span class="comment">// it is not available, use current_time.</span></span><br><span class="line">      <span class="type">uint64_t</span> oldest_ancester_time = std::<span class="built_in">min</span>(current_time, oldest_key_time);</span><br><span class="line"></span><br><span class="line">      meta_.oldest_ancester_time = oldest_ancester_time;</span><br><span class="line">      meta_.file_creation_time = current_time;</span><br><span class="line"></span><br><span class="line">      <span class="type">uint64_t</span> num_input_entries = <span class="number">0</span>;</span><br><span class="line">      <span class="type">uint64_t</span> memtable_payload_bytes = <span class="number">0</span>;</span><br><span class="line">      <span class="type">uint64_t</span> memtable_garbage_bytes = <span class="number">0</span>;</span><br><span class="line">      IOStatus io_s;</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> std::string* <span class="type">const</span> full_history_ts_low =</span><br><span class="line">          (full_history_ts_low_.<span class="built_in">empty</span>()) ? <span class="literal">nullptr</span> : &amp;full_history_ts_low_;</span><br><span class="line">      <span class="function">TableBuilderOptions <span class="title">tboptions</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">          *cfd_-&gt;ioptions(), mutable_cf_options_, cfd_-&gt;internal_comparator(),</span></span></span><br><span class="line"><span class="params"><span class="function">          cfd_-&gt;int_tbl_prop_collector_factories(), output_compression_,</span></span></span><br><span class="line"><span class="params"><span class="function">          mutable_cf_options_.compression_opts, cfd_-&gt;GetID(), cfd_-&gt;GetName(),</span></span></span><br><span class="line"><span class="params"><span class="function">          <span class="number">0</span> <span class="comment">/* level */</span>, <span class="literal">false</span> <span class="comment">/* is_bottommost */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          TableFileCreationReason::kFlush, oldest_key_time, current_time,</span></span></span><br><span class="line"><span class="params"><span class="function">          db_id_, db_session_id_, <span class="number">0</span> <span class="comment">/* target_file_size */</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          meta_.fd.GetNumber())</span></span>;</span><br><span class="line">      <span class="type">const</span> SequenceNumber job_snapshot_seq =</span><br><span class="line">          job_context_-&gt;<span class="built_in">GetJobSnapshotSequence</span>();</span><br><span class="line">      <span class="function"><span class="type">const</span> ReadOptions <span class="title">read_options</span><span class="params">(Env::IOActivity::kFlush)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 合并多个 memtables 的数据，输出到 level0 sst 中</span></span><br><span class="line">      s = <span class="built_in">BuildTable</span>(dbname_, versions_, db_options_, tboptions, file_options_,</span><br><span class="line">                     read_options, cfd_-&gt;<span class="built_in">table_cache</span>(), iter.<span class="built_in">get</span>(),</span><br><span class="line">                     std::<span class="built_in">move</span>(range_del_iters), &amp;meta_, &amp;blob_file_additions,</span><br><span class="line">                     existing_snapshots_, earliest_write_conflict_snapshot_,</span><br><span class="line">                     job_snapshot_seq, snapshot_checker_,</span><br><span class="line">                     mutable_cf_options_.paranoid_file_checks,</span><br><span class="line">                     cfd_-&gt;<span class="built_in">internal_stats</span>(), &amp;io_s, io_tracer_,</span><br><span class="line">                     BlobFileCreationReason::kFlush, seqno_to_time_mapping_,</span><br><span class="line">                     event_logger_, job_context_-&gt;job_id, io_priority,</span><br><span class="line">                     &amp;table_properties_, write_hint, full_history_ts_low,</span><br><span class="line">                     blob_callback_, base_, &amp;num_input_entries,</span><br><span class="line">                     &amp;memtable_payload_bytes, &amp;memtable_garbage_bytes);</span><br><span class="line">     <span class="comment">//... handle error</span></span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 4. 尝试 SYNC SST 目录</span></span><br><span class="line">     <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; output_file_directory_ != <span class="literal">nullptr</span> &amp;&amp; sync_output_directory_) &#123;</span><br><span class="line">      s = output_file_directory_-&gt;<span class="built_in">FsyncWithDirOptions</span>(</span><br><span class="line">          <span class="built_in">IOOptions</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">          <span class="built_in">DirFsyncOptions</span>(DirFsyncOptions::FsyncReason::kNewFileSynced));</span><br><span class="line">    &#125;</span><br><span class="line">    db_mutex_-&gt;<span class="built_in">Lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  base_-&gt;<span class="built_in">Unref</span>();</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> has_output = meta_.fd.<span class="built_in">GetFileSize</span>() &gt; <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5. 将生成的 level0 文件元数据信息写入 VersionEdit </span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; has_output) &#123;</span><br><span class="line">    <span class="comment">// Add file to L0</span></span><br><span class="line">    edit_-&gt;<span class="built_in">AddFile</span>(<span class="number">0</span> <span class="comment">/* level */</span>, meta_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Piggyback FlushJobInfo on the first first flushed memtable.</span></span><br><span class="line">  mems_[<span class="number">0</span>]-&gt;<span class="built_in">SetFlushJobInfo</span>(<span class="built_in">GetFlushJobInfo</span>());</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TryInstallMemtableFlushResults"><a href="#TryInstallMemtableFlushResults" class="headerlink" title="TryInstallMemtableFlushResults"></a>TryInstallMemtableFlushResults</h3><p>如果上一步 <code>WriteLevel0Table</code> 成功，则需要将 Flush 的信息 COMMIT 到 MANIFEST。实际上 MANIFEST 可以视为 transaction log，保存着每次 Flush/Compaction 的记录。</p><p>当前可能有多个线程在并发执行 Flush 操作，但是只能有一个线程能 COMMIT：率先进入的此函数的线程，它先将 <code>commit_in_progress_</code> 设置为 true，来阻止后来的线程。因此判断 commit_in_progress_ 是否为 true 是个分界点：</p><ul><li><p>之前：所有 Flush 线程都都先更新 mems[i] 的 {flush_completed_, file_number_} 状态</p><p> flush_completed_ 表示 mems[i] 已经成功 Flush，file_number_ 则是指向 Flush 后生成的 SST 文件。 由于 mems 是 Flush 线程的局部变量，因此这一步操作线程安全。</p></li><li><p>之后</p><p>由于只有一个线程能进行 COMMIT。因此 COMMIT 对象是 <em>memlist_</em> 中所有已经 Flushed MemTable，即进入此函数的线程会将所有 Flush 线程中的 mems 一起 COMMIT。 后面进入此函数的线程发现 commit_in_progress_ 为 false 则直接返回。</p><p>其次，COMMIT 也需要按照 MemTable 的创建顺序，即 <code>MemTable::id_</code> 递增的顺序，因此需要逆序遍历 memlist_，并且如果中途某个 MemTable 在 WriteLevel0Table 中失败了，则需要中断当前 COMMIT 操作，只能将前面成功 Flush 的连续 MemTables 的 VersionEdit 写入 MANIFEST，并在回调函数 <code>RemoveMemTablesOrRestoreFlags</code> 中将这部分 MemTable 从 memlist_ 中删除。</p><p>因此，Flush 失败的 MemTable 就会变成 oldeest memtable，等待下一次 FlushJob 再次选择它，重复上述执行流程。</p></li></ul><p>这部分代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">MemTableList::TryInstallMemtableFlushResults</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    ColumnFamilyData* cfd, <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> autovector&lt;MemTable*&gt;&amp; mems, LogsWithPrepTracker* prep_tracker,</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionSet* vset, InstrumentedMutex* mu, <span class="type">uint64_t</span> file_number,</span></span></span><br><span class="line"><span class="params"><span class="function">    autovector&lt;MemTable*&gt;* to_delete, FSDirectory* db_directory,</span></span></span><br><span class="line"><span class="params"><span class="function">    LogBuffer* log_buffer,</span></span></span><br><span class="line"><span class="params"><span class="function">    std::list&lt;std::unique_ptr&lt;FlushJobInfo&gt;&gt;* committed_flush_jobs_info,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">bool</span> write_edits)</span> </span>&#123;</span><br><span class="line">  <span class="function">AutoThreadOperationStageUpdater <span class="title">stage_updater</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      ThreadStatus::STAGE_MEMTABLE_INSTALL_FLUSH_RESULTS)</span></span>;</span><br><span class="line">  mu-&gt;<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">const</span> ReadOptions <span class="title">read_options</span><span class="params">(Env::IOActivity::kFlush)</span></span>;</span><br><span class="line">  Status s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 更改所有成功 Flush 的 MemTable 状态</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; mems.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    mems[i]-&gt;flush_completed_ = <span class="literal">true</span>;</span><br><span class="line">    mems[i]-&gt;file_number_ = file_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 分界点: 只有一个线程可以 commit</span></span><br><span class="line">  <span class="keyword">if</span> (commit_in_progress_) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 commit 流程</span></span><br><span class="line">  commit_in_progress_ = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; memlist = current_-&gt;memlist_;</span><br><span class="line">    <span class="comment">// 3. 遇到 Flush 失败的 memtable 则中断</span></span><br><span class="line">    <span class="keyword">if</span> (memlist.<span class="built_in">empty</span>() || !memlist.<span class="built_in">back</span>()-&gt;flush_completed_) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> batch_file_number = <span class="number">0</span>;</span><br><span class="line">    <span class="type">size_t</span> batch_count = <span class="number">0</span>;</span><br><span class="line">    autovector&lt;VersionEdit*&gt; edit_list;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照 memtable 创建的顺序 scan and commit</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = memlist.<span class="built_in">rbegin</span>(); it != memlist.<span class="built_in">rend</span>(); ++it) &#123;</span><br><span class="line">      MemTable* m = *it;</span><br><span class="line">      <span class="comment">// 3.1 遇到 Flush 失败的 memtable 则中断</span></span><br><span class="line">      <span class="keyword">if</span> (!m-&gt;flush_completed_) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 遇到一个新的 FlushJob</span></span><br><span class="line">      <span class="comment">// 此时 file_number_ 和 edit 都是新的</span></span><br><span class="line">      <span class="keyword">if</span> (it == memlist.<span class="built_in">rbegin</span>() || batch_file_number != m-&gt;file_number_) &#123;</span><br><span class="line">        batch_file_number = m-&gt;file_number_;</span><br><span class="line">        edit_list.<span class="built_in">push_back</span>(&amp;m-&gt;edit_);</span><br><span class="line">        std::unique_ptr&lt;FlushJobInfo&gt; info = m-&gt;<span class="built_in">ReleaseFlushJobInfo</span>();</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          committed_flush_jobs_info-&gt;<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(info));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      batch_count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.2 commit 已经 Flush 成功的</span></span><br><span class="line">    <span class="keyword">if</span> (batch_count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 计算当前 oldest_wal</span></span><br><span class="line">      <span class="type">uint64_t</span> min_wal_number_to_keep =</span><br><span class="line">          <span class="built_in">PrecomputeMinLogNumberToKeepNon2PC</span>(vset, *cfd, edit_list);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// logfile_num &lt; min_wal_number_to_keep 都应该删除</span></span><br><span class="line">      VersionEdit wal_deletion;</span><br><span class="line">      wal_deletion.<span class="built_in">SetMinLogNumberToKeep</span>(min_wal_number_to_keep);</span><br><span class="line">      <span class="keyword">if</span> (vset-&gt;<span class="built_in">db_options</span>()-&gt;track_and_verify_wals_in_manifest) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min_wal_number_to_keep &gt;</span><br><span class="line">            vset-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">GetMinWalNumberToKeep</span>()) &#123;</span><br><span class="line">          wal_deletion.<span class="built_in">DeleteWalsBefore</span>(min_wal_number_to_keep);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      edit_list.<span class="built_in">push_back</span>(&amp;wal_deletion);</span><br><span class="line"></span><br><span class="line">      <span class="type">const</span> <span class="keyword">auto</span> manifest_write_cb = [<span class="keyword">this</span>, cfd, batch_count, log_buffer,</span><br><span class="line">                                      to_delete, mu](<span class="type">const</span> Status&amp; status) &#123;</span><br><span class="line">        <span class="comment">// 从 memlist_ 中删除 flushed memtable</span></span><br><span class="line">        <span class="built_in">RemoveMemTablesOrRestoreFlags</span>(status, cfd, batch_count, log_buffer,</span><br><span class="line">                                      to_delete, mu);</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 写入 MANIFEST</span></span><br><span class="line">      s = vset-&gt;<span class="built_in">LogAndApply</span>(cfd, mutable_cf_options, read_options, edit_list,</span><br><span class="line">                            mu, db_directory, <span class="comment">/*new_descriptor_log=*/</span><span class="literal">false</span>,</span><br><span class="line">                            <span class="comment">/*column_family_options=*/</span><span class="literal">nullptr</span>,</span><br><span class="line">                            manifest_write_cb);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 退出 commit 流程</span></span><br><span class="line">  commit_in_progress_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PrecomputeMinLogNumberToKeepNon2PC"><a href="#PrecomputeMinLogNumberToKeepNon2PC" class="headerlink" title="PrecomputeMinLogNumberToKeepNon2PC"></a>PrecomputeMinLogNumberToKeepNon2PC</h3><p>PrecomputeMinLogNumberToKeepNon2PC 函数返回的 <code>min_wal_number_to_keep</code> 用来删除满足 logfile_num &lt; min_wal_number_to_keep 条件的 WAL。由于 min_wal_number_to_keep 也写入 VersionEdit 并最终序列化到 MANIFEST，因此在 Recovery 过程中，如果磁盘上存在部分这些 WAL 也会被忽略，不会被加载。</p><p>min_log_number_to_keep 的计算分为三个阶段：</p><ol><li><p>每个 <code>FlushJob::edit_</code> 中记录的 <code>log_number_</code> 是在 <code>FlushJob::PickMemTable</code> 函数中设置，指向了每个 CF 最大可以删除的 WAL</p><p>因为 CF memlist_ 指向的 WAL 对于当前 CF 来说都是可以删除的，因此 FlushJob::mems_[-1]-&gt;GetNextLogNumber() 就是FlushJob::edit_::log_numer_ 能取到的最大值。通过迭代不同 FlushJob 的 edit_，则可以获得所有 FlushJobs 中最小的 log_number_ ，作为 min_log_number_to_keep</p></li><li><p>ColumnFamilyData::log_number_ 字段记录了 CF 当前指向的 WAL 文件。因此小于 <code>ColumnFamilyData::log_number_</code> 的 WAL 对于当前 CF 来说都可以删除。</p><p>这一步和 step(1) 是互斥的，如果没有成功执行的 FlushJobs，则 step(1) 中不会修改 min_log_number_to_keep 的值，此时就会进入 step(2)，来获得他们中最小的 <code>min_log_number_to_keep</code>；</p></li><li><p>再检查没有执行 Flush 的或者 Flush 失败的的 CFs 的 <code>ColumnFamilyData::log_number_</code> 字段，和 <code>min_log_number_to_keep</code> 进行比较最小值</p></li></ol><p>上述三步结束，所得的 <code>min_log_number_to_keep</code> 即生命周期没有结束的最小 WAL：所有满足 <code>logfile_num &lt; min_log_number_to_keep</code> 的 WAL 可以安全地从磁盘上删除了，Recovery 期间也不会被加载了，即生命周期可以结束了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">PrecomputeMinLogNumberToKeepNon2PC</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    VersionSet* vset, <span class="type">const</span> autovector&lt;ColumnFamilyData*&gt;&amp; cfds_to_flush,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> autovector&lt;autovector&lt;VersionEdit*&gt;&gt;&amp; edit_lists)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> min_log_number_to_keep = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 检测 min_log_number_to_keep</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; edit_list : edit_lists) &#123;</span><br><span class="line">    <span class="type">uint64_t</span> log = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : edit_list) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e-&gt;<span class="built_in">HasLogNumber</span>()) &#123;</span><br><span class="line">        log = std::<span class="built_in">max</span>(log, e-&gt;<span class="built_in">GetLogNumber</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (log != <span class="number">0</span>) &#123;</span><br><span class="line">      min_log_number_to_keep = std::<span class="built_in">min</span>(min_log_number_to_keep, log);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 如果 edit_lists 为空</span></span><br><span class="line">  <span class="keyword">if</span> (min_log_number_to_keep == std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>()) &#123;</span><br><span class="line">    min_log_number_to_keep = cfds_to_flush[<span class="number">0</span>]-&gt;<span class="built_in">GetLogNumber</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">1</span>; i &lt; cfds_to_flush.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">      min_log_number_to_keep =</span><br><span class="line">          std::<span class="built_in">min</span>(min_log_number_to_keep, cfds_to_flush[i]-&gt;<span class="built_in">GetLogNumber</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 检测没有 Flush 或者 Flush 失败的 CFs</span></span><br><span class="line">  <span class="function">std::unordered_set&lt;<span class="type">const</span> ColumnFamilyData*&gt; <span class="title">flushed_cfds</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      cfds_to_flush.begin(), cfds_to_flush.end())</span></span>;</span><br><span class="line">  min_log_number_to_keep =</span><br><span class="line">      std::<span class="built_in">min</span>(min_log_number_to_keep,</span><br><span class="line">               vset-&gt;<span class="built_in">PreComputeMinLogNumberWithUnflushedData</span>(flushed_cfds));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> min_log_number_to_keep;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">uint64_t</span> <span class="title">PreComputeMinLogNumberWithUnflushedData</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   <span class="type">const</span> ColumnFamilyData* cfd_to_skip)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"> <span class="type">uint64_t</span> min_log_num = std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">auto</span> cfd : *column_family_set_) &#123;</span><br><span class="line">   <span class="comment">// 跳过 step(2) 中处理过的 CF</span></span><br><span class="line">   <span class="keyword">if</span> (cfd == cfd_to_skip) &#123;</span><br><span class="line">     <span class="keyword">continue</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 和 min_log_num 取较小值</span></span><br><span class="line">   <span class="keyword">if</span> (min_log_num &gt; cfd-&gt;<span class="built_in">GetLogNumber</span>() &amp;&amp; !cfd-&gt;<span class="built_in">IsDropped</span>()) &#123;</span><br><span class="line">     min_log_num = cfd-&gt;<span class="built_in">GetLogNumber</span>();</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> min_log_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FindObsoleteFiles"><a href="#FindObsoleteFiles" class="headerlink" title="FindObsoleteFiles"></a>FindObsoleteFiles</h2><p>上述获得 <code>min_log_number_to_keep</code> 后，会生成一个 VersionEdit 对象 wal_deletion，它写入 MANIFEST 的过程中，会更新<code>VersionSet::min_log_number_to_keep_</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in function: VersionSet::ProcessManifestWrites</span></span><br><span class="line"><span class="type">uint64_t</span> last_min_log_number_to_keep = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; e : batch_edits) &#123;</span><br><span class="line">  <span class="comment">//... other code</span></span><br><span class="line">  <span class="keyword">if</span> (e-&gt;has_min_log_number_to_keep_) &#123;</span><br><span class="line">    last_min_log_number_to_keep =</span><br><span class="line">        std::<span class="built_in">max</span>(last_min_log_number_to_keep, e-&gt;min_log_number_to_keep_);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (last_min_log_number_to_keep != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="built_in">MarkMinLogNumberToKeep</span>(last_min_log_number_to_keep);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 FindObsoleteFiles 函数中，会根据 <code>VersionSet::min_log_number_to_keep_</code> 来判断一个 WAL 的生命周期是否已经结束：已经结束的则加入 <code>JobContextl::log_delete_files</code> 中，在 <code>PurgeObsoleteFiles</code> 函数中从磁盘上删除该文件，再释放 <code>JobContextl::logs_to_free_</code> 中记录的 <code>LogWriter</code> 内存。</p><p>到此，一个 WAL 生命周期才算结束。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">VersionSet::MarkMinLogNumberToKeep</span><span class="params">(<span class="type">uint64_t</span> number)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (min_log_number_to_keep_.<span class="built_in">load</span>(std::memory_order_relaxed) &lt; number) &#123;</span><br><span class="line">   min_log_number_to_keep_.<span class="built_in">store</span>(number, std::memory_order_relaxed);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::FindObsoleteFiles</span><span class="params">(JobContext* job_context, <span class="type">bool</span> force,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">bool</span> no_full_scan)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//... ignore other code...</span></span><br><span class="line">  job_context-&gt;log_number = versions_-&gt;<span class="built_in">min_log_number_to_keep</span>();</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (alive_log_files_.<span class="built_in">empty</span>() || logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!alive_log_files_.<span class="built_in">empty</span>() &amp;&amp; !logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// logfile_num &lt;= min_log_number 都应该删除</span></span><br><span class="line">    <span class="type">uint64_t</span> min_log_number = job_context-&gt;log_number;</span><br><span class="line">    <span class="type">size_t</span> num_alive_log_files = alive_log_files_.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 检测新的 obsoleted WAL files，即生命周期已结束的</span></span><br><span class="line">    <span class="keyword">while</span> (alive_log_files_.<span class="built_in">begin</span>()-&gt;number &lt; min_log_number) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; earliest = *alive_log_files_.<span class="built_in">begin</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 是否回收，不收回则加入待删除队列</span></span><br><span class="line">      <span class="keyword">if</span> (immutable_db_options_.recycle_log_file_num &gt; log_recycle_files_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        log_recycle_files_.<span class="built_in">push_back</span>(earliest.number);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        job_context-&gt;log_delete_files.<span class="built_in">push_back</span>(earliest.number);</span><br><span class="line">      &#125;</span><br><span class="line">      alive_log_files_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 检测待释的 LogWriter</span></span><br><span class="line">    log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">    <span class="keyword">while</span> (!logs_.<span class="built_in">empty</span>() &amp;&amp; logs_.<span class="built_in">front</span>().number &lt; min_log_number) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; log = logs_.<span class="built_in">front</span>();</span><br><span class="line">      <span class="keyword">if</span> (log.<span class="built_in">IsSyncing</span>()) &#123;</span><br><span class="line">        log_sync_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      logs_to_free_.<span class="built_in">push_back</span>(log.<span class="built_in">ReleaseWriter</span>());</span><br><span class="line">      logs_.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  job_context-&gt;logs_to_free = logs_to_free_;</span><br><span class="line">  logs_to_free_.<span class="built_in">clear</span>();</span><br><span class="line">  log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 回收</span></span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  job_context-&gt;log_recycle_files.<span class="built_in">assign</span>(log_recycle_files_.<span class="built_in">begin</span>(),</span><br><span class="line">                                        log_recycle_files_.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文是 WAL/MemTable 生命周期的完结篇，主要关注 FlushJob 执行流程以及如何确定哪些 WAL/MmmTable 可以安全地删除。&lt;/p&gt;
&lt;h2 id=&quot;PickMemTable&quot;&gt;&lt;a href=&quot;#PickMemTable&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>WAL、MemTable 的生命周期管理(2)</title>
    <link href="https://szza.github.io/2022/01/15/rocksdb/WritePath/WAL_2/"/>
    <id>https://szza.github.io/2022/01/15/rocksdb/WritePath/WAL_2/</id>
    <published>2022-01-15T06:15:35.000Z</published>
    <updated>2023-08-01T02:20:56.518Z</updated>
    
    <content type="html"><![CDATA[<p>本文简要讲下在 Flush  MemTable 之前，WAL 需要进行 SYNC 的原因。更多设计思考可以阅读 <a href="https://github.com/facebook/rocksdb/wiki/Track-WAL-in-MANIFEST">Track-WAL-in-MANIFEST</a></p><h3 id="WHY-NEED-to-SYNC-WAL"><a href="#WHY-NEED-to-SYNC-WAL" class="headerlink" title="WHY NEED to SYNC WAL"></a>WHY NEED to SYNC WAL</h3><p>出于性能考虑，默认情况下 RocksDB 不会每写入一次数据就进行一次 SYNC WAL 操作。但没有 SYNC WAL 会带来两个影响：</p><ol><li><p>在 recovery 时，就无法检查 WAL 是否存在磁盘上，这是因为当机器挂了，WAL 的 innode 元数据可能尚未持久化到磁盘。</p><p>除此之外，默认情况下误删 WAL 目录下的 log 文件，也没有机制来检测是否有 WAL 丢失以及哪个文件丢失。此时 DB::Open 是会成功，但是 log 中对应的数据 <em>“悄悄地”</em> 丢失了。</p></li><li><p>在 recovery 期间也无法判断 WAL 的大小是否正常，因为如果不主动 SYNC，则 SYNC WAL 操作则由操作系统来完成的，这对 RocksDB 并不透明：无法知道在 RocksDB 退出前， WAL 持久化到磁盘的大小。</p></li></ol><p>目前 SYNC WAL 有四种场景：</p><ol><li>上层应用调用 <code>DB::SyncWAL</code> 函数，会主动 SYNC 所有生命周期还没结束的 WALs</li><li>上层应用调用 <code>DB::FlushWAL(true)</code> 函数，内部也是调用 SyncWAL 函数</li><li>写入数据时，设置 <code>WriteOption::sync</code> 为 <em>true</em>，即每写入一次数据，就会进行一次 SYNC WAL</li><li>在 Flush MemTable 前，如果不止一个 ColumnFamily ，会 SYNC 所有 <em>closed_wals</em>，即除了当前WAL之外的所有生命周期尚未结束的 WALs</li></ol><p>case(1,2) 交给应用层调用，case(3) 虽然安全但是效率太低，一般不会开启。因此，交给 RocksDB 自己需要 SYNC WAL 的场景就剩下case(4)。 SYNC WAL 主要是为了防止机器宕机，而不是进程crash。虽然 case(4) 还是有丢数据的风险，但是在生产环境中，一般都会配备多副本来冗余。除非是一个副本的数据在一个机房，一个机房的数据又全部挂了，为了防止这种情况，又搞出来了跨机房部署。</p><blockquote><p>BUT, 该挂的还是会挂。</p></blockquote><p>因此，在执行 FlushJob 前，会将本次 <em>synced_wals</em> 大小信息记录到 <code>VersionEdit</code> 中，再序列化到 MANIFEST 中，在 recovery 期间可以对 WALs 进行强制检查：1）MANIFEST 中记录的 WAL 也应该存在磁盘上；2）磁盘上 WAL 的大小不应该小于 MANIFEST 中记录的 WAL 大小。</p><p>case(4) 是否需要 SYNC 的判断条件如下: </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 判断本次 Flush 前是否需要 sync closed_wals</span></span><br><span class="line"><span class="type">const</span> <span class="type">bool</span> needs_to_sync_closed_wals =</span><br><span class="line">    logfile_number_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">    versions_-&gt;<span class="built_in">GetColumnFamilySet</span>()-&gt;<span class="built_in">NumberOfColumnFamilies</span>() &gt; <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ul><li><p><em>needs_to_sync_closed_wals</em> 为 true 时，需要记录当前 CF 的 <em>max_memtable_id</em>，这样后续 FlushJob::PickMemTable 函数选择待 Flush 的MemTable时，会过滤掉满足 MemTable::id_ &gt; max_memtable_id 的 memtable。</p><p>这是因为在执行 <code>SyncClosedLogs</code> 函数会 DBImpl::mutex_.Unlock，而当前 CF 的 SwitchMemTable 函数可能会在这个期间执行，新增 new_mem，通过 max_memtable_id 来过滤掉这个期间新增的 new_mm。</p></li><li><p><em>needs_to_sync_closed_wals</em> 为 false，会使得 max_memtable_id 为 UINT64_MAX，表示要 Flush 所有的 ImmutableMemtables</p></li></ul><p>这部分代码上下文逻辑如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. 设置 max_memtable_id</span></span><br><span class="line"><span class="type">uint64_t</span> max_memtable_id = needs_to_sync_closed_wals</span><br><span class="line">    ? cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">GetLatestMemTableID</span>()</span><br><span class="line">    : std::numeric_limits&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//... other middle codes</span></span><br><span class="line">IOStatus log_io_s = IOStatus::<span class="built_in">OK</span>();</span><br><span class="line"><span class="keyword">if</span> (needs_to_sync_closed_wals) &#123;</span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 释放 mutex_, 再进行 sync</span></span><br><span class="line">  VersionEdit synced_wals;</span><br><span class="line">  log_io_s = <span class="built_in">SyncClosedLogs</span>(job_context, &amp;synced_wals);</span><br><span class="line">  </span><br><span class="line">  mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">  <span class="comment">// 4. write to MANIFEST</span></span><br><span class="line">  <span class="keyword">if</span> (log_io_s.<span class="built_in">ok</span>() &amp;&amp; synced_wals.<span class="built_in">IsWalAddition</span>()) &#123;</span><br><span class="line">    log_io_s = <span class="built_in">status_to_io_status</span>(<span class="built_in">ApplyWALToManifest</span>(</span><br><span class="line">          <span class="built_in">ReadOptions</span>(Env::IOActivity::kFlush), &amp;synced_wals));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SyncClosedLogs"><a href="#SyncClosedLogs" class="headerlink" title="SyncClosedLogs"></a>SyncClosedLogs</h3><p>SyncClosedLogs 函数需要在 <em>log_write_mutex_</em> 保护下。如果此时仍持有 <code>DBImpl::mutex_</code> 会影响增加其他其线程阻塞时间，比如写路径过程中的 <code>PreprocessWrite</code>，因此在进入 SyncClosedLogs 函数前会释放 <code>DBImpl::mutex_</code>，让其他的线程可以执行。</p><p>SyncClosedLogs 函数的目标是 [logs_.front().number, logfile_number_) 区间的 WALs，其中 logfile_number_ 指向当前最新的 WAL。由于在后台线程池中可能会同时执行多个 FlushMemTable 任务，只要一个 WAL 的生命周期还没结束，那么每次 FlushMemTables 前都会 SYNC WAL 一次，并使用 VersionEdit 记录该 WAL 的元信息再写入 MANIFEST。 因此在 SyncClosedLogs 函数开始，会先尝试阻塞等待其他线程完成对该 WAL 的 SYNC 操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOStatus <span class="title">DBImpl::SyncClosedLogs</span><span class="params">(JobContext* job_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                                VersionEdit* synced_wals)</span> </span>&#123;</span><br><span class="line">  <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;log_write_mutex_)</span></span>;</span><br><span class="line">  autovector&lt;log::Writer*, <span class="number">1</span>&gt; logs_to_sync;</span><br><span class="line">  <span class="type">uint64_t</span> current_log_number = logfile_number_;</span><br><span class="line">  <span class="comment">// 1. 阻塞等待其他线程完成 SYNC</span></span><br><span class="line">  <span class="keyword">while</span> (logs_.<span class="built_in">front</span>().number &lt; current_log_number &amp;&amp;</span><br><span class="line">         logs_.<span class="built_in">front</span>().<span class="built_in">IsSyncing</span>()) &#123;</span><br><span class="line">    log_sync_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//2. 获取所有待 SYNC 的对象: logs_to_sync</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = logs_.<span class="built_in">begin</span>();</span><br><span class="line">       it != logs_.<span class="built_in">end</span>() &amp;&amp; it-&gt;number &lt; current_log_number; ++it) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; log = *it;</span><br><span class="line">    log.<span class="built_in">PrepareForSync</span>();</span><br><span class="line">    logs_to_sync.<span class="built_in">push_back</span>(log.writer);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  IOStatus io_s;</span><br><span class="line">   <span class="comment">// 3. SYNC</span></span><br><span class="line">  <span class="keyword">if</span> (!logs_to_sync.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 操作局部变量 logs_to_sync 不需要 log_write_mutex_</span></span><br><span class="line">    log_write_mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line">    <span class="keyword">for</span> (log::Writer* log : logs_to_sync) &#123;</span><br><span class="line">      <span class="comment">// 每个文件进行 SYNC</span></span><br><span class="line">      io_s = log-&gt;<span class="built_in">file</span>()-&gt;<span class="built_in">Sync</span>(immutable_db_options_.use_fsync);</span><br><span class="line">      <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 关闭</span></span><br><span class="line">      <span class="keyword">if</span> (immutable_db_options_.recycle_log_file_num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        io_s = log-&gt;<span class="built_in">Close</span>();</span><br><span class="line">        <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只要有一个 WAL 需要 SYNC ，整个目录都需要 SYNC</span></span><br><span class="line">    <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      io_s = directories_.<span class="built_in">GetWalDir</span>()-&gt;<span class="built_in">FsyncWithDirOptions</span>(</span><br><span class="line">          <span class="built_in">IOOptions</span>(), <span class="literal">nullptr</span>,</span><br><span class="line">          <span class="built_in">DirFsyncOptions</span>(DirFsyncOptions::FsyncReason::kNewFileSynced));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要操作 active_logs_, logs_ 因此需要 log_write_mutex_</span></span><br><span class="line">    log_write_mutex_.<span class="built_in">Lock</span>();</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 标记是否完成</span></span><br><span class="line">    <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="built_in">MarkLogsSynced</span>(current_log_number - <span class="number">1</span>, <span class="literal">true</span>, synced_wals);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">MarkLogsNotSynced</span>(current_log_number - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">return</span> io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> io_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MarkLogsSynced"><a href="#MarkLogsSynced" class="headerlink" title="MarkLogsSynced"></a>MarkLogsSynced</h4><p><code>MarkLogsSynced</code> 函数记录 SYNCed WALs 信息:</p><p>选项 <em>DBOptions.track_and_verify_wals_in_manifest</em> 用于追踪 WAL 大小信息便于在 Recovery 期间进行校验。默认值为 false，但是 RocksDB 建议在生产环境设置为 true，防止误删或者损坏 WAL 目录下的文件而无法察觉。因此每次 Flush MemTable 前会记录 WAL 的 <code>&#123;wal.number, prev_synced_szie&#125;</code> 信息，那么当 recovery 时，存放 WAL 的目录下必须存在 <code>wal.number</code> 文件，且文件大小至少是 <code>prev_synced_szie</code>。</p><p>此外，还会更新 <code>logs_</code>：</p><ul><li>由于 WAL 在 SyncClosedLogs 函数中再次 SYNC。如果最新一次 SYNC 完成后 WAL 大小和上次 SYNC 的大小 prev_sync_size 相同，表示该 WAL 已完成持久化，则可以从 <code>logs_</code> 中删除，加入 <code>logs_to_free_</code> 队列，在 FlushJob 完成后，在 <code>FindObsoleteFiles</code> 函数中删除。</li><li>否则，还需要进行下一次 SYNC，将本次 SYNC 操作标记为完成，等待下一次 Flush 后台任务；</li></ul><p>由于 <code>MarkLogsSynced</code> 函数会对 <code>logs_</code> 和 <code>logs_to_free_</code> 进行操作，因此需要在 <code>log_write_mutex_</code> 保护下执行，执行完再阻塞唤醒所有阻塞等待在 <code>log_sync_cv_</code> 的地方。</p><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MarkLogsSynced</span><span class="params">(<span class="type">uint64_t</span> up_to, <span class="type">bool</span> synced_dir,</span></span></span><br><span class="line"><span class="params"><span class="function">                            VersionEdit* synced_wals)</span> </span>&#123;</span><br><span class="line">  log_write_mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = logs_.<span class="built_in">begin</span>(); it != logs_.<span class="built_in">end</span>() &amp;&amp; it-&gt;number &lt;= up_to;) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; wal = *it;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wal.number &lt; logs_.<span class="built_in">back</span>().number) &#123;</span><br><span class="line">      <span class="comment">// Inactive WAL</span></span><br><span class="line">      <span class="keyword">if</span> (immutable_db_options_.track_and_verify_wals_in_manifest &amp;&amp;</span><br><span class="line">          wal.<span class="built_in">GetPreSyncSize</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        synced_wals-&gt;<span class="built_in">AddWal</span>(wal.number, <span class="built_in">WalMetadata</span>(wal.<span class="built_in">GetPreSyncSize</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (wal.<span class="built_in">GetPreSyncSize</span>() == wal.writer-&gt;<span class="built_in">file</span>()-&gt;<span class="built_in">GetFlushedSize</span>()) &#123;</span><br><span class="line">        <span class="comment">// Fully synced</span></span><br><span class="line">        logs_to_free_.<span class="built_in">push_back</span>(wal.<span class="built_in">ReleaseWriter</span>());</span><br><span class="line">        it = logs_.<span class="built_in">erase</span>(it);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">assert</span>(wal.<span class="built_in">GetPreSyncSize</span>() &lt; wal.writer-&gt;<span class="built_in">file</span>()-&gt;<span class="built_in">GetFlushedSize</span>());</span><br><span class="line">        wal.<span class="built_in">FinishSync</span>();</span><br><span class="line">        ++it;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Active WAL</span></span><br><span class="line">      <span class="built_in">assert</span>(wal.number == logs_.<span class="built_in">back</span>().number);</span><br><span class="line">      wal.<span class="built_in">FinishSync</span>();</span><br><span class="line">      ++it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  log_sync_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ApplyWALToManifest"><a href="#ApplyWALToManifest" class="headerlink" title="ApplyWALToManifest"></a>ApplyWALToManifest</h3><p><code>ApplyWALToManifest</code> 函数是将 <code>MarkLogsSynced</code> 函数中获得 synced_wals 序列化写入到 MANIFEST，写入 MANIFEST 的数据都需要指定一个所属 CF，由于 WAL 是RocksDB 中所有 CFs 共享的，而 DefaultCF 是第一个 ColumnFamily，因此将 WAL 的数据归属给 default_cf。</p><p>至于 <code>LogAndApplyToDefaultColumnFamily</code> 内部怎么 MANIFEST 交互，后面会讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::ApplyWALToManifest</span><span class="params">(<span class="type">const</span> ReadOptions&amp; read_options,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  VersionEdit* synced_wals)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// not empty, write to MANIFEST.</span></span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line"></span><br><span class="line">  Status status = versions_-&gt;<span class="built_in">LogAndApplyToDefaultColumnFamily</span>(</span><br><span class="line">      read_options, synced_wals, &amp;mutex_, directories_.<span class="built_in">GetDbDir</span>());</span><br><span class="line">  <span class="keyword">if</span> (!status.<span class="built_in">ok</span>() &amp;&amp; versions_-&gt;<span class="built_in">io_status</span>().<span class="built_in">IsIOError</span>()) &#123;</span><br><span class="line">    status = error_handler_.<span class="built_in">SetBGError</span>(versions_-&gt;<span class="built_in">io_status</span>(),</span><br><span class="line">                                       BackgroundErrorReason::kManifestWrite);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Recovery"><a href="#Recovery" class="headerlink" title="Recovery"></a>Recovery</h3><p>在开启了 <em>track_and_verify_wals_in_manifest</em> 后，在 <code>DBImpl::Recover</code> 中，VersionSet 从 MANIFEST 恢复过来后，会将 MANIFEST 中记录的 WAL 元信息和 WAL 目录下的文件进行对比校验。如果该标志没有开启，则需要删除 MANIFEST 中记录的 WAL 信息，防止后续开启后，MANIFEST 中的记录的 WAL 文件已经被删除了，导致校验失败，无法恢复 RocksDB 实例。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (immutable_db_options_.track_and_verify_wals_in_manifest) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!immutable_db_options_.best_efforts_recovery) &#123;</span><br><span class="line">    <span class="comment">// Verify WALs in MANIFEST.</span></span><br><span class="line">    s = versions_-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">CheckWals</span>(env_, wal_files);</span><br><span class="line">  &#125; <span class="comment">// else since best effort recovery does not recover from WALs, no need</span></span><br><span class="line">    <span class="comment">// to check WALs.</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!versions_-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">GetWals</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  VersionEdit edit;</span><br><span class="line">  WalNumber max_wal_number =</span><br><span class="line">      versions_-&gt;<span class="built_in">GetWalSet</span>().<span class="built_in">GetWals</span>().<span class="built_in">rbegin</span>()-&gt;first;</span><br><span class="line">  edit.<span class="built_in">DeleteWalsBefore</span>(max_wal_number + <span class="number">1</span>);</span><br><span class="line">  recovery_ctx-&gt;<span class="built_in">UpdateVersionEdits</span>(</span><br><span class="line">      versions_-&gt;<span class="built_in">GetColumnFamilySet</span>()-&gt;<span class="built_in">GetDefault</span>(), edit);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CheckWals"><a href="#CheckWals" class="headerlink" title="CheckWals"></a>CheckWals</h4><p><code>CheckWals</code> 函数是将从 MANIFEST 中获得的 WAL 最后一次 SYNC 大小 <code>synced_size</code> 和实际磁盘上的 WAL 文件大小 <code>log_file_size</code> 进行对比校验，起码要满足 <code>synced_size &lt;= log_file_size</code>，校验才能通过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WalSet::CheckWals</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    Env* env,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::unordered_map&lt;WalNumber, std::string&gt;&amp; logs_on_disk)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [log_number, wal_meta] : wals_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!wal_meta.<span class="built_in">HasSyncedSize</span>()) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. MANIFEST 中有存在的 WALs，磁盘上也必须存在</span></span><br><span class="line">    <span class="keyword">if</span> (logs_on_disk.<span class="built_in">find</span>(log_number) == logs_on_disk.<span class="built_in">end</span>()) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(fmt::format(</span><br><span class="line">        <span class="string">&quot;Missing WAL with log number: &#123;&#125;&quot;</span>, log_number));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 磁盘上的 WAL 文件大小 &gt;= 最后一次 SYNC 大小</span></span><br><span class="line">    <span class="type">uint64_t</span> log_file_size = <span class="number">0</span>;</span><br><span class="line">    s = env-&gt;<span class="built_in">GetFileSize</span>(logs_on_disk.<span class="built_in">at</span>(log_number), &amp;log_file_size);</span><br><span class="line">    <span class="keyword">if</span> (!s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (log_file_size &lt; wal_meta.<span class="built_in">GetSyncedSizeInBytes</span>()) &#123;</span><br><span class="line">      s = Status::<span class="built_in">Corruption</span>(fmt::format(</span><br><span class="line">        <span class="string">&quot;Size mismatch: WAL (log number: &#123;&#125; ) in MANIFEST is &#123;&#125; bytes, &quot;</span></span><br><span class="line">        <span class="string">&quot;but actually is  &#123;&#125; bytes on disk.&quot;</span>,</span><br><span class="line">        log_number, wal_meta.<span class="built_in">GetSyncedSizeInBytes</span>(), log_file_size));</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本文简要讲下在 Flush  MemTable 之前，WAL 需要进行 SYNC 的原因。更多设计思考可以阅读 &lt;a href=&quot;https://github.com/facebook/rocksdb/wiki/Track-WAL-in-MANIFEST&quot;&gt;Track-WA</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>WAL、MemTable 的生命周期管理(1)</title>
    <link href="https://szza.github.io/2022/01/14/rocksdb/WritePath/WAL_1/"/>
    <id>https://szza.github.io/2022/01/14/rocksdb/WritePath/WAL_1/</id>
    <published>2022-01-14T06:15:35.000Z</published>
    <updated>2023-08-01T02:20:44.869Z</updated>
    
    <content type="html"><![CDATA[<p>WAL 在 DB::Open 时就会创建，用于持久化 MemTable 中尚未 Flush 的数据。具体写入 WAL 的格式可以参考 <a href="https://github.com/facebook/rocksdb/wiki/Write-Ahead-Log-File-Format">Write-Ahead-Log-File-Format</a> 及其对应实现 DBImpl::WriteToWAL 函数，本文及后续几期主要关注 WAL/MemTable 的生命周期管理。</p><h3 id="PreprocessWrite"><a href="#PreprocessWrite" class="headerlink" title="PreprocessWrite"></a>PreprocessWrite</h3><p>在写 WAL/MemTable 之前，会先在 <code>DBImpl::PreprocessWrite</code> 函数中基于当前 RocksDB 的一些指标判断是否需要 Flush MemTable，创建新的 WAL/MemTable 再接受本次写入：</p><ol><li>当前 WAL 的大小 <code>total_log_size_</code> 是否超过阈值 <code>DBOptions::max_total_wal_size</code></li><li>根据 write_buffer_manager_ 判断当前 MemTable 是否需要 Flush</li><li>flush_scheduler_.empty() 为 false，则说明上次某个 CF MemTable 写满了</li></ol><p>上述三种触发条件的处理方式，都需要先创建新的 WAL/MemTable，然后生成 Flush 请求 flush_request，并且触发后台线程去消费该 flush_request。</p><ul><li>正常情况下，发起 Flush 请求后，不用等待后台 Flush 完成，新的 WAL/MemTable 就可以继续接受后续读写请求，</li><li>但是如果写的压力过大，则会进一步限制，比如 DelayWrite，WriteStall，恢复正常后才会继续接受新的写入。</li></ul><p>上述三种的不同触发条件，不同在于如何选择 ColumnFamily。比如 条件（1）WAL 的大小超过阈值，则所有 ColumnFamilys 都需要进行更换 WAL/MemTable；而条件（3）则只是需要某个具体的 CF MemTable 满了。因此只是 FlushReason 不同，处理过程都类似。</p><p>下面针对核心处理流程开始讲解。</p><h3 id="SwitchMemTable"><a href="#SwitchMemTable" class="headerlink" title="SwitchMemTable"></a>SwitchMemTable</h3><p>SwitchMemtable 函数是针对具体的 ColumnFamily 创建 WAL/MemTable ，因此需要上层先筛选出需要切换 MemTable 的 CF，再传递给此函数。</p><p>由前文可知，进入 PreprocessWrite 函数时已经是单线程操作，而 SwitchMemtable 函数仍需要在 <code>DBImpl::_mutex</code> 的保护下才能调用，这是为了与后台 Flush 线程互斥。</p><p>根据 <code>log_empty_</code> 字段来判断是否需要创建新的 WAL，即当前 WAL 是否有数据写入，如果没有则不创建新的 WAL。主要是可能要为多个 CFs 创建新的 WAL/MemTable，但是 WAL 是共享的，只需要第一次创建 WAL 即可，后续的 ColumnFamily 检测到 <code>log_empty_</code> 为空，则不再重复创建。</p><p>每个 WAL 都有一个对应的编号 <code>logfile_num</code>，由 <code>VersionSet::NewFileNumber</code> 函数来生成。</p><p><em>DBOptions::recycle_log_file_num</em> 决定是否复用生命周期已结束的 WALs，<code>log_recycle_files_</code> 字段用于保存生命周期已结束待删除的 WALs。此如果 <code>recycle_log_file_num &gt; 0</code> 则按照 FIFO 规则从 <code>log_recycle_files_</code> 取出生命周期最早结束的 WAL 的 logfile_number，因此可以 truncate 旧 WAL 文件再接受新数据。</p><p>在 RocksDB 中，数据存储目录在 <em>DBOptions::wal_dir</em>，其值就是 db_name，每个 WAL 文件名就是<code>wal_dir</code>+<code>logfile_number</code>+<code>.log</code>。因此，后文一般提及 log 都是指 WAL 文件。</p><p>比如：编译完 RocksDB，并执行 <em>build/examples/simple_example</em>，在 <em>/tmp/rocksdb_simple_example</em> 目录下会有如下以 log 为后缀的文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ll /tmp/rocksdb_simple_example</span><br><span class="line">total 1832</span><br><span class="line">-rw-r--r-- 1 root root  1045 Jul 10 08:27 000326.sst</span><br><span class="line">-rw-r--r-- 1 root root   999 Jul 24 14:17 000331.sst</span><br><span class="line">-rw-r--r-- 1 root root    68 Jul 24 14:18 000332.<span class="built_in">log</span></span><br><span class="line">-rw-r--r-- 1 root root   999 Jul 24 14:18 000336.sst</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure><p><code>log_recycle_files_</code> 等字段会收到 FlushJob 的影响，因此需要在 <code>DBImpl::mutex_</code> 的保护下调用。而 CreateWAL 只是影响局部变量 new_log，不需要 mutex_ 保护，同理构建新的 MemTable 对象 new_mem 也不需要 mutex_。</p><p>下面是创建 new_log 和 new_mem 的核心代码及其注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::SwitchMemtable</span><span class="params">(ColumnFamilyData* cfd, WriteContext* context)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  log::Writer* new_log = <span class="literal">nullptr</span>;</span><br><span class="line">  MemTable* new_mem = <span class="literal">nullptr</span>;</span><br><span class="line">  IOStatus io_s;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 避免多个 CFs 创建不同的 WAL</span></span><br><span class="line">  <span class="type">bool</span> creating_new_log = !log_empty_;</span><br><span class="line">  <span class="type">uint64_t</span> recycle_log_number = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (creating_new_log &amp;&amp; immutable_db_options_.recycle_log_file_num &amp;&amp;</span><br><span class="line">      !log_recycle_files_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    recycle_log_number = log_recycle_files_.<span class="built_in">front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">uint64_t</span> new_log_number =</span><br><span class="line">      creating_new_log ? versions_-&gt;<span class="built_in">NewFileNumber</span>() : logfile_number_;</span><br><span class="line">  <span class="type">const</span> MutableCFOptions mutable_cf_options = *cfd-&gt;<span class="built_in">GetLatestMutableCFOptions</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为啥这个函数也需要保护 ???</span></span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> preallocate_block_size =</span><br><span class="line">      <span class="built_in">GetWalPreallocateBlockSize</span>(mutable_cf_options.write_buffer_size);</span><br><span class="line">  mutex_.<span class="built_in">Unlock</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 WAL</span></span><br><span class="line">  <span class="keyword">if</span> (creating_new_log) &#123;</span><br><span class="line">    io_s = <span class="built_in">CreateWAL</span>(new_log_number, recycle_log_number, preallocate_block_size,</span><br><span class="line">                     &amp;new_log);</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// WAL 创建成功后，再创建 MemTable</span></span><br><span class="line"> <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    SequenceNumber seq = versions_-&gt;<span class="built_in">LastSequence</span>();</span><br><span class="line">    new_mem = cfd-&gt;<span class="built_in">ConstructNewMemtable</span>(mutable_cf_options, seq);</span><br><span class="line">    context-&gt;superversion_context.<span class="built_in">NewSuperVersion</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 用于 delete_range</span></span><br><span class="line">  cfd-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">ConstructFragmentedRangeTombstones</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// mutex_.Lock();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CreateWAL"><a href="#CreateWAL" class="headerlink" title="CreateWAL"></a>CreateWAL</h4><p>WAL 的创建也比较简单，如代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">IOStatus <span class="title">DBImpl::CreateWAL</span><span class="params">(<span class="type">uint64_t</span> log_file_num, <span class="type">uint64_t</span> recycle_log_number,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">size_t</span> preallocate_block_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                           log::Writer** new_log)</span> </span>&#123;</span><br><span class="line">  IOStatus io_s;</span><br><span class="line">  std::unique_ptr&lt;FSWritableFile&gt; lfile;</span><br><span class="line"></span><br><span class="line">  DBOptions db_options =</span><br><span class="line">      <span class="built_in">BuildDBOptions</span>(immutable_db_options_, mutable_db_options_);</span><br><span class="line">  FileOptions opt_file_options =</span><br><span class="line">      fs_-&gt;<span class="built_in">OptimizeForLogWrite</span>(file_options_, db_options);</span><br><span class="line">  std::string wal_dir = immutable_db_options_.<span class="built_in">GetWalDir</span>();</span><br><span class="line">  std::string log_fname = <span class="built_in">LogFileName</span>(wal_dir, log_file_num);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//1. 生成底层 wal 文件</span></span><br><span class="line">  <span class="keyword">if</span> (recycle_log_number) &#123;</span><br><span class="line">    std::string old_log_fname = <span class="built_in">LogFileName</span>(wal_dir, recycle_log_number);</span><br><span class="line">    io_s = fs_-&gt;<span class="built_in">ReuseWritableFile</span>(log_fname, old_log_fname, opt_file_options,</span><br><span class="line">                                  &amp;lfile, <span class="comment">/*dbg=*/</span><span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    io_s = <span class="built_in">NewWritableFile</span>(fs_.<span class="built_in">get</span>(), log_fname, &amp;lfile, opt_file_options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    lfile-&gt;<span class="built_in">SetWriteLifeTimeHint</span>(<span class="built_in">CalculateWALWriteHint</span>());</span><br><span class="line">    lfile-&gt;<span class="built_in">SetPreallocationBlockSize</span>(preallocate_block_size);</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span>&amp; listeners = immutable_db_options_.listeners;</span><br><span class="line">    FileTypeSet tmp_set = immutable_db_options_.checksum_handoff_file_types;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建写 wal 的 writer</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;WritableFileWriter&gt; <span class="title">file_writer</span><span class="params">(<span class="keyword">new</span> WritableFileWriter(</span></span></span><br><span class="line"><span class="params"><span class="function">        std::move(lfile), log_fname, opt_file_options,</span></span></span><br><span class="line"><span class="params"><span class="function">        immutable_db_options_.clock, io_tracer_, <span class="literal">nullptr</span> <span class="comment">/* stats */</span>, listeners,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="literal">nullptr</span>, tmp_set.Contains(FileType::kWalFile),</span></span></span><br><span class="line"><span class="params"><span class="function">        tmp_set.Contains(FileType::kWalFile)))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 封装 log_writer</span></span><br><span class="line">    *new_log = <span class="keyword">new</span> log::<span class="built_in">Writer</span>(std::<span class="built_in">move</span>(file_writer), log_file_num,</span><br><span class="line">                               immutable_db_options_.recycle_log_file_num &gt; <span class="number">0</span>,</span><br><span class="line">                               immutable_db_options_.manual_wal_flush,</span><br><span class="line">                               immutable_db_options_.wal_compression);</span><br><span class="line">    io_s = (*new_log)-&gt;<span class="built_in">AddCompressionTypeRecord</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> io_s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ConstructNewMemtable"><a href="#ConstructNewMemtable" class="headerlink" title="ConstructNewMemtable"></a>ConstructNewMemtable</h4><p>WAL 创建成功后，由 MemTable 所属的 ColumnFamily 构建 MemTable。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MemTable* <span class="title">ColumnFamilyData::ConstructNewMemtable</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> MutableCFOptions&amp; mutable_cf_options, SequenceNumber earliest_seq)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">MemTable</span>(internal_comparator_, ioptions_, mutable_cf_options,</span><br><span class="line">                      write_buffer_manager_, earliest_seq, id_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ColumnFamily"><a href="#ColumnFamily" class="headerlink" title="ColumnFamily"></a>ColumnFamily</h3><p>上面 new_log, new_mem 成功创建完后，下面对 ColumnFamily 的 WAL/MemTable 相关的元信息进行更新。</p><p>首先需要将当前 cur_log_writer 中已有的数据 flush 到操作系统中。实际上在 LogWriter::AddRecord 内部，每次写完都会进行一次 flush，将数据刷操作系统page cache 中，由操作系统决定何时将数据写入文件。flush 只能保证 RocksDB 进程中途挂了再重启数据不会丢，但是如果机器挂了数据还是有丢的可能，如果想要进一步保证安全就需要 sync 操作，将操作系统缓存层的数据同步到磁盘，很显然这个操作会拖慢写入速度。RocksDB 也配置了开启选项 <em>WriteOptions::sync: bool</em>，默认 false。</p><p><code>logs_</code>字段是个map，映射关系是{logfile_number_, log_writer}，记录了每一个log_writer及其对应的logfile_number，<code>alive_log_files_</code>记录是 logfile_number及其log_writer写入的数据量大小。由于 WAL 的生命周期和 ColumnFamily 有关，因此需要 <code>logs_</code> 和 <code>alive_log_files_</code> 来记录一个 RocksDB 实例中所有生命周期尚未结束的 WALs。</p><p>因此，当创建了新的 WAL ，需要在 log_write_mutex_ 的保护下添加新的记录。后续 FLushJob 完成了，也会相应删除生命周期结束的 WAL 记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//... above code</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面 Unlock, 现在恢复 Lock</span></span><br><span class="line">mutex_.<span class="built_in">Lock</span>();</span><br><span class="line"><span class="keyword">if</span> (recycle_log_number != <span class="number">0</span>) &#123;</span><br><span class="line">  log_recycle_files_.<span class="built_in">pop_front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; creating_new_log) &#123;</span><br><span class="line">  <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;log_write_mutex_)</span></span>;</span><br><span class="line">  <span class="comment">// 1. Flush</span></span><br><span class="line">  <span class="keyword">if</span> (!logs_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    log::Writer* cur_log_writer = logs_.<span class="built_in">back</span>().writer;</span><br><span class="line">    io_s = cur_log_writer-&gt;<span class="built_in">WriteBuffer</span>();</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      s = io_s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. Flush 成功后，更新 log 相关元信息</span></span><br><span class="line">  <span class="keyword">if</span> (s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    logfile_number_ = new_log_number;</span><br><span class="line">    log_empty_ = <span class="literal">true</span>;</span><br><span class="line">    log_dir_synced_ = <span class="literal">false</span>;</span><br><span class="line">    logs_.<span class="built_in">emplace_back</span>(logfile_number_, new_log);</span><br><span class="line">    alive_log_files_.<span class="built_in">push_back</span>(<span class="built_in">LogFileNumberSize</span>(logfile_number_));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前置工作已经完成，下面要开始更新 ColumnFaimly了。</p><p>由于传递给 SwitchMemTable 的 CF 并非都是因为自己的 MemTable 满了，可能是因为某个 CF0 把 WAL 写满了，导致所有的 MmeTable 都要切换，比如上述条件（1）。有些 CF1 可能仍然是空的，此时就需要更新 CF1 当前的 LogNumber。 这样就可以删除 CF1 之前指向的 WAL。</p><p>比如：CF0，CF1 当前都指向 log1，由于 CF0 一直写入数据，导致 log1 满了。此时需要创建新的 WAL 文件 log2。但是 CF1 一直没有写入数据，此时同步将 CF1 当前 log 指针 <code>log_number_</code> 指向 log2，使得指向 log1 的引用就是0，因此就可以在 MemTable 完成 Flush 完成后，将 log1 删除。</p><p>其余解释见代码，这部分代码简化如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...above code</span></span><br><span class="line"><span class="type">bool</span> empty_cf_updated = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (!empty_cf_updated) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> cf : *versions_-&gt;<span class="built_in">GetColumnFamilySet</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cf-&gt;<span class="built_in">IsEmpty</span>()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (creating_new_log) &#123;</span><br><span class="line">        cf-&gt;<span class="built_in">SetLogNumber</span>(logfile_number_);</span><br><span class="line">      &#125;</span><br><span class="line">      cf-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">SetCreationSeq</span>(versions_-&gt;<span class="built_in">LastSequence</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// CF 当前 Memtable 下一个活跃的 logfile_numer_，</span></span><br><span class="line"><span class="comment">// 选择需要 Flush 的 ImmutableMemTables 使用</span></span><br><span class="line">cfd-&gt;<span class="built_in">mem</span>()-&gt;<span class="built_in">SetNextLogNumber</span>(logfile_number_);</span><br><span class="line"><span class="comment">// 将当前 Memtable 添加到 ImmutableMemTable 链表中，等待 Flush 删除。</span></span><br><span class="line">cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">Add</span>(cfd-&gt;<span class="built_in">mem</span>(), &amp;context-&gt;memtables_to_free_);</span><br><span class="line"><span class="comment">// 设置新的 MemTable</span></span><br><span class="line">new_mem-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">cfd-&gt;<span class="built_in">SetMemtable</span>(new_mem);</span><br><span class="line"><span class="comment">// 更新 superversion</span></span><br><span class="line"><span class="built_in">InstallSuperVersionAndScheduleWork</span>(cfd, &amp;context-&gt;superversion_context,</span><br><span class="line">                                   mutable_cf_options);</span><br></pre></td></tr></table></figure><h4 id="GenerateFlushRequest"><a href="#GenerateFlushRequest" class="headerlink" title="GenerateFlushRequest"></a>GenerateFlushRequest</h4><p>SwitchMemTable，完成了 WAL/MemTable 的切换。紧接着就会尝试发起一次 flush 请求。Flush 的对象是从每个 CF 的 ImmutableMemtables 中提取的，因此 FlushRequest 需要保存每个 CF 的 max_memtable_id。</p><p>CF 中的每个 MemTable 都有一个单增的 <code>id_</code>，用于追踪 Flush。在使用 <code>ColumnFamilyData::SetMemtable</code> 函数添加到 CF 中时更新 <code>MemTable::id_</code> 字段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::GenerateFlushRequest</span><span class="params">(<span class="type">const</span> autovector&lt;ColumnFamilyData*&gt;&amp; cfds,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  FlushReason flush_reason, FlushRequest* req)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(req != <span class="literal">nullptr</span>);</span><br><span class="line">  req-&gt;flush_reason = flush_reason;</span><br><span class="line">  req-&gt;cfd_to_max_mem_id_to_persist.<span class="built_in">reserve</span>(cfds.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> cfd : cfds) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == cfd) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// max_memtable_id 即最新加入 ImmutableMemtables 的 memtable 的 Id</span></span><br><span class="line">    <span class="type">uint64_t</span> max_memtable_id = cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">GetLatestMemTableID</span>();</span><br><span class="line">    req-&gt;cfd_to_max_mem_id_to_persist.<span class="built_in">emplace</span>(cfd, max_memtable_id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SchedulePendingFlush"><a href="#SchedulePendingFlush" class="headerlink" title="SchedulePendingFlush"></a>SchedulePendingFlush</h4><p> <code>flush_queue_</code> 用于保存MemTables的Flush请求，<code>SchedulePendingFlush</code> 将上述生成的flush请求压入flush_queue_，再调度后台任务线程从 flush_queue_中取出FlushRequest执行。</p><p>这里也有个设计，如果开启了 <em>DBOptions::atomic_flush</em> 则会让多个 CFs 的 Flush 请求放到一个线程去执行，这样就可以保证 Flush 的原子性。否则，每次只 flush。但是其默认值为 false，因为只要开启了 WAL，就能保证跨多个 CFs 的写操作是原子性的，即便 flush 操作挂了也还有 WAL 可以恢复。</p><p>部分代码如下。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::SchedulePendingFlush</span><span class="params">(<span class="type">const</span> FlushRequest&amp; flush_req)</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="keyword">if</span> (flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!immutable_db_options_.atomic_flush) &#123;</span><br><span class="line">    <span class="comment">// only one</span></span><br><span class="line">    <span class="built_in">assert</span>(flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">size</span>() == <span class="number">1</span>);</span><br><span class="line">    ColumnFamilyData* cfd =</span><br><span class="line">        flush_req.cfd_to_max_mem_id_to_persist.<span class="built_in">begin</span>()-&gt;first;</span><br><span class="line">    <span class="keyword">if</span> (!cfd-&gt;<span class="built_in">queued_for_flush</span>() &amp;&amp; cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">IsFlushPending</span>()) &#123;</span><br><span class="line">      cfd-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">      cfd-&gt;<span class="built_in">set_queued_for_flush</span>(<span class="literal">true</span>);</span><br><span class="line">      ++unscheduled_flushes_;</span><br><span class="line">      flush_queue_.<span class="built_in">push_back</span>(flush_req);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; [cfd, _] : flush_req.cfd_to_max_mem_id_to_persist) &#123;</span><br><span class="line">      cfd-&gt;<span class="built_in">Ref</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    ++unscheduled_flushes_;</span><br><span class="line">    flush_queue_.<span class="built_in">push_back</span>(flush_req);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MaybeScheduleFlushOrCompaction"><a href="#MaybeScheduleFlushOrCompaction" class="headerlink" title="MaybeScheduleFlushOrCompaction"></a>MaybeScheduleFlushOrCompaction</h4><p>RocksDB 的后台任务线程调度是主动触发的，并没有 loop 线程在阻塞等待 <code>flush_queue_</code> 加入新元素后就从 <code>flush_queue_</code> 提取请求去执行。</p><p>因此，在向 <code>flush_req</code> 加入有新请求后，需要主动通过 <code>MaybeScheduleFlushOrCompaction</code> 函数调度后台线程执行 <code>DBImpl::BackgroundCallFlush</code> 函数执行 FlushRequest 请求。</p><p>最大后台任务有 <code>bg_job_limits</code> 限制，<code>unscheduled_flushes_</code> 表征当前有多少待 flush 的请求，<code>bg_flush_scheduled_</code> 表征当前已经调度了多少 flush 请求，配合 <code>bg_job_limits</code> 参数限制后台 flush 任务。</p><p><code>DBImpl::BGWorkFlush</code> 函数用于执行 FlushRequest，<code>DBImpl::UnscheduleFlushCallback</code> 函数则是执行 FlushRequest 完的回调函数，用于释放 <code>FlushThreadArg</code> 对象。</p><p><code>MaybeScheduleFlushOrCompaction</code> 函数执行，是个分界点：</p><ul><li>提交完 Flush 请求后，如果没有触发 DelayWrite，WriteStall，就会接受新的读写请求了；</li><li>后台线程池接受到 <code>BGWorkFlush</code> 请求后，就开始执行 FlushReqeust</li></ul><p>这部分相关代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::MaybeScheduleFlushOrCompaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  mutex_.<span class="built_in">AssertHeld</span>();</span><br><span class="line">  <span class="comment">//... precondition check</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> bg_job_limits = <span class="built_in">GetBGJobLimits</span>();</span><br><span class="line">  <span class="type">bool</span> is_flush_pool_empty =</span><br><span class="line">      env_-&gt;<span class="built_in">GetBackgroundThreads</span>(Env::Priority::HIGH) == <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (!is_flush_pool_empty &amp;&amp; unscheduled_flushes_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         bg_flush_scheduled_ &lt; bg_job_limits.max_flushes) &#123;</span><br><span class="line">    bg_flush_scheduled_++;</span><br><span class="line">    FlushThreadArg* fta = <span class="keyword">new</span> FlushThreadArg;</span><br><span class="line">    fta-&gt;db_ = <span class="keyword">this</span>;</span><br><span class="line">    fta-&gt;thread_pri_ = Env::Priority::HIGH;</span><br><span class="line">    env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWorkFlush, fta, Env::Priority::HIGH, <span class="keyword">this</span>,</span><br><span class="line">                   &amp;DBImpl::UnscheduleFlushCallback);</span><br><span class="line">    --unscheduled_flushes_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_flush_pool_empty) &#123;</span><br><span class="line">    <span class="keyword">while</span> (unscheduled_flushes_ &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">           bg_flush_scheduled_ + bg_compaction_scheduled_ &lt;</span><br><span class="line">               bg_job_limits.max_flushes) &#123;</span><br><span class="line">      bg_flush_scheduled_++;</span><br><span class="line">      FlushThreadArg* fta = <span class="keyword">new</span> FlushThreadArg;</span><br><span class="line">      fta-&gt;db_ = <span class="keyword">this</span>;</span><br><span class="line">      fta-&gt;thread_pri_ = Env::Priority::LOW;</span><br><span class="line">      env_-&gt;<span class="built_in">Schedule</span>(&amp;DBImpl::BGWorkFlush, fta, Env::Priority::LOW, <span class="keyword">this</span>,</span><br><span class="line">                     &amp;DBImpl::UnscheduleFlushCallback);</span><br><span class="line">      --unscheduled_flushes_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//.. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BackgroundCallFlush"><a href="#BackgroundCallFlush" class="headerlink" title="BackgroundCallFlush"></a>BackgroundCallFlush</h3><p>DBImpl::BGWorkFlush 只是个 <code>BackgroundCallFlush</code> 的 wrapper。 进入 <code>BackgroundCallFlush</code> 函数后，需要获取 <code>DBImpl::mutex_</code> 来执行 <code>BackgroundFlush</code>，执行成功后。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DBImpl::BackgroundCallFlush</span><span class="params">(Env::Priority thread_pri)</span> </span>&#123;</span><br><span class="line">  <span class="type">bool</span> made_progress = <span class="literal">false</span>;</span><br><span class="line">  <span class="function">JobContext <span class="title">job_context</span><span class="params">(next_job_id_.fetch_add(<span class="number">1</span>), <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 需要 DBImpl::mutex_</span></span><br><span class="line">    <span class="function">InstrumentedMutexLock <span class="title">l</span><span class="params">(&amp;mutex_)</span></span>; </span><br><span class="line">    num_running_flushes_++;</span><br><span class="line"></span><br><span class="line">    std::unique_ptr&lt;std::list&lt;<span class="type">uint64_t</span>&gt;::iterator&gt;</span><br><span class="line">        <span class="built_in">pending_outputs_inserted_elem</span>(<span class="keyword">new</span> std::list&lt;<span class="type">uint64_t</span>&gt;::<span class="built_in">iterator</span>(</span><br><span class="line">            <span class="built_in">CaptureCurrentFileNumberInPendingOutputs</span>()));</span><br><span class="line">    FlushReason reason;</span><br><span class="line"></span><br><span class="line">    Status s = <span class="built_in">BackgroundFlush</span>(&amp;made_progress, &amp;job_context, &amp;log_buffer,</span><br><span class="line">                               &amp;reason, thread_pri);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(num_running_flushes_ &gt; <span class="number">0</span>);</span><br><span class="line">    num_running_flushes_--;</span><br><span class="line">    bg_flush_scheduled_--;</span><br><span class="line">    <span class="comment">// See if there&#x27;s more work to be done</span></span><br><span class="line">    <span class="built_in">MaybeScheduleFlushOrCompaction</span>();</span><br><span class="line">    atomic_flush_install_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">    bg_cv_.<span class="built_in">SignalAll</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BackgroundFlush"><a href="#BackgroundFlush" class="headerlink" title="BackgroundFlush"></a>BackgroundFlush</h4><p><code>PopFirstFromFlushQueue</code> 函数从 <code>flush_request_</code> 中取出待 Flush 的请求，过滤掉不符合条件的的CF，符合结果的存在 <code>bg_flush_args</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">DBImpl::BackgroundFlush</span><span class="params">(<span class="type">bool</span>* made_progress, JobContext* job_context,</span></span></span><br><span class="line"><span class="params"><span class="function">                               LogBuffer* log_buffer, FlushReason* reason,</span></span></span><br><span class="line"><span class="params"><span class="function">                               Env::Priority thread_pri)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  autovector&lt;BGFlushArg&gt; bg_flush_args;</span><br><span class="line">  std::vector&lt;SuperVersionContext&gt;&amp; superversion_contexts =</span><br><span class="line">      job_context-&gt;superversion_contexts;</span><br><span class="line">  autovector&lt;ColumnFamilyData*&gt; column_families_not_to_flush;</span><br><span class="line">  <span class="keyword">while</span> (!flush_queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="comment">// This cfd is already referenced</span></span><br><span class="line">    <span class="keyword">auto</span> [flush_reason, cfd_to_max_mem_id_to_persist] =</span><br><span class="line">        <span class="built_in">PopFirstFromFlushQueue</span>();</span><br><span class="line">    superversion_contexts.<span class="built_in">clear</span>();</span><br><span class="line">    superversion_contexts.<span class="built_in">reserve</span>(cfd_to_max_mem_id_to_persist.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; [cfd, max_mem_id] : cfd_to_max_mem_id_to_persist) &#123;</span><br><span class="line">      <span class="keyword">if</span> (cfd-&gt;<span class="built_in">GetMempurgeUsed</span>()) &#123;</span><br><span class="line">        cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">FlushRequested</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (cfd-&gt;<span class="built_in">IsDropped</span>() || !cfd-&gt;<span class="built_in">imm</span>()-&gt;<span class="built_in">IsFlushPending</span>()) &#123;</span><br><span class="line">        <span class="comment">// can&#x27;t flush this CF, try next one</span></span><br><span class="line">        column_families_not_to_flush.<span class="built_in">push_back</span>(cfd);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      superversion_contexts.<span class="built_in">emplace_back</span>(<span class="built_in">SuperVersionContext</span>(<span class="literal">true</span>));</span><br><span class="line">      bg_flush_args.<span class="built_in">emplace_back</span>(cfd, max_mem_id,</span><br><span class="line">                                 &amp;(superversion_contexts.<span class="built_in">back</span>()), flush_reason);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有待 Flush 的 CF</span></span><br><span class="line">    <span class="keyword">if</span> (!bg_flush_args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获得具有 Flush 条件的 <code>bg_flush_args</code>，下面就是真正的准备执行 FlushJob。<code>FlushJob</code> 由 <code>FlushMemTablesToOutputFiles</code> 函数执行，这个后续再讲。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (!bg_flush_args.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">  <span class="keyword">auto</span> bg_job_limits = <span class="built_in">GetBGJobLimits</span>();</span><br><span class="line">  status = <span class="built_in">FlushMemTablesToOutputFiles</span>(bg_flush_args, made_progress,</span><br><span class="line">                                       job_context, log_buffer, thread_pri);</span><br><span class="line">  *reason = bg_flush_args[<span class="number">0</span>].flush_reason_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; arg : bg_flush_args) &#123;</span><br><span class="line">    ColumnFamilyData* cfd = arg.cfd_;</span><br><span class="line">    <span class="keyword">if</span> (cfd-&gt;<span class="built_in">UnrefAndTryDelete</span>()) &#123;</span><br><span class="line">      arg.cfd_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> cfd : column_families_not_to_flush) &#123;</span><br><span class="line">  cfd-&gt;<span class="built_in">UnrefAndTryDelete</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;WAL 在 DB::Open 时就会创建，用于持久化 MemTable 中尚未 Flush 的数据。具体写入 WAL 的格式可以参考 &lt;a href=&quot;https://github.com/facebook/rocksdb/wiki/Write-Ahead-Log-File</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>WriteThread 如何使用 Pipeline 提升写入吞吐，降低延迟</title>
    <link href="https://szza.github.io/2022/01/13/rocksdb/WritePath/write_thread_4/"/>
    <id>https://szza.github.io/2022/01/13/rocksdb/WritePath/write_thread_4/</id>
    <published>2022-01-13T06:15:35.000Z</published>
    <updated>2023-08-01T02:21:25.019Z</updated>
    
    <content type="html"><![CDATA[<p>在前面几篇讲解了从 WriteBatch 的内部序列化流程 和 WriteThread 如何控制并发写入的基本流程，本文进一步讲解 WriteThread 如何使用 PipelinedWrite 来提升写吞吐，其中和前文相似的逻辑不再细说。</p><p>通过设置选项 <code>DBOptions::enable_pipelined_write = true</code> 来开启，开启后整个db的 WriteThread 都是通过 PipelinedWrite 方式控制写入流程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (immutable_db_options_.enable_pipelined_write) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">PipelinedWriteImpl</span>(write_options, my_batch, callback, log_used,</span><br><span class="line">                            log_ref, disable_memtable, seq_used);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WAL-Pipelined-Write"><a href="#WAL-Pipelined-Write" class="headerlink" title="WAL: Pipelined Write"></a>WAL: Pipelined Write</h4><p>在之前的 WriteThread 写入控制流程中， 是依次有序地将数据写入 WAL 和 MemTable，那么如何使得 WAL 和 MemTable 的写入操作并行起来？</p><p>在多个 writers 并发写入同一个 RocksdB 实例时，只要前一个 <code>writer_group0</code> 将数据写入 WAL 了，那么下一个 <code>writer_group1</code> 就不必等待 writer_group0 完成 MemTable 写入流程，writer_group1 就可以开始自己的 WAL 写入流程: 因此 writer_group0 的 MemTable 写流程和 writer_group1 的 WAL 写流程就可以并行起来。</p><p>上述就是 <code>PipelinedWrite</code> 的核心思想。因此 PipelinedWrite 需要开启 WAL，来保证 writer_group0 写入 WAL 的数据不会丢。</p><h4 id="MemTable-Concurrent-Write"><a href="#MemTable-Concurrent-Write" class="headerlink" title="MemTable: Concurrent Write"></a>MemTable: Concurrent Write</h4><p>已经写入 WAL 的数据不会丢，那么是否可以在写入 MemTable 时，允许多个 writers 并发地写 MemTable，而不是原先由 leader-writer 来完成 memtable_write_group 的写入？</p><p>选项 <code>DBOptions::allow_concurrent_memtable_write</code> 默认值为 true，即默认支持并发写入 MemTable，但实际上当前只有基于 skiplist 实现的 MemTable 才支持这一特性（ <code>SkipListRep</code> 也是 MemTable 的默认实现）。</p><p>因此，在写路径使用 <code>PipelineWrite</code> 实现时，实际上就有了两种优化：</p><ul><li>WriteGroup 之间可以 Pipeline</li><li>MemTable 可以并发写入</li></ul><p>从实现角度，可以粗略地将有 <code>PipelinedWriteImpl</code> 函数划分成三个阶段（任务）:</p><ul><li><p>T1：完成当前 write_group0 的 WAL 写入流程，</p></li><li><p>T2：通知 write_group1 开启 WAL 写入流程，即 write_group1 无需等待 write_group0 完成 MemTable 写入流程才开启自己的 WAL 写入流程；</p></li><li><p>T3：write_group0 的 WAL 写入流程完成后，需要启动 write_group0 的并发写 MemTable 流程。</p><p>实际上，在 T3 阶段可能会携带其他 write_group 的 writers 一起进入 T3 阶段，来提升性能，详情见后文。</p></li></ul><p>由于后两个任务都需要等待第一个任务完成，因此三个任务的分界点就可以设置在 <code>WrriteThread::ExitAsBatchGroupLeader</code> 函数中: T1 在写 WAL 期间需要整个 RocksDB 只有一个 leader-writer，在 T1 任务结束后就可以不再担任 leader 角色。此时有两件事需要做 <em>1）</em> 挑选出下一个 WriteGroup 中的 leader-writer，让 T2 任务可以 pipeline 执行；<em>2）</em> 开启当前 WriteGroup 并发写入 MemTable 流程。</p><p>整个设计如下图：</p><h2 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h2><p>T1 任务的流程和 <a href="https://mp.weixin.qq.com/s/o5JxgEf1u0JjeA5IMhEZUg">WriteThread 如何控制并发写入流程</a> 的基本一致，都需要经过 <code>JoinBatchGroup</code> -&gt; <code>EnterAsBatchGroupLeader</code> -&gt; <code>ExitAsBatchGroupLeader</code>， 只是将原来 leader-writer 作用范围（WriteToWAL 和 MemTable::Add） 范围缩小到了仅有 WALs。</p><p>因此，只有当 <code>JoinBatchGroup</code> 函数返回的 writer 是 leader-writer 时才会进入 WAL 写流程，而且当前 write_group0 的其他 writers 和后续 write_group1 等都会阻塞在 <code>JoinBatchGroupl</code> 函数处。</p><p>具体的阻塞逻辑可以参考 <a href="https://mp.weixin.qq.com/s/5BP0eXYHbAmRMld8ac4ufg">WriteThread 如何自适应优化线程同步</a>。PipelineWriteImpl 的函数入口代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">WriteThread::Writer <span class="title">w</span><span class="params">(write_options, my_batch, callback, log_ref,</span></span></span><br><span class="line"><span class="params"><span class="function">                      disable_memtable, <span class="comment">/*_batch_cnt=*/</span><span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="comment">/*_pre_release_callback=*/</span><span class="literal">nullptr</span>)</span></span>;</span><br><span class="line">write_thread_.<span class="built_in">JoinBatchGroup</span>(&amp;w);</span><br><span class="line"><span class="keyword">if</span> (w.state == WriteThread::STATE_GROUP_LEADER) &#123;</span><br><span class="line">  WriteThread::WriteGroup wal_write_group;</span><br><span class="line">  last_batch_group_size_ =</span><br><span class="line">      write_thread_.<span class="built_in">EnterAsBatchGroupLeader</span>(&amp;w, &amp;wal_write_group);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (w.status.<span class="built_in">ok</span>() &amp;&amp; !write_options.disableWAL) &#123;</span><br><span class="line">    <span class="comment">// 将当前 wal_write_group 数据写入 WAL</span></span><br><span class="line">    io_s =</span><br><span class="line">        <span class="built_in">WriteToWAL</span>(wal_write_group, log_context.writer, log_used,</span><br><span class="line">                   log_context.need_log_sync, log_context.need_log_dir_sync,</span><br><span class="line">                   current_sequence, log_file_number_size);</span><br><span class="line">    w.status = io_s;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  write_thread_.<span class="built_in">ExitAsBatchGroupLeader</span>(wal_write_group, w.status);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，PipelinedWrite 如何关联前后 writer_group 的核心就在 <code>ExitAsBatchGroupLeader</code> 函数中了。</p><h4 id="ExitAsBatchGroupLeader"><a href="#ExitAsBatchGroupLeader" class="headerlink" title="ExitAsBatchGroupLeader"></a>ExitAsBatchGroupLeader</h4><p>在前文 <a href="https://mp.weixin.qq.com/s/o5JxgEf1u0JjeA5IMhEZUg">WriteThread 如何控制并发写入流程</a> 已经详细讲解了 <code>ExitAsBatchGroupLeader</code> 函数在 <code>enable_pipelined_write == false</code> 时的执行流程，下面来讲另一个分支。主要有两个任务：</p><ul><li><p>T2：选出下一个 write_group1 中的 leader-writer，使其也进入写 WAL 流程</p></li><li><p>T3：由 <code>CompleteLeader</code> 和 <code>CompleteFollower</code> 函数提前将不用写入 MemTable 的 writrs 从 write_group0 链表中删除。将 <code>write_group0</code> 中剩余的 writers 移动到 <code>newest_memtable_writer_</code> 指向的链表。</p><p>只有 leader-memtable-writer 才能开启并发写 MemTable 的流程，<code>w-&gt;state</code> 状态会变成 <code>STATE_MEMTABLE_WRITER_LEADER</code>。</p><p>如果此时多个 write_group（wg0，wg1）的 leader-writer 都想变成 leader-memtable-writer，假设最终 wg0-&gt;leader 成功，则新的 memtable_write_group 实际上会包含 (wg0, wg1)，并且 wg1-&gt;link_older = wg0 的方式串联起来。</p><p>接着，leader-memtable-writer 通过 <code>LaunchParallelMemTableWriters</code> 函数来启动 <code>memtable_write_group</code> 并发写 MemTables 的流程，follower-writer 才会解除阻塞等待， 进入 MemTable::Add 写入流程。</p></li></ul><p>整体代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::ExitAsBatchGroupLeader</span><span class="params">(WriteGroup&amp; write_group,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Status&amp; status)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enable_pipelined_write_) &#123;</span><br><span class="line">    Writer dummy;</span><br><span class="line">    Writer* head = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="comment">// 1. 在当前 write_group0 和下一个 write_group1 中间插入一个 dummy 节点</span></span><br><span class="line">    <span class="keyword">if</span> (head != last_writer ||</span><br><span class="line">        !newest_writer_.<span class="built_in">compare_exchange_strong</span>(head, &amp;dummy)) &#123;</span><br><span class="line">  </span><br><span class="line">      <span class="built_in">CreateMissingNewerLinks</span>(head);</span><br><span class="line">      <span class="built_in">assert</span>(last_writer-&gt;link_newer != <span class="literal">nullptr</span>);</span><br><span class="line">      last_writer-&gt;link_newer-&gt;link_older = &amp;dummy;</span><br><span class="line">      dummy.link_newer = last_writer-&gt;link_newer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 提前删除不用写 MemTable 的 writers 节点</span></span><br><span class="line">    <span class="keyword">for</span> (Writer* w = last_writer; w != leader;) &#123;</span><br><span class="line">      Writer* next = w-&gt;link_older;</span><br><span class="line">      w-&gt;status = status;</span><br><span class="line">      <span class="keyword">if</span> (!w-&gt;<span class="built_in">ShouldWriteToMemtable</span>()) &#123;</span><br><span class="line">        <span class="built_in">CompleteFollower</span>(w, write_group);</span><br><span class="line">      &#125;</span><br><span class="line">      w = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!leader-&gt;<span class="built_in">ShouldWriteToMemtable</span>()) &#123;</span><br><span class="line">      <span class="built_in">CompleteLeader</span>(write_group);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3.1 (T3) 将 write_group0 中剩余的 writers 转移到</span></span><br><span class="line">    <span class="comment">//     newest_memtable_writer_  指向的链表</span></span><br><span class="line">    <span class="keyword">if</span> (write_group.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">LinkGroup</span>(write_group, &amp;newest_memtable_writer_)) &#123;</span><br><span class="line">        <span class="comment">// 设置 leader-memtable-writer</span></span><br><span class="line">        <span class="built_in">SetState</span>(write_group.leader, STATE_MEMTABLE_WRITER_LEADER);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. (T2) 选取 writ_group1 中 leader-writer</span></span><br><span class="line">    head = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (head != &amp;dummy ||</span><br><span class="line">        !newest_writer_.<span class="built_in">compare_exchange_strong</span>(head, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      <span class="built_in">CreateMissingNewerLinks</span>(head);</span><br><span class="line">      Writer* new_leader = dummy.link_newer;</span><br><span class="line">      <span class="built_in">assert</span>(new_leader != <span class="literal">nullptr</span>);</span><br><span class="line">      new_leader-&gt;link_older = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="built_in">SetState</span>(new_leader, STATE_GROUP_LEADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 等待 leader-memtable-writer 调用 LaunchParallelMemTableWriters</span></span><br><span class="line">    <span class="built_in">AwaitState</span>(leader,</span><br><span class="line">               STATE_MEMTABLE_WRITER_LEADER | STATE_PARALLEL_MEMTABLE_WRITER |</span><br><span class="line">                   STATE_COMPLETED,</span><br><span class="line">               &amp;eabgl_ctx);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//... enable_pipelined_write_ == false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompleteFollower"><a href="#CompleteFollower" class="headerlink" title="CompleteFollower"></a>CompleteFollower</h4><p>WriteThread 是逆序从 <code>[last_writer, leader)</code> 来删除不需要写入 MemTable 的 writers-follower 节点。这个 write_group 的 writers list 首尾节点是 <code>leader</code> 和 <code>last_writer</code>。 CompleteFollower 删除的都是 followers 节点，因此在删除时需要注意下是不是尾部节点 last_writer 即可。</p><p>这里只需要将 w 从 write_group 中剔除即可，并不需要 delete w，而是将 <code>w-&gt;state</code> 状态设置为 <code>STATE_COMPLETED</code>。这是因为 w 这份资源由 w 所属的线程去释放，将其状态更改为 <code>STATE_COMPLETED</code> 后，w 所属的线程就会解除阻塞，去释放这份资源，回到应用层。</p><p><code>CompleteLeader</code> 逻辑也类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::CompleteFollower</span><span class="params">(Writer* w, WriteGroup&amp; write_group)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(write_group.size &gt; <span class="number">1</span>);</span><br><span class="line">  <span class="built_in">assert</span>(w != write_group.leader);</span><br><span class="line">  <span class="keyword">if</span> (w == write_group.last_writer) &#123;</span><br><span class="line">    w-&gt;link_older-&gt;link_newer = <span class="literal">nullptr</span>;</span><br><span class="line">    write_group.last_writer = w-&gt;link_older;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    w-&gt;link_older-&gt;link_newer = w-&gt;link_newer;</span><br><span class="line">    w-&gt;link_newer-&gt;link_older = w-&gt;link_older;</span><br><span class="line">  &#125;</span><br><span class="line">  write_group.size -= <span class="number">1</span>;</span><br><span class="line">  <span class="built_in">SetState</span>(w, STATE_COMPLETED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LinkGroup"><a href="#LinkGroup" class="headerlink" title="LinkGroup"></a>LinkGroup</h4><p><code>LinkGroup</code> 函数的作用是将当前 write_group0 中需要向 MemTable 写数据的 writers 转移到 <code>newest_memtable_writer_</code> 中来，并且保持 write_group0 中的顺序。</p><ol><li><p>先断开 <code>(leader, last_writer]</code> 区间所有的 <code>w-&gt;link_newer/prev</code> 指针（leader-&gt;link_newer 已经是 NULL)。这是因为 <code>LinkGroup</code> 可能会将多个 WriteGroup 的 writers 串到一个 <code>newest_memtable_writer_</code> 指针中，后续需要重新建立 prev 指针。</p></li><li><p>通过 <code>compare_exchange_weak</code> 尝试让 <code>newest_memtable_writer_</code> 指向 <code>last_writer</code>。多个并发的 WriteGroup 通过 link_older 指针串联起来。</p><p> 因此，在 <code>ExitAsBatchGroupLeader</code> 函数末尾会有个 <code>AwaitState(leader, state)</code> 代码，用于阻塞那些被串在 memtable_write_group 中的 follower-memtable-writers，等待 leader-memtable-writer 调用 <code>LaunchParallelMemTableWriters</code> 函数才能解除阻塞。</p></li></ol><p>原理和 <code>LinkOne</code> 函数差不多，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteThread::LinkGroup</span><span class="params">(WriteGroup&amp; write_group,</span></span></span><br><span class="line"><span class="params"><span class="function">                            std::atomic&lt;Writer*&gt;* newest_writer)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader; <span class="comment">// head</span></span><br><span class="line">  Writer* last_writer = write_group.last_writer; <span class="comment">// tail</span></span><br><span class="line">  Writer* w = last_writer;</span><br><span class="line">  <span class="comment">// 1. 断开 [last_writer, leader) 区间 w-&gt;link_newer 指针</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    w-&gt;link_newer = <span class="literal">nullptr</span>;</span><br><span class="line">    w-&gt;write_group = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (w == leader) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    w = w-&gt;link_older;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2. 将 newest_writer 指向 last_writer</span></span><br><span class="line">  Writer* newest = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    leader-&gt;link_older = newest; <span class="comment">// leader-&gt;next = newest</span></span><br><span class="line">    <span class="keyword">if</span> (newest_writer-&gt;<span class="built_in">compare_exchange_weak</span>(newest, last_writer)) &#123;</span><br><span class="line">      <span class="comment">// newest_writer = last_writer</span></span><br><span class="line">      <span class="keyword">return</span> (newest == <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h2><p>T1 在 <code>ExitAsBatchGroupLeader</code> 函数中已经选出 write_group1 的 leader-writer， 因此不会等待 write_group0 完成，T2 就会直接启动。重复write_group0 的 T1 流程。</p><h2 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h2><p>write_group0 执行完 T1 任务后就进入 T3 阶段，准备并发写 MemTables 操作。这个阶段的写流程如下:</p><p>leader-memtable-writer 会通过 <code>EnterAsMemTableWriter</code> 获取 <code>memtable_write_group</code>，</p><ul><li><p>如果 memtable_write_group 的 writers 数量大于 1 则调用 <code>LaunchParallelMemTableWriters</code> 函数启动所有的 writers 进入 MemTable::Add 阶段。</p></li><li><p>否则，当前 leader-memtable-writer 就直接写 MemTable。</p><p>写 MemTable 的操作是由 <code>WriteBatchInternal::InsertInto</code> 函数完成。</p></li></ul><p>而 follower-memtable-writers 会一直阻塞等待在两个的地方:</p><ul><li>当前 write_group0 的 followers 会阻塞在 PipelineWriteImpl 函数开始的 JoinBatchGroup 处</li><li>其他 write_group1 的 followers 会阻塞在 ExitAsBatchGroupLeader 函数末尾的 AwaitState 处</li></ul><p>因此，当 leader-memtable-writer 调用 <code>LaunchParallelMemTableWriters</code> 函数，则会解除上述两处阻塞状态的 writers，进入 T3 阶段。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">WriteThread::WriteGroup memtable_write_group;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (w.state == WriteThread::STATE_MEMTABLE_WRITER_LEADER) &#123;</span><br><span class="line">  <span class="comment">// memtable-writer-leader reach here</span></span><br><span class="line">  write_thread_.<span class="built_in">EnterAsMemTableWriter</span>(&amp;w, &amp;memtable_write_group);</span><br><span class="line">  <span class="keyword">if</span> (memtable_write_group.size &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">      immutable_db_options_.allow_concurrent_memtable_write) &#123;</span><br><span class="line">    write_thread_.<span class="built_in">LaunchParallelMemTableWriters</span>(&amp;memtable_write_group);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    memtable_write_group.status = WriteBatchInternal::<span class="built_in">InsertInto</span>(</span><br><span class="line">        memtable_write_group, w.sequence, column_family_memtables_.<span class="built_in">get</span>(),</span><br><span class="line">        &amp;flush_scheduler_, &amp;trim_history_scheduler_,</span><br><span class="line">        write_options.ignore_missing_column_families, <span class="number">0</span> <span class="comment">/*log_number*/</span>, <span class="keyword">this</span>,</span><br><span class="line">        <span class="literal">false</span> <span class="comment">/*concurrent_memtable_writes*/</span>, seq_per_batch_, batch_per_txn_);</span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(memtable_write_group.last_sequence);</span><br><span class="line">    write_thread_.<span class="built_in">ExitAsMemTableWriter</span>(&amp;w, memtable_write_group);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// memtable-writer-follower reach here</span></span><br><span class="line">  memtable_write_group.status.<span class="built_in">PermitUncheckedError</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EnterAsMemTableWriter"><a href="#EnterAsMemTableWriter" class="headerlink" title="EnterAsMemTableWriter"></a>EnterAsMemTableWriter</h4><p><code>EnterAsMemTableWriter</code> 函数和 <code>EnterAsBatchGroupLeader</code> 工作逻辑类似，从 <code>newest_memtable_writer_</code> 中取出memtable-writers，组成一个由 <code>[leader, last_writer]</code> 组成的 memtable_write_group。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::EnterAsMemTableWriter</span><span class="params">(Writer* leader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        WriteGroup* write_group)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> size = WriteBatchInternal::<span class="built_in">ByteSize</span>(leader-&gt;batch);</span><br><span class="line">  <span class="comment">//..</span></span><br><span class="line">  leader-&gt;write_group = write_group;</span><br><span class="line">  write_group-&gt;leader = leader;</span><br><span class="line">  write_group-&gt;size = <span class="number">1</span>;</span><br><span class="line">  Writer* last_writer = leader;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (allow_concurrent_memtable_write_ &amp;&amp; !leader-&gt;batch-&gt;<span class="built_in">HasMerge</span>()) &#123;</span><br><span class="line">    Writer* newest_writer = newest_memtable_writer_.<span class="built_in">load</span>();</span><br><span class="line">    <span class="built_in">CreateMissingNewerLinks</span>(newest_writer);</span><br><span class="line"></span><br><span class="line">    Writer* w = leader;</span><br><span class="line">    <span class="keyword">while</span> (w != newest_writer) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(w-&gt;link_newer);</span><br><span class="line">      w = w-&gt;link_newer;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w-&gt;batch == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (w-&gt;batch-&gt;<span class="built_in">HasMerge</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      w-&gt;write_group = write_group;</span><br><span class="line">      last_writer = w;</span><br><span class="line">      write_group-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  write_group-&gt;last_writer = last_writer;</span><br><span class="line">  write_group-&gt;last_sequence =</span><br><span class="line">      last_writer-&gt;sequence + WriteBatchInternal::<span class="built_in">Count</span>(last_writer-&gt;batch) - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="LaunchParallelMemTableWriters"><a href="#LaunchParallelMemTableWriters" class="headerlink" title="LaunchParallelMemTableWriters"></a>LaunchParallelMemTableWriters</h4><p><code>LaunchParallelMemTableWriters</code> 函数即遍历 <code>memtable_write_group</code> 中所有的 writers，将其 w-&gt;state 设置为 <code>STATE_PARALLEL_MEMTABLE_WRITER</code> 来解除阻塞。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::LaunchParallelMemTableWriters</span><span class="params">(WriteGroup* memtable_write_group)</span> </span>&#123;</span><br><span class="line">  memtable_write_group-&gt;running.<span class="built_in">store</span>(memtable_write_group-&gt;size);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> w : *memtable_write_group) &#123;</span><br><span class="line">    <span class="built_in">SetState</span>(w, STATE_PARALLEL_MEMTABLE_WRITER);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CompleteParallelMemTableWriter"><a href="#CompleteParallelMemTableWriter" class="headerlink" title="CompleteParallelMemTableWriter"></a>CompleteParallelMemTableWriter</h4><p>所有的 <code>w-&gt;state</code> 都在 LaunchParallelMemTableWriters 函数中被更改 <code>STATE_PARALLEL_MEMTABLE_WRITER</code>，此时已经没有主从 writers 的概念。</p><p>每个 writer 都并发地调用 WriteBatchInternal::InsertInto 函数向 MemTable 写数据。每个 writer 写完 MemTable，都会调用一次 CompleteParallelMemTableWriter 来检测自己是不是 memtable_write_group 中最后一个完成写 MemTable 的 writer。最后一个 memtable-writers 在 <code>ExitAsMemTableWriter</code> 函数中做善后工作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (w.state == WriteThread::STATE_PARALLEL_MEMTABLE_WRITER) &#123;</span><br><span class="line">  <span class="function">ColumnFamilyMemTablesImpl <span class="title">column_family_memtables</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      versions_-&gt;GetColumnFamilySet())</span></span>;</span><br><span class="line">  w.status = WriteBatchInternal::<span class="built_in">InsertInto</span>(</span><br><span class="line">      &amp;w, w.sequence, &amp;column_family_memtables, &amp;flush_scheduler_,</span><br><span class="line">      &amp;trim_history_scheduler_, write_options.ignore_missing_column_families,</span><br><span class="line">      <span class="number">0</span> <span class="comment">/*log_number*/</span>, <span class="keyword">this</span>, <span class="literal">true</span> <span class="comment">/*concurrent_memtable_writes*/</span>,</span><br><span class="line">      <span class="literal">false</span> <span class="comment">/*seq_per_batch*/</span>, <span class="number">0</span> <span class="comment">/*batch_cnt*/</span>, <span class="literal">true</span> <span class="comment">/*batch_per_txn*/</span>,</span><br><span class="line">      write_options.memtable_insert_hint_per_batch);</span><br><span class="line">  <span class="keyword">if</span> (write_thread_.<span class="built_in">CompleteParallelMemTableWriter</span>(&amp;w)) &#123;</span><br><span class="line">    <span class="built_in">MemTableInsertStatusCheck</span>(w.status);</span><br><span class="line">    versions_-&gt;<span class="built_in">SetLastSequence</span>(w.write_group-&gt;last_sequence);</span><br><span class="line">    write_thread_.<span class="built_in">ExitAsMemTableWriter</span>(&amp;w, *w.write_group);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次 memtable-writer 写完 MemTable，都会进入 <code>CompleteParallelMemTableWriter</code> 将 <code>memtable_write_group-&gt;running</code> 减 1: 如果不是最后一个 memtable-writer，则阻塞等待最后一个 memtable-writer 完成后在 <code>ExitAsMemTableWriter</code> 函数中将所有的 writers 状态更改为 STATE_COMPLETED，则本次并发写 MemTable 操作结束。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteThread::CompleteParallelMemTableWriter</span><span class="params">(Writer* w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span>* write_group = w-&gt;write_group;</span><br><span class="line">  <span class="keyword">if</span> (!w-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(write_group-&gt;leader-&gt;StateMutex())</span></span>;</span><br><span class="line">    write_group-&gt;status = w-&gt;status;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (write_group-&gt;running-- &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// we&#x27;re not the last one</span></span><br><span class="line">    <span class="built_in">AwaitState</span>(w, STATE_COMPLETED, &amp;cpmtw_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// else we&#x27;re the last parallel worker and should perform exit duties.</span></span><br><span class="line">  w-&gt;status = write_group-&gt;status;</span><br><span class="line">  <span class="comment">// Callers of this function must ensure w-&gt;status is checked.</span></span><br><span class="line">  write_group-&gt;status.<span class="built_in">PermitUncheckedError</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ExitAsMemTableWriter"><a href="#ExitAsMemTableWriter" class="headerlink" title="ExitAsMemTableWriter"></a>ExitAsMemTableWriter</h4><p><code>ExitAsMemTableWriter</code> 函数和 <code>ExitAsBatchGroupLeader</code> 函数类似，主要有两个作用：</p><ul><li><p>选出下一轮 memtable_write_group1 的的 leader-memtable-writer，将其 state 设置为 <code>STATE_MEMTABLE_WRITER_LEADER</code>，使下一轮 memtable_write_group1 能尽快进入 T3 阶段；</p></li><li><p>将本轮 memtable_write_group0 的所有 memtable-writers 的状态更改为 <code>STATE_COMPLETED</code>，解除阻塞在 <code>CompleteParallelMemTableWriter</code> 函数处阻塞的 writers，让他们释放资源返回应用层。</p><p>这里需要让 leader-memtable-writer 最后一个退出，因为它拥有 memtable_write_group 所有权：如果它不是最后一个释放，会造成 <code>ExitAsMemTableWriter</code> 函数在执行过程中 coredump。</p></li></ul><p>这部分代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::ExitAsMemTableWriter</span><span class="params">(Writer* <span class="comment">/*self*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                       WriteGroup&amp; write_group)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. </span></span><br><span class="line">  Writer* newest_writer = last_writer;</span><br><span class="line">  <span class="keyword">if</span> (!newest_memtable_writer_.<span class="built_in">compare_exchange_strong</span>(newest_writer,</span><br><span class="line">                                                       <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">    <span class="built_in">CreateMissingNewerLinks</span>(newest_writer);</span><br><span class="line">    Writer* next_leader = last_writer-&gt;link_newer;</span><br><span class="line">    <span class="built_in">assert</span>(next_leader != <span class="literal">nullptr</span>);</span><br><span class="line">    next_leader-&gt;link_older = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">SetState</span>(next_leader, STATE_MEMTABLE_WRITER_LEADER);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 2.</span></span><br><span class="line">  Writer* w = leader;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!write_group.status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      w-&gt;status = write_group.status;</span><br><span class="line">    &#125;</span><br><span class="line">    Writer* next = w-&gt;link_newer;</span><br><span class="line">    <span class="keyword">if</span> (w != leader) &#123;</span><br><span class="line">      <span class="built_in">SetState</span>(w, STATE_COMPLETED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (w == last_writer) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(next);</span><br><span class="line">    w = next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//! Note that leader has to exit last, since it owns the write group.</span></span><br><span class="line">  <span class="built_in">SetState</span>(leader, STATE_COMPLETED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在前面几篇讲解了从 WriteBatch 的内部序列化流程 和 WriteThread 如何控制并发写入的基本流程，本文进一步讲解 WriteThread 如何使用 PipelinedWrite 来提升写吞吐，其中和前文相似的逻辑不再细说。&lt;/p&gt;
&lt;p&gt;通过设置选项 &lt;c</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>WriteThread 如何控制并发写入流程</title>
    <link href="https://szza.github.io/2022/01/12/rocksdb/WritePath/write_thread_3/"/>
    <id>https://szza.github.io/2022/01/12/rocksdb/WritePath/write_thread_3/</id>
    <published>2022-01-12T06:15:35.000Z</published>
    <updated>2023-08-01T02:21:19.684Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>ROCKSDB_NAMESPACE::WriteThread</code> 中，通过 <a href="https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d2b39/db/write_thread.cc#L64">WriteThread::AwaitState</a> 和 <a href="https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d2b39/db/write_thread.cc#L212">WriteThread::SetState</a> 两个函数来 writers 的控制并发写入行为。 这一期主要来分析 RocksDB 中 WriteThread::AwaitState 中的优化，是如何尽可能地缩短阻塞等待时间。</p><h2 id="WriteThread-AwaitState"><a href="#WriteThread-AwaitState" class="headerlink" title="WriteThread::AwaitState"></a>WriteThread::AwaitState</h2><p><code>AwaitState</code> 函数用于阻塞等待直到满足 <code>w-&gt;state &amp; goal_mask != 0</code> 这一条件。如 <a href="https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d2b39/db/write_thread.cc#L401">JoinBatchGroup</a> 函数中新插入的 w 需要阻塞等待 <code>w-&gt;state</code> 变成 <code>goal_mask</code> 中的一种才能继续执行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::JoinBatchGroup</span><span class="params">(Writer* w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//... above code</span></span><br><span class="line">    <span class="keyword">if</span> (!linked_as_leader) &#123; </span><br><span class="line">        <span class="built_in">AwaitState</span>(</span><br><span class="line">            w,</span><br><span class="line">            <span class="comment">// goal_mask</span></span><br><span class="line">            STATE_GROUP_LEADER | </span><br><span class="line">            STATE_MEMTABLE_WRITER_LEADER |</span><br><span class="line">            STATE_PARALLEL_MEMTABLE_WRITER | </span><br><span class="line">            STATE_COMPLETED,</span><br><span class="line">            &amp;jbg_ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RocksDB 为尽可能降低阻塞时间，将等待情况分为三种:</p><ul><li><em>short-uncontended</em>: 几乎无竞争，直接使用 <code>spin-wait loop</code> 就能解决；</li><li><em>short-contended</em>: 存在竞争，但是预测阻塞时间不会太久，使用 <code>loop + yield</code> 应对</li><li><em>long</em>: 竞争激烈，使用 <code>mutex + condition_variable</code> 应对。</li></ul><p>如果开启了上帝视角，即事先知道本次 <em>AwaitState</em> 要等待的时间，就可以直接使用 <code>spin-wait loop</code>  来应对 short-uncontended, <code>mutex</code> 来应对 long。显然没有这样的上帝视角，那么就只能通过一种自适应的方式来判断了。</p><h3 id="pause-based-spin-wait-loop"><a href="#pause-based-spin-wait-loop" class="headerlink" title="pause-based spin-wait loop"></a><a href="https://stackoverflow.com/questions/12894078/what-is-the-purpose-of-the-pause-instruction-in-x86">pause-based spin-wait loop</a></h3><p><code>spin-wait loop</code> 是应对阻塞时间很短 (short-periods) 场景的常用方式，即占据着 CPU 做空转阻塞等待 <code>w-&gt;state</code> 变成预期值，这样可以减少线程上下文切换（context switch）带来的开销。如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123; </span><br><span class="line">    <span class="type">uint8_t</span> state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquired);</span><br><span class="line">    <span class="keyword">if</span> (state &amp; goal_mask != <span class="number">0</span>) &#123; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这么简单的写法却有问题，一般都会在 spin-wait loop 中加上一条 “<em>Pause</em>“ 指令来提升性能。在 <a href="https://www.felixcloutier.com/x86/pause">Pause</a> 指令中有这么一段描述：</p><blockquote><p>When executing a ‘spin-wait loop’, processors will suffer a severe performance penalty when exiting the loop because it detects a <code>possible memory order violation</code></p></blockquote><p>意思就是说，如果 spin-wait loop 里如果不加上 <em>Pause</em> 指令，则很可能因为 memory order violation 问题导致退出 loop 时遭受严重的性能惩罚</p><h4 id="memory-order-violation"><a href="#memory-order-violation" class="headerlink" title="memory order violation"></a>memory order violation</h4><p>如下从 <a href="https://cdrdv2-public.intel.com/671488/248966-Software-Optimization-Manual-R047.pdf">Intel 64 and IA-32 Architectures Optimization Reference Manual</a> 中选取的示例代码，来解释为什么退出loop时会带来性能惩罚。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Spin_Lock:</span><br><span class="line">    CMP lockvar, <span class="number">0</span>;       <span class="comment">// (1) Check if lock is free.</span></span><br><span class="line">    JE Get_Lock;          <span class="comment">// (1.1) lockvar == 0</span></span><br><span class="line">    JMP Spin_Lock;        <span class="comment">// (1.2) lockvar != 0</span></span><br><span class="line">Get_Lock:</span><br><span class="line">    MOV EAX, <span class="number">1</span>;</span><br><span class="line">    XCHG EAX, lockvar;    <span class="comment">// (2) Try to get lock</span></span><br><span class="line">    CMP EAX, <span class="number">0</span>;           <span class="comment">// (3) Test if successful.</span></span><br><span class="line">    JNE Spin_Lock;</span><br><span class="line">Critical_Section:</span><br><span class="line">    <span class="comment">// critical section cod&gt;</span></span><br><span class="line">    MOV lockvar, <span class="number">0</span>;      <span class="comment">// (4) Release lock</span></span><br></pre></td></tr></table></figure><p>当线程 T1 spin-wait loop 几轮迭代后，条件分支(1)处一直都是 false，即 <code>lockvar</code> 一直不是 0。这种情况下，CPU 的分支预测器会认为条件(1) 永远不会为 true，就会将 JMP(1.2) 的指令填充整个 pipeline。</p><p>当线程 T2 将 <code>lockvar</code>  写为 0 时，由于此时 T1 的 <em>pipeline</em> 已经被错误的预测指令 (1.2) 填充满，即(1) 处的 <code>lockvar</code>  已经预测为0。这时 <em>memory order violation</em> 就会发生了：T1 线程看到 T2 线程对 <code>lockvar</code>  的修改后，就会在 T1 的 pipeline 中搜索访问了 <code>lockvar</code>  变量且还没执行的预测指令（1.2），如果发现了则会使得这部分预测指令失效，并且 flush pipeline 来删除这部分预测指令。获取锁后，就会退出 spin-wait loop。</p><p>在退出时 flush pipeline 的代价会很高。</p><p>因此，每次进入 spin-wait loop ，就会在满足条件退出 spin-wait loop 时带来严重的性能惩罚，比预期的同步时间要久。</p><p>加上 <em>PAUSE</em> 指令，是通过引入轻微的延迟来 <code>de-pipelined</code>，使得 pipeline 中不会填充错误的预测指令: 插入 PAUSE 指令后，会等待 PAUSE 之前的 pipeline 执行完变空，然后再执行下一轮 CMP，如果 T2 线程将 lockvar 的值为 0，则 T1 能立即检测到。因此现在 CMP 指令就是顺序执行，消除了预测。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Spin_Lock:</span><br><span class="line">    CMP lockvar, <span class="number">0</span>;       <span class="comment">// (1) Check if lock is free.</span></span><br><span class="line">    JE Get_Lock</span><br><span class="line">        PAUSE;            <span class="comment">// (2) short a delay, wait for memory pipeline to become empty</span></span><br><span class="line">    JMP Spin_Lock;</span><br><span class="line">Get_Lock:</span><br></pre></td></tr></table></figure><p>从使用角度来说，”PAUSE” 指令<em>甚至是专门</em>用于优化 spin-wait loop 的，需要搭配使用。</p><p>而 RocksDB 进入 <em>AwaitState</em> 后率先使用 <code>spin-wait loop</code> 迭代两百次(大约 1us)来尝试满足 short-uncontended 场景。原生代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">AwaitState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> goal_mask, AdaptationContext* ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> tries = <span class="number">0</span>; tries &lt; <span class="number">200</span>; ++tries) &#123;</span><br><span class="line">        state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span> ((state &amp; goal_mask) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line">        port::<span class="built_in">AsmVolatilePause</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">````</span><br><span class="line">由于 <span class="string">&quot;PAUSE&quot;</span> 指令随着架构的变化，latency 也会更改，甚至差一个数量级，故而这里如果想要更准确的控制 wait 的时间可以使用 `__rdtsc()` 函数来控制:</span><br><span class="line">```cpp</span><br><span class="line">    <span class="comment">// __rdtsc intrinsic is used to read the time stamp counter</span></span><br><span class="line">    <span class="comment">// This allows the loop to run for a fixed number of cycles</span></span><br><span class="line">    <span class="type">uint64_t</span> prev = __rdtsc();</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">        <span class="keyword">if</span> ((state &amp; goal_mask) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line">        port::<span class="built_in">AsmVolatilePause</span>();</span><br><span class="line">    &#125; <span class="keyword">while</span> (__rdtsc() - prev &lt; max_spin_time);</span><br></pre></td></tr></table></figure><h3 id="std-this-thread-yield"><a href="#std-this-thread-yield" class="headerlink" title="std::this_thread::yield"></a>std::this_thread::yield</h3><p>如果第一阶段的 spin-wait loop 没能等到 <code>w-&gt;state</code> 的值变更为预期值，说明还是存在竞争，则进入第二阶段 <code>short-contended</code>。 这一阶段由 <code>DBOptions::enable_write_thread_adaptive_yield</code> 配置是否开启，默认值为 true。</p><p>这一段有两个问题:</p><ul><li>如何从 <code>short-contended</code> 阶段进入 <code>long</code> 阶段</li><li>如何判断下一次是否需要再进入 <code>short-contended</code> 阶段</li></ul><p>当进入 <code>short-contended</code> 阶段说明存在竞争，<em>但是假设竞争可能不大</em>。比如线程数可能不超过 CPU cores 数目，这种情况下使用 <code>std::thread::yield()</code> 并不会导致 cotext switch，效果比 pthread_mutex 要好。</p><blockquote><p>注意：从 RocksDB 开发者角度，没有上帝视角，只能先假设没有竞争（short-uncontended），不满足则再假设存在竞争但是不激烈（<code>short-contended</code>），如果还没不满足再考虑mutex阻塞。</p></blockquote><p>因此，需要对调用 <code>std::thread::yield()</code> 前后的 latency 进行统计，粗略判断竞争激烈程度：</p><ul><li><p><code>max_yield_usec_</code>: 默认 100us，控制 <code>short-contended</code> 阶段最大等待时间</p></li><li><p><code>slow_yield_usec_</code>: 默认 3us, 是 <code>yield</code> 的 latency 上限，用来反应是否有其他线程也想占据当前 cpu core</p><p>如果当前竞争比较激烈，那么调用 <code>std::thread::yield()</code> 前后的 latency 肯定会增加，(比如 threads &gt; cpu-cores 时，甚至会产生 context switch），最终导致 latency &gt; <code>slow_yield_usec_</code>。如果累计 <code>kMaxSlowYieldsWhileSpinning = 3</code> 次都超过该值，则可以跳出 <code>short-contended</code> 阶段，直接进入 <code>long</code> 阶段，阻塞等待。</p></li></ul><p>开启第二阶段的开关有3个，这一部分代码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> would_spin_again = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> update_ctx = <span class="literal">false</span>;</span><br><span class="line"><span class="type">uint64_t</span> sampling_base = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">if</span> (max_yield_usec_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  update_ctx = Random::<span class="built_in">GetTLSInstance</span>()-&gt;<span class="built_in">OneIn</span>(sampling_base);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (update_ctx || yield_credit.<span class="built_in">load</span>(std::memory_order_relaxed) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// short-contended code...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>max_yield_usec_ &gt; 0</code>: 默认情况下总是开启</p></li><li><p><code>update_ctx</code>: 表示是否更新 <code>yield_credit</code> 的值。当且仅当基于均匀分布从 <em>[0, 255]</em> 区间获得 0 时值为 true，即 <code>Random::OneIn(sampling_base)</code> 返回 true 的概率为 <em>1/256</em></p><p>  <em>would_spin_again</em> 表示 <code>w-&gt;state</code> 是否在第二阶段等到预期值，如果成功则 <code>yield_credit</code> 值增加，反之降低。<code>yield_credit</code> 的更新公式如下：</p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (update_ctx) &#123;</span><br><span class="line">   <span class="keyword">auto</span> v = yield_credit.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">   v = v - (v / <span class="number">1024</span>) + (would_spin_again ? <span class="number">1</span> : <span class="number">-1</span>) * <span class="number">131072</span>;</span><br><span class="line">   yield_credit.<span class="built_in">store</span>(v, std::memory_order_relaxed);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>yield_credit</code>: 默认值为 0，在是否开启第二阶段中起着决定性作用。基本上需要满足 <code>yield_credit &gt;= 0</code> 才能进入第二阶段</p><p>  <em>yield_credit</em> 值在两种情况下会更改，也是<strong>自适应</strong>原理：</p><p>  1）进入了第二阶段，但是因为竞争太激烈，没有在第二阶段实现 <code>w-&gt;state &amp; goal_mask != 0</code>，此时会将 update_ctx = true，再由上述公式降低 <em>yield_credit</em> 的值，使其小于 0，这样 AwaitState 函数下次不会再进入第二阶段；</p><ol start="2"><li>如果长时间 <code>yield_credit &lt; 0</code> 会一直无法进入第二阶段。但是由均匀分布可知，存在 1/256 的概率将 update_ctx = true，进入第二阶段，来<em>试探</em>现在竞争是否没那么激烈了。如果此时在第二阶段等到了 <code>w-&gt;state &amp; goal_mask != 0</code> ，那么就会再根据上述公式将 <code>yield_credit</code> 调节为非负数，使得下一次 AwaitState 函数仍能进入第二阶段。</li></ol></li></ul><p>这里的 <code>yield_credit</code> 值记录在 <code>AdaptationContext::value</code> 中，<code>AdaptationContext</code> 的所有对象在 <code>WriteThread</code> 中都是 static 变量，因此会一直反应着进程生命周期中线程竞争状态，故而上述的 <code>update_ctx</code> 中的 <code>ctx</code> 即 <code>yield_credit</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AdaptationContext</span> &#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">  std::atomic&lt;<span class="type">int32_t</span>&gt; value;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AdaptationContext</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name0)</span> : name(name0), value(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的介绍大致介绍了 <code>short-contended</code> 阶段的自适应原理，下面来看看核心代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>&amp; yield_credit = ctx-&gt;value;</span><br><span class="line"><span class="type">bool</span> update_ctx = <span class="literal">false</span>;</span><br><span class="line"><span class="type">bool</span> would_spin_again = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (update_ctx || yield_credit.<span class="built_in">load</span>(std::memory_order_relaxed) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="keyword">auto</span> spin_begin = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超过 slow_yield_usec_ 的次数</span></span><br><span class="line">  <span class="type">size_t</span> slow_yield_count = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> iter_begin = spin_begin;</span><br><span class="line">  <span class="comment">// 最多消耗的时间片: max_yield_usec_</span></span><br><span class="line">  <span class="keyword">while</span> (iter_begin - spin_begin) &lt;= </span><br><span class="line">            std::chrono::<span class="built_in">microseconds</span>(max_yield_usec_) &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line"></span><br><span class="line">    state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> ((state &amp; goal_mask) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 1. 成功，则退出第二阶段</span></span><br><span class="line">      would_spin_again = <span class="literal">true</span>; </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> now = std::chrono::steady_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="comment">// 2. latency 超过 slow_yield_usec_</span></span><br><span class="line">    <span class="keyword">if</span> (now == iter_begin ||</span><br><span class="line">        now - iter_begin &gt;= std::chrono::<span class="built_in">microseconds</span>(slow_yield_usec_)) &#123;</span><br><span class="line">      ++slow_yield_count;</span><br><span class="line">      <span class="comment">// 2.1 累计超过 kMaxSlowYieldsWhileSpinning 次则退出第二阶段，</span></span><br><span class="line">      <span class="comment">//     并设置 update_ctx =true，后续更新 yield_credit</span></span><br><span class="line">      <span class="keyword">if</span> (slow_yield_count &gt;= kMaxSlowYieldsWhileSpinning) &#123;</span><br><span class="line">        update_ctx = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    iter_begin = now;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BlockingAwaitState"><a href="#BlockingAwaitState" class="headerlink" title="BlockingAwaitState"></a>BlockingAwaitState</h3><p>如果不幸，<code>w-&gt;state</code> 的值仍然没有变更为预期值，则需要进入第三阶段：使用 Mutex + ConditionVarable 进行阻塞等待。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((state &amp; goal_mask) == <span class="number">0</span>) &#123;</span><br><span class="line">  state = <span class="built_in">BlockingAwaitState</span>(w, goal_mask);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlockingAwaitState</code> 函数比较简单：先再次判断 <code>w-&gt;state</code> 是否变更为预期值 <code>goal_mask</code>； 没有，则将 w-&gt;state 设置为 <code>STATE_LOCKED_WAITING</code> 状态，等待唤醒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">WriteThread::BlockingAwaitState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> goal_mask)</span> </span>&#123;</span><br><span class="line">  w-&gt;<span class="built_in">CreateMutex</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="built_in">assert</span>(state != STATE_LOCKED_WAITING);</span><br><span class="line">  <span class="keyword">if</span> ((state &amp; goal_mask) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      w-&gt;state.<span class="built_in">compare_exchange_strong</span>(state, STATE_LOCKED_WAITING)) &#123;</span><br><span class="line">    <span class="comment">// we have permission (and an obligation) to use StateMutex</span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(w-&gt;StateMutex())</span></span>;</span><br><span class="line">    w-&gt;<span class="built_in">StateCV</span>().<span class="built_in">wait</span>(guard, [w] &#123;</span><br><span class="line">      <span class="keyword">return</span> w-&gt;state.<span class="built_in">load</span>(std::memory_order_relaxed) != STATE_LOCKED_WAITING;</span><br><span class="line">    &#125;);</span><br><span class="line">    state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// else tricky.  Goal is met or CAS failed.  In the latter case the waker</span></span><br><span class="line">  <span class="comment">// must have changed the state, and compare_exchange_strong has updated</span></span><br><span class="line">  <span class="comment">// our local variable with the new one.  At the moment WriteThread never</span></span><br><span class="line">  <span class="comment">// waits for a transition across intermediate states, so we know that</span></span><br><span class="line">  <span class="comment">// since a state change has occurred the goal must have been met</span></span><br><span class="line">  <span class="built_in">assert</span>((state &amp; goal_mask) != <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="WriteThread-SetState"><a href="#WriteThread-SetState" class="headerlink" title="WriteThread::SetState"></a>WriteThread::SetState</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::SetState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> new_state)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(w);</span><br><span class="line">  <span class="keyword">auto</span> state = w-&gt;state.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span> (state == STATE_LOCKED_WAITING ||</span><br><span class="line">      !w-&gt;state.<span class="built_in">compare_exchange_strong</span>(state, new_state)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(state == STATE_LOCKED_WAITING);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(w-&gt;StateMutex())</span></span>;</span><br><span class="line">    <span class="built_in">assert</span>(w-&gt;state.<span class="built_in">load</span>(std::memory_order_relaxed) != new_state);</span><br><span class="line">    w-&gt;state.<span class="built_in">store</span>(new_state, std::memory_order_relaxed);</span><br><span class="line">    w-&gt;<span class="built_in">StateCV</span>().<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 &lt;code&gt;ROCKSDB_NAMESPACE::WriteThread&lt;/code&gt; 中，通过 &lt;a href=&quot;https://github.com/facebook/rocksdb/blob/749b179c041347d150fa6721992ae8398b7d</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>WriteThread 如何自适应优化线程同步</title>
    <link href="https://szza.github.io/2022/01/11/rocksdb/WritePath/write_thread_2/"/>
    <id>https://szza.github.io/2022/01/11/rocksdb/WritePath/write_thread_2/</id>
    <published>2022-01-11T06:15:35.000Z</published>
    <updated>2023-08-01T02:21:14.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>建议先阅读上一篇文章 <a href="./WAL_1.md">WriteBatch 写入前的准备工作</a> 了解一些基本概念</p></blockquote><p>本篇博客讲解批量写流程的控制流程，了解这个流程之后再来讲解 <em>PipelineWriteImpl</em> 中优化。</p><p>整个写入流程大致如下：</p><h3 id="WriteThread-JoinBatchGroup"><a href="#WriteThread-JoinBatchGroup" class="headerlink" title="WriteThread::JoinBatchGroup"></a>WriteThread::JoinBatchGroup</h3><p><code>JoinBatchGroup</code> 函数充当着锁的作用：能成为 leader 的 writer 才能真正执行 <code>WriteToWAL</code> 和 <code>MemTable::Add</code> 操作，其他 writers 只能阻塞等待 leader-writer 完成。</p><p>在 <code>WriteThread</code> 中有个 <code>newest_writer_</code> 字段总是指向最新插入的 <code>Writer</code> 对象：</p><ol><li>如果新插入一个 <code>Writer</code> 对象 w，则会尝试让 <code>newest_writer_</code> 指向该 w 。如果当前触发了 <em>WriteStall</em> 则会等待 <code>WriteStall</code> 被解除，才会再次尝试让 <code>newest_writer_</code> 指向该 w</li><li>如果 w 插入时，<code>newest_writer_ == NULL</code> ，则 w 能顺利通过 <code>JoinBatchGroup</code> 函数，进入后续写入流程</li><li>否则，说明当前已经存在 leader-writer，则只能阻塞等待 <code>w-&gt;state</code> 更改为下面其中一种才能解除阻塞:<ul><li><p><code>STATE_GROUP_LEADER</code>: 变成下一个 write_group 的 leader，执行写入</p></li><li><p><code>STATE_COMPLETED</code>: 说明已经存在一个 leader-writer 替自己完成了写入，解除阻塞后就可以直接返回应用层</p></li><li><p><code>STATE_MEMTABLE_WRITER_LEADER</code>: …</p></li><li><p><code>STATE_PARALLEL_MEMTABLE_WRITER</code>: …</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::JoinBatchGroup</span><span class="params">(Writer* w)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(w-&gt;batch != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 1. 让 nnewest_writer_ 指向 w</span></span><br><span class="line">  <span class="type">bool</span> linked_as_leader = <span class="built_in">LinkOne</span>(w, &amp;newest_writer_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (linked_as_leader) &#123;</span><br><span class="line">    <span class="built_in">SetState</span>(w, STATE_GROUP_LEADER);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!linked_as_leader) &#123;</span><br><span class="line">     <span class="comment">// 2. 阻塞等待 w-&gt;state &amp; mask != 0</span></span><br><span class="line">    <span class="built_in">AwaitState</span>(w,</span><br><span class="line">               STATE_GROUP_LEADER | STATE_MEMTABLE_WRITER_LEADER |</span><br><span class="line">                   STATE_PARALLEL_MEMTABLE_WRITER | STATE_COMPLETED,</span><br><span class="line">               &amp;jbg_ctx);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteThread-LinkOne"><a href="#WriteThread-LinkOne" class="headerlink" title="WriteThread::LinkOne"></a>WriteThread::LinkOne</h3><p><code>LinkOne</code>的功能其实就是在链表头发插入一个节点，不过需要先检查一个前提 <em>WriteStall</em>。</p></li></ul></li></ol><h4 id="WriteStall"><a href="#WriteStall" class="headerlink" title="WriteStall"></a>WriteStall</h4><p>如果写操作触发了 <em>WriteStall</em> ，会向 WriterThread 中写入一个 <code>write_stall_dummy_</code> 标志。因此在尝试将 <code>newest_writer_</code> 指向新加入的 <code>w</code> 时都需要先检查下 <code>newest_writer_</code> 是否等于 <code>write_stall_dummy_</code>。如果等于，有以下两种情况：</p><ul><li><p><code>Writer::no_slowdown == false</code>，这是默认情况，即基于条件变量 <code>stall_cv_</code> 阻塞等待 <em>WriteStall</em> 解除。解除后则需要重新读取 <code>newest_writer_</code></p><p>条件变量一般配合 while 一起使用，防止虚假唤醒，因此 <code>stall_cv_</code> 被唤醒后会 <em>continue</em> 并进行下一轮 while 循环，确认 <code>newest_writer_</code> 不是 <code>write_stall_dummy_</code> 才能继续下一步。</p></li><li><p><code>Writer::no_slowdown == true</code>，此时将错误 <code>Status::Incomplete</code> 返回给上层应用，让其自行决定如何处理 <code>WriteStall</code>，这就类似网络编程的非阻塞行为。</p></li></ul><h4 id="compare-exchange-weak"><a href="#compare-exchange-weak" class="headerlink" title="compare_exchange_weak"></a>compare_exchange_weak</h4><p>当没有 <em>WriteStall</em> 或者有已经解除，则可以继续写入，将 <code>w-&gt;link_older = writers</code>。这里的 <code>link_older</code> 的语义其实就是 <code>next</code> 指针，效果即 <code>w-&gt;next = writers</code>。</p><p>完成这一步后 <font color=red> 却并没有执行 writers-&gt;prev = w 操作</font>，为什么呢？这是为了在 leader-writer 写流程结束时能通过 <code>link_newer/prev</code> 是否为 NULL 选出下一轮的 leader-writer，详见后文的 <code>ExitAsBatchGroupLeader</code> 函数。</p><p>再通过 <code>compare_exchange_weak</code> 操作将 <code>newest_writer_</code> 指向最新插入的 w，</p><ul><li><p>成功，则通过判断 <code>writers</code> 是否为 NULL，来判断 w 是不是下一轮 writer_group 的 leader-writer </p><p>这是因为上一个 write_group 完成后就会尝试将 <code>newest_writer_</code> 设置为 NULL，只需要通过判断 <code>writers ==  NULL</code> 就可以确定新插入的 w 是不是下一轮 write_group 的 leader。</p></li><li><p>失败，则说明有个并发 <code>w0</code> 在自己之前完成了 <code>compare_exchange_weak</code> 操作，则自己会在下一轮 while 循环中完成此操作，使得 <code>newest_writer_</code> 指向 w，并形成 <code>w-&gt;next = w0</code> 连接。</p></li></ul><p>每次有新的 w，都只是改变 <code>newest_writer_</code>，并通过 <code>link_older/next</code> 指针把所有插入的 writers 串联起来，<em>且不重不漏</em>。由于每次只有 leader-writer 具有写权限，再让 leader-writer 在将所有的 writers 打包成一个 writer_group 时，给缺失的 <code>link_newer/prev</code> 指针赋值，就完成了双链表创建。由于此时实际上已经是单线程操作，因此不需要借助任何同步措施也没有并发的风险。</p><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WriteThread::LinkOne</span><span class="params">(Writer* w, std::atomic&lt;Writer*&gt;* newest_writer)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(newest_writer != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(w-&gt;state == STATE_INIT);</span><br><span class="line">  Writer* writers = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(writers != w);</span><br><span class="line">    <span class="keyword">if</span> (writers == &amp;write_stall_dummy_) &#123;</span><br><span class="line">      <span class="keyword">if</span> (w-&gt;no_slowdown) &#123;</span><br><span class="line">        w-&gt;status = Status::<span class="built_in">Incomplete</span>(<span class="string">&quot;Write stall&quot;</span>);</span><br><span class="line">        <span class="built_in">SetState</span>(w, STATE_COMPLETED);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="function">MutexLock <span class="title">lock</span><span class="params">(&amp;stall_mu_)</span></span>;</span><br><span class="line">        writers = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (writers == &amp;write_stall_dummy_) &#123;</span><br><span class="line">          stall_cv_.<span class="built_in">Wait</span>();</span><br><span class="line">          <span class="comment">// Load newest_writers_ again since it may have changed</span></span><br><span class="line">          writers = newest_writer-&gt;<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    w-&gt;link_older = writers;</span><br><span class="line">    <span class="keyword">if</span> (newest_writer-&gt;<span class="built_in">compare_exchange_weak</span>(writers, w)) &#123;</span><br><span class="line">      <span class="keyword">return</span> (writers == <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteThread-AwaitState"><a href="#WriteThread-AwaitState" class="headerlink" title="WriteThread::AwaitState"></a>WriteThread::AwaitState</h4><p><code>WriteThread::AwaitState</code> 中的优化点较多，下一期单独开一篇讲解这里的优化。这个函数的作用是阻塞等待直到满足 <code>w-&gt;state &amp; goal_mask != 0</code>。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">uint8_t</span> <span class="title">AwaitState</span><span class="params">(Writer* w, <span class="type">uint8_t</span> goal_mask, AdaptationContext* ctx)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="WriteThread-CreateMissingNewerLinks"><a href="#WriteThread-CreateMissingNewerLinks" class="headerlink" title="WriteThread::CreateMissingNewerLinks"></a>WriteThread::CreateMissingNewerLinks</h4><p>缺失的 <code>prev</code> 指针由 <code>CreateMissingNewerLinks</code> 函数补全。</p><p>传入的 <code>head</code> 即 <code>newest_writer_</code> 的值，目前所有待执行的 writers 已经通过 next 指针串联起来了，这里要做的就是将其 prev 指针补全。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::CreateMissingNewerLinks</span><span class="params">(Writer* head)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    Writer* next = head-&gt;link_older;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">nullptr</span> || next-&gt;link_newer != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(next == <span class="literal">nullptr</span> || next-&gt;link_newer == head);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    next-&gt;link_newer = head; <span class="comment">// next-&gt;prev = head;</span></span><br><span class="line">    head = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteThread-EnterAsBatchGroupLeader"><a href="#WriteThread-EnterAsBatchGroupLeader" class="headerlink" title="WriteThread::EnterAsBatchGroupLeader"></a>WriteThread::EnterAsBatchGroupLeader</h3><p>writer 没有阻塞在 <code>WriteThread::JoinBatchGroup</code> 函数，则说明 <code>writer</code> 目前已经成为 leader-writer，则需要由 leader-writer 尝试将目前所有待执行的 writers 封装到一个 write_group 中，这个由 <code>EnterAsBatchGroupLeader</code> 函数完成。</p><p>执行到 <code>EnterAsBatchGroupLeader</code> 函数时，<code>newest_writer_</code> 可能一直在更改，即不断指向最新的 writer。但是没关系，因为此时 leader-writer 已经诞生了，更新的 writer 在执行 <code>WriteThread::JoinBatchGroup</code> 时候会被阻塞在 <code>AwaitState</code>，如果此时 leader-writer 刚好执行到 <code>EnterAsBatchGroupLeader</code> 函数，则会由 leader-writer 将 <em>[leader-writer, newest_writer]</em> 区间的所有 writers 封装到 writer_group 中，由 leader-writer 来统一执行批量写入。其中 <code>write_group-&gt;last_writer</code> 指向的就是当前最新的 newest_writer。</p><p>在上一篇文章，讲解了 <code>WriteGroup</code> 内部封装了迭代器，那么就可以使用如下方式并以 <code>leader_writer -&gt; newst_writer</code> 顺序遍历所有 writers。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> writer : *writer_group) &#123;</span><br><span class="line">  <span class="comment">// 批量写入 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如下4步：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">WriteThread::EnterAsBatchGroupLeader</span><span class="params">(Writer* leader,</span></span></span><br><span class="line"><span class="params"><span class="function">                                            WriteGroup* write_group)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;batch != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(write_group != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> size = WriteBatchInternal::<span class="built_in">ByteSize</span>(leader-&gt;batch);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. write_group 大小限制</span></span><br><span class="line">  <span class="type">size_t</span> max_size = max_write_batch_group_size_bytes;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> min_batch_size_bytes = max_write_batch_group_size_bytes / <span class="number">8</span>;</span><br><span class="line">  <span class="keyword">if</span> (size &lt;= min_batch_size_bytes) &#123;</span><br><span class="line">    max_size = size + min_batch_size_bytes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 初始化 write_group</span></span><br><span class="line">  leader-&gt;write_group = write_group;</span><br><span class="line">  write_group-&gt;leader = leader;</span><br><span class="line">  write_group-&gt;last_writer = leader;</span><br><span class="line">  write_group-&gt;size = <span class="number">1</span>;</span><br><span class="line">  Writer* newest_writer = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 补全 [leader-writer, newest_writer] 丢失的 prev 指针</span></span><br><span class="line">  <span class="built_in">CreateMissingNewerLinks</span>(newest_writer);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 封装到 write_group</span></span><br><span class="line">  Writer* w = leader;</span><br><span class="line">  <span class="keyword">while</span> (w != newest_writer) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(w-&gt;link_newer);</span><br><span class="line">    w = w-&gt;link_newer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... other break conditions</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (size + WriteBatchInternal::<span class="built_in">ByteSize</span>(w-&gt;batch) &gt; max_size) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    w-&gt;write_group = write_group; <span class="comment">// 设置 w 属于当前 write_group</span></span><br><span class="line">    size += batch_size;           <span class="comment">// 这个 write_group 的数据量大小</span></span><br><span class="line">    write_group-&gt;last_writer = w; <span class="comment">// 更新 last_writer</span></span><br><span class="line">    write_group-&gt;size++;          <span class="comment">// writer_group 中 writers 的个数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="WriteThread-ExitAsBatchGroupLeader"><a href="#WriteThread-ExitAsBatchGroupLeader" class="headerlink" title="WriteThread::ExitAsBatchGroupLeader"></a>WriteThread::ExitAsBatchGroupLeader</h3><p>这里暂时不关注 <em>enable_pipelined_write_</em>, 这是开启 <em>PipelineWriteImpl</em> 的标志位。</p><p>当数据都已经写入 WAL 和 MemTable，则会调用 <code>ExitAsBatchGroupLeader</code>，此时需要判断在当前 write_group 写入过程中是否出现了新的 writers：</p><ul><li>是：则需要从等待的 writers 中挑选出<em>新的</em> leader-writer</li><li>否：则需要将 <code>newest_writer_</code> 赋值为 NULL</li></ul><p>需要先读取 <code>newest_writer_</code> 的最新值 <em>head</em>，来判断是否有新的 <code>writer</code> 插入: </p><ul><li><p>如果 <code>head != last_writer</code> 则说明在当前 write_group 写操作过程中有出现新的 writers ，并阻塞等待在 <code>JoinBatchGroup</code></p></li><li><p>如果 <code>head == last_writer</code> 但是 <code>newest_writer_.compare_exchange_strong(head, nullptr)</code> 为 false，则说明在 <code>newest_writer_</code> load <em>之后</em>并在 <code>compare_exchange_strong</code> <em>之前</em> 有新的 writers 出现</p><p>上述两种情况，都需要将 <em>[<code>last_writer</code>, <code>head</code>]</em> 区间所有 writers 缺失的 prev 指针补全，因为补全后 <code>last_writer-&gt;prev</code> 指向的就是新的 leader-writer。</p><p>这是因为 <code>last_writer-&gt;prev</code> 是在 last_writer 之后最早插入的 writer，为保持顺序性，这就是新的 leader-writer。</p></li></ul><p>完成上述操作，剩下的就是将当前 write_group 中的所有 writers 状态更改为 <em>STATE_COMPLETED</em> 解除他们在 <code>JoinBatchGroup</code> 处的阻塞，尽快返回应用层。这一步也有个小细节，见代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteThread::ExitAsBatchGroupLeader</span><span class="params">(WriteGroup&amp; write_group,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         Status&amp; status)</span> </span>&#123;</span><br><span class="line">  Writer* leader = write_group.leader;</span><br><span class="line">  Writer* last_writer = write_group.last_writer;</span><br><span class="line">  <span class="built_in">assert</span>(leader-&gt;link_older == <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (enable_pipelined_write_) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Writer* head = newest_writer_.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (head != last_writer ||</span><br><span class="line">        !newest_writer_.<span class="built_in">compare_exchange_strong</span>(head, <span class="literal">nullptr</span>)) &#123;</span><br><span class="line">      <span class="comment">// 存在新插入的 writer</span></span><br><span class="line">      <span class="built_in">assert</span>(head != last_writer);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 1. 补全 [last_writer, head] 的 prev指针</span></span><br><span class="line">      <span class="built_in">CreateMissingNewerLinks</span>(head);</span><br><span class="line">      <span class="built_in">assert</span>(last_writer-&gt;link_newer != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="built_in">assert</span>(last_writer-&gt;link_newer-&gt;link_older == last_writer);</span><br><span class="line">      <span class="comment">// 2. 断开链表</span></span><br><span class="line">      last_writer-&gt;link_newer-&gt;link_older = <span class="literal">nullptr</span>; </span><br><span class="line"></span><br><span class="line">      <span class="comment">// 3. 设置新的 leader-writer</span></span><br><span class="line">      <span class="built_in">SetState</span>(last_writer-&gt;link_newer, STATE_GROUP_LEADER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 将 [leader, last_writer] 区间的 writers 状态设置为 STATE_COMPLETED</span></span><br><span class="line">    <span class="comment">//    即解除阻塞，让 follower-writer 返回应用层</span></span><br><span class="line">    <span class="keyword">while</span> (last_writer != leader) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(last_writer);</span><br><span class="line">      last_writer-&gt;status = status;</span><br><span class="line">      <span class="comment">// 需要先获取 next指针，再更改状态为 STATE_COMPLETED</span></span><br><span class="line">      <span class="comment">// 因为先更改 STATE_COMPLETED 很可能导致 last_writer 就被正在阻塞的线程销毁了</span></span><br><span class="line">      <span class="comment">// 再获取 next 指针就会触发 coredump</span></span><br><span class="line">      <span class="keyword">auto</span> next = last_writer-&gt;link_older;</span><br><span class="line">      <span class="built_in">SetState</span>(last_writer, STATE_COMPLETED); <span class="comment">// 解除阻塞</span></span><br><span class="line"></span><br><span class="line">      last_writer = next;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="By-the-Way"><a href="#By-the-Way" class="headerlink" title="By the Way"></a>By the Way</h3><ul><li>这篇文章里面用了许多原子操作以及一些内存序，诸如 <code>compare_exchange_strong/compare_exchange_weak</code> 区别，<code>acquire/release</code>语义，等后面有空再单独讲解下这个问题。</li><li>欢迎点赞转发，有问题后台交流</li></ul><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;建议先阅读上一篇文章 &lt;a href=&quot;./WAL_1.md&quot;&gt;WriteBatch 写入前的准备工作&lt;/a&gt; 了解一些基本概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇博客讲解批量写流程的控制流程，了解这个流程之后再来讲解 &lt;em&gt;Pipe</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>WriteBatch 写入前的准备工作</title>
    <link href="https://szza.github.io/2022/01/10/rocksdb/WritePath/write_thread_1/"/>
    <id>https://szza.github.io/2022/01/10/rocksdb/WritePath/write_thread_1/</id>
    <published>2022-01-10T06:15:35.000Z</published>
    <updated>2023-08-01T02:21:03.536Z</updated>
    
    <content type="html"><![CDATA[<h2 id="WriteBatch"><a href="#WriteBatch" class="headerlink" title="WriteBatch"></a>WriteBatch</h2><blockquote><p>无论 <code>Put/Delete/DeleteRange</code> 都是向 RocksDB 插入一对 {key, value}，在不至于引起误解的前提下，下面不加以区分地统一表述为 <strong>写入</strong> 操作</p></blockquote><p>写入一条 <code>&#123;key, value&#125;</code> 数据需要先在 <em>WriteBatch</em> 内部序列化到 <code>WriteBatch::rep_</code>字段中。其整体格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实时上是一行连续存储，为便于阅读多行显示</span></span><br><span class="line">  |sequence|count|</span><br><span class="line">  |serialized-kv-1|</span><br><span class="line">  |serialized-kv-2|</span><br></pre></td></tr></table></figure><p><code>WriteBatch::rep_</code> 在首部需要 <code>KHeader=12</code> 个字节存储本次 <code>writer_batch</code> 的元数据信息:</p><ul><li><code>sequence: uint64_t</code>: 8个字节，类似主键 id，记录的是当前 write_batch 是自从 RocksDB 创建以来第几个 write_batch。即便 RocksDB 挂了重启也不会更改，只会单增；</li><li><code>count: uint32_t</code>: 4个字节，记录本次 write_batch 写入了多少个 <code>&#123;key, value&#125;</code>，每次写入一条数据就会递增一次。下面的<code>Put</code> 案例操作可见。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  WriteBatch::<span class="built_in">WriteBatch</span>(<span class="type">size_t</span> reserved_bytes, <span class="type">size_t</span> max_bytes,</span><br><span class="line">                         <span class="type">size_t</span> protection_bytes_per_key, <span class="type">size_t</span> default_cf_ts_sz)</span><br><span class="line">    : <span class="built_in">content_flags_</span>(<span class="number">0</span>),</span><br><span class="line">      <span class="built_in">max_bytes_</span>(max_bytes),</span><br><span class="line">      <span class="built_in">default_cf_ts_sz_</span>(default_cf_ts_sz) &#123;</span><br><span class="line">    rep_.<span class="built_in">reserve</span>((reserved_bytes &gt; WriteBatchInternal::kHeader)</span><br><span class="line">                   ? reserved_bytes</span><br><span class="line">                   : WriteBatchInternal::kHeader);</span><br><span class="line">    rep_.<span class="built_in">resize</span>(WriteBatchInternal::kHeader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>元信息 <code>sequence/count</code> 的 <em>setter</em>/<em>getter</em> 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SequenceNumber <span class="title">WriteBatchInternal::Sequence</span><span class="params">(<span class="type">const</span> WriteBatch* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">SequenceNumber</span>(<span class="built_in">DecodeFixed64</span>(b-&gt;rep_.<span class="built_in">data</span>()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::SetSequence</span><span class="params">(WriteBatch* b, SequenceNumber seq)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">EncodeFixed64</span>(&amp;b-&gt;rep_[<span class="number">0</span>], seq);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">uint32_t</span> <span class="title">WriteBatchInternal::Count</span><span class="params">(<span class="type">const</span> WriteBatch* b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">DecodeFixed32</span>(b-&gt;rep_.<span class="built_in">data</span>() + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteBatchInternal::SetCount</span><span class="params">(WriteBatch* b, <span class="type">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">EncodeFixed32</span>(&amp;b-&gt;rep_[<span class="number">8</span>], n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Serialization"><a href="#Serialization" class="headerlink" title="Serialization"></a>Serialization</h3><p>RocksDB 中数据本身基本按照 <code>|xxx_length|xxx_bytes|</code> 格式编码。</p><p>下面将写入的 <code>&#123;key, value&#125;</code> 序列化成 <code>Record</code>，根据是否指定 ColumnFamily 有两种格式:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">default cf:</span><br><span class="line">  |KTypeValue|</span><br><span class="line">  |key_size|key_bytes|</span><br><span class="line">  |value_length|value_bytes|</span><br><span class="line"></span><br><span class="line">specify cf:    </span><br><span class="line">  |kTypeColumnFamilyValue|column_family_id|</span><br><span class="line">  |key_size|key_bytes|</span><br><span class="line">  |value_length|value_bytes|</span><br></pre></td></tr></table></figure><p>在 <code>Record</code> 前面有两个字段:</p><ul><li><code>ValueType: uint8_t</code>: 1个字节，表征本次是 <code>Put/Delete</code> 等具体操作类型，以及是否指定了 ColumnFamily</li><li><code>column_family_id: uint32_t</code>: 4个字节，只有指定了 ColumnFamily，才会有这个字段</li></ul><p>下面的 <code>WriteBatchInternal::Put</code> 实现就是按照上述格式封装 <code>&#123;key, value&#125;</code> 后续写入WAL 和 MemTable。 </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">WriteBatchInternal::Put</span><span class="params">(WriteBatch* b, <span class="type">uint32_t</span> column_family_id,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  <span class="function">LocalSavePoint <span class="title">save</span><span class="params">(b)</span></span>;</span><br><span class="line">  WriteBatchInternal::<span class="built_in">SetCount</span>(b, WriteBatchInternal::<span class="built_in">Count</span>(b) + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (column_family_id == <span class="number">0</span>) &#123;</span><br><span class="line">    b-&gt;rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeValue));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b-&gt;rep_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(kTypeColumnFamilyValue));</span><br><span class="line">    <span class="built_in">PutVarint32</span>(&amp;b-&gt;rep_, column_family_id);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;b-&gt;rep_, key);</span><br><span class="line">  <span class="built_in">PutLengthPrefixedSlice</span>(&amp;b-&gt;rep_, value);</span><br><span class="line">  b-&gt;content_flags_.<span class="built_in">store</span>(</span><br><span class="line">      b-&gt;content_flags_.<span class="built_in">load</span>(std::memory_order_relaxed) | ContentFlags::HAS_PUT,</span><br><span class="line">      std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">return</span> save.<span class="built_in">commit</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LocalSavePoint"><a href="#LocalSavePoint" class="headerlink" title="LocalSavePoint"></a>LocalSavePoint</h3><p>LocalSavePoint 是基于 RAII 机制来判断 WriteBatch 写入的数据量累计是否已经超过限制: 是则回滚到生成 <em>save</em> 的位置，即调用本次 <code>WriteBatchInternel::Put</code> 之前的状态，然后返回 <code>Status::MemoryLimit</code> 错误，阻止本次写入流程。源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LocalSavePoint</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">LocalSavePoint</span><span class="params">(WriteBatch* batch)</span></span></span><br><span class="line"><span class="function">    : batch_(batch), </span></span><br><span class="line"><span class="function">      // savepoint 记录初始状态</span></span><br><span class="line"><span class="function">      savepoint_(batch-&gt;GetDataSize(), </span></span><br><span class="line"><span class="function">                 batch-&gt;Count(),</span></span><br><span class="line"><span class="function">                 batch-&gt;content_flags_.load(std::memory_order_relaxed))</span></span><br><span class="line"><span class="function">  &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 超过限制则 rollack 到初始状态</span></span><br><span class="line">    <span class="keyword">if</span> (batch_-&gt;max_bytes_ &amp;&amp; batch_-&gt;rep_.<span class="built_in">size</span>() &gt; batch_-&gt;max_bytes_) &#123;</span><br><span class="line">      batch_-&gt;rep_.<span class="built_in">resize</span>(savepoint_.size);</span><br><span class="line">      WriteBatchInternal::<span class="built_in">SetCount</span>(batch_, savepoint_.count);</span><br><span class="line">      batch_-&gt;content_flags_.<span class="built_in">store</span>(savepoint_.content_flags,</span><br><span class="line">                                   std::memory_order_relaxed);</span><br><span class="line">      <span class="keyword">return</span> Status::<span class="built_in">MemoryLimit</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  WriteBatch* batch_;</span><br><span class="line">  SavePoint savepoint_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>而 Savepoint 也是个简单的 <em>struct</em>:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SavePoint</span> &#123;</span><br><span class="line">  <span class="type">size_t</span> size;  <span class="comment">// size of rep_</span></span><br><span class="line">  <span class="type">int</span> count;    <span class="comment">// count of elements in rep_</span></span><br><span class="line">  <span class="type">uint32_t</span> content_flags;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SavePoint</span>() : <span class="built_in">size</span>(<span class="number">0</span>), <span class="built_in">count</span>(<span class="number">0</span>), <span class="built_in">content_flags</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">SavePoint</span>(<span class="type">size_t</span> _size, <span class="type">int</span> _count, <span class="type">uint32_t</span> _flags)</span><br><span class="line">      : <span class="built_in">size</span>(_size), <span class="built_in">count</span>(_count), <span class="built_in">content_flags</span>(_flags) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    content_flags = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">is_cleared</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (size | count | content_flags) == <span class="number">0</span>; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Deserializtion"><a href="#Deserializtion" class="headerlink" title="Deserializtion"></a>Deserializtion</h3><p>WriteBatch 序列化时将数据连续存储，反序列化时则可以顺序读取，具有更好的局部性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ReadRecordFromWriteBatch</span><span class="params">(Slice* input, <span class="type">char</span>* tag,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">uint32_t</span>* column_family, Slice* key,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Slice* value, Slice* blob, Slice* xid)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(key != <span class="literal">nullptr</span> &amp;&amp; value != <span class="literal">nullptr</span>);</span><br><span class="line">  *tag = (*input)[<span class="number">0</span>];</span><br><span class="line">  input-&gt;<span class="built_in">remove_prefix</span>(<span class="number">1</span>);</span><br><span class="line">  *column_family = <span class="number">0</span>;  <span class="comment">// default</span></span><br><span class="line">  <span class="keyword">switch</span> (*tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> kTypeColumnFamilyValue:</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">GetVarint32</span>(input, column_family)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad WriteBatch Put&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">case</span> kTypeValue:</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">GetLengthPrefixedSlice</span>(input, key) ||</span><br><span class="line">          !<span class="built_in">GetLengthPrefixedSlice</span>(input, value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Status::<span class="built_in">Corruption</span>(<span class="string">&quot;bad WriteBatch Put&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// other value   </span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>数据写入 WriteBatch 后，下面就要写入 WAL 和 MemTable，先来看看写入操作之前的一些逻辑。</p><h2 id="WriteThread"><a href="#WriteThread" class="headerlink" title="WriteThread"></a>WriteThread</h2><p>基于 RocksDB 构建的上层应用向 RocksDB 多线程写入数据时，由 <code>RocksDB::WriteThread</code> 保障多线程写入的有序性，并通过内部优化尽可能提高写入效率，不阻塞后来的写入流程，具体优化下一期再来详解，下面先讲解一些基础逻辑。</p><p>上层应用向 RocksDB 写入的数据序列化到 <code>WriteBatch</code> 后，再把 WriteBatch 封装到 <code>WriteThread::Writer</code>，生成一个 writer 并向 <code>WriteThread</code> 申请写入许可。</p><h3 id="WriteThread-Writer"><a href="#WriteThread-Writer" class="headerlink" title="WriteThread::Writer"></a>WriteThread::Writer</h3><p><code>WriterThread::Writer</code> 是个链表:</p><ul><li><code>link_older</code> 指向 <code>this</code> 之前插入的 <code>Writer</code>，类似 <code>next</code></li><li><code>link_newer</code> 指向 <code>this</code> 后面插入的 <code>Writer</code>，类似 <code>prev</code></li></ul><p>每个 writer 节点内部存储着本次写入的数据 batch:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WriteThread</span>::Writer &#123;</span><br><span class="line">  WriteBatch* batch;</span><br><span class="line">  <span class="comment">//.. too many other fields ..</span></span><br><span class="line"></span><br><span class="line">  std::atomic&lt;<span class="type">uint8_t</span>&gt; state;</span><br><span class="line">  std::aligned_storage&lt;<span class="built_in">sizeof</span>(std::mutex)&gt;::type state_mutex_bytes;</span><br><span class="line">  std::aligned_storage&lt;<span class="built_in">sizeof</span>(std::condition_variable)&gt;::type state_cv_bytes;</span><br><span class="line">  Writer* link_older;  <span class="comment">// this 之前之前写入的 writers</span></span><br><span class="line">  Writer* link_newer;  <span class="comment">// this 之后写入的 writers</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//... methods</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用 <code>std::aligned_storage</code> 进行内存对齐的原理可以参考之前写的一篇文章 <a href="https://mp.weixin.qq.com/s/Tw70s2aiPj5ez6tSgT78GA">内存对齐之 alignof、alignas 、aligned_storage、align 剖析</a></p></blockquote><h3 id="WriteThread-WriteGroup"><a href="#WriteThread-WriteGroup" class="headerlink" title="WriteThread::WriteGroup"></a>WriteThread::WriteGroup</h3><p>如果每次只有一个 writer 能写入数据，其他 writers 只能阻塞等待，那 RocksDB 也就毫无写性能可言。于是乎，RocksDB 每次将一批 writers 组成一个 <code>WriteGroup</code> 统一写入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">WriteThread</span>::WriteGroup &#123;</span><br><span class="line">  Writer* leader = <span class="literal">nullptr</span>;</span><br><span class="line">  Writer* last_writer = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">//... other fields</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Iterator</span> &#123;</span><br><span class="line">    Writer* writer;</span><br><span class="line">    Writer* last_writer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Iterator</span><span class="params">(Writer* w, Writer* last)</span></span></span><br><span class="line"><span class="function">        : writer(w), last_writer(last) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">    Writer* <span class="keyword">operator</span>*() <span class="type">const</span> &#123; <span class="keyword">return</span> writer; &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">      <span class="built_in">assert</span>(writer != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="keyword">if</span> (writer == last_writer) &#123;</span><br><span class="line">        writer = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writer = writer-&gt;link_newer;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Iterator&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> writer != other.writer;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">Iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Iterator</span>(leader, last_writer); &#125;</span><br><span class="line">  <span class="function">Iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">Iterator</span>(<span class="literal">nullptr</span>, <span class="literal">nullptr</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p><code>leader</code> 负责本次 write_group 的写入操作</p></li><li><p><code>last_writer</code> 负责将本次 writer_group 中待写入的所有 writers 对象串联起来。</p><p>last_writr 实际上是 <em>tail node</em>，而 leader 是 <em>head node</em>，通过 last_writer 向 leader 方向迭代，可以遍历整个 writer_group。</p><p>因此就可以通过 <code>leader</code> 和 <code>last_writer</code> 实现 <code>Iterator</code>，进一步可以轻松融入 for-loop 迭代体系，方便后续遍历 writer_group 中所有的 witers</p></li></ul><p>之所以从 last_writer 向 leader 节点遍历，也是为了满足写入的<em>顺序性</em>：tail 是更早写 RocksDB，head 是最晚写 RocksDB，因此需要迭代时使用 <code>link_newer</code>。</p><h3 id="WriteThread-State"><a href="#WriteThread-State" class="headerlink" title="WriteThread::State"></a>WriteThread::State</h3><p>而每个 writer 在写入过程中都有个状态， 由 <code>Writer::state</code> 字段表示:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">WriteThread</span>::State : <span class="type">uint8_t</span> &#123;</span><br><span class="line">  STATE_INIT = <span class="number">1</span>,</span><br><span class="line">  STATE_GROUP_LEADER = <span class="number">2</span>,</span><br><span class="line">  STATE_MEMTABLE_WRITER_LEADER = <span class="number">4</span>,</span><br><span class="line">  STATE_PARALLEL_MEMTABLE_WRITER = <span class="number">8</span>,</span><br><span class="line">  STATE_COMPLETED = <span class="number">16</span>,</span><br><span class="line">  STATE_LOCKED_WAITING = <span class="number">32</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>writer 创建后，初始化状态 <em>State::STATE_INIT</em> ，然后进入 <code>WriteThread::JoinBatchGroup</code> 函数中尝试更改自己的状态：</p><ol><li>要么成为本次写入流程的 leader，即 <em>State::STATE_GROUP_LEADER</em> 状态，然后组建自己的 writer_group，代替 writer_group 中所有 writers 完成写入，所有的 writers 状态都变成 <em>State::STATE_COMPLETED</em>；</li><li>要么加入一个已经选出 leader 但是尚未执行的 writer_group 成为 follower，让该 leader 代替自己执行完本次写入，完成后自己状态即 <em>State::STATE_COMPLETED</em></li><li>否则，只能阻塞等待前面正在执行写操作的 writer_group 完成</li></ol><p>这一期主要讲解个 WriteBatch 在写入前的准备工作，下一期会开始讲解 <code>WriteThread</code> 内部的调度过程以及一些多线程中的原子操作。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;WriteBatch&quot;&gt;&lt;a href=&quot;#WriteBatch&quot; class=&quot;headerlink&quot; title=&quot;WriteBatch&quot;&gt;&lt;/a&gt;WriteBatch&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;无论 &lt;code&gt;Put/Delete/Delet</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>MemTable、WAL、ColumnFamily 简述</title>
    <link href="https://szza.github.io/2022/01/08/rocksdb/WritePath/overview/"/>
    <id>https://szza.github.io/2022/01/08/rocksdb/WritePath/overview/</id>
    <published>2022-01-08T06:15:35.000Z</published>
    <updated>2023-08-01T02:10:02.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><p>尽管 rocksdb wiki 中 <a href="https://github.com/facebook/rocksdb/wiki">rocksdb-overview</a> 已经描述了，本文以自己的理解作为一个补充。</p><p>如图 rocksdb 的总体架构图中主要由 <code>MemTable</code>, <code>WAL</code> 和 <code>sstfile</code> 三个基本组件组成，本文主要阐述下他们之间的协作关系。<br><img src="../images/rocksdb-overview.png" alt="rocksdb-overview"></p><h3 id="MemTable"><a href="#MemTable" class="headerlink" title="MemTable"></a>MemTable</h3><p>写入的kv数据会先写入 <code>WriteBatch</code>， 在经过 <code>WriteBatchInternal</code> 封装后写入 MemTable。</p><p>MemTable 是在读写路径中共享，这样可以减少读写路径中和磁盘交互的频次。但由于 MemTable 是个内存结构，为了防止各种故障导致 MemTable 中数据丢失，进而引入 WAL (<code>W</code>rite <code>A</code>head <code>L</code>og)，即每次写入的数据，会先写入 WAL，成功后再写入 MemTable，如果 MemTable 中的数据丢失则从 WAL 中恢复。</p><p>正常情况下，写入的数据会持续写入 MemTable，直到 MemTable 的大小超过阈值，则会变成只具有只读属性的 ImutableMemTable, 同时创建新的 MemTable 接受后续的写入。等待后台线程 <em>Pickup</em> 合适的 ImmutableMemTables，将其 Flush 到 $Level_0$ 中，那么选中的 ImmutableMemTables 对应的 WALs 也可以删除了。</p><p>这里为什么用了 <em>Pickup</em> 这个说法？在 RocksDB-3.0 引入 cf(<code>C</code>olumn<code>F</code>amily) 设计，每个 cf 都有一个自己的 MemTable，但是所有的 cfs 共享一个 WAL：当向其中一个 cf 写入大量数据会导致它的 MemTable full 并转为 ImmtableMemTable。此时能直接删除当前 WAL 吗，由于WAL 可能仍保存着其他 cfs 的 MemTable 数据，这就涉及到 WAL 生命周期的问题。因此在删除 WALs 时，需要挑选出 WALs 生命周期结束的才能删除。</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>TiKV 原本的架构是一个 TiKV-Server 上的所有 regions 共享两个 RocksDB 实例: <code>raft-rocksdb</code> 用于存放 raft log，<code>kv-rocksdb</code> 用于存放状态机数据，kv-rocksdb 实例有三个 column family，</p><ol><li><p>事务 T1 在 prewrite 阶段写入 MemTable 的 lock 信息，在事务 T1 commit 阶段之前可能有其他热点 regions 写入大量数据导致 Flush MemTable，进而导致事务 T1 commit 阶段原本可以在 MemTable 中就可以查询到 lock 信息，现在需要去 sst 文件中查询，无疑增加了成本。</p></li><li><p>那么我们是否可以通过每个 region 一个 cf 来实现 region 的隔离？</p><p>显然也是不行，因为 cf 只是逻辑上的隔离，所有的 cf 仍共享一个 WAL：如果上万个 regions 对应上万个 cfs，如果会造成很多 WALs 生命周期无法结束、得不到释放，势必生成占用大量资源。</p></li><li><p>每个 region 一个 RocksDB 实例</p><p>在 Release-6.6 提出 Partitioned-TiKV 架构，即每个 region 分配一个 rocksdb 实例，从物理层上实现 region 隔离，这样原本一个 region 只能存储 64M 的存储，现在可以存储10G+的数据，减少了写入过程 region-leader 分裂的频次。</p></li></ol><p>  <em>Question</em>: 但是也有其他问题，比如 每个 region 一个 rocksdb，是否会因为 MemTable 导致占用的内存增加？尤其本来 TiKV 对硬件要求就很高，如此硬件成本是否会更高，以及内部 region 合并时 两个不同 RocksDB 实例的 regions 数据如何合并。不过由于 tikv region 本身就是按照 kv-range 划分的，不存在重复，合并可能主要需要修改元数据信息。</p><p>  这个设计可以参考: <a href="https://cn.pingcap.com/blog/principle-analysis-of-partitioned-raft-kv">partitioned-raft-kv</a></p><h3 id="SST"><a href="#SST" class="headerlink" title="SST"></a>SST</h3><p>Rocksdb 引擎是个 LSM (<code>L</code>og <code>S</code>tructured <code>M</code>erge) Tree， 其中 $level_0$ ~ $level_N$ 都由 sst(<code>S</code>orted <code>S</code>tring <code>T</code>able) files 组成。</p><p>sstfile 是已经将 kv 数据有序存储在磁盘上，因此和 sstfile 有关的问题不再是数据有没有可能丢失，而是如何减少 LSM Tree 中不同 level 的 sstfiles 中存储的冗余数据。这种方式即 compaction。</p><ul><li>$Level_0$ 存储最新的数据， $Level_N$ 存储最旧的数据。</li><li>$Level_0$ 中的 sstfiles 可能会有重复，$Level_1$ ~ $Level_N$ 中的数据不重复</li></ul><p>当 Compaction 方式是 <code>Level Compaction</code> 时:</p><ul><li><p>$level_0$: 当 MemTable 中的数据 Flush 到 $Level_0$ 时，会导致 $Level_0$ 存在重复的 kv range。当 $Level_0$ 的文件数量达到阈值 <code>$Level_0$_file_num_compaction_trigger</code>，$Level_0$ 会被合并到会和 $Level_1$，并保持使得 $Level_1$ 层的 sstfiles 仍然有序且无重复。</p><p>如图是 $level_0$ 的 compaction 前后过程：</p><p><img src="../images/rocksdb_pre_l0_compaction.png" alt="pre_l0_compaction"></p><p><img src="../images/rocksdb_post_l0_compaction.png" alt="post_l0_compaction"></p></li><li><p>当 $$Level_1$$ 的数据量越来越大，会触发 $Level_1$(inpit-level)层和 $level_2$ (output-level)层的 compaction。</p><p>如图是 $level_1$ 的 compaction 前后过程：</p><p><img src="../images/rocksdb_pre_l1_compaction.png" alt="rocksdb_pre_l1_compaction"></p><p><img src="../images/rocksdb_post_l1_compaction.png" alt="rocksdb_post_l1_compaction"></p></li><li><p>以此类推到 LSM 最底层。</p></li></ul><p>这里面需要研究的细节:</p><ul><li>input/output level 中的哪些 sstfiles 进行 compaction</li><li>如何选择合适的 compaction 方式，平衡读写放大</li><li>当 value 较大，进行 kv 分离来降低写方大问题</li></ul><p>由于现在新型的数据库的存储引擎基本都是以 LSM Tree 为蓝本， compaction 对内存和磁盘的影响就显得愈发重要，几乎都会借鉴 RocksDB 的设计。因此，在学习 RocksDB 时，compaction 是不可或缺的一点。 </p><h2 id="ColumnFamily"><a href="#ColumnFamily" class="headerlink" title="ColumnFamily"></a>ColumnFamily</h2><p>上面已经简述了 cf，它在逻辑上将 RocksDB 划分为多个 cf，每个 cf 类似一个关系数据库中的分区表的概念。</p><p>如图，cf 的实体是 <code>class ColumnFamilyData</code>，一个 RocksDB 实例可以有多个 cfs，都保存在 <code>ColumnFamilySet</code> 对象中。一个 cf 中要记录三大部分:</p><ul><li><code>version</code>: 表征的是 lsm tree 的 $Level_0$ - $Level_N$ 信息</li><li><code>imm</code>: 表征的是只读的 MemTable，不再接受写入的 MemTable；</li><li><code>mm</code>: 当前最新的 MemTable，接受读写</li></ul><p>同样这里也存在<code>version</code>、<code>imm</code> 生命周期的问题，因为每次 flush/comapction，都会对 imm/version 产生影响，为了追踪生命周期，</p><ul><li><code>MemTableList</code> 对象 imm 中有个 <code>MemTableListVersion</code> 对象，并有 <em>Ref()</em>/<em>Unref()</em> 函数来追踪生命周期；</li><li><code>Version</code> 对象 version 也有 <em>Ref()</em>/<em>Unref()</em> 函数来追踪生命周期；</li></ul><p><img src="../images/rocksdb_cf.png" alt="rocksdb-cf"></p><p>因此，关于 cf 也好理解，在分析这块的时候可以多关注下 WALs、Version 等生命周期的起始。</p><h2 id="Get-MultiGet"><a href="#Get-MultiGet" class="headerlink" title="Get/MultiGet"></a>Get/MultiGet</h2><p>读取路径会比较复杂，主要是将 mm/imm、sstfile 数据有序合并起来再取最新的数据输出，相关的三个迭代器 <code>MergingIterator</code>，<code>CompactionIterator</code>、<code>RangeTomeStoneIterator</code> 放在后续慢慢再讲解。这一部分还有一点就是利用 C++20 的协程实现异步IO来提取读取性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Overview&quot;&gt;&lt;a href=&quot;#Overview&quot; class=&quot;headerlink&quot; title=&quot;Overview&quot;&gt;&lt;/a&gt;Overview&lt;/h1&gt;&lt;p&gt;尽管 rocksdb wiki 中 &lt;a href=&quot;https://github.com/</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>内存分配器之 concurrent_arena</title>
    <link href="https://szza.github.io/2022/01/07/rocksdb/MemoryAllocator/2_concurrent_arena/"/>
    <id>https://szza.github.io/2022/01/07/rocksdb/MemoryAllocator/2_concurrent_arena/</id>
    <published>2022-01-07T06:15:35.000Z</published>
    <updated>2023-08-01T01:56:49.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="concurrent-arena"><a href="#concurrent-arena" class="headerlink" title="concurrent_arena"></a>concurrent_arena</h1><p>在上一期的 <a href="./2_arena.md">存分配器之 arena</a> 中，讲解了 RocksDB 是如何混合new、mmap设计一个高效的内存分配器。这一期，我们继续深入探索 RocksDB 是如何设计出一个高效的多线程内存分配器 <code>concurrent_arena</code> 。</p><p>let’s go</p><p>多线程程序的性能关键，有两个关键因素：</p><ul><li><p>减少竞争</p><p>减少竞争，有诸多方式，比如使用原子变量、细粒度锁（fine-grained mutex），threadlocal。</p></li><li><p>False Sharing</p><p>降低false sharing，一般解决办法是将线程间共享的数据大小与cacheline大小对齐（align）。</p></li></ul><p>而 concurrent_arena 即在 arena 的基础上，增加了一些多线程间的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConcurrentArena</span> : <span class="keyword">public</span> Allocator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// @brief 参数 @c block_size 与 @c huge_page_size 含义同 Arena 中</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ConcurrentArena</span><span class="params">(<span class="type">size_t</span> block_size = Arena::kMinBlockSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">size_t</span> huge_page_size = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 分配无须对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 分配需要对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Logger* logger = <span class="literal">nullptr</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Shard</span> &#123;</span><br><span class="line">    <span class="type">char</span> padding[<span class="number">40</span>] ROCKSDB_FIELD_UNUSED; </span><br><span class="line">    <span class="keyword">mutable</span> SpinMutex mutex;</span><br><span class="line">    <span class="type">char</span>* free_begin_; </span><br><span class="line">    std::atomic&lt;<span class="type">size_t</span>&gt; allocated_and_unused_; </span><br><span class="line"></span><br><span class="line">    <span class="built_in">Shard</span>() : <span class="built_in">free_begin_</span>(<span class="literal">nullptr</span>), <span class="built_in">allocated_and_unused_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="keyword">thread_local</span> <span class="type">size_t</span> tls_cpuid; </span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> padding0[<span class="number">56</span>] ROCKSDB_FIELD_UNUSED;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> shard_block_size_;</span><br><span class="line"></span><br><span class="line">  CoreLocalArray&lt;Shard&gt; shards_; <span class="comment">// 存储数据</span></span><br><span class="line"></span><br><span class="line">  Arena arena_;                                     <span class="comment">// 内存分配器</span></span><br><span class="line">  <span class="keyword">mutable</span> SpinMutex arena_mutex_;                   <span class="comment">// 保证使用 arena 分配内存时线程安全</span></span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; arena_allocated_and_unused_;  <span class="comment">// arena_ 剩余可使用的内存 </span></span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; memory_allocated_bytes_;      <span class="comment">// arena 总的分配内存</span></span><br><span class="line">  std::atomic&lt;<span class="type">size_t</span>&gt; irregular_block_num_;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> padding1[<span class="number">56</span>] ROCKSDB_FIELD_UNUSED;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Shard"><a href="#ConcurrentArena-Shard" class="headerlink" title="ConcurrentArena::Shard"></a>ConcurrentArena::Shard</h3><p>为避免竞争，<code>concurrent_arena</code> 使用将每个线程所需的内存分配在线程所属的cpu核上，如此每个线程在分配内存时都会使用自己的内存，如此就避免了竞争。这也是一种空间换时间的策略，类似于threadlocal思想。</p><p>结构体 <code>Shard</code> 记录了每个核上的内存分配、使用情况。字段 <code>shards_</code> 记录了所有核上shard。</p><p>类<code>CoreLocalArray</code> 本质上是个数组，为了提高多线程的访问效率，要将<code>Shard</code>的大小对齐到cacheline大小，以阻止false sharing现象。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Shard</span> &#123;</span><br><span class="line">   <span class="comment">// 填充字节以对齐到 cacheline, 避免 false sharding</span></span><br><span class="line">   <span class="type">char</span> padding[<span class="number">40</span>] ROCKSDB_FIELD_UNUSED; </span><br><span class="line">   <span class="comment">// 用于保护 free_begin_ 指向的数据</span></span><br><span class="line">   <span class="keyword">mutable</span> SpinMutex mutex;</span><br><span class="line">   <span class="comment">// 每个core上分配内存地址</span></span><br><span class="line">   <span class="type">char</span>* free_begin_; </span><br><span class="line">   <span class="comment">// 每个core剩余可用内存</span></span><br><span class="line">   std::atomic&lt;<span class="type">size_t</span>&gt; allocated_and_unused_; </span><br><span class="line"></span><br><span class="line">   <span class="built_in">Shard</span>() : <span class="built_in">free_begin_</span>(<span class="literal">nullptr</span>), <span class="built_in">allocated_and_unused_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> CoreLocalArray&lt;Shard&gt; shards_;</span><br></pre></td></tr></table></figure><h4 id="CoreLocalArray"><a href="#CoreLocalArray" class="headerlink" title="CoreLocalArray"></a>CoreLocalArray</h4><p>类 <code>CoreLocalArray</code>  只用于存储数据，本身不是线程安全的，因此需要 <code>Shard::mutex</code> 字段保护。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CoreLocalArray</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">CoreLocalArray</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 数组元素个数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @return 返回当前线程所在core上的数据地址 ptr</span></span><br><span class="line">  <span class="function">T* <span class="title">Access</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AccessElementAndIndex</span>().first;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// @return 不仅返回当前线程所在core上的数据地址 ptr，还返回该core的index</span></span><br><span class="line">  <span class="function">std::pair&lt;T*, <span class="type">size_t</span>&gt; <span class="title">AccessElementAndIndex</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 通过 core_idx 来获取该 core 的数据</span></span><br><span class="line">  <span class="function">T* <span class="title">AccessAtCore</span><span class="params">(<span class="type">size_t</span> core_idx)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::unique_ptr&lt;T[]&gt; data_;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="type">int</span> size_shift_;             </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-CoreLocalArray"><a href="#CoreLocalArray-CoreLocalArray" class="headerlink" title="CoreLocalArray::CoreLocalArray"></a>CoreLocalArray::CoreLocalArray</h5><p>C++11中提供了<code>std::thread::hardware_concurrency</code> 函数，来获取CPU的核数<code>num_cpus</code>，将线程数设置为 <code>num_cpus</code>，如此就能避免在一个进程中线程频繁的在不同的core上来回切换，降低线程切换上下文的开销。</p><ul><li>如果<code>num_cpus &lt;= 8</code>，则启动8个线程；</li><li>否则，开启<code>num_cpus</code>个线程（num_cpus 一般也是2的幂）。</li></ul><p>代码简洁如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">CoreLocalArray&lt;T&gt;::<span class="built_in">CoreLocalArray</span>() &#123;</span><br><span class="line">  <span class="type">int</span> num_cpus = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(std::thread::<span class="built_in">hardware_concurrency</span>());</span><br><span class="line">  size_shift_ = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span> &lt;&lt; size_shift_ &lt; num_cpus) &#123;</span><br><span class="line">    ++size_shift_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 每个core上都有类型 T 的数据</span></span><br><span class="line">  data_.<span class="built_in">reset</span>(<span class="keyword">new</span> T[<span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-AccessAtCore"><a href="#CoreLocalArray-AccessAtCore" class="headerlink" title="CoreLocalArray::AccessAtCore"></a>CoreLocalArray::AccessAtCore</h5><p><code>AccessAtCore</code> 函数，用于获取核<code>core_idx</code>上的数据，即获取数组<code>data_[core_idx]</code>中数据。</p><p>在这解释下为啥类型<code>T</code>大小需要对齐到 cacheline大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* CoreLocalArray&lt;T&gt;::<span class="built_in">AccessAtCore</span>(<span class="type">size_t</span> core_idx) <span class="type">const</span> &#123;</span><br><span class="line">  <span class="built_in">assert</span>(core_idx &lt; <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(<span class="number">1</span>) &lt;&lt; size_shift_);</span><br><span class="line">  <span class="keyword">return</span> &amp;data_[core_idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CoreLocalArray-AccessElementAndIndex"><a href="#CoreLocalArray-AccessElementAndIndex" class="headerlink" title="CoreLocalArray::AccessElementAndIndex"></a>CoreLocalArray::AccessElementAndIndex</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">std::pair&lt;T*, <span class="type">size_t</span>&gt; CoreLocalArray&lt;T&gt;::<span class="built_in">AccessElementAndIndex</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="type">int</span> cpuid = port::<span class="built_in">PhysicalCoreID</span>(); <span class="comment">// 获取cpu的物理id</span></span><br><span class="line">  <span class="type">size_t</span> core_idx;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(cpuid &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">    <span class="comment">// cpu id unavailable, just pick randomly</span></span><br><span class="line">    core_idx = Random::<span class="built_in">GetTLSInstance</span>()-&gt;<span class="built_in">Uniform</span>(<span class="number">1</span> &lt;&lt; size_shift_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 将 cpuid 映射到 1 &lt;&lt; size_shift_ 以内</span></span><br><span class="line">    core_idx = <span class="built_in">static_cast</span>&lt;<span class="type">size_t</span>&gt;(cpuid &amp; ((<span class="number">1</span> &lt;&lt; size_shift_) - <span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123;<span class="built_in">AccessAtCore</span>(core_idx), core_idx&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-ShardAllocatedAndUnused"><a href="#ConcurrentArena-ShardAllocatedAndUnused" class="headerlink" title="ConcurrentArena::ShardAllocatedAndUnused"></a>ConcurrentArena::ShardAllocatedAndUnused</h3><p><code>ShardAllocatedAndUnused</code> 则用于记录，<code>shards</code>中各个<code>shard</code>中剩余可用内存大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所有已分配但未使用的内存</span></span><br><span class="line"> <span class="function"><span class="type">size_t</span> <span class="title">ConcurrentArena::ShardAllocatedAndUnused</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">   <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; shards_.<span class="built_in">Size</span>(); ++i) &#123;</span><br><span class="line">     total += </span><br><span class="line">       shards_.<span class="built_in">AccessAtCore</span>(i)-&gt;allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> total;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-ConcurrentArena"><a href="#ConcurrentArena-ConcurrentArena" class="headerlink" title="ConcurrentArena::ConcurrentArena"></a>ConcurrentArena::ConcurrentArena</h3><p><code>ConcurrentArena</code> 的构造函数比较简单：</p><ol><li>初始化每个<code>shard</code> 需要分配的内存大小 <code>shard_block_size_</code>；</li><li>初始化 <code>shards_</code> 数组；</li><li>初始化<code>arena</code></li><li>调用<code>Fixup</code>函数，初始化内存使用情况；</li></ol><p>简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConcurrentArena::<span class="built_in">ConcurrentArena</span>(<span class="type">size_t</span> block_size,</span><br><span class="line">                                 AllocTracker* tracker,</span><br><span class="line">                                 <span class="type">size_t</span> huge_page_size)</span><br><span class="line">    : <span class="built_in">shard_block_size_</span>(std::<span class="built_in">min</span>(kMaxShardBlockSize, block_size / <span class="number">8</span>)),</span><br><span class="line">      <span class="built_in">shards_</span>(),</span><br><span class="line">      <span class="built_in">arena_</span>(block_size, tracker, huge_page_size) &#123;</span><br><span class="line">  <span class="built_in">Fixup</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Fixup"><a href="#ConcurrentArena-Fixup" class="headerlink" title="ConcurrentArena::Fixup"></a>ConcurrentArena::Fixup</h3><p><code>FixUp</code> 函数用于记录当前内存情况。</p><p>下面三个原子变量写入新值时，使用<code>::std::memory_order_relaxed</code>即能满足。关于<code>memory order</code>，花了两个周末的时候重温了下，有时间会再出博客深度讲解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConcurrentArena::Fixup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// arena_ 所分配的内存中剩余可使用的内存</span></span><br><span class="line">    arena_allocated_and_unused_.<span class="built_in">store</span>(arena_.<span class="built_in">AllocatedAndUnused</span>(), std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// arena 分配的内存总量</span></span><br><span class="line">    memory_allocated_bytes_.<span class="built_in">store</span>(arena_.<span class="built_in">MemoryAllocatedBytes</span>(), std::memory_order_relaxed);</span><br><span class="line">    irregular_block_num_.<span class="built_in">store</span>(arena_.<span class="built_in">IrregularBlockNum</span>(), std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-Repick"><a href="#ConcurrentArena-Repick" class="headerlink" title="ConcurrentArena::Repick"></a>ConcurrentArena::Repick</h3><p><code>Repick</code> 函数，用来初始化线程。把一个线程绑定到所属的核<code>tls_cpuid</code>。这样下次以后这个线程需要内存，直接去对应的<code>shard</code>获取内存。</p><p>注意，<code>tls_cpuid</code> 默认为0，因此对于<code>core_idx</code>为0的线程需要映射到<code>num_cpus</code>，这样就能通过<code>tls_cpuid != 0</code>来判断这个线程是否初始化过。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ConcurrentArena::Shard* <span class="title">ConcurrentArena::Repick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> shard_and_index = shards_.<span class="built_in">AccessElementAndIndex</span>();</span><br><span class="line">  <span class="comment">// 用于将 cord_idx 为 0 时 映射为 num_cpus，来体现此线程已初始化 </span></span><br><span class="line">  tls_cpuid = shard_and_index.second | shards_.<span class="built_in">Size</span>();</span><br><span class="line">  <span class="keyword">return</span> shard_and_index.first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConcurrentArena-AllocateImpl"><a href="#ConcurrentArena-AllocateImpl" class="headerlink" title="ConcurrentArena::AllocateImpl"></a>ConcurrentArena::AllocateImpl</h3><p>整个流程如下：</p><ol><li><p>先判断此次分配内存，是否需要从arena直接分配即可</p><ul><li>超过一个shards内存大小的1/4</li><li>上层强制使用 arena</li><li>该线程首次调用<code>AllocateImpl</code> 函数，此时<code>shards</code>中的各个<code>shard-&gt;free_begin</code>尚未指向有效内存地址；</li></ul><p>如果要使用 <code>arena_</code>，则需要使用<code>arena_mutex_</code>保护。</p></li><li><p>尝试从shard中获取内存</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">AllocateImpl</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">bool</span> force_arena, <span class="type">const</span> Func&amp; func)</span> </span>&#123;</span><br><span class="line">  <span class="type">size_t</span> cpu;</span><br><span class="line">  <span class="comment">// 直接使用arena分配内存，有两种情况：</span></span><br><span class="line">  <span class="comment">// 1. 待分配的内存比较大。</span></span><br><span class="line">  <span class="comment">// 2. Repick 尚未调用过，并且当前 arena_mutex_ 能直接获得</span></span><br><span class="line">  <span class="function">std::unique_lock&lt;SpinMutex&gt; <span class="title">arena_lock</span><span class="params">(arena_mutex_, std::defer_lock)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; shard_block_size_ / <span class="number">4</span> </span><br><span class="line">      <span class="comment">// 使用 huge_page</span></span><br><span class="line">      || force_arena </span><br><span class="line">      <span class="comment">// 判断条件执行到此，说明 所需的内存 bytes 并不大，比较小</span></span><br><span class="line">      <span class="comment">// 原则上是不需要使用 arena，但是如果同时满足以下二个条件：</span></span><br><span class="line">      <span class="comment">//  1. 没有执行过 Repick 函数</span></span><br><span class="line">      <span class="comment">//  2. 成功获得锁</span></span><br><span class="line">      || ((cpu = tls_cpuid) == <span class="number">0</span>   <span class="comment">// 线程尚未初始化</span></span><br><span class="line">           &amp;&amp; !shards_.<span class="built_in">AccessAtCore</span>(<span class="number">0</span>)-&gt;allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed) </span><br><span class="line">           &amp;&amp; arena_lock.<span class="built_in">try_lock</span>())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!arena_lock.<span class="built_in">owns_lock</span>()) &#123;</span><br><span class="line">      <span class="comment">// 阻塞等待</span></span><br><span class="line">      arena_lock.<span class="built_in">lock</span>();</span><br><span class="line">      <span class="comment">// 获得锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> rv = <span class="built_in">func</span>(); <span class="comment">// 分配内存的回调函数</span></span><br><span class="line">    <span class="built_in">Fixup</span>();</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 选择一个 shard 来满足此次内存分配</span></span><br><span class="line">  Shard* s = shards_.<span class="built_in">AccessAtCore</span>(cpu &amp; (shards_.<span class="built_in">Size</span>() - <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">if</span> (!s-&gt;mutex.<span class="built_in">try_lock</span>()) &#123;</span><br><span class="line">    s = <span class="built_in">Repick</span>();</span><br><span class="line">    s-&gt;mutex.<span class="built_in">lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::unique_lock&lt;SpinMutex&gt; <span class="title">lock</span><span class="params">(s-&gt;mutex, std::adopt_lock)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> avail = s-&gt;allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  <span class="keyword">if</span> (avail &lt; bytes) &#123;</span><br><span class="line">    <span class="comment">// reload</span></span><br><span class="line">    <span class="comment">// 此时需要使用 arnea 来分配内存</span></span><br><span class="line">    <span class="comment">// 1. 该 core 所剩的内存不足</span></span><br><span class="line">    <span class="comment">// 2. 第一次执行（本质还是第一种情况）</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;SpinMutex&gt; <span class="title">reload_lock</span><span class="params">(arena_mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> exact = arena_allocated_and_unused_.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    <span class="built_in">assert</span>(exact == arena_.<span class="built_in">AllocatedAndUnused</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (exact &gt;= bytes &amp;&amp; arena_.<span class="built_in">IsInInlineBlock</span>()) &#123;</span><br><span class="line">      <span class="comment">// 如果还没有消耗完 arena 的inline block的内存，则直接使用该内存</span></span><br><span class="line">      <span class="comment">// 这样就可以避免分配新的block，</span></span><br><span class="line">      <span class="keyword">auto</span> rv = <span class="built_in">func</span>(); <span class="comment">// 执行回调函数分配</span></span><br><span class="line">      <span class="built_in">Fixup</span>();</span><br><span class="line">      <span class="keyword">return</span> rv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avail = exact &gt;= shard_block_size_ / <span class="number">2</span> &amp;&amp; exact &lt; shard_block_size_ * <span class="number">2</span></span><br><span class="line">                ? exact</span><br><span class="line">                : shard_block_size_;</span><br><span class="line">    <span class="comment">// 重新分配内存</span></span><br><span class="line">    <span class="comment">// 首次调用即在此分配内存</span></span><br><span class="line">    s-&gt;free_begin_ = arena_.<span class="built_in">AllocateAligned</span>(avail);</span><br><span class="line">    <span class="built_in">Fixup</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 可用内存减少</span></span><br><span class="line">  s-&gt;allocated_and_unused_.<span class="built_in">store</span>(avail - bytes, std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span>* rv;</span><br><span class="line">  <span class="keyword">if</span> ((bytes % <span class="built_in">sizeof</span>(<span class="type">void</span>*)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// aligned allocation from the beginning</span></span><br><span class="line">    rv = s-&gt;free_begin_;</span><br><span class="line">    s-&gt;free_begin_ += bytes;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// unaligned from the end</span></span><br><span class="line">    rv = s-&gt;free_begin_ + avail - bytes;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;concurrent-arena&quot;&gt;&lt;a href=&quot;#concurrent-arena&quot; class=&quot;headerlink&quot; title=&quot;concurrent_arena&quot;&gt;&lt;/a&gt;concurrent_arena&lt;/h1&gt;&lt;p&gt;在上一期的 &lt;a href=</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>内存分配器之 arena</title>
    <link href="https://szza.github.io/2022/01/06/rocksdb/MemoryAllocator/2_arena/"/>
    <id>https://szza.github.io/2022/01/06/rocksdb/MemoryAllocator/2_arena/</id>
    <published>2022-01-06T06:15:35.000Z</published>
    <updated>2023-07-31T16:55:35.148Z</updated>
    
    <content type="html"><![CDATA[<p>今天，就开始逐步更新剖析 RocksDB 源码的博客。思前想后，准备自下而上，因此还是从内存分配器开始叭。</p><p>在 RocksDB 中主要有两类内存分配器<code>MemoryAllocator</code>、<code>Allocator</code>。</p><h4 id="MemoryAllocator"><a href="#MemoryAllocator" class="headerlink" title="MemoryAllocator"></a>MemoryAllocator</h4><p><code>MemoryAllocator</code> 是个基类，RocksDB 提供了两个子类：<code>MemkindKmemAllocator</code>、<code>JemallocNodumpAllocator</code>，而这两个子类，实际上分别是 <a href="https://github.com/memkind/memkind">memkind</a>、<a href="https://github.com/jemalloc/jemalloc">jemalloc</a>两个开源库的 wrapper，即利用两个开源库的函数来实现<code>Allocate</code>、<code>Deallocate</code>操作。<code>jemalloc</code>后者有时间再开专题专门细解，这里就不展开说了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MemoryAllocator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">MemoryAllocator</span>() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">Name</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">///@note 需要保证线程安全</span></span><br><span class="line">  <span class="comment">///@param 至少分配的内存大小</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> size)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///@note 需要保证线程安全</span></span><br><span class="line">  <span class="comment">///@brief 释放之前由 Allocate 分配的内存</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Deallocate</span><span class="params">(<span class="type">void</span>* p)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">///@brief 返回 ptr 指向的block的内存大小</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">UsableSize</span><span class="params">(<span class="type">void</span>* ptr, <span class="type">size_t</span> allocation_size)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// default implementation just returns the allocation size</span></span><br><span class="line">    <span class="keyword">return</span> allocation_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="Allocator"><a href="#Allocator" class="headerlink" title="Allocator"></a>Allocator</h2><p>本节主要详细讲解<code>Allocator</code>及其子类<code>Arena</code>的实现。</p><p>类 <code>Allocator</code> 是个基类，主要有两个接口：</p><ul><li><code>Allocate</code>：分配无须对齐的内存；</li><li><code>AllocateAligned</code>：分配需要经过对齐的内存；</li></ul><p>关于内存对齐，可以参考之前写过的一期博客 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析]，在这一期，通过讲解<code>Allocator</code>，会更加深刻的理解内存对齐。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Allocator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">Allocator</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">char</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="type">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Logger* logger = <span class="literal">nullptr</span>)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">BlockSize</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基类<code>Allocator</code> 有两个子类，<code>Arena</code> 和<code>concurrent_arena</code>，分别用于单线程和多线程内存分配，其中 <code>concurrent_arena</code> 也是个<code>Arena</code>的<code>wrapper</code>，外加了一些措施，保证<code>Arnea</code>在多线程下的安全。因此，本文先详细讲解下<code>Arena</code>，下一节再把注意力集中在concurrent_arena`的多线程设计上。</p><img src="/Users/shuzhuangzhuang/self_study/graph/需求/rocksdb/images/Allocator.jpg" style="zoom:50%;" /><h2 id="Arena"><a href="#Arena" class="headerlink" title="Arena"></a>Arena</h2><p>类<code>Arena</code> 在分配内存时，是以 <code>block</code> 为单位，即每次先分配一个<code>block</code>大小的内存，后续所需<code>bytes</code>大小的内存时，会先尝试从<code>block</code> 中获取，如果这个<code>block</code>中剩余的可用内存能满足<code>bytes</code>，则从<code>block</code>中划出一部分给上层使用，否则才从操作系统中获取。</p><p>一个<code>block</code>容纳的内存大小，由<code>kBlockSize</code>参数来指定。</p><p>现在<code>Arena</code>怎么实现基类中<code>Allocate</code>、<code>AllocateAligned</code>两个接口？</p><p><code>Arena</code> 中有两个指针：<code>aligned_alloc_ptr_</code>、<code>unaligned_alloc_ptr_</code>，当一个<code>block</code>的内存创建完毕时：</p><ul><li><code>aligned_alloc_ptr_</code>：指向该<code>block</code>的首地址（低地址），后续用于分配需要对齐的内存；</li><li><code>unaligned_alloc_ptr_</code>：指向该<code>block</code>的末地址（高地址），后续用于分配不需要对齐的内存。</li></ul><p>示意图如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block : [-------------------------]</span><br><span class="line">        ^                         ^</span><br><span class="line">        |                         | </span><br><span class="line">   aligned_alloc_ptr_    unaligned_alloc_ptr_</span><br></pre></td></tr></table></figure><p>为啥要这么做？</p><p>由于每次内存对齐操作可能存在一定的浪费，而同一个类中所需的内存对齐大小一般是固定的，因此从blokc的一端只分配需要对齐的内存，若内存对齐大小是固定的，那么每次分配的内存也都是连续的，如此就可以减少因为内存对齐带来的浪费。</p><p>从<code>block</code>的另一端分配无需对齐的内存，还能提高内存利用率。</p><blockquote><p>比如，block的大小为7个字节，分配一块需要4字节对齐的内存，还剩下3字节的内存，可以继续用于无须对齐的内存。</p></blockquote><p>下面先整体看看类<code>Arean</code>。</p><blockquote><p>在下面的源码分析中，做了一些简化，去除了一些统计内存大小部分的代码，读者可自行追溯RocksDB中该部分的源码。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Arena</span> : <span class="keyword">public</span> Allocator &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  <span class="built_in">Arena</span>(<span class="type">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> Arena&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kInlineSize = <span class="number">2048</span>;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kMinBlockSize;</span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kMaxBlockSize;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Arena</span><span class="params">(<span class="type">size_t</span> block_size = kMinBlockSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                 AllocTracker* tracker = <span class="literal">nullptr</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">size_t</span> huge_page_size = <span class="number">0</span>)</span></span>;</span><br><span class="line">  ~<span class="built_in">Arena</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 分配无需对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 分配需要对齐的内存</span></span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">size_t</span> huge_page_size = <span class="number">0</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                        Logger* logger = <span class="literal">nullptr</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/// 当前已使用内存大小</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">ApproximateMemoryUsage</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blocks_memory_ + blocks_.<span class="built_in">capacity</span>() * <span class="built_in">sizeof</span>(<span class="type">char</span>*) - alloc_bytes_remaining_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 总的已分配内存</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">MemoryAllocatedBytes</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> blocks_memory_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 剩余可用内存</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">AllocatedAndUnused</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> alloc_bytes_remaining_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 分配的不对齐block数</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">IrregularBlockNum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> irregular_block_num; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 一个 block 的内存大小</span></span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">BlockSize</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> kBlockSize; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// blocks_ 是否用的栈上内存</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">IsInInlineBlock</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> blocks_.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">alignas</span>(<span class="type">max_align_t</span>) <span class="type">char</span> inline_block_[kInlineSize];</span><br><span class="line">  <span class="comment">// 一个block分配的内存大小</span></span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> kBlockSize;           </span><br><span class="line">  <span class="keyword">typedef</span> std::vector&lt;<span class="type">char</span>*&gt; Blocks; </span><br><span class="line">  <span class="comment">// 使用new分配的block集合</span></span><br><span class="line">  Blocks blocks_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">MmapInfo</span> &#123;</span><br><span class="line">    <span class="type">void</span>* addr_;</span><br><span class="line">    <span class="type">size_t</span> length_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MmapInfo</span>(<span class="type">void</span>* addr, <span class="type">size_t</span> length) : <span class="built_in">addr_</span>(addr), <span class="built_in">length_</span>(length) &#123;&#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 使用 mmap 分配内存的block集合</span></span><br><span class="line">  std::vector&lt;MmapInfo&gt; huge_blocks_; </span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> irregular_block_num = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span>* unaligned_alloc_ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="type">char</span>* aligned_alloc_ptr_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 当前block剩余可用内存</span></span><br><span class="line">  <span class="type">size_t</span> alloc_bytes_remaining_ = <span class="number">0</span>; </span><br><span class="line">   <span class="comment">// 目前一共分配的内存</span></span><br><span class="line">  <span class="type">size_t</span> blocks_memory_ = <span class="number">0</span>;        </span><br><span class="line">  </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="type">size_t</span> hugetlb_size_ = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">// MAP_HUGETLB</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateFromHugePage</span><span class="params">(<span class="type">size_t</span> bytes)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">bool</span> aligned)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">char</span>* <span class="title">AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Arena-Arena"><a href="#Arena-Arena" class="headerlink" title="Arena::Arena"></a>Arena::Arena</h3><p>先来看看构造函数 <code>Arena::Arena</code>。这里，主要初始化一些类成员变量：</p><ul><li><p><code>kBlockSize</code></p><p>字段<code>kBlockSize</code> ，表达的是以后每次分配一个block时的内存大小。在初始化之前，使用<code>OptimizeBlockSize</code>函数对传入的参数<code>block_size</code>进行限制，使其满足后续的<code>assert</code>判断。</p><p>通过 <code>OptimizeBlockSize</code> 函数限制<code>block_size</code>的值，减少后续分配需要对齐的内存浪费。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">size_t</span> Arena::kMinBlockSize = <span class="number">4096</span>;           <span class="comment">// 最小为 4k</span></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> Arena::kMaxBlockSize = <span class="number">2u</span> &lt;&lt; <span class="number">30</span>;       <span class="comment">// 最大为 8k</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> kAlignUnit = <span class="built_in">alignof</span>(<span class="type">max_align_t</span>); <span class="comment">// 按照 8 byte 对齐</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">OptimizeBlockSize</span><span class="params">(<span class="type">size_t</span> block_size)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确保满足： Arena::kMinBlockSize &lt;= block_size &lt;= Arena::kMaxBlockSize</span></span><br><span class="line">  block_size = std::<span class="built_in">max</span>(Arena::kMinBlockSize, block_size);</span><br><span class="line">  block_size = std::<span class="built_in">min</span>(Arena::kMaxBlockSize, block_size);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保 block_size 是 8 的倍数</span></span><br><span class="line">  <span class="keyword">if</span> (block_size % kAlignUnit != <span class="number">0</span>) &#123;</span><br><span class="line">    block_size = (<span class="number">1</span> + block_size / kAlignUnit) * kAlignUnit;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>inline_block_</code></p><p>字段<code>inline_block_</code> ，其中的<code>inline</code>语义是指这块内存分配在栈上，在地址上和<code>Arena</code>是连续的。这对于那些只需要分配小内存的操作具有优势，可以避免从堆上分配内存。当这块内存使用完毕，会再从堆上获取。</p></li><li><p><code>hugetlb_size_</code></p><p>字段<code>hugetlb_size_</code>，是默认情况下使用<code>mmap</code>给block分配的内存大小。如果 <code>hugetlb_size_ == 0</code>，则表示不使用<code>mmap</code>分配内存。</p><p>当然，<code>hugetlb_size_</code> 在构造函数中也是经过向上取整操作，变为 8 的倍数。</p></li></ul><p>现在，可以很好的阅读构造函数 <code>Arena::Arena</code> 了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Arena::<span class="built_in">Arena</span>(<span class="type">size_t</span> block_size, </span><br><span class="line">             AllocTracker* tracker, </span><br><span class="line">             <span class="type">size_t</span> huge_page_size)</span><br><span class="line">    : <span class="built_in">kBlockSize</span>(<span class="built_in">OptimizeBlockSize</span>(block_size)) &#123;</span><br><span class="line">  <span class="built_in">assert</span>(kBlockSize &gt;= kMinBlockSize &amp;&amp; kBlockSize &lt;= kMaxBlockSize &amp;&amp;</span><br><span class="line">         kBlockSize % kAlignUnit == <span class="number">0</span>);</span><br><span class="line">  alloc_bytes_remaining_ = <span class="built_in">sizeof</span>(inline_block_);</span><br><span class="line">  blocks_memory_ += alloc_bytes_remaining_;</span><br><span class="line">  <span class="comment">// 对齐侧指向了低地址</span></span><br><span class="line">  aligned_alloc_ptr_ = inline_block_;</span><br><span class="line">  <span class="comment">// 不对齐侧指向了高地址</span></span><br><span class="line">  unaligned_alloc_ptr_ = inline_block_ + alloc_bytes_remaining_;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  hugetlb_size_ = huge_page_size;</span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_ &amp;&amp; kBlockSize &gt; hugetlb_size_) &#123;</span><br><span class="line">    <span class="comment">// hugetlb_size_ 向上取整</span></span><br><span class="line">    hugetlb_size_ = ((kBlockSize - <span class="number">1U</span>) / hugetlb_size_ + <span class="number">1U</span>) * hugetlb_size_;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)huge_page_size;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateNewBlock"><a href="#Arena-AllocateNewBlock" class="headerlink" title="Arena::AllocateNewBlock"></a>Arena::AllocateNewBlock</h3><p><code>AllocateNewBlock</code> 函数比较普通，本质上就是使用 <code>new</code> 操作从操作系统获取内存。</p><p>这里面稍微有个<code>trick</code>的操作，是<code>blocks_.emplace_back(nullptr);</code> 这行，作用是在<code>blocks_</code>中预留一个指针大小的空间，即 <code>sizeof(Block*)</code>，出于内存泄露的考虑，使用了<code>emplace_back</code>，而不是<code>reserve</code>函数。</p><p>RocksDB 解释如下：</p><ul><li>如果<code>emplace_back</code> 函数抛出异常，不会发生内存泄露，因为此时还没使用<code>new</code>分配内存；</li><li>如果<code>new</code> 抛出异常（即<code>std::bad_alloc</code>异常），也不会发生内存泄露，因为在<code>blocks_</code>中预留的空间将会基于RAII语义被清除。</li></ul><p><code>AllocateNewBlock</code> 函数，直接使用<code>new</code>操作分配内存，不负责进行内存对齐操作。如果需要按照某个<code>alignment</code>大小进行对齐，得调用 <code>AllocateAligned</code>  函数，这个后面再说。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///@return 返回指针，指向当前分配的 block</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Reserve space in `blocks_` before allocating memory via new.</span></span><br><span class="line">  <span class="comment">// Use `emplace_back()` instead of `reserve()` to let std::vector manage its</span></span><br><span class="line">  <span class="comment">// own memory and do fewer reallocations.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// - If `emplace_back` throws, no memory leaks because we haven&#x27;t called `new`</span></span><br><span class="line">  <span class="comment">//   yet.</span></span><br><span class="line">  <span class="comment">// - If `new` throws, no memory leaks because the vector will be cleaned up</span></span><br><span class="line">  <span class="comment">//   via RAII.</span></span><br><span class="line">  blocks_.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 分配内存</span></span><br><span class="line">  <span class="type">char</span>* block = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">  <span class="type">size_t</span> allocated_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ROCKSDB_MALLOC_USABLE_SIZE</span></span><br><span class="line">  allocated_size = <span class="built_in">malloc_usable_size</span>(block);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  allocated_size = block_bytes;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 增加已分配内存</span></span><br><span class="line">  blocks_memory_ += allocated_size;</span><br><span class="line">  <span class="comment">// 赋值</span></span><br><span class="line">  blocks_.<span class="built_in">back</span>() = block;</span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来解释下为何使用<code>reserve</code>可能会导致内存泄露，写法如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateNewBlock</span><span class="params">(<span class="type">size_t</span> block_bytes)</span> </span>&#123;</span><br><span class="line">  blocks_.<span class="built_in">reserve</span>(<span class="number">1</span>);        <span class="comment">// 预留空间</span></span><br><span class="line">  <span class="type">char</span>* block = <span class="keyword">new</span> <span class="type">char</span>[block_bytes];</span><br><span class="line">  <span class="type">size_t</span> allocated_size;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> ROCKSDB_MALLOC_USABLE_SIZE</span></span><br><span class="line">  allocated_size = <span class="built_in">malloc_usable_size</span>(block);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  allocated_size = block_bytes;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  blocks_memory_ += allocated_size;</span><br><span class="line">  blocks_.<span class="built_in">emplace_back</span>(block); <span class="comment">// 抛出异常???</span></span><br><span class="line">  <span class="keyword">return</span> block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理由很简单：上面这个写法，如果在<code>emplace_back</code>的过程中抛出异常，那么 <code>block</code> 指向的内存将会泄露。</p><p>尽管<code>emplace_back</code>抛异常这种bad case极少出现，但也应该为RocksDB的细致点赞。</p><h3 id="Arena-AllocateFromHugePage"><a href="#Arena-AllocateFromHugePage" class="headerlink" title="Arena::AllocateFromHugePage"></a>Arena::AllocateFromHugePage</h3><p><code>Arena</code> 中有两种方式从操作系统获取内存：</p><ul><li><code>new</code>：即如<code>Arena::AllocateNewBlock</code> 函中数的实现；</li><li><code>mmap</code>：即如 <code>Arena::AllocateFromHugePage</code> 函数中的实现。</li></ul><p><code>mmap</code>、<code>munmap</code>函数的原型如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="comment">// 分配内存</span></span><br><span class="line"><span class="type">void</span>* <span class="title function_">mmap</span><span class="params">(<span class="type">void</span>* addr, <span class="type">size_t</span> len, <span class="type">int</span> prot, <span class="type">int</span> flags, <span class="type">int</span> fd, <span class="type">off_t</span> offset)</span>; </span><br><span class="line"><span class="comment">// 释放 mmap 分配的内存</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *addr, <span class="type">size_t</span> len)</span>;   </span><br></pre></td></tr></table></figure><p>使用<code>mmap</code>分配内存，需要<code>linux</code>内核支持  <a href="https://kernel.googlesource.com/pub/scm/linux/kernel/git/maz/arm-platforms/+/1da177e4c3f41524e886b7f1b8a0c1fc7321cac2/Documentation/vm/hugetlbpage.txt">HUGE_PAGE</a>，即当前linux内核具有 <code>MAP_HUGETLB</code> 标志位， 即可以如下操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">///@return 返回指针，指向当前分配的 block</span></span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateFromHugePage</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_ == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先使用 emplace_back 理由同上</span></span><br><span class="line">  huge_blocks_.<span class="built_in">emplace_back</span>(<span class="literal">nullptr</span> <span class="comment">/* addr */</span>, <span class="number">0</span> <span class="comment">/* length */</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用 mmap 从 hugepage 中分配 bytes 个字节</span></span><br><span class="line">  <span class="type">void</span>* addr = <span class="built_in">mmap</span>(<span class="literal">nullptr</span>, </span><br><span class="line">                    bytes, </span><br><span class="line">                    (PROT_READ | PROT_WRITE),</span><br><span class="line">                    (MAP_PRIVATE | MAP_ANONYMOUS | MAP_HUGETLB), <span class="comment">// 需要 MAP_HUGETLB 支持</span></span><br><span class="line">                    <span class="number">-1</span>, </span><br><span class="line">                    <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (addr == MAP_FAILED) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  huge_blocks_.<span class="built_in">back</span>() = <span class="built_in">MmapInfo</span>(addr, bytes);</span><br><span class="line">  blocks_memory_ += bytes;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(addr);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)bytes;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateFallback"><a href="#Arena-AllocateFallback" class="headerlink" title="Arena::AllocateFallback"></a>Arena::AllocateFallback</h3><p>好嘞，介绍完上面两种分配内存的措施，现在来看看统一上述两个操作的<code>AllocateFallback</code>函数。</p><p>当调用<code>AllocateFallback</code>函数时，是上层发现当前<code>block</code>中剩余的内存无法满足<code>bytes</code>个字节的需求，需要重新从操作系统获取内存。运行到<code>AllocateFallback</code>函数时，逻辑如下：</p><ul><li><p>如果所需的内存大小 <code>bytes</code> 超过了<code>kBlockSize / 4</code>，就直接从操作系统中获取<code>bytes</code>大小的内存，返回给<code>AllocateFallback</code>函数的调用方。那么就能避免浪费当前 block 中剩余的内存，这部分可以继续保留，供给下一次内存分配时使用。</p></li><li><p>否则，当前block中剩余的内存就将会被抛弃，重新从操作系统获中分配一个block的内存，供给上层使用。</p><p>此时，由 <code>bytes &lt;= kBlockSize / 4</code>，因此也降低了浪费，</p></li></ul><p>现在，顺着代码注释往下看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateFallback</span><span class="params">(<span class="type">size_t</span> bytes, <span class="type">bool</span> aligned)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (bytes &gt; kBlockSize / <span class="number">4</span>) &#123;</span><br><span class="line">    ++irregular_block_num;</span><br><span class="line">    <span class="comment">// 如果所需的内存大小 bytes 超过了 block 的1/4，那么就直接分配内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">AllocateNewBlock</span>(bytes);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> size = <span class="number">0</span>;</span><br><span class="line">  <span class="type">char</span>* block_head = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (hugetlb_size_) &#123;</span><br><span class="line">    <span class="comment">// mmap 分配的的一个block内存大小为 hugetlb_size_</span></span><br><span class="line">    size = hugetlb_size_;</span><br><span class="line">    block_head = <span class="built_in">AllocateFromHugePage</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (!block_head) &#123;</span><br><span class="line">    <span class="comment">// block_head == nullptr, 即当前linux内核不支 hugetlb</span></span><br><span class="line">    <span class="comment">// 那么使用 new 来分配内存</span></span><br><span class="line">    size = kBlockSize;</span><br><span class="line">    block_head = <span class="built_in">AllocateNewBlock</span>(size);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//! 之前block未使用的内存就忽略了，</span></span><br><span class="line">  <span class="comment">//! 但不会内存泄露，因为会在析构函数 ~Arena 中释放</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当前block划掉 bytes 个字节后，剩余的可用内存大小</span></span><br><span class="line">  alloc_bytes_remaining_ = size - bytes;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (aligned) &#123;</span><br><span class="line">    aligned_alloc_ptr_ = block_head + bytes; <span class="comment">// 从低地址端增加 bytes 字节</span></span><br><span class="line">    unaligned_alloc_ptr_ = block_head + size;</span><br><span class="line">    <span class="comment">// 表示 [block_head, block_head + bytes) 可用</span></span><br><span class="line">    <span class="keyword">return</span> block_head;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    aligned_alloc_ptr_ = block_head; </span><br><span class="line">    unaligned_alloc_ptr_ = block_head + size - bytes; <span class="comment">// 尾部向前推动 bytes</span></span><br><span class="line">    <span class="comment">// 表示 [unaligned_alloc_ptr_, unaligned_alloc_ptr_ + bytes) 可用</span></span><br><span class="line">    <span class="keyword">return</span> unaligned_alloc_ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-AllocateAligned"><a href="#Arena-AllocateAligned" class="headerlink" title="Arena::AllocateAligned"></a>Arena::AllocateAligned</h3><p>最后，就是对外提供分配对齐内存的函数 <code>AllocateAligned</code>。</p><p>其输入参数<code>huge_page_size</code>，语义是在使用mmap分配内存时的自定义 <code>alignment</code>，如果 <code>huge_page_size</code>  为 0，只是表示此时不需要自定义的<code>alignment</code>，使用默认的<code>kAlignUnit</code>即可。</p><p>换句话说，当需要自定义<code>alignment</code>时，RcoskDb 是准备使用<code>mmap</code>来分配内存。</p><p>当使用默认的<code>kAlignUnit</code>，如果当前block中剩余的可用内存能满足need个字节（need个字节，是bytes字节按照<code>kAlignUnit</code>对齐的后的大小），则继续从当前block中划分出去need个字节，否则就使用上述的<code>AllocateFallback</code>函数，重新从操作系统分配内存。</p><p>现在，顺着代码注释向下看。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">Arena::AllocateAligned</span><span class="params">(<span class="type">size_t</span> bytes, </span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">size_t</span> huge_page_size,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Logger* logger)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Pointer size should be a power of 2</span></span><br><span class="line">  <span class="built_in">assert</span>((kAlignUnit &amp; (kAlignUnit - <span class="number">1</span>)) == <span class="number">0</span>);  </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义的内存对齐值 huge_page_size，只使用mmap来分配</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">if</span> (huge_page_size &gt; <span class="number">0</span> &amp;&amp; bytes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(logger != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 将 bytes 向上调整到 huge_page_size 的整倍数</span></span><br><span class="line">    <span class="type">size_t</span> reserved_size = ((bytes - <span class="number">1U</span>) / huge_page_size + <span class="number">1U</span>) * huge_page_size;</span><br><span class="line">    <span class="built_in">assert</span>(reserved_size &gt;= bytes);</span><br><span class="line">    <span class="type">char</span>* addr = <span class="built_in">AllocateFromHugePage</span>(reserved_size);</span><br><span class="line">    <span class="keyword">if</span> (addr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">ROCKS_LOG_WARN</span>(logger,</span><br><span class="line">                     <span class="string">&quot;AllocateAligned fail to allocate huge TLB pages: %s&quot;</span>,</span><br><span class="line">                     <span class="built_in">errnoStr</span>(errno).<span class="built_in">c_str</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> addr;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  (<span class="type">void</span>)huge_page_size;</span><br><span class="line">  (<span class="type">void</span>)logger;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面则使用默认的 kAlignUnit 对齐大小</span></span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> current_mod =</span><br><span class="line">      <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(aligned_alloc_ptr_) &amp; (kAlignUnit - <span class="number">1</span>);</span><br><span class="line">  <span class="comment">// 计算距离对齐还差几个字节</span></span><br><span class="line">  <span class="type">size_t</span> slop = (current_mod == <span class="number">0</span> ? <span class="number">0</span> : kAlignUnit - current_mod);</span><br><span class="line">  <span class="comment">// 对齐后需分配的字节数</span></span><br><span class="line">  <span class="type">size_t</span> needed = bytes + slop;  </span><br><span class="line">  <span class="type">char</span>* result;</span><br><span class="line">  <span class="comment">// 当前block中的剩余内存是否能满足此次 needed 个字节需求</span></span><br><span class="line">  <span class="keyword">if</span> (needed &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    <span class="comment">// result 调整到对齐后的位置</span></span><br><span class="line">    result = aligned_alloc_ptr_ + slop; </span><br><span class="line">    <span class="comment">// 调整到对齐后的位置</span></span><br><span class="line">    aligned_alloc_ptr_ += needed;  </span><br><span class="line">    <span class="comment">// block中剩余的字节数</span></span><br><span class="line">    alloc_bytes_remaining_ -= needed;   </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果当前 block 剩余的内存不足，则从操作系统获取</span></span><br><span class="line">    result = <span class="built_in">AllocateFallback</span>(bytes, <span class="literal">true</span> <span class="comment">/* aligned */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">assert</span>((<span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(result) &amp; (kAlignUnit - <span class="number">1</span>)) == <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>by the way</strong></p><p>这里稍微总结下，如何向上调整、计算对齐后的地址。</p><p>实际上计算的方法有很多种，但是都符合上一期 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析] 最后提到了一点：本质上就是以「<code>alignment</code>进制」向上（下）取为<code>alignment</code>的整倍数。</p><p>比如，在十进制下，12向上取整为10的倍数，即20。</p><p>理解了这一层之后，再来看看下面几个计算方式：</p><ul><li><p>case 1：<code>size_t aligned = ((bytes - 1U) / alignment + 1U) * alignment</code></p><p>单纯地将<code>bytes</code>向上调整为<code>alignment</code>的整倍数，可以实现为  <code>(bytes / alignment + 1U) * alignment</code>，那为啥要 <code>- 1</code> 呢？</p><p>如果<code>bytes</code>本身就已是<code>alignment</code>的整数，按照这 native 实现，会无端将<code>bytes</code>增加了<code>alignment</code>。为了应对这种情况，需要先减少1。</p><p>此外，在 <code>Arena::Arena</code> 中调整<code>hugetlb_size_</code> 时，也是如此计算。而在<code>OptimizeBlockSize</code>函数中，调整<code>block_size</code>时，可以确定<code>block_size</code> 不是 <code>kAlignUnit</code>的整数时，就可将<code>-1</code>去掉，简化如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (block_size % kAlignUnit != <span class="number">0</span>) &#123;</span><br><span class="line">  block_size = (<span class="number">1</span> + block_size / kAlignUnit) * kAlignUnit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>case 2：<code>size_t aligned = (bytes - 1u + alignment) &amp; -alignment</code></p><p>这种实现，利用位位运算将余数清除，效率较高，这也是<code>std::align</code> 函数的实现方式，这在 [内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析] 分析过，这里顺带再解释下。</p><p>其中 <code>alignment</code> 是无符号数，<code>-alignment</code> 的值实际上是 <code>::pow(2, n) - alignment</code>。那么<code>bytes - 1u + alignment</code> 对 <code>-alignment</code> 取 <code>&amp;</code>操作，就能保证 <code>bytes - 1u + alignment</code> 的高位不变，而小于<code>alignment</code> 的余数全部清除。 </p></li></ul><p>万变不离其宗，理解了这个逻辑，无论是向上调整、亦或是向下调整，都能很好理解了。</p><h3 id="Arena-Allocate"><a href="#Arena-Allocate" class="headerlink" title="Arena::Allocate"></a>Arena::Allocate</h3><p>讲完了上面<code>AllocateAligned</code>函数之后，再看<code>Allocate</code>函数，就非常好理解了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">char</span>* <span class="title">Arena::Allocate</span><span class="params">(<span class="type">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(bytes &gt; <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 如果当前block剩余足够的内存，则直接分配</span></span><br><span class="line">  <span class="keyword">if</span> (bytes &lt;= alloc_bytes_remaining_) &#123;</span><br><span class="line">    unaligned_alloc_ptr_ -= bytes;</span><br><span class="line">    alloc_bytes_remaining_ -= bytes;</span><br><span class="line">    <span class="keyword">return</span> unaligned_alloc_ptr_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 不用对齐</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">AllocateFallback</span>(bytes, <span class="literal">false</span> <span class="comment">/* unaligned */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arena-Arena-1"><a href="#Arena-Arena-1" class="headerlink" title="Arena::~Arena"></a>Arena::~Arena</h3><p>释放所有已分配的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Arena::~<span class="built_in">Arena</span>() &#123;</span><br><span class="line">  <span class="comment">// 释放所有使用 new 分配的内存</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; block : blocks_) &#123;</span><br><span class="line">    <span class="keyword">delete</span>[] block;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MAP_HUGETLB</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; mmap_info : huge_blocks_) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mmap_info.addr_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放所有使用 mmap 分配的内存</span></span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">munmap</span>(mmap_info.addr_, mmap_info.length_);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// TODO(sdong): Better handling</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Say-Something"><a href="#Say-Something" class="headerlink" title="Say Something"></a>Say Something</h2><p>一个优秀的开源项目，其单元测试（unitest）也是很好的学习资料。尤其对于RocksDB这类比较大的项目，无法下手的话，可以先从单元测试着手。</p><p>下一期，讲解下多线程内存分配器的设计，会更加硬核，敬请期待。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天，就开始逐步更新剖析 RocksDB 源码的博客。思前想后，准备自下而上，因此还是从内存分配器开始叭。&lt;/p&gt;
&lt;p&gt;在 RocksDB 中主要有两类内存分配器&lt;code&gt;MemoryAllocator&lt;/code&gt;、&lt;code&gt;Allocator&lt;/code&gt;。&lt;/p</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
    <category term="RocksDB" scheme="https://szza.github.io/tags/RocksDB/"/>
    
  </entry>
  
  <entry>
    <title>内存对齐之 alignof、alignas 、aligned_storage、align 深度剖析</title>
    <link href="https://szza.github.io/2022/01/01/C++/0_align/"/>
    <id>https://szza.github.io/2022/01/01/C++/0_align/</id>
    <published>2022-01-01T06:09:54.000Z</published>
    <updated>2023-07-31T16:36:10.684Z</updated>
    
    <content type="html"><![CDATA[<p>关于内存对齐，有诸多好处，因此常常在分配内存时也会将内存对齐这一因素纳入考量。</p><p>这一节，来讲下内存对齐以及C++11中关于内存对齐引入的<code>alignof</code>、<code>alignas</code>、<code>std::aligned_storage</code>、<code>std::align</code> ，其中前两个为关键字，后两个分别为类和函数。</p><h2 id="alignment"><a href="#alignment" class="headerlink" title="alignment"></a>alignment</h2><p>我们知道，C++中的内置的基础类型，比如<code>char</code>、<code>int</code>、<code>float</code>、<code>double</code>，在内存布局上都是按照其 <code>sizeof</code> 大小进行对齐（alignment）。</p><p>什么叫对齐？</p><p>比如，<code>sizoef(int)</code> 值为 4，如果满足内存对齐要求，那么int类型变量<code>a</code>的地址<code>&amp;a</code>对4取余的结果应该是0。</p><p>下面提供一个编译期就能检测内存对齐的宏 <code>CHECK_ALIGN</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CHECK_ALIGN(ptr, alignment)                       \</span></span><br><span class="line"><span class="meta">  do&#123;                                                     \</span></span><br><span class="line"><span class="meta">    constexpr size_t status                               \</span></span><br><span class="line"><span class="meta">       = reinterpret_cast<span class="string">&lt;uintptr_t&gt;</span>(ptr) % alignment;    \</span></span><br><span class="line"><span class="meta">    static_assert(status == 0, <span class="string">&quot;ptr must be aligned&quot;</span>);    \</span></span><br><span class="line"><span class="meta">  &#125;while(0)                                               \</span></span><br></pre></td></tr></table></figure><p>下面我们来校验内置类型的内存对齐大小确实等于其<code>sizoef(T)</code>值，demo如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">long</span> l ;</span><br><span class="line">  <span class="type">float</span> f;</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;c, <span class="built_in">sizeof</span>(c));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;i, <span class="built_in">sizeof</span>(i));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;l, <span class="built_in">sizeof</span>(l));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;f, <span class="built_in">sizeof</span>(f));</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;i, <span class="built_in">sizeof</span>(l)); <span class="comment">// 编译错误</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述demo中的 <code>CHECK_ALIGN(&amp;i, sizeof(l));</code> 会导致编译错误，因为<code>int</code>类型变量的内存对齐大小要求是4，而<code>long</code>在gcc下是8个字节，即<code>sizoef(l)</code>为8，故而编译失败。</p><p>到此，我相信你应该明白何为「内存对齐」了。</p><h2 id="alignof"><a href="#alignof" class="headerlink" title="alignof"></a>alignof</h2><p>C++11引入的关键字<code>alignof</code>，可直接获取类型<code>T</code>的内存对齐要求。<code>alignof</code>的返回值类型是<code>size_t</code>，用法类似于<code>sizeof</code>。</p><p>下面先来看看<code>alignof</code>的用法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHOW_SIZEOF_AND_ALIGNOF(T)                                   \</span></span><br><span class="line"><span class="meta">  do &#123;                                                               \</span></span><br><span class="line"><span class="meta">    std::cout &lt;&lt; <span class="string">&quot;sizeof(&quot;</span> &lt;&lt; #T &lt;&lt; <span class="string">&quot;):\t&quot;</span> &lt;&lt; sizeof(T) &lt;&lt; <span class="string">&quot;,\t&quot;</span>     \</span></span><br><span class="line"><span class="meta">              &lt;&lt; <span class="string">&quot;alignof(&quot;</span> &lt;&lt; #T &lt;&lt; <span class="string">&quot;):\t&quot;</span> &lt;&lt; alignof(T)            \</span></span><br><span class="line"><span class="meta">              &lt;&lt; std::endl;                                          \</span></span><br><span class="line"><span class="meta">  &#125;while(0)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">char</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">int</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">long</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">float</span>);</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(<span class="type">double</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下，这也是符合前文关于基础类型内存对齐的论述。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(char):   1,      alignof(char):  1</span><br><span class="line">sizeof(int):    4,      alignof(int):   4</span><br><span class="line">sizeof(long):   8,      alignof(long):  8</span><br><span class="line">sizeof(<span class="built_in">float</span>):  4,      alignof(<span class="built_in">float</span>): 4</span><br><span class="line">sizeof(double): 8,      alignof(double):8</span><br></pre></td></tr></table></figure><p>好，到此我相信你已经对内存对齐和<code>alignof</code>有了基本了解。下面我们来看看类的内存对齐。</p><p>现在有类<code>Foo</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1; </span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>考虑下<code>alignof(Foo)</code>和<code>sizeof(Foo)</code>分别会是多少，即下面的demo会输出？？？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(Foo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Think Again~~~~</p><p>3</p><p>2</p><p>1</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(Foo):    24,     alignof(Foo):   8</span><br></pre></td></tr></table></figure><p>嗯？怎么会是这个结果？</p><p>为了更好地解释这个结果，我准备借助<code>offsetof</code>函数，来获取成员变量距离类起始地址的偏移量，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Offset of member MEMBER in a struct of type TYPE. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> offsetof(OBJECT_TYPE, MEMBER) __builtin_offsetof (OBJECT_TYPE, MEMBER)</span></span><br></pre></td></tr></table></figure><p>好，现在看下如下代码，并猜测下输出？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="built_in">offsetof</span>(Foo, c)  &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">offsetof</span>(Foo, i1) &lt;&lt; <span class="string">&#x27;\n&#x27;</span> </span><br><span class="line">            &lt;&lt; <span class="built_in">offsetof</span>(Foo, i2) &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">            &lt;&lt; <span class="built_in">offsetof</span>(Foo, l)  &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">0   <span class="comment"># c 的偏移量为 0 </span></span><br><span class="line">4   <span class="comment"># i1 的偏移量为 4， c  -&gt; i1 中间填充了 3个字节，才满足 4 字节的内存对齐要求</span></span><br><span class="line">8   <span class="comment"># i2 的偏移量为 8,  i1 -&gt; i2 无填充</span></span><br><span class="line">16  <span class="comment"># l 的偏移量为 16， i2 -&gt; l  中间填充了4个字节，才满足8字节的内存对齐要求</span></span><br></pre></td></tr></table></figure><p>好，到此，我准备基于这个输出来解释<code>alignof</code>了。</p><p>对于<code>Foo</code>而言，所谓内存对齐，即<code>Foo</code>中每个字段都要满足内存对齐。而内存对齐最严格（即对齐字节数最大）的字段满足了，其他的字段也就满足了。</p><p>假设现在有三个起始地址，分别是 0、1、4，我们来看看是否都能满足<code>Foo</code>中所有字段的内存对齐要求。</p><p>起始地址分别0、1、4，各个字段的地址如下三列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;   </span><br><span class="line">  <span class="type">char</span> c;     <span class="comment">// 0  |  1  |  4</span></span><br><span class="line">  <span class="type">int</span> i1;     <span class="comment">// 4  |  5  |  8</span></span><br><span class="line">  <span class="type">int</span> i2;     <span class="comment">// 8  |  9  |  12 </span></span><br><span class="line">  <span class="type">long</span> l;     <span class="comment">// 16 |  17 |  20</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从上面的右侧三列结果可以看出，只有起始地址为0（8的整倍数）的恰好能满足所有字段内存对齐的要求。因此，<code>alignof(Foo)</code>输出为8。</p><h2 id="alignas"><a href="#alignas" class="headerlink" title="alignas"></a>alignas</h2><p>上面讲述的内存对齐要求都是默认情况下的，有时候考虑到cacheline、以及向量化操作，可能会需要改变一个类的<code>alignof</code>值。</p><p>怎么办？</p><p>在C++11之前，需要依赖靠编译器的扩展指令，C++11之后可以借助<code>alignas</code>关键字。</p><blockquote><p>比如，在C++11之前，gcc实现 <code>alignas(alignment)</code> 效果的方式为  <code>__attribute__((__aligned__((alignment)))</code></p></blockquote><p>仍然以上述的<code>Foo</code>为例子，不过此时你希望<code>Foo</code>对象的起始地址总是32的倍数，C++11之后借助<code>alignas</code>关键字，可以如下操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>) Foo &#123; </span><br><span class="line">  <span class="built_in">Foo</span>() &#123; std::cout &lt;&lt; <span class="keyword">this</span> &lt;&lt; std::endl; &#125;</span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1; </span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">  Foo foo;</span><br><span class="line">  <span class="built_in">CHECK_ALIGN</span>(&amp;foo, <span class="built_in">alignof</span>(foo));</span><br><span class="line">  <span class="built_in">SHOW_SIZEOF_AND_ALIGNOF</span>(Foo);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">0x16d6f34e0</span><br><span class="line">sizeof(Foo):    32,     alignof(Foo):   32</span><br></pre></td></tr></table></figure><p>说完<code>alignas</code>的基础用法，下面说下使用<code>alignas</code>时的注意事项，即<code>alignas(alignment)</code>中的<code>alignment</code>也不是随意写的，对于类型<code>T</code>，需要满足如下两个条件。</p><h3 id="1-alignment-gt-alignof-T"><a href="#1-alignment-gt-alignof-T" class="headerlink" title="1. alignment &gt;= alignof(T)"></a>1. alignment &gt;= alignof(T)</h3><p>仍然以<code>Foo</code>为例，在没有<code>alignas</code>修饰时，默认的Foo的内存对齐要求<code>alignof(Foo)</code>为8，现在尝试使用<code>alignas</code>让<code>Foo</code>的对齐要求为4，操作如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">4</span>) Foo &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1;</span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时 <code>SHOW_SIZEOF_AND_ALIGNOF(Foo);</code>的输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">sizeof(Foo):    24,     alignof(Foo):   8</span><br></pre></td></tr></table></figure><p>可以看出，此时的<code>alignas</code>是失效的，在其他编译器下也许直接编译失败。</p><h3 id="2-alignment-pow-2-N"><a href="#2-alignment-pow-2-N" class="headerlink" title="2. alignment == pow(2, N)"></a>2. alignment == pow(2, N)</h3><p>即<code>alignas</code> 指定的大小<code>alignment</code>必须是2的正数幂（<code>N&gt;0</code>），否则也是失效，在有些编译器下也许直接编译失败。</p><p>仍然以<code>Foo</code>为例子，</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">9</span>) Foo &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1;</span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>编译如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ main.cc -o main &amp;&amp; ./main</span><br><span class="line">main.cc:<span class="number">20</span>:<span class="number">19</span>: error: requested alignment <span class="string">&#x27;9&#x27;</span> is <span class="keyword">not</span> a positive power of <span class="number">2</span></span><br><span class="line">   <span class="number">20</span> | <span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">9</span>) Foo &#123;</span><br><span class="line">      |                   ^~~</span><br></pre></td></tr></table></figure><p>好，到此，我想你应该大致理解了<code>alignof</code>和<code>alignas</code>两个关键字，更多用法可以参`<a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a>。</p><h2 id="std-aligned-storage"><a href="#std-aligned-storage" class="headerlink" title="std::aligned_storage"></a>std::aligned_storage</h2><p>在C++11中，也引入了一个满足内存对齐要求的静态内存分配类<code>std::aligned_storage</code>，其类模板原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &lt;type_traits&gt;</span></span><br><span class="line"><span class="keyword">template</span>&lt; std::<span class="type">size_t</span> Len, </span><br><span class="line">          std::<span class="type">size_t</span> Align = <span class="comment">/*default-alignment*/</span> &gt;</span><br><span class="line"><span class="keyword">struct</span> aligned_storage;</span><br></pre></td></tr></table></figure><p>类<code> std::aligned_storage</code>对象构造完成时，即分配了长度为<code>Len</code>个字节的内存，且该内存满足大小为 <code>Align</code> 的对齐要求。</p><p>下面，我们先来看看 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a> 给的一个demo，来熟悉下怎么使用<code>std::aligned_storage</code>。</p><p>类 <code>StaticVector</code> ，是一个满足内存对齐要求的静态数组，模板参数<code>T</code>是元素类型，<code>N</code>是数组元素个数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticVector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">StaticVector</span>() &#123; </span><br><span class="line">      std::cout &lt;&lt; <span class="built_in">alignof</span>(T) &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(T)&lt;&lt; std::endl;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> idx = <span class="number">0</span>; idx &lt; N; ++idx) &#123; </span><br><span class="line">        std::cout &lt;&lt; &amp;data[idx] &lt;&lt; std::endl;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">StaticVector</span>() &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">size_t</span> pos = <span class="number">0</span>; pos &lt; m_size; ++pos) &#123;</span><br><span class="line">        <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(data+pos)-&gt;~<span class="built_in">T</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ...Args&gt; </span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">emplace_back</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(m_size &gt;= N) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::bad_alloc&#123;&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">new</span>(data+m_size) <span class="built_in">T</span>(std::forward&lt;Args&gt;(args)...);</span><br><span class="line">      ++m_size;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="type">const</span> T&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> pos) <span class="type">const</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> *<span class="built_in">reinterpret_cast</span>&lt;<span class="type">const</span> T*&gt;(data+pos);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// std::aligned_storage&lt;sizeof(T), alignof(T)&gt;::type data[N]; // C++11</span></span><br><span class="line">  std::<span class="type">aligned_storage_t</span>&lt;<span class="built_in">sizeof</span>(T), <span class="built_in">alignof</span>(T)&gt; data[N];        <span class="comment">// c++14</span></span><br><span class="line">  <span class="type">size_t</span> m_size = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类<code>StaticVector</code>的使用如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">alignas</span>(<span class="number">32</span>) Foo &#123; </span><br><span class="line">  <span class="type">char</span> c;</span><br><span class="line">  <span class="type">int</span> i1; </span><br><span class="line">  <span class="type">int</span> i2;</span><br><span class="line">  <span class="type">long</span> l;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    StaticVector&lt;std::string, <span class="number">2</span>&gt; v1;</span><br><span class="line">    v1.<span class="built_in">emplace_back</span>(<span class="number">5</span>, <span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    std::cout &lt;&lt; v1[<span class="number">0</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    StaticVector&lt;Foo, <span class="number">2</span>&gt;v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在输出前，我们预测下：</p><ul><li><code>std:::string</code> 的<code>alignof</code>值是8，那么<code>StaticVector</code>分配的两个<code>std::string</code>对象地址，都应该是8的倍数</li><li><code>Foo</code>的<code>alignof</code>值是32，那么<code>StaticVector</code>为<code>Foo</code> 分配的两个<code>Foo</code>对象地址，都是32的倍数，</li></ul><p>好，现在我们来看下输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align_stroe.cc -o as &amp;&amp; ./as</span><br><span class="line">8/32</span><br><span class="line">0x16b5734c0</span><br><span class="line">0x16b5734e0</span><br><span class="line">*****</span><br><span class="line">32/32</span><br><span class="line">0x16b573470</span><br><span class="line">0x16b573490</span><br></pre></td></tr></table></figure><p>所以，到此，你也许理解了<code>std::aligned_storage</code> 中<code>aligned</code>的含义，即每个对象都是经过内存对齐的。</p><p>熟悉了<code>std::aligned_storage</code> 的用法，现在来看看他的实现叭，毕竟没人愿意只做个调包侠（滑稽脸）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in std namespace;</span></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> _Len&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__aligned_storage_msa</span> &#123;</span><br><span class="line">  <span class="keyword">union</span> <span class="title class_">__type</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> __data[_Len];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">__attribute__</span>((__aligned__)) &#123; &#125; __align;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span> _Len, </span><br><span class="line">      std::<span class="type">size_t</span> _Align = <span class="built_in">alignof</span>(<span class="keyword">typename</span> __aligned_storage_msa&lt;_Len&gt;::__type)&gt;</span><br><span class="line"><span class="keyword">struct</span> aligned_storage &#123;</span><br><span class="line">  <span class="keyword">union</span> type &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> __data[_Len];</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">alignas</span>(_Align) &#123; &#125; __align;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 <code>std::aligned_storage</code> 内部，是通过一个<code>union</code>来实现的：</p><ul><li><code>unsigned char __data[_Len];</code>：这一行保证了分配的内存大小是<code>_Len</code>个字节</li><li><code>struct alignas(_Align) &#123; &#125; __align;</code> ：这一行保证了分配的内存是按照<code>Align</code> 大小进行对齐的。</li></ul><p>其中，第二点很好理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> data[<span class="number">16</span>];</span><br><span class="line">    <span class="built_in">alignas</span>(<span class="number">16</span>) <span class="type">char</span> aligned_data[<span class="number">16</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;unaligned: &quot;</span>&lt;&lt; <span class="built_in">alignof</span>(data) &lt;&lt; <span class="string">&quot;, aligned: &quot;</span> &lt;&lt; <span class="built_in">alignof</span>(aligned_data) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unaligned: <span class="number">1</span>, aligned: <span class="number">16</span></span><br></pre></td></tr></table></figure><p>因此，如果只有<code>unsigned char __data[_Len]；</code>，无法保证内存对齐，需要<code>struct alignas(_Align) &#123; &#125; __align</code>的辅助。</p><p>最后再提下 <code>std::__aligned_storage_msa</code>的必要性：在构造类<code>std::aligned_storage</code>对象时，如果没有指定类的第二个模板参数<code>_Align</code>，即内存对齐大小，由<code>std::__aligned_storage_msa</code>为你设置默认的内存对齐大小。</p><p>可以看出，在 <code>std::__aligned_storage_msa</code> 的实现中，<code>__attribute__((__aligned__))</code> 后面是没有参数的，此时gcc即会根据平台生成默认内存对齐大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">1</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">4</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">16</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">alignof</span>(std::__aligned_storage_msa&lt;<span class="built_in">sizeof</span>(<span class="number">32</span>)&gt;::__type) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align_stroe.cc -o as &amp;&amp; ./as</span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="number">16</span></span><br></pre></td></tr></table></figure><p>这个大小就是gcc编译器默认的内存大小。</p><h2 id="std-align"><a href="#std-align" class="headerlink" title="std::align"></a>std::align</h2><p>类<code>std::aligned_storage</code> 是一个静态的内存对齐分配器，即在类<code>std::aligned_storage</code>对象构造完时，就已满足设定内存大小、内存对齐要求，但是如果现在有一块内存，想从中取出一块符合某对齐要求的内存，咋办？</p><p>此时就可以使用<code>std::align</code>函数，其函数原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param  alignment 是想要分配的内存符合的内存对齐大小</span></span><br><span class="line"><span class="comment">/// @param  size 想要分配内存的大小</span></span><br><span class="line"><span class="comment">/// @param  ptr 是个输入输出参数，输入时指向待使用的内存，输出时调整为符合alignment对齐要求的内存地址</span></span><br><span class="line"><span class="comment">/// @param  space 是ptr指向的内存剩余的空间</span></span><br><span class="line"><span class="comment">/// @return 如果 ptr 经过调整后能满足大小为 alignment 的对齐要求，则返回ptr的值，否则返回 nullptr</span></span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">align</span><span class="params">( std::<span class="type">size_t</span> alignment,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::<span class="type">size_t</span> size,</span></span></span><br><span class="line"><span class="params"><span class="function">             <span class="type">void</span>*&amp; ptr,</span></span></span><br><span class="line"><span class="params"><span class="function">             std::<span class="type">size_t</span>&amp; space)</span></span>;</span><br></pre></td></tr></table></figure><p>下面，我们继续先来看看 <a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cpprefernece</a> 中提供的一个demo，熟悉下怎么使用<code>std::align</code>这个函数。</p><p>类<code>Arena</code>内已有一块缓冲区<code>buffer</code>，每次调用<code>AlignedAllocate&lt;T&gt;(size_t alignment)</code>函数时，即需要从<code>buffer</code>中取出大小为<code>sizeof(T)</code>的一块内存<code>ptr</code>，<code>AlignedAllocate</code>函数的输入参数<code>alignment</code>指定了获得的内存<code>ptr</code>满足的内存对齐要求。</p><p>现在来看看实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Arena</span> &#123;</span><br><span class="line">  <span class="type">char</span> buffer[N];</span><br><span class="line">  <span class="type">void</span>* ptr;</span><br><span class="line">  <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Arena</span>() : <span class="built_in">ptr</span>(buffer), <span class="built_in">size</span>(N) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @return 返回的指针满足大小为 alignment 的内存对齐要求</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">  <span class="function">T* <span class="title">AlignedAllocate</span><span class="params">(<span class="type">size_t</span> alignment = <span class="keyword">alignof</span>(T))</span> </span>&#123;</span><br><span class="line">      std::cout &lt;&lt; <span class="string">&quot;ptr: &quot;</span> &lt;&lt; <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span>*&gt;(ptr) &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">      <span class="keyword">if</span> (std::<span class="built_in">align</span>(alignment, <span class="built_in">sizeof</span>(T), ptr, size)) &#123;</span><br><span class="line">          T* result = <span class="built_in">reinterpret_cast</span>&lt;T*&gt;(ptr);</span><br><span class="line">          ptr = (<span class="type">char</span>*)ptr + <span class="built_in">sizeof</span>(T);</span><br><span class="line">          size -= <span class="built_in">sizeof</span>(T);</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 若无，则返回 nullptr</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    Arena&lt;<span class="number">64</span>&gt; arena;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>* p1 = arena.<span class="built_in">AlignedAllocate</span>&lt;<span class="type">char</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p1) *p1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocated a char at &quot;</span> &lt;&lt; (<span class="type">void</span>*)p1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span>* p2 = arena.<span class="built_in">AlignedAllocate</span>&lt;<span class="type">int</span>&gt;();</span><br><span class="line">    <span class="keyword">if</span> (p2) *p2 = <span class="number">1</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocated an int at &quot;</span> &lt;&lt; (<span class="type">void</span>*)p2 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="type">int</span>* p3 = arena.<span class="built_in">AlignedAllocate</span>&lt;<span class="type">int</span>&gt;(<span class="number">32</span>);</span><br><span class="line">    <span class="keyword">if</span> (p3) *p3 = <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;allocated an int at &quot;</span> &lt;&lt; (<span class="type">void</span>*)p3 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从下面的输出可以看出，<code>AlignedAllocate</code> 函数返回的内存地址都是符合设定的内存对齐要求的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ g++ align.cc -o align &amp;&amp; ./align </span><br><span class="line">ptr: 0x16fc2b4b8, allocated a char at 0x16fc2b4b8     <span class="comment"># 1 byte 内存对齐，指针无须调整</span></span><br><span class="line">ptr: 0x16fc2b4b9, allocated an int at 0x16fc2b4bc     <span class="comment"># 4 byte 内存对齐，指针调整了 3 个字节</span></span><br><span class="line">ptr: 0x16fc2b4c0, allocated an int at 0x16fc2b4c0     <span class="comment"># 32 byte 内存对齐，指针无须调整</span></span><br></pre></td></tr></table></figure><p>最后，我们再来看看<code>std::align</code>函数的实现，稍微简化后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// in &lt;memory&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span>* <span class="title">align</span><span class="params">(<span class="type">size_t</span> __align, <span class="type">size_t</span> __size, <span class="type">void</span> *&amp;__ptr, <span class="type">size_t</span> &amp;__space)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> __intptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(__ptr);</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> __aligned = (__intptr - <span class="number">1u</span> + __align) &amp; -__align;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">auto</span> __diff = __aligned - __intptr;</span><br><span class="line">  <span class="comment">// 如果没有剩余的空间，直接返回 nullptr</span></span><br><span class="line">  <span class="keyword">if</span> ((__size + __diff) &gt; __space)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">   __space -= __diff;</span><br><span class="line">   <span class="keyword">return</span> __ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">void</span> *&gt;(__aligned);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::align</code>的实现里，最为关键的一步，即计算对齐后的地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> __aligned = (__intptr - <span class="number">1u</span> + __align) &amp; -__align;</span><br></pre></td></tr></table></figure><p>对于这一步，本来想写个证明啥的，还是举个例子来解释比较通俗。</p><p>按照<code>__align</code>大小进行内存对齐，即可视为按<code>__align</code>进制向上取整。</p><p>什么意思呢？</p><p>比如说，现在按照10进制对齐，有地址12，想让12向上调整到10的倍数，怎么做？</p><ol><li>先加上一个步长：<code>12 + 10 - 1 = 21</code></li><li>将余数1清掉：<code>21 &amp;  (-10) = 20</code>。这一步中，<code>-10</code> 的本质就是保证高位不变，将低位全部变为0，取<code>&amp;</code>之后，取余就全部清理了。</li></ol><p>现在的内存对齐，本质上也是向上取整：<code>__intptr - 1u + __align</code>是为了向前一个步长，再对  <code>-__align</code>取<code>&amp;</code>，来清除余数。</p><p>关于内存对齐，很多项目里都有涉及，最近在阅读RocksDB也再次遇到，于是乎就找了个契机写下了这篇博客，后续会尝试更新RocksDB。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于内存对齐，有诸多好处，因此常常在分配内存时也会将内存对齐这一因素纳入考量。&lt;/p&gt;
&lt;p&gt;这一节，来讲下内存对齐以及C++11中关于内存对齐引入的&lt;code&gt;alignof&lt;/code&gt;、&lt;code&gt;alignas&lt;/code&gt;、&lt;code&gt;std::aligned_s</summary>
      
    
    
    
    <category term="深入了解 Modern C++" scheme="https://szza.github.io/categories/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>从 std::auto_ptr 到 std::unique_ptr 到进化之路</title>
    <link href="https://szza.github.io/2021/12/21/C++/unique_ptr/"/>
    <id>https://szza.github.io/2021/12/21/C++/unique_ptr/</id>
    <published>2021-12-21T04:47:23.000Z</published>
    <updated>2022-02-14T14:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>从本期，就开始智能指针源码分析之路，从源码中了解他们的设计。</p><p>智能指针，可以分为两类：</p><ul><li>独占型：如<code>std::unique_ptr</code>，一份资源，仅能由一个<code>std::unique_ptr</code>对象管理；</li><li>共享型：如<code>std::shared_ptr</code>，一份资源，可以由多个<code>std::shared_ptr</code>对象共同管理，当没有<code>std::shared_ptr</code>对象指向这份的资源，资源才会被释放，即基于引用技术原理。</li></ul><p>本期，先来讲解<code>std::unique_ptr</code>，之后会分几期来讲解<code>std::shared_ptr</code>的设计。</p><p>不过，在讲解<code>std::unique_ptr</code>之前，先讲解下C++03中的失败品：<code>std::auto_ptr</code>。</p><h2 id="std-auto-ptr"><a href="#std-auto-ptr" class="headerlink" title="std::auto_ptr"></a>std::auto_ptr</h2><p>原本也是想要将 <code>std::auto_ptr</code> 设计成资源独占型的指针，即像现在的<code>std::unique_ptr</code>，但由于移动语义直到C++11中才出现，使得<code>std::auto_ptr</code>终究成了失败品。</p><p>不明白，没关系，go on。</p><p>在C++03标准下，有如下demo中的一个场景。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> <span class="type">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">iptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line">    std::vector&lt;std::auto_ptr&lt;<span class="type">int</span>&gt; &gt; integer_vec;</span><br><span class="line"></span><br><span class="line">    integer_vec.<span class="built_in">push_back</span>(iptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在C++03标准中还没有引入移动语义，只能以<code>push_back</code>函数向<code>vector</code>中添加元素。</p><p>如果你没接触过<code>std::auto_ptr</code>，应该会认为上面的demo是能编译通过的，但实际上是无法编译通过的。</p><p>编译指令如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -std=c++<span class="number">03</span>  main.cc -o main &amp;&amp; ./main</span><br></pre></td></tr></table></figure><p>下面只贴出最初的错误信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc<span class="number">-8.2</span>/include/c++/<span class="number">8.2</span><span class="number">.0</span>/ext/new_allocator.h:<span class="number">146</span>:<span class="number">9</span>: error: no matching function <span class="keyword">for</span> call to ‘std::auto_ptr&lt;<span class="type">int</span>&gt;::<span class="built_in">auto_ptr</span>(<span class="type">const</span> std::auto_ptr&lt;<span class="type">int</span>&gt;&amp;)’</span><br><span class="line">       &#123; ::<span class="keyword">new</span>((<span class="type">void</span> *)__p) _Tp(__val); &#125;</span><br><span class="line">         ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure><p>先给出导致错误的结论：是由于类<code>std::auto_ptr</code> 没有提供<code>const std::auto_ptr&lt;T&gt;&amp;</code>类型的复制构造函数。</p><p>那为啥会没有呢？</p><p>因为<code>std::auto_ptr</code>的设计者，想使<code>std::auto_ptr</code>的复制构造函数具备移动构造函数的属性（如果不懂右值、移动等内容，可以看看 <a href="https://mp.weixin.qq.com/s?__biz=MzkyMjIxMzIxNA==&mid=2247483868&idx=1&sn=3271bc5f1694818a493fd54185b341dd&chksm=c1f68fedf68106fb21fedd83136aa39a1ed01761ad68018d9bedd1591d9241cb8838432d634b&token=1599630750&lang=zh_CN#rd">右值引用的正确用法</a>），这就使得<code>std::auto_ptr</code>复制构造函数的输入参数<code>__a</code>不能由 const 修饰，否则<code>__a</code>指向的资源就无法移动到新创建的对象中了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto_ptr</span>(auto_ptr&amp; __a) <span class="keyword">throw</span>() : _M_ptr(__a.<span class="built_in">release</span>()) &#123;&#125; </span><br></pre></td></tr></table></figure><p>这就导致<code>std::auto_ptr</code>中，所有和赋值有关的操作，都不能有<code>const</code>修饰。</p><p><code>std::auto_ptr</code>的核心代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  _Tp *_M_ptr;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> _Tp element_type;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">auto_ptr</span><span class="params">(element_type *__p = <span class="number">0</span>)</span> <span class="title">throw</span><span class="params">()</span> : _M_ptr(__p) &#123;</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">auto_ptr</span>(auto_ptr&amp; __a) <span class="keyword">throw</span>() : _M_ptr(__a.<span class="built_in">release</span>()) &#123;&#125; </span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">  <span class="built_in">auto_ptr</span>(auto_ptr&lt;_Tp1&gt;&amp; __a) <span class="built_in">throw</span>() : _M_ptr(__a.<span class="built_in">release</span>()) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  auto_ptr &amp;<span class="keyword">operator</span>=(auto_ptr&amp; __a) <span class="built_in">throw</span>() &#123;</span><br><span class="line">    <span class="built_in">reset</span>(__a.<span class="built_in">release</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">auto_ptr</span>() &#123; <span class="keyword">delete</span> _M_ptr; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">element_type* <span class="title">release</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    element_type *__tmp = _M_ptr;</span><br><span class="line">    _M_ptr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> __tmp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(element_type *__p = <span class="number">0</span>)</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (__p != _M_ptr) &#123;</span><br><span class="line">      <span class="keyword">delete</span> _M_ptr;</span><br><span class="line">      _M_ptr = __p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="by-the-way"><a href="#by-the-way" class="headerlink" title="by the way"></a>by the way</h3><p>对于最上面的demo，我们再啰嗦几点：为什么会在 <code>construct</code>函数中报错？</p><ol><li><p>因为<code>push_back</code>函数中，输入参数<code>__x</code>是<code>const std::auto_ptr&amp;</code>类型，能接受<code>iptr</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Alloc&gt; </span><br><span class="line"><span class="type">void</span> std::vector&lt;_Tp, _Alloc&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> value_type&amp; __x);</span><br></pre></td></tr></table></figure></li><li><p>在<code>push_back</code>函数内部会调用 <code>_Alloc_traits::construct</code> 函数来构造一个新的<code>std::auto_ptr</code>对象<code>obj</code>，然后将这个<code>obj</code>放到<code>integer_vec</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_Alloc_traits::<span class="built_in">construct</span>(<span class="keyword">this</span>-&gt;_M_impl, <span class="keyword">this</span>-&gt;_M_impl._M_finish, __x);</span><br></pre></td></tr></table></figure></li><li><p>因为要构造<code>obj</code>，那么必要会调用<code>std::auto_ptr</code>的复制构造函数，且输入参数是<code>__x</code>；</p></li><li><p>但由于<code>__x</code> 是 <code>const std::auto_ptr&amp;</code> 类型，二<code>std::auto_ptr</code>的复制构造函数输入类型是<code>std::auto_ptr&amp;</code>，接受不了<code>__x</code>作为输入，因此会导致<code>construct</code>函数执行失败。出现上述的错误。</p></li></ol><h2 id="std-unique-ptr"><a href="#std-unique-ptr" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h2><p>C++11引入移动语义，提出了<code>std::unique_ptr</code>，才真正地完成了<code>std::auto_ptr</code>的设计意图，而原本的<code>std::auto_ptr</code>也被标记为<code>deprecated</code>。</p><p>由于 <code>std::unique_ptr</code> 对象管理的资源，不可共享，只能在 <code>std::unique_ptr</code> 对象之间转移，因此类<code>std::unique_ptr</code> 就禁止了复制构造函数、赋值表达式，仅实现了移动构造函数等。</p><p>此外，<code>std::unique_ptr</code> 有两个版本：</p><ol><li>管理单个对象（例如以 <code>new</code> 分配）</li><li>管理动态分配的对象数组（例如以 <code>new[]</code> 分配）</li></ol><p>因此， <code>std::unique_ptr</code> 的类模板有如下两个。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 适合 new 分配的内存</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr &#123; <span class="comment">/****/</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 针对 new[] 特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_ptr</span>&lt;_Tp[], _Dp&gt; &#123; <span class="comment">/****/</span> &#125;;</span><br></pre></td></tr></table></figure><p>在下面的情况中，<code>std::unique_ptr</code>对象管理的资源，会调用传入的析构器<code>_Dp</code>来释放放资源：</p><ul><li>当前<code>std::unique_ptr</code> 对象被销毁，生命周期结束；</li><li>重新给当前<code>std::unique_ptr</code>对象赋值，比如调用 <code>operator=</code>、<code>reset()</code> 等操作。</li></ul><p>下面就先讲解下默认的析构器<code>std::default_delete</code>。</p><h3 id="std-default-delete"><a href="#std-default-delete" class="headerlink" title="std::default_delete"></a>std::default_delete</h3><p>由于<code>std::unique_ptr</code> 有两个版本，因此默认的析构器也存在两个版本，即对<code>new[]</code> 进行特化。</p><p>此外，这就导致后文的<code>make_unique</code> 函数也需要对<code>new[]</code>进行特化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span> &#123; <span class="comment">/****/</span> &#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span>&lt;_Tp[]&gt; &#123; <span class="comment">/****/</span> &#125;;</span><br></pre></td></tr></table></figure><p>由于默认采用<code>new</code>、<code>new[]</code>来分配内存的，而<code>sd::default_delete</code> 实际上是个仿函数，内部也是基于<code>delete</code>、<code>delete[]</code>来释放内存资源的。</p><h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>类<code>std::default_delete</code>  实际上是个仿函数，并且是个空类，因此他的默认构造函数直接设置为<code>default</code>了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/// @brief 默认构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 复制构造函数</span></span><br><span class="line">  <span class="comment">///        _Up* 必须能转为 _Tp*，否则无法编译通过</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, </span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up*, _Tp*&gt;::value&gt;::type&gt;</span><br><span class="line">  <span class="built_in">default_delete</span>(<span class="type">const</span> default_delete&lt;_Up&gt;&amp; ) <span class="keyword">noexcept</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 释放内存</span></span><br><span class="line">  <span class="type">void</span> <span class="built_in">operator</span>()(_Tp *__ptr) <span class="type">const</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，<code>std::default_delete</code> 还有个复制构造函数，这里传入<code>_Up*</code>参数 必须能转换为 <code>_Tp*</code> 类型，否则在编译期会报错。所谓<code>_Up*</code> 能转换为 <code>_Tp*</code>，即<code>is_convertible&lt;_Up*, _Tp*&gt;::value</code> 为 true，这个值在编译期就能确定，如果为false，就相当于不存在这个复制构造函数。</p><p>不信，可以把下面的代码复制到IDE中，会有红线提示，编译会出错。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::is_convertible&lt;<span class="type">float</span>*, <span class="type">double</span>*&gt;::value;                  <span class="comment">// false: float* 不能直接转换为 double*</span></span><br><span class="line"><span class="function">std::default_delete&lt;<span class="type">double</span>&gt; <span class="title">de</span><span class="params">(std::default_delete&lt;<span class="type">float</span>&gt;&#123;&#125;)</span></span>; <span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><p>在<code>std::default_delete</code>的内部，实现的<code>operator()</code> 函数会调用<code>delete</code>来 析构传入的指针<code>__ptr</code>，对于<code>__ptr</code>需要满足两点：</p><ul><li><code>__ptr</code>不能是个<code>void</code>类型；</li><li>大小也不能是0。</li></ul><p>否则无法提供完整的信息去析构<code>__ptr</code>指向的内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(_Tp *__ptr)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">static_assert</span>(!is_void&lt;_Tp&gt;::value, <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">  <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(_Tp) &gt; <span class="number">0</span>, <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">  <span class="keyword">delete</span> __ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，你就可以这样来使用<code>std::default_delete</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* iptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">std::<span class="built_in">default_delete</span>&lt;<span class="type">int</span>&gt;()(iptr); <span class="comment">// delete iptr;</span></span><br></pre></td></tr></table></figure><p>使用<code>valgrind</code>检测也不存在内存泄露。</p><h4 id="delete-1"><a href="#delete-1" class="headerlink" title="delete[]"></a>delete[]</h4><p>当输入类型是<code>_Tp[]</code>时，会进入此版本。实现和上面的版本差不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">default_delete</span>&lt;_Tp[]&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// @brief 默认构造函数</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">default_delete</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 复制构造函数</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, </span><br><span class="line">            <span class="keyword">typename</span> = <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up (*)[], _Tp (*)[]&gt;::value&gt;::type&gt;</span><br><span class="line">  <span class="built_in">default_delete</span>(<span class="type">const</span> default_delete&lt;_Up[]&gt; &amp;) <span class="keyword">noexcept</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 释放内存</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">            <span class="keyword">typename</span> enable_if&lt;is_convertible&lt;_Up (*)[], _Tp (*)[]&gt;::value&gt;::type</span><br><span class="line">  <span class="built_in">operator</span>()(_Up *__ptr) <span class="type">const</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">sizeof</span>(_Tp) &gt; <span class="number">0</span>, <span class="string">&quot;can&#x27;t delete pointer to incomplete type&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span>[] __ptr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，这样就可以使用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* iptr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>];</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">std::<span class="built_in">default_delete</span>&lt;<span class="type">int</span>[]&gt;()(iptr); </span><br></pre></td></tr></table></figure><p>使用<code>valgrind</code>检查也没有任何内存泄露。</p><p>因此，<code>std::default_delete</code> 对两种常用的内存释放方式进行重载，提供了同一个统一接口。</p><h3 id="std-uniq-ptr-impl"><a href="#std-uniq-ptr-impl" class="headerlink" title="std::__uniq_ptr_impl"></a>std::__uniq_ptr_impl</h3><p>类<code>std::unique_ptr</code> 内部只有一个成员变量，其类型是 <code>std::__uniq_ptr_impl</code>。</p><p>类<code>std::__uniq_ptr_impl</code>实际上就一个<code>&lt;pointer, Deleter&gt;</code>的一个wrapper，即简单封装了指向资源的指针，以及对应的析构器 <code>Deleter</code>。</p><p>先大致看下<code>std::__uniq_ptr_impl</code>的部分实现。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">__uniq_ptr_impl</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> _DeleterConstraint = enable_if&lt;__and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;, </span><br><span class="line">                                              is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;</span><br><span class="line">  </span><br><span class="line">  __uniq_ptr_impl() = <span class="keyword">default</span>;</span><br><span class="line">  __uniq_ptr_impl(pointer __p) : _M_t() &#123; _M_ptr() = __p; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del&gt;</span><br><span class="line">  __uniq_ptr_impl(pointer __p, _Del&amp;&amp; __d)</span><br><span class="line">  : _M_t(__p, std::forward&lt;_Del&gt;(__d)) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  pointer&amp;   _M_ptr()           &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">  pointer    _M_ptr()     <span class="type">const</span> &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(_M_t); &#125;</span><br><span class="line">  _Dp&amp;       _M_deleter()       &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line">  <span class="type">const</span> _Dp&amp; _M_deleter() <span class="type">const</span> &#123; <span class="keyword">return</span> std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(_M_t); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(__uniq_ptr_impl&amp; __rhs)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;_M_ptr(), __rhs._M_ptr());</span><br><span class="line">    std::<span class="built_in">swap</span>(<span class="keyword">this</span>-&gt;_M_deleter(), __rhs._M_deleter());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  tuple&lt;pointer, _Dp&gt; _M_t; <span class="comment">// pointer 的定义后文讲解</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类<code>std::__uniq_ptr_impl</code> 的成员变量<code>_M_t</code>是由<code>tuple</code>类型：</p><ul><li>第一个成员：是指针，指向资源；</li><li>第二个成员：是析构器，用于释放指针指向的资源。</li></ul><p>由于在X86-84位系统上指针大小是8，而<code>_Dp</code>在默认情况下（即<code>std::default_delete</code>）是个空类，得益于<a href="https://mp.weixin.qq.com/s?__biz=MzkyMjIxMzIxNA==&mid=2247485249&idx=1&sn=f395397f1621cf8a4d897d0213ca1788&chksm=c1f68970f68100666cbb65313780797bc65490703dac02a9603e0b9733fa01db270ca445f0e6&token=1599630750&lang=zh_CN#rd">空基类优化</a>，因此<code>_M_t</code> 的大小是8。</p><blockquote><p><strong>NOTICE</strong>：如果自定义了一个<code>Deleter</code>，且不是空类，则<code>std::unique_ptr</code>的大小会增加。</p></blockquote><p>下面，来分析下<code>std::__uniq_ptr_impl</code> 中的 <code>pointer</code>类型，他的完整实现及注释如下。</p><p>因此，当<code>_Dp</code>是默认的析构器<code>std::default_delete</code>时，<code>pointer</code> 即 <code>_Tp*</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp&gt;</span><br><span class="line"> <span class="keyword">class</span> <span class="title class_">__uniq_ptr_impl</span></span><br><span class="line"> &#123;    </span><br><span class="line">   <span class="comment">/// 原型</span></span><br><span class="line">   <span class="comment">/// @brief 特化版本决议失败，则会进入此版本</span></span><br><span class="line">   <span class="comment">/// @type  此时 type 就是 _up*</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep, <span class="keyword">typename</span> = <span class="type">void</span>&gt;</span><br><span class="line">   <span class="keyword">struct</span> _Ptr</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">using</span> type = _Up*;</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/// 特化版本</span></span><br><span class="line">   <span class="comment">/// @brief 如果 类 _Ep 中有 pointer 的定义，则会进入此特化版本</span></span><br><span class="line">   <span class="comment">/// @type  此时 type 是 _Ep 中的 pointer </span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line">   <span class="keyword">struct</span> <span class="title class_">_Ptr</span>&lt;_Up, _Ep, <span class="type">__void_t</span>&lt;<span class="keyword">typename</span> remove_reference&lt;_Ep&gt;::type::pointer&gt;&gt;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">using</span> type = <span class="keyword">typename</span> remove_reference&lt;_Ep&gt;::type::pointer;</span><br><span class="line">   &#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="keyword">using</span> pointer = <span class="keyword">typename</span> _Ptr&lt;_Tp, _Dp&gt;::type;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"> &#125;；</span><br></pre></td></tr></table></figure><h3 id="std-unique-ptr-1"><a href="#std-unique-ptr-1" class="headerlink" title="std::unique_ptr"></a>std::unique_ptr</h3><p>分析的进度终于到了类<code>std::unique_ptr</code>，它的设计主要如下四点：</p><ol><li>禁止复制构造函数、复制赋值的重载，即设置为<code>=delete</code>；</li><li>实现各种移动构造函数；</li><li>实现移动赋值重载，即<code>operator=</code>，需要先释放本身的资源，再将对方的资源移动过来；</li><li>如果资源没有释放过，则会在析构函数中释放。</li></ol><p>为便于理解，先看下<code>std::unique_ptr</code>的部分源码及其注释，另一个特化版本差不多。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span> _Dp = default_delete&lt;_Tp&gt;&gt;</span><br><span class="line"><span class="keyword">class</span> unique_ptr</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up&gt;</span><br><span class="line">  <span class="keyword">using</span> _DeleterConstraint = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Up&gt;::_DeleterConstraint::type;</span><br><span class="line"></span><br><span class="line">  __uniq_ptr_impl&lt;_Tp, _Dp&gt; _M_t; <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">typename</span> __uniq_ptr_impl&lt;_Tp, _Dp&gt;::pointer;</span><br><span class="line">  <span class="keyword">using</span> element_type = _Tp;</span><br><span class="line">  <span class="keyword">using</span> deleter_type = _Dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// 用于检测从另一个 std::unique_ptr 对象转换过来是否安全</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line">  <span class="keyword">using</span> __safe_conversion_up = __and_&lt;is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Up, _Ep&gt;::pointer, pointer&gt;,</span><br><span class="line">                                      __not_&lt;is_array&lt;_Up&gt;&gt;&gt;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/*** Move constructors. ***/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 移动构造函数</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">  : _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>())) &#123; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 移动赋值</span></span><br><span class="line">  unique_ptr&amp; <span class="keyword">operator</span>=(unique_ptr&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">reset</span>(__u.<span class="built_in">release</span>()); </span><br><span class="line">    <span class="built_in">get_deleter</span>() = std::forward&lt;deleter_type&gt;(__u.<span class="built_in">get_deleter</span>());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 设置 unique_ptr 对象为初始化状态</span></span><br><span class="line">  unique_ptr&amp; <span class="keyword">operator</span>=(<span class="type">nullptr_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 禁止复制</span></span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  unique_ptr &amp;<span class="keyword">operator</span>=(<span class="type">const</span> unique_ptr &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  ~<span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(__is_invocable&lt;deleter_type&amp;, pointer&gt;::value,</span><br><span class="line">                  <span class="string">&quot;unique_ptr&#x27;s deleter must be invocable with a pointer&quot;</span>);</span><br><span class="line">    <span class="keyword">auto</span>&amp; __ptr = _M_t._M_ptr();</span><br><span class="line">    <span class="keyword">if</span> (__ptr != <span class="literal">nullptr</span>)</span><br><span class="line">       <span class="built_in">get_deleter</span>()(std::<span class="built_in">move</span>(__ptr)); <span class="comment">// 析构</span></span><br><span class="line">    __ptr = <span class="built_in">pointer</span>();                  <span class="comment">// 设置为初始化状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 返回指针</span></span><br><span class="line">  <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123; <span class="keyword">return</span> _M_t._M_ptr(); &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/// @brief 返回一个指向内部的deleter的引用</span></span><br><span class="line">  <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _M_t._M_deleter();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Return @c true if the stored pointer is not null.</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">get</span>() == <span class="built_in">pointer</span>() ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Release ownership of any stored pointer.</span></span><br><span class="line">  <span class="function">pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    pointer __p = <span class="built_in">get</span>();</span><br><span class="line">    _M_t._M_ptr() = <span class="built_in">pointer</span>();</span><br><span class="line">    <span class="keyword">return</span> __p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(pointer __p = pointer())</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(__is_invocable&lt;deleter_type &amp;, pointer&gt;::value,</span><br><span class="line">                  <span class="string">&quot;unique_ptr&#x27;s deleter must be invocable with a pointer&quot;</span>);</span><br><span class="line">    std::<span class="built_in">swap</span>(_M_t._M_ptr(), __p);</span><br><span class="line">    <span class="keyword">if</span> (__p != <span class="built_in">pointer</span>())</span><br><span class="line">      <span class="built_in">get_deleter</span>()(std::<span class="built_in">move</span>(__p));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(unique_ptr &amp;__u)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(__is_swappable&lt;_Dp&gt;::value, <span class="string">&quot;deleter must be swappable&quot;</span>);</span><br><span class="line">    _M_t.<span class="built_in">swap</span>(__u._M_t);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::unique_ptr</code> 的设计总体比较清晰。</p><p>到此，<code>std::unique_ptr</code>的设计分析差不多就结束了，下面对源码中（上面未列出）几个模板稍微分析下。</p><h4 id="DeleterConstraint"><a href="#DeleterConstraint" class="headerlink" title="_DeleterConstraint"></a>_DeleterConstraint</h4><p><code>_DeleterConstraint</code> 定义于<code>std::__uniq_ptr_impl</code>之中，用于限制传入的析构器<code>Deleter</code>必须满足以下两点：</p><ol><li>传入的<code>Deleter</code> 不能是指针；</li><li>必须具备默认构造函数。</li></ol><p>否则，<code>std::unique_ptr</code> 的构造函数会失败。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> _DeleterConstraint = enable_if&lt;__and_&lt;__not_&lt;is_pointer&lt;_Dp&gt;&gt;, </span><br><span class="line">                                        is_default_constructible&lt;_Dp&gt;&gt;::value&gt;;</span><br><span class="line">   </span><br><span class="line"><span class="comment">/// 构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Del&gt;&gt;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="built_in">unique_ptr</span>() <span class="keyword">noexcept</span></span><br><span class="line">: _M_t()</span><br><span class="line">&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = _Dp, <span class="keyword">typename</span> = _DeleterConstraint&lt;_Del&gt;&gt;</span><br><span class="line"><span class="keyword">explicit</span> <span class="built_in">unique_ptr</span>(pointer __p) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p)</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="Require"><a href="#Require" class="headerlink" title="_Require"></a>_Require</h4><p>其原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... _Cond&gt;</span><br><span class="line"><span class="keyword">using</span> _Require = <span class="type">__enable_if_t</span>&lt;__and_&lt;_Cond...&gt;::value&gt;;</span><br></pre></td></tr></table></figure><p><code>_Require</code>模板是要求所有传入的条件<code>Cond</code>都为true，则<code>_Require</code>修饰的函数才会存在。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 如果传入的 _Del 没有复制构造函数，则unique_ptr此版本构造函数就不存在</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = deleter_type,</span><br><span class="line">          <span class="keyword">typename</span> = _Require&lt;is_copy_constructible&lt;_Del&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p, <span class="type">const</span> deleter_type&amp; __d) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p, __d) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 如果传入的 _Del 没有移动构造函数，则 unique_ptr此版本构造函数就不存在</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Del = deleter_type,</span><br><span class="line">          <span class="keyword">typename</span> = _Require&lt;is_move_constructible&lt;_Del&gt;&gt;&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>(pointer __p, <span class="type">__enable_if_t</span>&lt;!is_lvalue_reference&lt;_Del&gt;::value, _Del&amp;&amp;&gt; __d) <span class="keyword">noexcept</span></span><br><span class="line">: _M_t(__p, std::<span class="built_in">move</span>(__d))</span><br><span class="line">&#123; &#125;</span><br></pre></td></tr></table></figure><h4 id="safe-conversion-up"><a href="#safe-conversion-up" class="headerlink" title="__safe_conversion_up"></a>__safe_conversion_up</h4><p>在构造函数中，有时候需要通过其他<code>std::unique_ptr</code>对象来构造当前<code>std::unique_ptr</code>对象，但是<code>pointer</code>类型可能不同，模板<code>__safe_conversion_up</code>可以在编译期确定是否可以转换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, <span class="keyword">typename</span> _Ep&gt;</span><br><span class="line"><span class="keyword">using</span> __safe_conversion_up = __and_&lt;is_convertible&lt;<span class="keyword">typename</span> unique_ptr&lt;_Up, _Ep&gt;::pointer, pointer&gt;,</span><br><span class="line">                                    __not_&lt;is_array&lt;_Up&gt;&gt;&gt;;</span><br></pre></td></tr></table></figure><p>此外还有个条件模板<code>conditional</code>，实现编译期的条件表达式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// _Cond ? _Iftrue ： _Iffalse;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">bool</span> _Cond, <span class="keyword">typename</span> _Iftrue, <span class="keyword">typename</span> _Iffalse&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> _Iftrue type; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Iftrue, <span class="keyword">typename</span> _Iffalse&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">conditional</span>&lt;<span class="literal">false</span>, _Iftrue, _Iffalse&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> _Iffalse type; &#125;;</span><br></pre></td></tr></table></figure><p>最终，可以用于构造函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 由其他std::unique_ptr对象 __u 构造this</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Up, </span><br><span class="line">          <span class="keyword">typename</span> _Ep, </span><br><span class="line">          <span class="keyword">typename</span> = _Require&lt;__safe_conversion_up&lt;_Up, _Ep&gt;,   <span class="comment">// 先判断指针，必须可转换</span></span><br><span class="line">          <span class="keyword">typename</span> conditional&lt;is_reference&lt;_Dp&gt;::value,        <span class="comment">// 再判断析构器</span></span><br><span class="line">                               is_same&lt;_Ep, _Dp&gt;,               </span><br><span class="line">                               is_convertible&lt;_Ep, _Dp&gt;&gt;::type&gt;&gt;</span><br><span class="line"> <span class="built_in">unique_ptr</span>(unique_ptr&lt;_Up, _Ep&gt;&amp;&amp; __u) <span class="keyword">noexcept</span></span><br><span class="line"> : _M_t(__u.<span class="built_in">release</span>(), std::forward&lt;_Ep&gt;(__u.<span class="built_in">get_deleter</span>()))</span><br><span class="line"> &#123; &#125;</span><br></pre></td></tr></table></figure><h3 id="std-make-unique"><a href="#std-make-unique" class="headerlink" title="std::make_unique"></a>std::make_unique</h3><p>最后，再来看下<code>std::make_unique</code> 函数，它在C++14中引入，这在之前的’编译器优化之copy elision’一期中也讲解过怎么设计它。</p><p>现在，我们再来看看C++14中 <code>std::make_unique()</code> 的实现，如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*** 返回类型 ***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 原型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MakeUniq</span></span><br><span class="line">&#123; <span class="keyword">typedef</span> unique_ptr&lt;_Tp&gt; __single_object; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 为数组类型特化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MakeUniq</span>&lt;_Tp[]&gt;</span><br><span class="line">&#123; <span class="keyword">typedef</span> unique_ptr&lt;_Tp[]&gt; __array; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief 无效</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="type">size_t</span> _Bound&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_MakeUniq</span>&lt;_Tp[_Bound]&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">__invalid_type</span> &#123; &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*** 函数实现 ***/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// std::make_unique for single objects</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> _MakeUniq&lt;_Tp&gt;::<span class="function">__single_object <span class="title">make_unique</span><span class="params">(_Args&amp;&amp; ...__args)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> _Tp(std::forward&lt;_Args&gt;(__args)...)); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// std::make_unique for arrays of unknown bound</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> _MakeUniq&lt;_Tp&gt;::<span class="function">__array <span class="title">make_unique</span><span class="params">(<span class="type">size_t</span> __num)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;_Tp&gt;(<span class="keyword">new</span> <span class="type">remove_extent_t</span>&lt;_Tp&gt;[__num]()); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// Disable std::make_unique for arrays of known bound</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="keyword">inline</span> </span><br><span class="line"><span class="keyword">typename</span> _MakeUniq&lt;_Tp&gt;::<span class="function">__invalid_type <span class="title">make_unique</span><span class="params">(_Args&amp;&amp; ...)</span> </span>= <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure><p>结束，再回顾下<code>std::unique_ptr</code> 和 <code>std::auto_ptr</code>。</p><p>可以发现<code>std::auto_ptr</code>的失败在于CXX03中并不支持移动语义，而<code>std::auto_ptr</code> 却试图用复制构造函数来实现移动构造函数的功能，结果导致其无法与<code>vector</code> 等容器兼容，论为失败品。</p><p><code>std::unique_ptr</code> 的分析为止。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从本期，就开始智能指针源码分析之路，从源码中了解他们的设计。&lt;/p&gt;
&lt;p&gt;智能指针，可以分为两类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;独占型：如&lt;code&gt;std::unique_ptr&lt;/code&gt;，一份资源，仅能由一个&lt;code&gt;std::unique_ptr&lt;/code&gt;对</summary>
      
    
    
    
    <category term="深入了解 Modern C++" scheme="https://szza.github.io/categories/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3-Modern-C/"/>
    
    
    <category term="Modern C++" scheme="https://szza.github.io/tags/Modern-C/"/>
    
  </entry>
  
  <entry>
    <title>异步通信</title>
    <link href="https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/"/>
    <id>https://szza.github.io/2021/12/09/Redis/%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1/</id>
    <published>2021-12-09T03:40:15.000Z</published>
    <updated>2022-02-14T14:14:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异步通信"><a href="#异步通信" class="headerlink" title="异步通信"></a>异步通信</h1><p>之前有两期讲解了服务端框的架构，这一期来讲下服务器是如何与客户端进行异步通信的，下一期再讲述客户端是如何异步非阻塞connect服务器的。</p><ul><li>通信，无外乎两点：1）服务器读取对端发送过来的数据；2）向对端发送数据。</li><li>异步，目前常用的是<code>epoll</code> + 回调函数。</li></ul><p>下面从非阻塞IO开始，逐步构建异步通信框架。</p><h2 id="Non-Blocking-IO"><a href="#Non-Blocking-IO" class="headerlink" title="Non-Blocking IO"></a>Non-Blocking IO</h2><p>在服务端常用的IO读写操作，主要是<code>read</code>、<code>write</code>及其衍生函数。</p><p>所谓阻塞模式，也是<code>read</code>、<code>write</code>等操作的默认行为，比如<code>read</code>函数从<code>stdin</code>读取输入，如果用户没有从终端输入，则会一直阻塞在<code>read</code>函数处。</p><p>在非阻塞模式下，<code>read</code>继续从终端读取数据，如果用户没有在终端输入数据，<code>read</code>函数并不会阻塞等待，而是立即返回-1，并将错误码<code>errno</code> 设置为<code>EAGAIN</code> 或者 <code>EWOULDBLOCK</code>。此时<code>read</code>函数返回值<code>n</code>有三种可能：</p><ul><li><code>n &gt; 0</code>：读取到<code>n</code>个字节；</li><li><code>n == 0</code>：对端关闭、文件末尾；</li><li><code>n == -1</code>：表示遇到问题，<ul><li><code>errno == EAGAIN/EWOULDBLOCK </code>：在非阻塞IO模式下，表示没有数据可读，可忽略本次<code>read</code>操作；</li><li><code>errno == EINTR</code>：表示被信号中断，重新读取一次即可。</li><li>其他错误类型。</li></ul></li></ul><p>写操作<code>write</code>函数也基本类似，更加详细可以<code>man 2 read/write</code> 查看。</p><p>因此，非阻塞IO非常适合服务器设计，不会在<code>read/write</code>处发生堵塞。</p><p>将文件描述符fd设置为非阻塞模式，有如下两种方式（来自muduo）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setNonBlockAndCloseOnExec</span><span class="params">(<span class="type">int</span> sockfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> flags = ::<span class="built_in">fcntl</span>(sockfd, F_GETFL, <span class="number">0</span>);</span><br><span class="line">  flags |= O_NONBLOCK;</span><br><span class="line">  <span class="type">int</span> ret = ::<span class="built_in">fcntl</span>(sockfd, F_SETFL, flags);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// close-on-exec</span></span><br><span class="line">  flags = ::<span class="built_in">fcntl</span>(sockfd, F_GETFD, <span class="number">0</span>);</span><br><span class="line">  flags |= FD_CLOEXEC;</span><br><span class="line">  ret = ::<span class="built_in">fcntl</span>(sockfd, F_SETFD, flags);</span><br><span class="line"></span><br><span class="line">  (<span class="type">void</span>)ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sockets::createNonblockingOrDie</span><span class="params">(<span class="type">sa_family_t</span> family)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> VALGRIND</span></span><br><span class="line">  <span class="comment">// 方式1 </span></span><br><span class="line">  <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(family, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;sockets::createNonblockingOrDie&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">setNonBlockAndCloseOnExec</span>(sockfd);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">// 方式2：系统内核支持 SOCK_NONBLOCK 标志，更加安全。</span></span><br><span class="line">  <span class="type">int</span> sockfd = ::<span class="built_in">socket</span>(family, SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC, IPPROTO_TCP);</span><br><span class="line">  <span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_SYSFATAL &lt;&lt; <span class="string">&quot;sockets::createNonblockingOrDie&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ET-amp-LT"><a href="#ET-amp-LT" class="headerlink" title="ET &amp; LT"></a>ET &amp; LT</h2><p>众所周知，<code>epoll</code>有两种工作模式：<code>ET </code>&amp; <code>LT</code>。但是在讲解 ET &amp; LT 之前，先讲解下「高电平」和「低电平」的概念。</p><h3 id="高低电平"><a href="#高低电平" class="headerlink" title="高低电平"></a>高低电平</h3><p>对于可读事件：</p><ul><li>内核中<code>socket</code>的<code>recv_buff </code> 为空，此时为「低电平」状态，即无数据可读</li><li>内核中<code>socket</code>的<code>recv_buff </code> 不空，此时为「高电平」状态，此时有数据可读</li></ul><p>对于可写事件：</p><ul><li>内核中<code>socket</code>的<code>send_buff</code>为满 ，此时为「低电平」状态，不可发送数据</li><li>内核中<code>socket</code>的<code>send_buff</code>不满，此时为「高电平」状态，可发送数据</li></ul><p>简而言之，「低电平」状态下不能进行读、写操作，「高电平」则可以读、写。</p><p>为便于描述，<code>socket</code>的接受缓冲区定义为<code>recv_buff</code>，<code>socket</code>的发送缓冲区定义为<code>send_buff</code>，<code>connfd</code>是服务端与对端建立连接的文件描述符。</p><h3 id="LT（Level-Triggered）"><a href="#LT（Level-Triggered）" class="headerlink" title="LT（Level Triggered）"></a>LT（Level Triggered）</h3><p>LT，电平触发，即socket缓冲区处于高电平时触发事件。此外，<code>epoll_wait</code>的默认工作模式也是LT。</p><h4 id="可读事件"><a href="#可读事件" class="headerlink" title="可读事件"></a>可读事件</h4><p>为接受对端<code>connfd</code>发送的数据，服务器首先要为<code>connfd</code>注册可读事件<code>EPOLLIN</code>。</p><p>如此，当对端发送数据过来，服务器<code>connfd</code>的<code>recv_buff </code> 不为空，则<code>epoll_wait</code>上的可读事件触发，在读回调函数<code>HandleRead</code>中从<code>socket</code>的<code>recv_buff </code> 中读取数据。</p><p>然而，即使服务端本次没有将scoket<code>recv_buff </code> 中的数据全部读取，下次调用<code>epoll_wait</code>时也依然会触发可读事件。</p><p>为啥？</p><p>因为，只要<code>recv_buff </code> 中的数据没有读取完，即为「高电平」状态，那么就会一直触发<code>epoll_wait</code>的<code>EPOLLIN</code> 事件，直到<code>recv_buff </code> 变空，即为「低电平」状态。</p><p>因此<code>LT</code>模式下，不用担心数据漏读的问题。</p><h4 id="可写事件"><a href="#可写事件" class="headerlink" title="可写事件"></a>可写事件</h4><p>然而，可写事件与可读事件不同：可读事件是被动触发的，即服务端不知道对端何时发送数据。因此服务端与对端建立连接之后，要立即为<code>connfd</code>注册可读事件，然后在<code>epoll_wait</code>上阻塞等待客户端发送数据过来。</p><p>那么，可写事件呢？是服务端主动触发的。</p><p>服务端与对端建立连接后，<code>connfd</code>的<code>send_buff</code>是空的，即处于高电平，是可以直接发送数据的。</p><p>如果此时为<code>connfd</code>注册可写事件，这就会导致<code>epoll_wait</code>一直检测到<code>connfd</code>上的可写事件触发，但实际上服务端又没有数据可以发送给对端，造成服务端的CPU资源无端被消耗。</p><p>因此，在<code>LT</code>模式下，当服务端要向对端发送数据时，不需要先通过<code>epoll_ctl</code>注册可写事件，然后阻塞在<code>epoll_wait</code>上等待可写事件的发生。<font color=red> 正确的做法如下</font>：</p><ul><li>直接发送数据 <code>n = write(connfd, outbuffer, sizeof(outbuffer))</code>；</li><li>如果此次数据没有发送完毕，即<code>n != sizeof(outbuffer)</code>，则为<code>connfd</code>注册可写事件；</li><li>在<code>epoll_wait</code>上等待可写事件触发；</li><li>可写事件触发，则将剩余的数据发送完毕；</li><li>如果没有发送完毕，则等待下次的可写事件；发送完毕，则取消关注可写事件。</li></ul><p><strong>注意</strong>：当数据发送完毕，一定要取消可写事件，否则当<code>connfd</code>的<code>send_buff</code>变空，后面又没有可发的数据，则又会导致<code>epoll_wait</code>一直触发可写事件。</p><h3 id="ET（Edge-Triggered）"><a href="#ET（Edge-Triggered）" class="headerlink" title="ET（Edge Triggered）"></a>ET（Edge Triggered）</h3><p>ET，所谓边缘触发，即只有在电平状态发生变化时才会触发。开启ET模式，需要设置如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> ev;</span><br><span class="line">ev.events = EPOLLIN | EPOLLET; <span class="comment">// ET 模式</span></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epollfd, EPOLL_CTL_ADD, connfd, &amp;ev);</span><br></pre></td></tr></table></figure><h4 id="可读事件-1"><a href="#可读事件-1" class="headerlink" title="可读事件"></a>可读事件</h4><p>注册了可读事件后，阻塞于<code>epoll_wait</code>等待对端发送数据，再触发可读事件。</p><p><strong>注意</strong>：如果服务端没有将<code>recv_buff </code> 中的数据全部读取，那么进入下一轮循环并阻塞在<code>epoll_wait</code>后，可读事件就再也不会触发。</p><p>为啥？</p><p>在<code>ET</code>模式下，只有<code>connfd</code>的<code>recv_buffer</code>电平状态发生变化才会触发可读事件，但只要<code>recv_buff </code> 中还有数据，则一直为高电平状态，那么即便下次对端又发送数据过来，并不会改<code>recv_buff </code> 的电平状态，这就导致<code>epoll_wait</code>就无法再检测到<code>connfd</code>上的可读事件。</p><p>那么对端发送了数据，服务端迟迟无法给出回应。如果是<code>listenfd</code>，那么这个服务器就不再能处理新的连接请求了。</p><p>因此，如果不熟悉<code>ET</code>模式的正确使用方法，很可能导致整个服务器无法使用。</p><p>那<code>ET</code>模式下，怎么处理可读事件？</p><p>一旦检测到<code>connfd</code>上的可读事件，需要不停地从<code>recv_buff </code> 中读取数据，直到<code>read</code>函数返回<code>-1</code>，且错误码<code>errno</code>是<code>EAGAIN</code>标志。</p><p>这标志着<code>recv_buff </code> 中的数据已经读取完（已处于低电平），下次对端再发送数据过来（变为高电平），就能再次触发可读事件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(; ; ;) &#123; </span><br><span class="line">  ret = <span class="built_in">read</span>(connfd, buffer, <span class="built_in">sizeof</span>(buffer));</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span> &amp;&amp; errno == EAGAIN) &#123; </span><br><span class="line">     <span class="built_in">LOG</span>(NOTICE) &lt;&lt; <span class="string">&quot;READ DONE&quot;</span>;</span><br><span class="line">     <span class="keyword">break</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>但是又有一个问题：</p><ul><li><code>read</code>函数，什么情况下才会返回<code>EAGAIN</code>？</li><li>要是<code>read</code> 函数不返回<code>EAGAIN</code>，那么岂不是一直在<code>while/for</code>循环？</li></ul><p>仅在<code>connfd</code>设置为非阻塞模式时，<code>read</code>函数无法从空的<code>recv_buff</code>继续读取到数据，此时错误码<code>errno</code>就会被设置为<code>EAGAIN</code>。</p><h4 id="可写事件-1"><a href="#可写事件-1" class="headerlink" title="可写事件"></a>可写事件</h4><p>ET模式下，在与客户端建立连接后，<strong>可以为<code>connfd</code>注册可写事件</strong>，因为此时<code>connfd</code>的<code>send_buff</code>是空的，处于高电平，不会触发可写事件。</p><p>当服务端要通过<code>connfd</code>向客户端发送数据时，直接发送即可：</p><ul><li><p>如果应用层缓冲区<code>outbuffer</code>的数据大小小于<code>send_buff</code>大小，则无须任何操作；</p><p>换言之，<code>connfd</code>的<code>send_buff</code>能容纳<code>outbuffer</code>中的全部数据，那么<code>send_buff</code>依然未满，即处于高电平状态。下次应用层有待发送的数据，直接发送即可；</p></li><li><p>如果<code>outbuffer</code>中的数据大小大于<code>send_buff</code>大小，那么<code>write(connfd, outbuffer, size)</code>返回-1 且 <code>errno</code>是<code>EAGAIN</code>。</p><p>由于<code>send_buff</code>满了，即处于「低电平」状态，表示不可再接受来自应用层的数据。为了将<code>outbuffer</code>中剩余的数据也发送到对端，此时需要为<code>connfd</code>注册可写事件。</p><p>当<code>send_buff</code>的数据发送出去，则会变为「高电平」状态，此时就会触发<code>connfd</code>上的可写事件，进而就能继续发送<code>outbuffer</code>中剩下的数据了。</p></li></ul><p>总结下，写操作要一直写到应用层<code>outBuffer</code>为空，或者<code>write</code>函数返回<code>EAGAIN</code>。</p><p>上面的 <code>epoll LT</code> 模式注：如果数据未发送完毕，需要注册可写事件；可写事件触发后，尝试发送<code>outBuffer</code>中的剩余数据，如果数据此时还不能全部发送完，<strong>不用再次注册可写事件，若全部发送完毕，需要取消注册可写事件</strong>。</p><p>如果是 <code>epoll ET</code> 模：如果数据未发送完毕，注册可写事件；可写事件触发后，尝试发送剩余数据，如果数据此时还不能全部发送完，<strong>需要再次注册可写事件，以便让可写事件下次再次触发，数据全部发送完毕，不用取消注册可写事件</strong>。</p><h3 id="LT-or-ET"><a href="#LT-or-ET" class="headerlink" title="LT  or ET ?"></a>LT  or ET ?</h3><p>说了这么多，那自己设计一个服务器，到底是选 <code>ET</code> 还是 <code>LT</code> ?</p><p>从个人的目前经验来说，看到的大多数都是<code>LT</code>。</p><p>对于可读事件，<code>ET</code>模式只会触发一次<code>epoll_wait</code>，而<code>LT</code>模式下，如果不能一次性读取完<code>recv_buff </code> 中的数据，则会多次触发<code>epoll_wait</code>，增加系统调用开销。</p><p>如果我使用<code>LT</code>模式，且一次就将<code>recv_buff </code> 中的数据全部读取出来，那不也就只调用一次<code>epoll_wait</code>，不就和<code>ET</code>模式一样了？</p><p>此外，LT模式下的<code>read</code>函数可以少一次系统调用，因为<code>ET</code>模式下的<code>read</code>操作必须读取到返回<code>EAGAIN</code>，就多了一次系统调用开销。</p><p>这就是<code>muduo</code>设计了一个<code>InputBuffer</code>的原因，而在<code>redis</code>中也有个输入缓冲区。</p><blockquote><p>muduo、libuv、redis等都是采用LT模式，其他库不太清楚。</p></blockquote><p>更为重要的是，<code>ET</code>模式操作不当，容易造成数据漏读、甚至服务器阻塞等问题，而良好的设计的<code>LT</code>模式效率也依然很高。</p><p>下面我们从muduo源码角度还原上述过程。</p><h2 id="muduo源码展示"><a href="#muduo源码展示" class="headerlink" title="muduo源码展示"></a>muduo源码展示</h2><p>确定好大的方向是「LT模式的<code>epoll</code> + 非阻塞IO」来设计异步通信之后。下面，我们就根据「网络编程」的前三期大致梳理下muduo服务端的源码。</p><h3 id="监听客户端连接请求"><a href="#监听客户端连接请求" class="headerlink" title="监听客户端连接请求"></a>监听客户端连接请求</h3><p>当muduo的服务器<code>TcpServer</code>运行时，会先在<code>Acceptor</code>中创建一个非阻塞的<code>listenfd</code>，用于监听客户端的连接请求，即muduo中的<code>acceptSocket_</code>字段， 并为<code>acceptSocket_</code>注册可读事件、设置可读回调函数 <code>Acceptor::handleRead</code>。</p><p>这样，服务端就能监听客户端<code>cli</code>的连接请求：</p><ul><li>当监听到客户端的连接请求后，在读取回调函数<code>Acceptor::handleRead</code>中为请求连接的客户端<code>cli</code>创建<code>TcpConnection</code>对象<code>conn</code>；</li><li>在众多<code>sub-eventloops</code>线程中，选择一个<code>sub-loop</code>线程，将<code>conn</code>分发到该<code>sub-loop</code>线程；</li><li>以后服务端与该<code>cli</code>的通信，都在<code>sub-loop</code>线程中完成，而<code>Acceptor</code>所在的<code>main-eventloop</code>线程，只是负责监听客户端的连接请求。</li></ul><p>如此，<code>Accptor</code>的作用即任务分发器<code>dispatcher</code>：</p><p>整个框架逻辑如图。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Acceptor::<span class="built_in">Acceptor</span>(EventLoop* loop, <span class="type">const</span> InetAddress&amp; listenAddr, <span class="type">bool</span> reuseport)</span><br><span class="line">  : <span class="built_in">loop_</span>(loop),</span><br><span class="line">    <span class="built_in">acceptSocket_</span>(sockets::<span class="built_in">createNonblockingOrDie</span>(listenAddr.<span class="built_in">family</span>())),</span><br><span class="line">    <span class="built_in">acceptChannel_</span>(loop, acceptSocket_.<span class="built_in">fd</span>()),</span><br><span class="line">    <span class="built_in">listening_</span>(<span class="literal">false</span>),</span><br><span class="line">    <span class="built_in">idleFd_</span>(::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">assert</span>(idleFd_ &gt;= <span class="number">0</span>);</span><br><span class="line">  acceptSocket_.<span class="built_in">setReuseAddr</span>(<span class="literal">true</span>);</span><br><span class="line">  acceptSocket_.<span class="built_in">setReusePort</span>(reuseport); <span class="comment">// 设置端口复用</span></span><br><span class="line">  acceptSocket_.<span class="built_in">bindAddress</span>(listenAddr); <span class="comment">// 绑定地址</span></span><br><span class="line">  acceptChannel_.<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;Acceptor::handleRead, <span class="keyword">this</span>)); <span class="comment">// 可读事件回调函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自然，分发任务的操作就是在可读事件的回调函数<code>Acceptor::handleRead</code>中完成的，其核心就是<code>newConnectionCallback_</code>函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Acceptor::handleRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  InetAddress peerAddr;</span><br><span class="line">  <span class="type">int</span> connfd = acceptSocket_.<span class="built_in">accept</span>(&amp;peerAddr); <span class="comment">// 获取客户端的 ip:port</span></span><br><span class="line">  <span class="keyword">if</span> (connfd &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newConnectionCallback_) &#123;</span><br><span class="line">      <span class="built_in">newConnectionCallback_</span>(connfd, peerAddr); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      sockets::<span class="built_in">close</span>(connfd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">&quot;in Acceptor::handleRead&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (errno == EMFILE) &#123;</span><br><span class="line">      ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">      idleFd_ = ::<span class="built_in">accept</span>(acceptSocket_.<span class="built_in">fd</span>(), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">      ::<span class="built_in">close</span>(idleFd_);</span><br><span class="line">      idleFd_ = ::<span class="built_in">open</span>(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY | O_CLOEXEC);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而回调函数<code>newConnectionCallback_</code>最终初始化为<code>TcpServer</code>类中的<code>TcpServer::newConnection</code>函数：</p><ul><li>创建<code>TcpConnection</code>对象 <code>conn</code>；</li><li><code>TcpServer</code>中的<code>connections_</code>记录着每个客户端，因此要把新创建的客户端记录在<code>connections_</code>中；</li><li>为<code>conn</code>设置一些回调函数；</li><li>将<code>conn</code>放到<code>sub-eventloop</code>中运行，以后服务器与该客户端的通讯就在<code>ioLoop</code>中进行了。</li></ul><p>整个逻辑如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpServer::newConnection</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> InetAddress&amp; peerAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  EventLoop* ioLoop = threadPool_-&gt;<span class="built_in">getNextLoop</span>(); <span class="comment">// 从子线程中选择一个</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span> buf, <span class="string">&quot;-%s#%d&quot;</span>, ipPort_.<span class="built_in">c_str</span>(), nextConnId_);</span><br><span class="line">  ++nextConnId_;</span><br><span class="line">  string connName = name_ + buf;</span><br><span class="line"></span><br><span class="line">  LOG_INFO &lt;&lt; <span class="string">&quot;TcpServer::newConnection [&quot;</span> &lt;&lt; name_</span><br><span class="line">           &lt;&lt; <span class="string">&quot;] - new connection [&quot;</span> &lt;&lt; connName</span><br><span class="line">           &lt;&lt; <span class="string">&quot;] from &quot;</span> &lt;&lt; peerAddr.<span class="built_in">toIpPort</span>();</span><br><span class="line">  <span class="function">InetAddress <span class="title">localAddr</span><span class="params">(sockets::getLocalAddr(sockfd))</span></span>;</span><br><span class="line">  <span class="comment">// 创建TcpConnection对象</span></span><br><span class="line">  <span class="function">TcpConnectionPtr <span class="title">conn</span><span class="params">(<span class="keyword">new</span> TcpConnection(ioLoop,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          connName,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          sockfd,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          localAddr,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          peerAddr))</span></span>;</span><br><span class="line">  connections_[connName] = conn;</span><br><span class="line">  <span class="comment">// 设置相关的回调函数</span></span><br><span class="line">  conn-&gt;<span class="built_in">setConnectionCallback</span>(connectionCallback_);</span><br><span class="line">  conn-&gt;<span class="built_in">setMessageCallback</span>(messageCallback_);</span><br><span class="line">  conn-&gt;<span class="built_in">setWriteCompleteCallback</span>(writeCompleteCallback_);</span><br><span class="line">  conn-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpServer::removeConnection, <span class="keyword">this</span>, _1));</span><br><span class="line">  <span class="comment">// 放到 sub-eventloop 中运行</span></span><br><span class="line">  ioLoop-&gt;<span class="built_in">runInLoop</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::connectEstablished, conn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>TcpConnection::connectEstablished</code>回调函数中，为每个刚建立连接的<code>TcpConnection</code>对象注册可读事件，这是为了监听等待客户端的发送数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::connectEstablished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="built_in">assert</span>(state_ == kConnecting);</span><br><span class="line">  <span class="built_in">setState</span>(kConnected);</span><br><span class="line">  channel_-&gt;<span class="built_in">tie</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">  channel_-&gt;<span class="built_in">enableReading</span>(); <span class="comment">// 注册可读事件</span></span><br><span class="line">  <span class="built_in">connectionCallback_</span>(<span class="built_in">shared_from_this</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个<code>conn</code>的可读、可写等事件的回调函数在<code>TcpConnection</code>构造函数中就完成了初始化。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">TcpConnection::<span class="built_in">TcpConnection</span>(EventLoop* loop,</span><br><span class="line">                             <span class="type">const</span> string&amp; nameArg,</span><br><span class="line">                             <span class="type">int</span> sockfd,</span><br><span class="line">                             <span class="type">const</span> InetAddress&amp; localAddr,</span><br><span class="line">                             <span class="type">const</span> InetAddress&amp; peerAddr)</span><br><span class="line">  : <span class="built_in">loop_</span>(<span class="built_in">CHECK_NOTNULL</span>(loop)),</span><br><span class="line">    <span class="built_in">name_</span>(nameArg),</span><br><span class="line">    <span class="built_in">state_</span>(kConnecting),</span><br><span class="line">    <span class="built_in">reading_</span>(<span class="literal">true</span>),</span><br><span class="line">    <span class="built_in">socket_</span>(<span class="keyword">new</span> <span class="built_in">Socket</span>(sockfd)),</span><br><span class="line">    <span class="built_in">channel_</span>(<span class="keyword">new</span> <span class="built_in">Channel</span>(loop, sockfd)),</span><br><span class="line">    <span class="built_in">localAddr_</span>(localAddr),</span><br><span class="line">    <span class="built_in">peerAddr_</span>(peerAddr),</span><br><span class="line">    <span class="built_in">highWaterMark_</span>(<span class="number">64</span>*<span class="number">1024</span>*<span class="number">1024</span>)</span><br><span class="line">&#123;</span><br><span class="line">  channel_-&gt;<span class="built_in">setReadCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleRead, <span class="keyword">this</span>, _1)); <span class="comment">// 读回调</span></span><br><span class="line">  channel_-&gt;<span class="built_in">setWriteCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleWrite, <span class="keyword">this</span>));   <span class="comment">// 写回调</span></span><br><span class="line">  channel_-&gt;<span class="built_in">setCloseCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleClose, <span class="keyword">this</span>));   <span class="comment">// 关闭回调</span></span><br><span class="line">  channel_-&gt;<span class="built_in">setErrorCallback</span>(std::<span class="built_in">bind</span>(&amp;TcpConnection::handleError, <span class="keyword">this</span>));   <span class="comment">// 错误处理回调</span></span><br><span class="line">  LOG_DEBUG &lt;&lt; <span class="string">&quot;TcpConnection::ctor[&quot;</span> &lt;&lt;  name_ &lt;&lt; <span class="string">&quot;] at &quot;</span> &lt;&lt; <span class="keyword">this</span></span><br><span class="line">            &lt;&lt; <span class="string">&quot; fd=&quot;</span> &lt;&lt; sockfd;</span><br><span class="line">  socket_-&gt;<span class="built_in">setKeepAlive</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，当<code>conn</code>对应的客户端发送过来数据时，触发可读事件后，会调用<code>TcpConnection::handleRead</code>来进行处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleRead</span><span class="params">(Timestamp receiveTime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="type">int</span> savedErrno = <span class="number">0</span>;</span><br><span class="line">  <span class="type">ssize_t</span> n = inputBuffer_.<span class="built_in">readFd</span>(channel_-&gt;<span class="built_in">fd</span>(), &amp;savedErrno);</span><br><span class="line">  <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">messageCallback_</span>(<span class="built_in">shared_from_this</span>(), &amp;inputBuffer_, receiveTime);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">handleClose</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    errno = savedErrno;</span><br><span class="line">    LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleRead&quot;</span>;</span><br><span class="line">    <span class="built_in">handleError</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，启动服务器到和客户端建立连接请求的过程、接受数据的流程大致结束了。</p><h3 id="可写事件-2"><a href="#可写事件-2" class="headerlink" title="可写事件"></a>可写事件</h3><p>在前面说过<code>LT</code>模式下的可写事件需要注意的点，下面顺着代码注释去看就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::sendInLoop</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* data, <span class="type">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="type">ssize_t</span> nwrote   = <span class="number">0</span>;</span><br><span class="line">  <span class="type">size_t</span> remaining = len;</span><br><span class="line">  <span class="type">bool</span> faultError  = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">if</span> (state_ == kDisconnected)</span><br><span class="line">  &#123;</span><br><span class="line">    LOG_WARN &lt;&lt; <span class="string">&quot;disconnected, give up writing&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 如果没有关注可写事件 且 outbuffer_ 中无待发送数据，说明之前的数据都已经写完</span></span><br><span class="line">  <span class="comment">/// 对于 用户来说是向 outbuffer_ 中写，</span></span><br><span class="line">  <span class="comment">/// 对于 socket 来说是从 outbuffer_ 中读取</span></span><br><span class="line">  <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>() &amp;&amp; outbuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    nwrote = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(), data, len);</span><br><span class="line">    <span class="keyword">if</span> (nwrote &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      remaining = len - nwrote;</span><br><span class="line">      <span class="comment">// 全部写完了，那么就执行写完成回调</span></span><br><span class="line">      <span class="keyword">if</span> (remaining == <span class="number">0</span> &amp;&amp; writeCompleteCallback_)</span><br><span class="line">      &#123;</span><br><span class="line">        loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// nwrote &lt; 0</span></span><br><span class="line">    &#123;</span><br><span class="line">      nwrote = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">/// socket 的发送缓冲已经满，无法将 outbuffer_ 的数据都复制到 socket 的 send_buff</span></span><br><span class="line">      <span class="comment">/// 非阻塞模式下，函数返回 -1 &amp;&amp; errno == EWOULDBLOCK</span></span><br><span class="line">      <span class="comment">/// 如果错误码不是EWOULDBLOCK，那么是真的产生错误了，需要关闭连接</span></span><br><span class="line">      <span class="keyword">if</span> (errno != EWOULDBLOCK) </span><br><span class="line">      &#123;</span><br><span class="line">        LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::sendInLoop&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (errno == EPIPE || errno == ECONNRESET) <span class="comment">// <span class="doctag">FIXME:</span> any others?</span></span><br><span class="line">        &#123;</span><br><span class="line">          faultError = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(remaining &lt;= len);</span><br><span class="line">  <span class="comment">/// @brief: 运行到这有两种可能：</span></span><br><span class="line">  <span class="comment">/// 1 之前没有注册可写事件，且 outbuffer_ 中没有可读取数据，</span></span><br><span class="line">  <span class="comment">/// 运行到此是因为此次数据 data 没有发送完</span></span><br><span class="line">  <span class="comment">/// 2 之前的数据没有发送完，又来了新的数据</span></span><br><span class="line">  <span class="comment">/// 无论哪种情况，处理方式：</span></span><br><span class="line">  <span class="comment">///  将数据复制到 outbuffer_ 中，关注 EPOLLOUT 事件，等待可写事件触发，发送数据</span></span><br><span class="line">  <span class="keyword">if</span> (!faultError &amp;&amp; remaining &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">size_t</span> oldLen = outbuffer_.<span class="built_in">readableBytes</span>();</span><br><span class="line">    <span class="comment">// 待发送的内容已经超过标志位了，就调用高水位这个函数</span></span><br><span class="line">    <span class="keyword">if</span> (oldLen + remaining &gt;= highWaterMark_  &amp;&amp;</span><br><span class="line">        oldLen &lt; highWaterMark_  &amp;&amp;</span><br><span class="line">        highWaterMarkCallback_)</span><br><span class="line">    &#123;</span><br><span class="line">      loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(highWaterMarkCallback_, </span><br><span class="line">                                   <span class="built_in">shared_from_this</span>(), </span><br><span class="line">                                   oldLen + remaining));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// 将剩余的内容加如 outbuffer_</span></span><br><span class="line">    outbuffer_.<span class="built_in">append</span>(<span class="built_in">static_cast</span>&lt;<span class="type">const</span> <span class="type">char</span>*&gt;(data)+nwrote, remaining);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 在LT 模式下不需要重复关注可写事件，即使运行到此的第二种情况不需要再关注可写事件</span></span><br><span class="line">    <span class="keyword">if</span> (!channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">    &#123;</span><br><span class="line">      channel_-&gt;<span class="built_in">enableWriting</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @brief: 写回调函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TcpConnection::handleWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  loop_-&gt;<span class="built_in">assertInLoopThread</span>();</span><br><span class="line">  <span class="comment">/// 触发写回调函数</span></span><br><span class="line">  <span class="comment">/// 将 @b outbuffer_ 中的数据复制到 @b socket 的`send_buff`</span></span><br><span class="line">  <span class="keyword">if</span> (channel_-&gt;<span class="built_in">isWriting</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">ssize_t</span> n = sockets::<span class="built_in">write</span>(channel_-&gt;<span class="built_in">fd</span>(),</span><br><span class="line">                               outbuffer_.<span class="built_in">peek</span>(),</span><br><span class="line">                               outbuffer_.<span class="built_in">readableBytes</span>());</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      outbuffer_.<span class="built_in">retrieve</span>(n);</span><br><span class="line">      <span class="comment">/// 如果 @b outbuffer_ 中的数据全部写完，</span></span><br><span class="line">      <span class="comment">/// 那么就可以取消关注 @b EPOLLOUT ，防止出现 busy loop</span></span><br><span class="line">      <span class="comment">/// 并且调用写完成回调函数</span></span><br><span class="line">      <span class="comment">/// 如果全部写完，此时就需要取消关注可写事件</span></span><br><span class="line">      <span class="comment">/// 如果 @b outbuffer_ 中还有数据，就继续等待下次可写事件的触发</span></span><br><span class="line">      <span class="keyword">if</span> (outbuffer_.<span class="built_in">readableBytes</span>() == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        channel_-&gt;<span class="built_in">disableWriting</span>();</span><br><span class="line">        <span class="keyword">if</span> (writeCompleteCallback_)</span><br><span class="line">        &#123;</span><br><span class="line">          loop_-&gt;<span class="built_in">queueInLoop</span>(std::<span class="built_in">bind</span>(writeCompleteCallback_, <span class="built_in">shared_from_this</span>()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (state_ == kDisconnecting)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">shutdownInLoop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      LOG_SYSERR &lt;&lt; <span class="string">&quot;TcpConnection::handleWrite&quot;</span>;</span><br><span class="line">      <span class="comment">// if (state_ == kDisconnecting)</span></span><br><span class="line">      <span class="comment">// &#123;</span></span><br><span class="line">      <span class="comment">//   shutdownInLoop();</span></span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    LOG_TRACE &lt;&lt; <span class="string">&quot;Connection fd = &quot;</span> &lt;&lt; channel_-&gt;<span class="built_in">fd</span>()</span><br><span class="line">              &lt;&lt; <span class="string">&quot; is down, no more writing&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>到此，就差不多了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;异步通信&quot;&gt;&lt;a href=&quot;#异步通信&quot; class=&quot;headerlink&quot; title=&quot;异步通信&quot;&gt;&lt;/a&gt;异步通信&lt;/h1&gt;&lt;p&gt;之前有两期讲解了服务端框的架构，这一期来讲下服务器是如何与客户端进行异步通信的，下一期再讲述客户端是如何异步非阻塞conne</summary>
      
    
    
    
    <category term="nio" scheme="https://szza.github.io/categories/nio/"/>
    
    
    <category term="nio" scheme="https://szza.github.io/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>多线程 HashTable 设计</title>
    <link href="https://szza.github.io/2021/11/26/rocksdb/utility/HashTablel/"/>
    <id>https://szza.github.io/2021/11/26/rocksdb/utility/HashTablel/</id>
    <published>2021-11-26T06:15:35.000Z</published>
    <updated>2023-07-31T16:46:24.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HashTable-lt-T-Hash-Equal-gt"><a href="#HashTable-lt-T-Hash-Equal-gt" class="headerlink" title="HashTable&lt;T, Hash, Equal&gt;"></a>HashTable&lt;T, Hash, Equal&gt;</h2><p>RocksDB 为了优化多核下的HashTable性能，放弃了全局锁设计，取而代之是如下分段锁设计：在并发下，将全局锁上的竞争分散到各个bucket上。</p><p>对每个桶（bucket）分配一个锁（mutex），当获取某个bucket中的元素时，只使用对应bucket的mutex即可，这样对其他bucket的元素就没有额外的负担。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//                         |&lt;-------- alpha -------------&gt;|</span></span><br><span class="line"><span class="comment">//               Buckets   Collision list</span></span><br><span class="line"><span class="comment">//          ---- +----+    +---+---+--- ...... ---+---+---+</span></span><br><span class="line"><span class="comment">//         /     |    |---&gt;|   |   |              |   |   |</span></span><br><span class="line"><span class="comment">//        /      +----+    +---+---+--- ...... ---+---+---+</span></span><br><span class="line"><span class="comment">//       /       |    |</span></span><br><span class="line"><span class="comment">// Locks/        +----+</span></span><br><span class="line"><span class="comment">// +--+/         .    .</span></span><br><span class="line"><span class="comment">// |  |          .    .</span></span><br><span class="line"><span class="comment">// +--+          .    .</span></span><br><span class="line"><span class="comment">// |  |          .    .</span></span><br><span class="line"><span class="comment">// +--+          .    .</span></span><br><span class="line"><span class="comment">// |  |          .    .</span></span><br><span class="line"><span class="comment">// +--+          .    .</span></span><br><span class="line"><span class="comment">//     \         +----+</span></span><br><span class="line"><span class="comment">//      \        |    |</span></span><br><span class="line"><span class="comment">//       \       +----+</span></span><br><span class="line"><span class="comment">//        \      |    |</span></span><br><span class="line"><span class="comment">//         \---- +----+</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Hash</span>, <span class="keyword">class</span> <span class="title class_">Equal</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HashTable</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">HashTable</span><span class="params">(<span class="type">const</span> <span class="type">size_t</span> capacity = <span class="number">1024</span> * <span class="number">1024</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">float</span> load_factor = <span class="number">2.0</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                     <span class="type">const</span> <span class="type">uint32_t</span> nlocks = <span class="number">256</span>)</span></span></span><br><span class="line"><span class="function">      : nbuckets_(static_cast&lt;uint32_t&gt;(load_factor ? capacity / load_factor : <span class="number">0</span>)),</span></span><br><span class="line"><span class="function">        nlocks_(nlocks) &#123;</span></span><br><span class="line">    <span class="built_in">assert</span>(capacity);</span><br><span class="line">    <span class="built_in">assert</span>(load_factor);</span><br><span class="line">    <span class="built_in">assert</span>(nbuckets_);</span><br><span class="line">    <span class="built_in">assert</span>(nlocks_);</span><br><span class="line"></span><br><span class="line">    buckets_.<span class="built_in">reset</span>(<span class="keyword">new</span> Bucket[nbuckets_]);</span><br><span class="line">  <span class="comment">// initialize</span></span><br><span class="line">    <span class="built_in">mlock</span>(buckets_.<span class="built_in">get</span>(), nbuckets_ * <span class="built_in">sizeof</span>(Bucket));</span><br><span class="line">    <span class="built_in">mlock</span>(locks_.<span class="built_in">get</span>(), nlocks_ * <span class="built_in">sizeof</span>(port::RWMutex));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(buckets_);</span><br><span class="line">    <span class="built_in">assert</span>(locks_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">HashTable</span>() &#123; <span class="built_in">AssertEmptyBuckets</span>(); &#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Bucket</span> &#123;</span><br><span class="line">    std::list&lt;T&gt; list_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">AssertEmptyBuckets</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> NDEBUG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; nbuckets_; ++i) &#123;</span><br><span class="line">      WriteLock _(&amp;locks_[i % nlocks_]);</span><br><span class="line">      <span class="built_in">assert</span>(buckets_[i].list_.<span class="built_in">empty</span>());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> nbuckets_;                 <span class="comment">// 桶的总数</span></span><br><span class="line">  std::unique_ptr&lt;Bucket[]&gt; buckets_;       <span class="comment">// 桶</span></span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> nlocks_;                   <span class="comment">// 锁的总数</span></span><br><span class="line">  std::unique_ptr&lt;port::RWMutex[]&gt; locks_;  <span class="comment">// 锁 </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="Find"><a href="#Find" class="headerlink" title="Find"></a>Find</h4><p>每个bucket都指向一个链表，用于解决hash冲突，因此当查找一个key时，需要在链表中顺序查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 顺序查找，时间复杂度O(N)</span></span><br><span class="line"><span class="keyword">typename</span> std::list&lt;T&gt;::<span class="function">iterator <span class="title">Find</span><span class="params">(std::list&lt;T&gt;* list, <span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = list-&gt;<span class="built_in">begin</span>(); it != list-&gt;<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Equal</span>()(*it, t)) &#123;</span><br><span class="line">      <span class="keyword">return</span> it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> list-&gt;<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">///@brief 在 bucket 中查找 t</span></span><br><span class="line"><span class="comment">///@param ret 就是传出参数，返回true时有效</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(Bucket* bucket, <span class="type">const</span> T&amp; t, T* ret)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = <span class="built_in">Find</span>(&amp;bucket-&gt;list_, t);</span><br><span class="line">  <span class="keyword">if</span> (it != bucket-&gt;list_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      *ret = *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将 t 添加到 bucket 中，不会重复添加</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(Bucket* bucket, <span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = <span class="built_in">Find</span>(&amp;bucket-&gt;list_, t);</span><br><span class="line">  <span class="keyword">if</span> (it != bucket-&gt;list_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// 不存在，则添加</span></span><br><span class="line">  bucket-&gt;list_.<span class="built_in">push_back</span>(t);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Erase"><a href="#Erase" class="headerlink" title="Erase"></a>Erase</h4><p><code>Erase</code> 和 <code>Insert</code>类似。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Erase</span><span class="params">(Bucket* bucket, <span class="type">const</span> T&amp; t, T* ret)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> it = <span class="built_in">Find</span>(&amp;bucket-&gt;list_, t);</span><br><span class="line">  <span class="keyword">if</span> (it != bucket-&gt;list_.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      *ret = *it;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bucket-&gt;list_.<span class="built_in">erase</span>(it);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GetMutex"><a href="#GetMutex" class="headerlink" title="GetMutex"></a>GetMutex</h4><p><code>GetMutex</code>函数，用于获得一个key对应的mutex。</p><ul><li>获得 key 对应的 hash_code</li><li>获得 hash_code 映射到 buckets_ 中的索引 bucket_idx</li><li>通过 bucket_idx 映射到 locks_ 中的索引 lock_idx</li></ul><p>最终，对 key 进行同步操作的锁就是 <code>locks_[lock_idx]</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">port::RWMutex* <span class="title">GetMutex</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint64_t</span> h = <span class="built_in">Hash</span>()(t);</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> bucket_idx = h % nbuckets_;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> lock_idx = bucket_idx % nlocks_;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;locks_[lock_idx];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>下面来看看，将一个 key 插入到 HashTable 中的过程。</p><ul><li>获得 <code>bucket_idx</code>、<code>lock_idx</code></li><li>使用 <code>locks_[lock_idx]</code> 对要修改的 <code>buckets_[bucket_idx]</code> 进行保护，再调用bucket级别的insert方法，将key插入到 <code>buckets_[bucket_idx]</code> 中。</li></ul><p>整体表现如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Insert</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">   <span class="type">const</span> <span class="type">uint64_t</span> h = <span class="built_in">Hash</span>()(t);</span><br><span class="line">   <span class="type">const</span> <span class="type">uint32_t</span> bucket_idx = h % nbuckets_;</span><br><span class="line">   <span class="type">const</span> <span class="type">uint32_t</span> lock_idx = bucket_idx % nlocks_;</span><br><span class="line"></span><br><span class="line">   WriteLock _(&amp;locks_[lock_idx]);</span><br><span class="line">   <span class="keyword">auto</span>&amp; bucket = buckets_[bucket_idx];</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">Insert</span>(&amp;bucket, t);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>其余方法，和 <code>Insert</code> 类似。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;HashTable-lt-T-Hash-Equal-gt&quot;&gt;&lt;a href=&quot;#HashTable-lt-T-Hash-Equal-gt&quot; class=&quot;headerlink&quot; title=&quot;HashTable&amp;lt;T, Hash, Equal&amp;gt;&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>persistent cache 设计</title>
    <link href="https://szza.github.io/2021/11/26/rocksdb/utility/persistent_cache/"/>
    <id>https://szza.github.io/2021/11/26/rocksdb/utility/persistent_cache/</id>
    <published>2021-11-26T06:15:35.000Z</published>
    <updated>2023-07-31T16:46:34.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="persistent-cache"><a href="#persistent-cache" class="headerlink" title="persistent cache"></a>persistent cache</h2><p>RocksDB  利用分层概念，设计了persistent cache：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">// PersistentTieredCache architecture:</span><br><span class="line">// +--------------------------+ PersistentCacheTier that handles multiple tiers</span><br><span class="line">// | +----------------+       |</span><br><span class="line">// | | RAM            | PersistentCacheTier that handles RAM (VolatileCacheImpl)</span><br><span class="line">// | +----------------+       |</span><br><span class="line">// |   | next                 |</span><br><span class="line">// |   v                      |</span><br><span class="line">// | +----------------+       |</span><br><span class="line">// | | NVM            | PersistentCacheTier implementation that handles NVM</span><br><span class="line">// | +----------------+ (BlockCacheImpl)</span><br><span class="line">// |   | next                 |</span><br><span class="line">// |   V                      |</span><br><span class="line">// | +----------------+       |</span><br><span class="line">// | | LE-SSD         | PersistentCacheTier implementation that handles LE-SSD</span><br><span class="line">// | +----------------+ (BlockCacheImpl)</span><br><span class="line">// |   |                      |</span><br><span class="line">// |   V                      |</span><br><span class="line">// |  null                    |</span><br><span class="line">// +--------------------------+</span><br><span class="line">//               |</span><br><span class="line">//               V</span><br><span class="line">//              null</span><br></pre></td></tr></table></figure><ul><li>在最上层，数据全都是在内存中，这一部分属于易失性数据由 <code>VolatileCacheImpl</code> 实现</li><li>其他层，在内存和文件中的数据进行交互，由 <code>BlockCacheImpl</code> 实现。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;persistent-cache&quot;&gt;&lt;a href=&quot;#persistent-cache&quot; class=&quot;headerlink&quot; title=&quot;persistent cache&quot;&gt;&lt;/a&gt;persistent cache&lt;/h2&gt;&lt;p&gt;RocksDB  利用分层概</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>FilterBlock 源码分析</title>
    <link href="https://szza.github.io/2021/11/26/rocksdb/Table/builder/3_FilterBlock/"/>
    <id>https://szza.github.io/2021/11/26/rocksdb/Table/builder/3_FilterBlock/</id>
    <published>2021-11-26T06:15:35.000Z</published>
    <updated>2023-07-31T16:46:13.213Z</updated>
    
    <content type="html"><![CDATA[<p>Rocksdb,为了加速查询，基于bloom filter 设计了Filter。</p><h2 id="FilterBlockBuilder"><a href="#FilterBlockBuilder" class="headerlink" title="FilterBlockBuilder"></a>FilterBlockBuilder</h2><p><code>FilterBlockBuilder</code> 是个基类，用于为特定的<code>table</code>构建filter，调用<code>::Finish</code>函数后会以字符串形式返回生成filter。它也有三个子类：</p><ul><li><code>BlockBasedFilterBlockBuilder</code></li><li><code>FullFilterBlockBuilder</code></li><li><code>PartitionedFilterBlockBuilder</code></li></ul><p><code>FilterBlockBuilder</code> 的成员函数的调用顺序，要符合正则表达式： <code>(StartBlock Add*)* Finish</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FilterBlockBuilder</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FilterBlockBuilder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">FilterBlockBuilder</span>() &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">FilterBlockBuilder</span>(<span class="type">const</span> FilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> FilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsBlockBased</span><span class="params">()</span> </span>= <span class="number">0</span>;                     <span class="comment">// If is blockbased filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartBlock</span><span class="params">(<span class="type">uint64_t</span> block_offset)</span> </span>= <span class="number">0</span>;  <span class="comment">// Start new block filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice&amp; key_without_ts)</span> </span>= <span class="number">0</span>;   <span class="comment">// Add a key to current filter</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;                    <span class="comment">// Empty == none added</span></span><br><span class="line">  <span class="comment">/// For reporting stats on how many entries the builder considered unique</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/// Generate Filter</span></span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> BlockHandle empty_handle;</span><br><span class="line">    Status dont_care_status;</span><br><span class="line">    <span class="keyword">auto</span> ret = <span class="built_in">Finish</span>(empty_handle, &amp;dont_care_status);</span><br><span class="line">    <span class="built_in">assert</span>(dont_care_status.<span class="built_in">ok</span>());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; tmp, Status* status)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="BlockBasedFilterBlockBuilder"><a href="#BlockBasedFilterBlockBuilder" class="headerlink" title="BlockBasedFilterBlockBuilder"></a>BlockBasedFilterBlockBuilder</h2><p><code>BlockBasedFilterBlockBuilder</code> 调用<code>::Finish</code>函数最后生成的字符串数据格式，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">filter_1</span><br><span class="line">filter_2</span><br><span class="line">...</span><br><span class="line">filter_N</span><br><span class="line">...</span><br><span class="line">filter_1_offset</span><br><span class="line">filter_2_offset</span><br><span class="line">...</span><br><span class="line">filter_N_offset</span><br></pre></td></tr></table></figure><p>下面先大致看下结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlockBasedFilterBlockBuilder</span> : <span class="keyword">public</span> FilterBlockBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">BlockBasedFilterBlockBuilder</span>(<span class="type">const</span> SliceTransform* prefix_extractor,</span><br><span class="line">                               <span class="type">const</span> BlockBasedTableOptions&amp; table_opt);</span><br><span class="line">  <span class="comment">// No copying allowed</span></span><br><span class="line">  <span class="built_in">BlockBasedFilterBlockBuilder</span>(<span class="type">const</span> BlockBasedFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> BlockBasedFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsBlockBased</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartBlock</span><span class="params">(<span class="type">uint64_t</span> block_offset)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice&amp; key_without_ts)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> start_.<span class="built_in">empty</span>() &amp;&amp; filter_offsets_.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> filter_bits_builder_-&gt;<span class="built_in">EstimateEntriesAdded</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; tmp, Status* status)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="keyword">using</span> FilterBlockBuilder::Finish;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddPrefix</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">GenerateFilter</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> FilterPolicy* policy_;</span><br><span class="line">  <span class="type">const</span> SliceTransform* prefix_extractor_;</span><br><span class="line">  <span class="type">bool</span> whole_key_filtering_;</span><br><span class="line"></span><br><span class="line">  <span class="type">size_t</span> prev_prefix_start_;      <span class="comment">// 上次添加到 entries_ 中的 key_prefix 的起始地址</span></span><br><span class="line">  <span class="type">size_t</span> prev_prefix_size_;       <span class="comment">// 该 key_prefix 的大小</span></span><br><span class="line"></span><br><span class="line">  std::string entries_;        <span class="comment">// 将所有的key打平后存储在 entries 中</span></span><br><span class="line">  std::vector&lt;<span class="type">size_t</span>&gt; start_;  <span class="comment">// 每个entry的的索引存储在 start_</span></span><br><span class="line"></span><br><span class="line">  std::string result_;              <span class="comment">// Filter data computed so far</span></span><br><span class="line">  std::vector&lt;Slice&gt; tmp_entries_;  <span class="comment">// policy_-&gt;CreateFilter() argument</span></span><br><span class="line">  std::vector&lt;<span class="type">uint32_t</span>&gt; filter_offsets_;</span><br><span class="line">  <span class="type">uint64_t</span> total_added_in_built_;  <span class="comment">// Total keys added to filters built so far</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p><code>BlockBasedFilterBlockBuilder</code> 在添加<code>key</code>时：</p><ul><li>如果能提取出待添加<code>key</code>的前缀，则会添加前缀</li><li>如果 <code>whole_key_filtering_  == true</code> ，则也会添加整个<code>key</code></li></ul><p>源码简单如斯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedFilterBlockBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key_without_ts)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是能提取出 key_without_ts 的前缀，则添加前缀</span></span><br><span class="line">  <span class="keyword">if</span> (prefix_extractor_ &amp;&amp; prefix_extractor_-&gt;<span class="built_in">InDomain</span>(key_without_ts)) &#123;</span><br><span class="line">    <span class="built_in">AddPrefix</span>(key_without_ts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否添加添加整个 key</span></span><br><span class="line">  <span class="keyword">if</span> (whole_key_filtering_) &#123;</span><br><span class="line">    <span class="built_in">AddKey</span>(key_without_ts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddKey"><a href="#AddKey" class="headerlink" title="AddKey"></a>AddKey</h4><p>在 <code>BlockBasedFilterBlockBuilder</code> 中，<code>entries_</code> 用于存储每次添加的<code>key</code>，<code>start_</code> 存储这个<code>key</code>在<code>entries_</code>中偏移量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BlockBasedFilterBlockBuilder::AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  start_.<span class="built_in">push_back</span>(entries_.<span class="built_in">size</span>()); <span class="comment">// entries_.size() 即下一个 key 在 entries_ 中的起始偏移量</span></span><br><span class="line">  entries_.<span class="built_in">append</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddPrefix"><a href="#AddPrefix" class="headerlink" title="AddPrefix"></a>AddPrefix</h4><p>非首次添加前缀时，都会先获得上一次添加key的前缀如果本次与上次不同，才添加本次key的前缀。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">BlockBasedFilterBlockBuilder::AddPrefix</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  Slice prev;</span><br><span class="line">  <span class="keyword">if</span> (prev_prefix_size_ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 上一个添加的 key 的前缀</span></span><br><span class="line">    prev = <span class="built_in">Slice</span>(entries_.<span class="built_in">data</span>() + prev_prefix_start_, prev_prefix_size_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 本次添加的key的前缀</span></span><br><span class="line">  Slice prefix = prefix_extractor_-&gt;<span class="built_in">Transform</span>(key);</span><br><span class="line">  <span class="comment">// 如果当前前缀 prefix 和之前的 prev 不同，则插入</span></span><br><span class="line">  <span class="keyword">if</span> (prev.<span class="built_in">size</span>() == <span class="number">0</span> || prefix != prev) &#123;</span><br><span class="line">    prev_prefix_start_ = entries_.<span class="built_in">size</span>();<span class="comment">// 待插入的 key 在entries_中的起始地址</span></span><br><span class="line">    prev_prefix_size_ = prefix.<span class="built_in">size</span>();    <span class="comment">// 待插入的key的前缀</span></span><br><span class="line">    <span class="built_in">AddKey</span>(prefix);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="StartBlock"><a href="#StartBlock" class="headerlink" title="StartBlock"></a>StartBlock</h3><p><code>StartBlock</code> 函数用于构建<code>filter block</code>。</p><p><code>BlockBasedFilterBlockBuilder</code> 是每 2kb的数据创建一个<code>filter block</code>，传入的参数<code>block_offset</code>是表示最终生成的<code>filter block</code> 在<code>result_</code>中的偏移量。</p><p>而 <code>filter_offsets_</code>中记录的是已有<code>filter block</code> 在<code>result_</code> 中的偏移量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kFilterBaseLg = <span class="number">11</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> kFilterBase = <span class="number">1</span> &lt;&lt; kFilterBaseLg; <span class="comment">// 2kb</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedFilterBlockBuilder::StartBlock</span><span class="params">(<span class="type">uint64_t</span> block_offset)</span> </span>&#123;</span><br><span class="line">  <span class="type">uint64_t</span> filter_index = (block_offset / kFilterBase);</span><br><span class="line">  <span class="built_in">assert</span>(filter_index &gt;= filter_offsets_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">while</span> (filter_index &gt; filter_offsets_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="built_in">GenerateFilter</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GenerateFilter"><a href="#GenerateFilter" class="headerlink" title="GenerateFilter"></a>GenerateFilter</h3><p>每个<code>filter block</code>的数据都记录在<code>entries_</code> 和 <code>start_</code>，当调用 <code>GenerateFilter</code> 函数时就会将<code>entries_</code> 、 <code>start_</code>中的数据添加到<code>result_</code>中，而这个<code>filter block</code> 的起始地址记录在<code>filter_offsets_</code>中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedFilterBlockBuilder::GenerateFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">size_t</span> num_entries = start_.<span class="built_in">size</span>();</span><br><span class="line">  <span class="keyword">if</span> (num_entries == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果这个 filter block 没有key，直接存储上次生成的滤波器的起始地址</span></span><br><span class="line">    filter_offsets_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(result_.<span class="built_in">size</span>()));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  total_added_in_built_ += num_entries;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 为便于下面使用 start_[i + 1] - start_[i] 计算每个entry的长度</span></span><br><span class="line">  start_.<span class="built_in">push_back</span>(entries_.<span class="built_in">size</span>());     </span><br><span class="line">  tmp_entries_.<span class="built_in">resize</span>(num_entries);</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_entries; i++) &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* base = entries_.<span class="built_in">data</span>() + start_[i]; <span class="comment">// 每个entry的起始地址</span></span><br><span class="line">    <span class="type">size_t</span> length = start_[i + <span class="number">1</span>] - start_[i];      <span class="comment">// 这个entry的长度</span></span><br><span class="line">    tmp_entries_[i] = <span class="built_in">Slice</span>(base, length);          <span class="comment">// slice</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// filter_offsets_  中保存着每个 filter block 的起始地址，即 result.size()</span></span><br><span class="line">  filter_offsets_.<span class="built_in">push_back</span>(<span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(result_.<span class="built_in">size</span>()));</span><br><span class="line">  <span class="comment">// 基于 tmp_entries 的内容创建 filter，结果存储至 result_</span></span><br><span class="line">  policy_-&gt;<span class="built_in">CreateFilter</span>(&amp;tmp_entries_[<span class="number">0</span>], </span><br><span class="line">                        <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(num_entries),</span><br><span class="line">                        &amp;result_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 清零，为下个 filter block 准备</span></span><br><span class="line">  tmp_entries_.<span class="built_in">clear</span>();</span><br><span class="line">  entries_.<span class="built_in">clear</span>();</span><br><span class="line">  start_.<span class="built_in">clear</span>();</span><br><span class="line">  prev_prefix_start_ = <span class="number">0</span>;</span><br><span class="line">  prev_prefix_size_ = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p>在调用<code>::Finish</code>函数时，需要<code>result_</code>向<code>result_</code>中写入三部分：</p><ul><li>每个<code>key</code>的偏移量<code>KEY_OFFSET</code></li><li><code>key</code>的数量<code>FILTER_BLOCK_NUM</code></li><li>结束标志 <code>kFilterBaseLg</code></li></ul><p>代码简单如此。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">BlockBasedFilterBlockBuilder::Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; <span class="comment">/*tmp*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           Status* status)</span> </span>&#123;</span><br><span class="line">  *status = Status::<span class="built_in">OK</span>();</span><br><span class="line">  <span class="keyword">if</span> (!start_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    <span class="built_in">GenerateFilter</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> array_offset = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(result_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; filter_offsets_.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    <span class="comment">// 把每个 filter block 的偏移量添加到result</span></span><br><span class="line">    <span class="built_in">PutFixed32</span>(&amp;result_, filter_offsets_[i]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 添加 filter block 的数量</span></span><br><span class="line">  <span class="built_in">PutFixed32</span>(&amp;result_, array_offset);</span><br><span class="line">  <span class="comment">// 结束标志位</span></span><br><span class="line">  result_.<span class="built_in">push_back</span>(kFilterBaseLg);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Slice</span>(result_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FullFilterBlockBuilder"><a href="#FullFilterBlockBuilder" class="headerlink" title="FullFilterBlockBuilder"></a>FullFilterBlockBuilder</h2><p>他就是将全部的的key都放在了一起、。</p><blockquote><p>TODO：设计点</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FullFilterBlockBuilder</span> : <span class="keyword">public</span> FilterBlockBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FullFilterBlockBuilder</span><span class="params">(<span class="type">const</span> SliceTransform* prefix_extractor,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  <span class="type">bool</span> whole_key_filtering,</span></span></span><br><span class="line"><span class="params"><span class="function">                                  FilterBitsBuilder* filter_bits_builder)</span></span>;</span><br><span class="line">  <span class="built_in">FullFilterBlockBuilder</span>(<span class="type">const</span> FullFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="type">void</span> <span class="keyword">operator</span>=(<span class="type">const</span> FullFilterBlockBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">FullFilterBlockBuilder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsBlockBased</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125; <span class="comment">// 区分 BlockBasedFilterBlockBuilder</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">StartBlock</span><span class="params">(<span class="type">uint64_t</span>)</span> <span class="keyword">override</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> !any_added_; &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice&amp; key_without_ts)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">using</span> FilterBlockBuilder::Finish;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; tmp, Status* status)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Reset</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddPrefix</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">const</span> SliceTransform* <span class="title">prefix_extractor</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prefix_extractor_; &#125;</span><br><span class="line">  <span class="function"><span class="type">const</span> std::string&amp; <span class="title">last_prefix_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> last_prefix_str_; &#125;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;FilterBitsBuilder&gt; filter_bits_builder_;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">const</span> SliceTransform* prefix_extractor_;<span class="comment">// 前缀提取器</span></span><br><span class="line">  <span class="type">bool</span> whole_key_filtering_;</span><br><span class="line">  <span class="type">bool</span> last_whole_key_recorded_;</span><br><span class="line">  std::string last_whole_key_str_;</span><br><span class="line">  <span class="type">bool</span> last_prefix_recorded_;</span><br><span class="line">  std::string last_prefix_str_;</span><br><span class="line">  <span class="type">bool</span> last_key_in_domain_;</span><br><span class="line">  <span class="type">bool</span> any_added_;</span><br><span class="line">  std::unique_ptr&lt;<span class="type">const</span> <span class="type">char</span>[]&gt; filter_data_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Add-1"><a href="#Add-1" class="headerlink" title="Add"></a>Add</h3><ol><li>根据<code>whole_key_filtering_</code> 来确定是否添加整个<code>key_without_ts</code> </li><li>根据<code>add_prefix</code>，来看是否添加<code>key_without_ts</code>的前缀</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FullFilterBlockBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key_without_ts)</span> </span>&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> add_prefix =</span><br><span class="line">      prefix_extractor_ &amp;&amp; prefix_extractor_-&gt;<span class="built_in">InDomain</span>(key_without_ts);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!last_prefix_recorded_ &amp;&amp; last_key_in_domain_) &#123;</span><br><span class="line">    <span class="built_in">AddKey</span>(last_prefix_str_);</span><br><span class="line">    last_prefix_recorded_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (whole_key_filtering_) &#123;</span><br><span class="line">    <span class="comment">// 如果没前缀，则直接添加key</span></span><br><span class="line">    <span class="keyword">if</span> (!add_prefix) &#123;</span><br><span class="line">      <span class="built_in">AddKey</span>(key_without_ts);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 第一个 key or 遇到新的 key</span></span><br><span class="line">      Slice last_whole_key = <span class="built_in">Slice</span>(last_whole_key_str_);</span><br><span class="line">      <span class="keyword">if</span> (!last_whole_key_recorded_ ||</span><br><span class="line">          last_whole_key.<span class="built_in">compare</span>(key_without_ts) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">AddKey</span>(key_without_ts);</span><br><span class="line">        last_whole_key_recorded_ = <span class="literal">true</span>;</span><br><span class="line">        last_whole_key_str_.<span class="built_in">assign</span>(key_without_ts.<span class="built_in">data</span>(),</span><br><span class="line">                                   key_without_ts.<span class="built_in">size</span>());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (add_prefix) &#123;</span><br><span class="line">    last_key_in_domain_ = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">AddPrefix</span>(key_without_ts);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    last_key_in_domain_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddKey-1"><a href="#AddKey-1" class="headerlink" title="AddKey"></a>AddKey</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">FullFilterBlockBuilder::AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  filter_bits_builder_-&gt;<span class="built_in">AddKey</span>(key);</span><br><span class="line">  any_added_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddPrefix-1"><a href="#AddPrefix-1" class="headerlink" title="AddPrefix"></a>AddPrefix</h4><ul><li><p><code>last_prefix_str_</code>：记录上一次添加的前缀</p></li><li><p>如果<code>whole_key_filtering_ == true</code>，那么，从<code>FullFilterBlockBuilder::Add</code>函数运行至<code>FullFilterBlockBuilder::AddPrefix</code> 函数结束，添加的数据是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">key_without_ts</span><br><span class="line">prefix</span><br></pre></td></tr></table></figure><p>但是如果<code>prefix</code>和上一个添加的前缀相同，则忽略本次的前缀，最终添加的内容只有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key_without_ts</span><br></pre></td></tr></table></figure></li><li><p>如果<code>whole_key_filtering_ == false</code>，添加的数据只有<code>prefix</code></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FullFilterBlockBuilder::AddPrefix</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(prefix_extractor_ &amp;&amp; prefix_extractor_-&gt;<span class="built_in">InDomain</span>(key));</span><br><span class="line">  Slice prefix = prefix_extractor_-&gt;<span class="built_in">Transform</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (whole_key_filtering_) &#123;</span><br><span class="line"> <span class="comment">// 前一个添加的前缀</span></span><br><span class="line">    Slice last_prefix = <span class="built_in">Slice</span>(last_prefix_str_);  <span class="comment">// 前缀</span></span><br><span class="line">    <span class="comment">// 遇到新的前缀</span></span><br><span class="line">    <span class="keyword">if</span> (!last_prefix_recorded_ || last_prefix.<span class="built_in">compare</span>(prefix) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// 记录前缀</span></span><br><span class="line">      <span class="built_in">AddKey</span>(prefix);</span><br><span class="line">      last_prefix_recorded_ = <span class="literal">true</span>; </span><br><span class="line">      last_prefix_str_.<span class="built_in">assign</span>(prefix.<span class="built_in">data</span>(), prefix.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 直接添加 prefix</span></span><br><span class="line">    <span class="built_in">AddKey</span>(prefix);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Finish-1"><a href="#Finish-1" class="headerlink" title="Finish"></a>Finish</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FullFilterBlockBuilder::Reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  last_whole_key_recorded_ = <span class="literal">false</span>;</span><br><span class="line">  last_prefix_recorded_ = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Slice <span class="title">FullFilterBlockBuilder::Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; <span class="comment">/*tmp*/</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     Status* status)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">Reset</span>();</span><br><span class="line">  <span class="comment">// In this impl we ignore BlockHandle</span></span><br><span class="line">  *status = Status::<span class="built_in">OK</span>();</span><br><span class="line">  <span class="keyword">if</span> (any_added_) &#123;</span><br><span class="line">    any_added_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> filter_bits_builder_-&gt;<span class="built_in">Finish</span>(&amp;filter_data_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Slice</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PartitionedFilterBlockBuilder"><a href="#PartitionedFilterBlockBuilder" class="headerlink" title="PartitionedFilterBlockBuilder"></a>PartitionedFilterBlockBuilder</h2><p>对应于 <code>PartitionedIndexBuilder</code>，rocksdb 现在是一个<code>partition filter block</code>  对应一个<code>partition index block</code>。</p><p>因此，每生成一个 <code>partition filter block</code> 也会请求  <code>PartitionedIndexBuilder</code> 生成一个 <code>partition index block</code>，来保证一一对应。</p><p>两种原理都差不多。</p><p>在<code>PartitionedFilterBlockBuilder</code>内部，也有个<code>FilterEntry</code>结构体，类似于<code>PartitionedIndexBuilder::Entry</code>，每个<code>value</code>都是一个<code>filter</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PartitionedFilterBlockBuilder</span> : <span class="keyword">public</span> FullFilterBlockBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PartitionedFilterBlockBuilder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> SliceTransform* prefix_extractor, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> whole_key_filtering,</span></span></span><br><span class="line"><span class="params"><span class="function">      FilterBitsBuilder* filter_bits_builder, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">int</span> index_block_restart_interval,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="params"><span class="function">      PartitionedIndexBuilder* <span class="type">const</span> p_index_builder,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">uint32_t</span> partition_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">PartitionedFilterBlockBuilder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">EstimateEntriesAdded</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Slice <span class="title">Finish</span><span class="params">(<span class="type">const</span> BlockHandle&amp; last_partition_block_handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Status* status)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">  BlockBuilder index_on_filter_block_builder_;  <span class="comment">// top-level index builder</span></span><br><span class="line">  BlockBuilder index_on_filter_block_builder_without_seq_;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">FilterEntry</span> &#123;</span><br><span class="line">    std::string key;</span><br><span class="line">    Slice filter;</span><br><span class="line">  &#125;;</span><br><span class="line">  std::list&lt;FilterEntry&gt; filters;      <span class="comment">// list of partitioned indexes and their keys</span></span><br><span class="line">  std::unique_ptr&lt;IndexBuilder&gt; value; <span class="comment">// 可以存储 PartitionedIndexBuilder</span></span><br><span class="line">  std::vector&lt;std::unique_ptr&lt;<span class="type">const</span> <span class="type">char</span>[]&gt;&gt; filter_gc;</span><br><span class="line">  <span class="type">bool</span> finishing_filters = <span class="literal">false</span>;      <span class="comment">// 为true，表示正调用 Finish 函数，尚未返回 Status::OK()</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">MaybeCutAFilterBlock</span><span class="params">(<span class="type">const</span> Slice* next_key)</span></span>;</span><br><span class="line">  </span><br><span class="line">  PartitionedIndexBuilder* <span class="type">const</span> p_index_builder_;</span><br><span class="line">  <span class="type">uint32_t</span> keys_per_partition_;<span class="comment">// 每个 partition 中 key 的数量</span></span><br><span class="line">  <span class="type">uint32_t</span> keys_added_to_partition_;<span class="comment">// 最近一个partion添加的key的数量</span></span><br><span class="line">  <span class="type">uint64_t</span> total_added_in_built_;  <span class="comment">// 总共添加的key的数量</span></span><br><span class="line">  BlockHandle last_encoded_handle_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="MaybeCutAFilterBlock"><a href="#MaybeCutAFilterBlock" class="headerlink" title="MaybeCutAFilterBlock"></a>MaybeCutAFilterBlock</h3><p><code>MaybeCutAFilterBlock</code> 函数，用于判断当前是否需要生成一个<code>filter block</code>： <strong>当前 <code>partition</code>添加的key的数量 <code>keys_added_to_partition_</code> 已经到达阈值 <code>keys_per_partition_</code></strong> 。</p><p>由于<code>partition filter block</code> 和 <code>partition index block</code> 的数目是一一对应的。因此，需要请求 <code>PartitionedIndexBuilder</code> 对象 <code>p_index_builder_</code>  也生成一个<code>partition index block</code>。此外，生成的<code>partition idnex block</code>  和 <code>partition filter block</code> 对应的key是相同的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PartitionedIndexBuilder</span>::Entry &#123;</span><br><span class="line">  std::string key;  <span class="comment">// sub_index_last_key_;</span></span><br><span class="line">  std::unique_ptr&lt;ShortenedIndexBuilder&gt; value; <span class="comment">// partition index block</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">PartitionedFilterBlockBuilderFilterEntry</span> &#123;</span><br><span class="line">  std::string key;<span class="comment">// sub_index_last_key_</span></span><br><span class="line">  Slice filter;    <span class="comment">// partition filter block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>MaybeCutAFilterBlock</code> 的函数分为三步：</p><ol><li>如果当前 <code>partition filter block</code>的<code>keys_added_to_partition_</code>已达到阈值，则请求对应的<code>partiiton index block</code>也创建完毕，否则就阻塞等待；</li><li>将待添加的<code>next_key</code>的前缀<code>next_key_prefix</code>添加到<code>partition filer block</code>；</li><li>生成<code>partition filter block</code>，并添加到<code>filters</code> 中。</li></ol><p>顺着源码更加详细地去理解这个过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PartitionedFilterBlockBuilder::MaybeCutAFilterBlock</span><span class="params">(<span class="type">const</span> Slice* next_key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当前 parition 的 key 达到阈值</span></span><br><span class="line">  <span class="keyword">if</span> (keys_added_to_partition_ == keys_per_partition_) &#123;</span><br><span class="line">    <span class="comment">// 请求 p_index_builder_ 生成一个 partition</span></span><br><span class="line">    p_index_builder_-&gt;<span class="built_in">RequestPartitionCut</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!p_index_builder_-&gt;<span class="built_in">ShouldCutFilterBlock</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// p_index_builder_ 已生成一个 partition</span></span><br><span class="line"> </span><br><span class="line">  filter_gc.<span class="built_in">push_back</span>(std::<span class="built_in">unique_ptr</span>&lt;<span class="type">const</span> <span class="type">char</span>[]&gt;(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否需要添加 next_key 的前缀</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> maybe_add_prefix =</span><br><span class="line">      next_key &amp;&amp; <span class="built_in">prefix_extractor</span>() &amp;&amp; <span class="built_in">prefix_extractor</span>()-&gt;<span class="built_in">InDomain</span>(*next_key);</span><br><span class="line">  <span class="keyword">if</span> (maybe_add_prefix) &#123;</span><br><span class="line">    <span class="type">const</span> Slice next_key_prefix = <span class="built_in">prefix_extractor</span>()-&gt;<span class="built_in">Transform</span>(*next_key);</span><br><span class="line">    <span class="comment">// 与之前的前缀不同，则添加</span></span><br><span class="line">    <span class="keyword">if</span> (next_key_prefix.<span class="built_in">compare</span>(<span class="built_in">last_prefix_str</span>()) != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="built_in">AddKey</span>(next_key_prefix);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  total_added_in_built_ += filter_bits_builder_-&gt;<span class="built_in">EstimateEntriesAdded</span>();</span><br><span class="line">  <span class="comment">// 生成一个 filter block</span></span><br><span class="line">  Slice filter = filter_bits_builder_-&gt;<span class="built_in">Finish</span>(&amp;filter_gc.<span class="built_in">back</span>());</span><br><span class="line">  <span class="comment">// index_key 是 partition index block 存储的时的 key</span></span><br><span class="line">  std::string&amp; index_key = p_index_builder_-&gt;<span class="built_in">GetPartitionKey</span>();</span><br><span class="line">  <span class="comment">// &#123;index_key, PartitionFilter&#125;</span></span><br><span class="line">  filters.<span class="built_in">push_back</span>(&#123;index_key, filter&#125;);</span><br><span class="line">  <span class="comment">// 当前 partition 已添加的key数清零</span></span><br><span class="line">  keys_added_to_partition_ = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">Reset</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AddKey-2"><a href="#AddKey-2" class="headerlink" title="AddKey"></a>AddKey</h4><p>添加 <code>key</code> 至当前<code>partition filter block</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PartitionedFilterBlockBuilder::AddKey</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  FullFilterBlockBuilder::<span class="built_in">AddKey</span>(key);</span><br><span class="line">  keys_added_to_partition_++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Add-2"><a href="#Add-2" class="headerlink" title="Add"></a>Add</h3><p>由于<code>PartitionedFilterBlockBuilder</code> 继承自<code>FullFilterBlockBuilder</code>，唯一的区别就在于将一整个<code>Filter Block</code>，划分为多个<code>partitions</code>。</p><p>因此，在每次<code>Add</code>新的<code>key</code>，都先判断下是是否要需要生成新的<code>partition filter block</code>，然后将<code>key</code>添加到当前<code>partiton filter block</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PartitionedFilterBlockBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">MaybeCutAFilterBlock</span>(&amp;key);</span><br><span class="line">  FullFilterBlockBuilder::<span class="built_in">Add</span>(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish-2"><a href="#Finish-2" class="headerlink" title="Finish"></a>Finish</h3><p>类似于<code>PartitionIndexBuiler</code>, 这里要将<code>fiters</code> 中记录的<code>partitions</code> 都写入到SST中，并记录下每个<code>partition</code> 在SST中的偏移量offset，根据<code>partiton</code>的大小size和offset生成 <code>TopLevelIndex</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Slice <span class="title">PartitionedFilterBlockBuilder::Finish</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> BlockHandle&amp; last_partition_block_handle, </span></span></span><br><span class="line"><span class="params"><span class="function">    Status* status)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (finishing_filters == <span class="literal">true</span>) &#123;</span><br><span class="line">    FilterEntry&amp; last_entry = filters.<span class="built_in">front</span>();</span><br><span class="line">    std::string handle_encoding;</span><br><span class="line">    last_partition_block_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">    std::string handle_delta_encoding;</span><br><span class="line">    <span class="built_in">PutVarsignedint64</span>(</span><br><span class="line">        &amp;handle_delta_encoding,</span><br><span class="line">        last_partition_block_handle.<span class="built_in">size</span>() - last_encoded_handle_.<span class="built_in">size</span>());</span><br><span class="line">    last_encoded_handle_ = last_partition_block_handle;</span><br><span class="line">    <span class="function"><span class="type">const</span> Slice <span class="title">handle_delta_encoding_slice</span><span class="params">(handle_delta_encoding)</span></span>;</span><br><span class="line">    index_on_filter_block_builder_.<span class="built_in">Add</span>(last_entry.key,  <span class="comment">// key 相同</span></span><br><span class="line">                                       handle_encoding,   <span class="comment">// block_handle</span></span><br><span class="line">                                       &amp;handle_delta_encoding_slice);</span><br><span class="line">    <span class="keyword">if</span> (!p_index_builder_-&gt;<span class="built_in">seperator_is_key_plus_seq</span>()) &#123;</span><br><span class="line">      index_on_filter_block_builder_without_seq_.<span class="built_in">Add</span>(</span><br><span class="line">          <span class="built_in">ExtractUserKey</span>(last_entry.key), handle_encoding,</span><br><span class="line">          &amp;handle_delta_encoding_slice);</span><br><span class="line">    &#125;</span><br><span class="line">    filters.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 第一次调用 ::Finish 函数，此时没有 next_key，</span></span><br><span class="line">    <span class="comment">// 仅仅是为了生成最后一个 partition fiter block</span></span><br><span class="line">    <span class="built_in">MaybeCutAFilterBlock</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(filters.<span class="built_in">empty</span>())) &#123;</span><br><span class="line">    *status = Status::<span class="built_in">OK</span>();</span><br><span class="line">    <span class="keyword">if</span> (finishing_filters) &#123;</span><br><span class="line">       <span class="comment">/// 最后一次调用 ::Finish</span></span><br><span class="line">      total_added_in_built_ = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">// 返回partitions的元信息</span></span><br><span class="line">      <span class="keyword">if</span> (p_index_builder_-&gt;<span class="built_in">seperator_is_key_plus_seq</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> index_on_filter_block_builder_.<span class="built_in">Finish</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> index_on_filter_block_builder_without_seq_.<span class="built_in">Finish</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This is the rare case where no key was added to the filter</span></span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Slice</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回当前 partition 的信息</span></span><br><span class="line">    *status = Status::<span class="built_in">Incomplete</span>();</span><br><span class="line">    finishing_filters = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> filters.<span class="built_in">front</span>().filter;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Rocksdb,为了加速查询，基于bloom filter 设计了Filter。&lt;/p&gt;
&lt;h2 id=&quot;FilterBlockBuilder&quot;&gt;&lt;a href=&quot;#FilterBlockBuilder&quot; class=&quot;headerlink&quot; title=&quot;FilterBl</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>IndexBlock 源码分析</title>
    <link href="https://szza.github.io/2021/11/26/rocksdb/Table/builder/2_IndexBlock/"/>
    <id>https://szza.github.io/2021/11/26/rocksdb/Table/builder/2_IndexBlock/</id>
    <published>2021-11-26T06:15:35.000Z</published>
    <updated>2023-07-31T16:46:08.895Z</updated>
    
    <content type="html"><![CDATA[<h2 id="IndexBuilder"><a href="#IndexBuilder" class="headerlink" title="IndexBuilder"></a>IndexBuilder</h2><p><code>IndexBuilder</code> 是个基类，一共有三个子类：</p><ol><li><code>ShortenedIndexBuilder</code></li><li><code>HashIndexBuilder</code></li><li><code>PartitionedIndexBuilder</code></li></ol><p>一个<code>IndexBlock</code> 会构建一个许多<code>IndexBlock</code>，每个<code>IndexBlock</code>都包含两个字段：</p><ul><li> <code>primary index block</code></li><li><code>meta_blocks</code>：主要是存储着关于 <code>primary index block</code> 的一些列<code>meta data</code>.</li></ul><p>这个<code>IndexBlocks</code>用于接受 <code>IndexBuilder::Finish</code> 调用时候的传出参数，用来接受<code>IndexBuilder</code>添加的<code>block</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IndexBuilder</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> IndexBuilder* <span class="title">CreateIndexBuilder</span><span class="params">(BlockBasedTableOptions::IndexType index_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> InternalKeyComparator* comparator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> InternalKeySliceTransform* int_key_slice_transform,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> <span class="type">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="params"><span class="function">                                          <span class="type">const</span> BlockBasedTableOptions&amp; table_opt)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">IndexBlocks</span> &#123;</span><br><span class="line">    Slice index_block_contents;</span><br><span class="line">    std::unordered_map&lt;std::string, Slice&gt; meta_blocks;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">IndexBuilder</span><span class="params">(<span class="type">const</span> InternalKeyComparator* comparator)</span></span></span><br><span class="line"><span class="function">      : comparator_(comparator) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">IndexBuilder</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 添加 &#123;key, block_handle&#125; 至 block_builder</span></span><br><span class="line">  <span class="comment">/// 其中 key in [last_key_in_current_block, first_key_in_next_block)</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIndexEntry</span><span class="params">(std::string* last_key_in_current_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> BlockHandle&amp; block_handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 回调函数：只要有 key 添加，这个函数就会被调用</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnKeyAdded</span><span class="params">(<span class="type">const</span> Slice&amp; <span class="comment">/*key*/</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 将 IndexBuilder 添加的数据序存储到 @c index_blocks 中</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks)</span> </span>&#123;</span><br><span class="line">    BlockHandle last_partition_block_handle;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Finish</span>(index_blocks, last_partition_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 子类重写这个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> BlockHandle&amp; last_partition_block_handle)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 当前这个IndexBluiler 的大小</span></span><br><span class="line">  <span class="comment">/// 必须先调用 ::Finish 函数</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">IndexSize</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">seperator_is_key_plus_seq</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="type">const</span> InternalKeyComparator* comparator_;</span><br><span class="line">  <span class="type">size_t</span> index_size_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="ShortenedIndexBuilder"><a href="#ShortenedIndexBuilder" class="headerlink" title="ShortenedIndexBuilder"></a>ShortenedIndexBuilder</h2><p><code>ShortenedIndexBuilder</code> 是个基础的<code>IndexBuilder</code>，在存储<code>&#123;k,v&#125;</code>时，可以尽可能的压缩内存空间，被在后面的<code>HashIndexBuilder</code>、<code>PartitionedIndexBuilder</code> 内置使用。</p><p>他的使用过程大致如下：</p><ol><li>通过 <code>AddIndexEntry</code> 函数来添加<code>&#123;k, v&#125;</code>，其中<code>key</code>是计算出来位于<code>[last_key_in_current_block, first_key_in_next_block)</code>区间的最短字符串，<code>value</code>是<code>block_hadnle</code>，即是表征某个block。</li><li>在每个添加<code>&#123;k, v&#125;</code>时，都会触发回调函数<code>onKeyAdd</code>，这可以用来记录一些额外的信息；</li><li>添加完毕的时候，调用<code>::Finish</code>函数，将通过 <code>AddIndexEntry</code> 函数添加的<code>&#123;k ,block_handle&#125;</code>序列化成字符串返回。</li></ol><p>下面先大致看下 <code>ShortenedIndexBuilder</code>类。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShortenedIndexBuilder</span> : <span class="keyword">public</span> IndexBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ShortenedIndexBuilder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> InternalKeyComparator* comparator,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">int</span> index_block_restart_interval, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">uint32_t</span> format_version,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="params"><span class="function">      BlockBasedTableOptions::IndexShorteningMode shortening_mode,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> include_first_key)</span></span></span><br><span class="line"><span class="function">      : IndexBuilder(comparator),</span></span><br><span class="line"><span class="function">        index_block_builder_(index_block_restart_interval,</span></span><br><span class="line"><span class="function">                             true /*use_delta_encoding*/,</span></span><br><span class="line"><span class="function">                             use_value_delta_encoding),</span></span><br><span class="line"><span class="function">        index_block_builder_without_seq_(index_block_restart_interval,</span></span><br><span class="line"><span class="function">                                         true /*use_delta_encoding*/,</span></span><br><span class="line"><span class="function">                                         use_value_delta_encoding),</span></span><br><span class="line"><span class="function">        use_value_delta_encoding_(use_value_delta_encoding),</span></span><br><span class="line"><span class="function">        include_first_key_(include_first_key),</span></span><br><span class="line"><span class="function">        shortening_mode_(shortening_mode) &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 低于版本2的不支持，需要 &gt;= 3</span></span><br><span class="line">    seperator_is_key_plus_seq_ = (format_version &lt;= <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在每个block添加第一个key时候进入if分支</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnKeyAdded</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (include_first_key_ &amp;&amp; current_block_first_internal_key_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">      current_block_first_internal_key_.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// @brief 目的是 将 @c block_handle 添加到 @c index_block_builder_ 中，</span></span><br><span class="line">  <span class="comment">///        细节编码可以参考代码解释。</span></span><br><span class="line">  <span class="comment">/// @param last_key_in_current_block 会变成存储 @c block_handle 对应的key</span></span><br><span class="line">  <span class="comment">/// @param first_key_in_next_block 指示当前 block 是否是最后一个block</span></span><br><span class="line">  <span class="comment">/// @param block_handle</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIndexEntry</span><span class="params">(std::string* last_key_in_current_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 复用基类的 ::Finish 函数</span></span><br><span class="line">  <span class="keyword">using</span> IndexBuilder::Finish;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// @brief 将当前使用 @c AddIndexEntry 添加block handle, @c index_blocks 中</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> BlockHandle&amp; <span class="comment">/*last_partition_block_handle*/</span>)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">IndexSize</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> index_size_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">seperator_is_key_plus_seq</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seperator_is_key_plus_seq_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">PartitionedIndexBuilder</span>; <span class="comment">// 友元，侵入式设计</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  BlockBuilder index_block_builder_;              <span class="comment">// 存储添加的数据</span></span><br><span class="line">  BlockBuilder index_block_builder_without_seq_;</span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> use_value_delta_encoding_;</span><br><span class="line">  <span class="type">bool</span> seperator_is_key_plus_seq_;                <span class="comment">// 如果可以为 false，则能节省内存</span></span><br><span class="line">  <span class="type">const</span> <span class="type">bool</span> include_first_key_;</span><br><span class="line">  BlockBasedTableOptions::IndexShorteningMode shortening_mode_;</span><br><span class="line">  BlockHandle last_encoded_handle_ = BlockHandle::<span class="built_in">NullBlockHandle</span>(); <span class="comment">// 记录最后添加的 block</span></span><br><span class="line">  std::string current_block_first_internal_key_; <span class="comment">// 当前block的第一个key</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>ShortenedIndexBuilder</code>中有个成员变量<code>seperator_is_key_plus_seq_</code>，这是为进一步压缩存储空间。</p><p>在前面，我们知道一个<code>internalkey</code>是由<code>&#123;userkey, seq, type&#125;</code>三部分组成，如果可以仅由<code>userkey</code>便能分辨不同的<code>internalkey</code>，那么就没必要加上<code>&#123;seq, type&#125;</code>，自然就可以进一步减少内存消耗。</p><p>因此，存在两个成员变量<code>index_block_builder_</code>、<code>index_block_builder_without_seq_</code>。</p><p>下面我们来看看<code>AddIndexEntry</code> 函数是如何处理的。</p><h3 id="AddIndexEntry"><a href="#AddIndexEntry" class="headerlink" title="AddIndexEntry"></a>AddIndexEntry</h3><p><code>last_key_in_urrent_block</code> 是个输入输出参数，最终存储的<code>&#123;k, v&#125;</code>中<code>k</code>会记录在<code>last_key_in_current_block</code>中。</p><p>整个过程如下：</p><h4 id="1-计算待存储的-key"><a href="#1-计算待存储的-key" class="headerlink" title="1. 计算待存储的 key"></a>1. 计算待存储的 <code>key</code></h4><p>对于非最后一个block，则 <code>first_key_in_next_block</code> 不为 <code>nullptr</code>。</p><p>对于压缩模式<code>shortening_mode_</code>有三种选择：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">IndexShorteningMode</span> : <span class="type">char</span> &#123;</span><br><span class="line">   kNoShortening,</span><br><span class="line">   kShortenSeparators,   </span><br><span class="line">   kShortenSeparatorsAndSuccessor,</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>只要不是<code>kNoShortening</code>，都会选择一个<code>[last_key_in_current_block, first_key_in_next_block)</code>区间最短的字符串来当做即将存储的<code>key</code>，而这个<code>key</code>也会记录在<code>last_key_in_current_block</code> 中。</p><p>注意，上面寻找<code>key</code>的区间是左闭右开。</p><p>如果<code>seperator_is_key_plus_seq_ == false</code>，即仅使用<code>key</code>的<code>userkey</code>、<code>first_key_in_next_block</code>的<code>userkey</code>来比较，发现二者相等，那么就需要将 <code>seperator_is_key_plus_seq_ = true</code>，来满足区间需求。</p><p>但是，如果当前blocks是最后一个，此时<code>first_key_in_next_block == nullptr</code>。</p><p>如果此时的<code>shortening_mode_ == IndexShorteningMode::kShortenSeparatorsAndSuccessor</code>，那么只需找出大于<code>last_key_in_current_block</code>的键，来来做带存储的<code>key</code>。</p><p>第一部分的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIndexEntry</span><span class="params">(std::string* last_key_in_current_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...1....</span></span><br><span class="line">   <span class="keyword">if</span> (first_key_in_next_block != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (shortening_mode_ !=</span><br><span class="line">         BlockBasedTableOptions::IndexShorteningMode::kNoShortening) &#123;</span><br><span class="line">       <span class="comment">// last_key_in_current_block 的值修改为 </span></span><br><span class="line">       <span class="comment">// [last_key_in_current_block, first_key_in_next_block] 区间的</span></span><br><span class="line">       comparator_-&gt;<span class="built_in">FindShortestSeparator</span>(last_key_in_current_block,</span><br><span class="line">                                          *first_key_in_next_block);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 不用携带 seq_,则直接用 UserKey 进行比较</span></span><br><span class="line">     <span class="comment">// 此时，如果两个 UserKey 相等</span></span><br><span class="line">     <span class="comment">// 则说明，光靠 UserKEy 无法比较</span></span><br><span class="line">     <span class="keyword">if</span> (!seperator_is_key_plus_seq_ &amp;&amp;</span><br><span class="line">         comparator_-&gt;<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">Compare</span>(</span><br><span class="line">             <span class="built_in">ExtractUserKey</span>(*last_key_in_current_block),</span><br><span class="line">             <span class="built_in">ExtractUserKey</span>(*first_key_in_next_block)) == <span class="number">0</span>) &#123;</span><br><span class="line">       seperator_is_key_plus_seq_ = <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// first_key_in_next_block == nullptr</span></span><br><span class="line">     <span class="comment">// 即当前 block 即最后一个 block</span></span><br><span class="line">     <span class="keyword">if</span> (shortening_mode_ == BlockBasedTableOptions::IndexShorteningMode::</span><br><span class="line">                                 kShortenSeparatorsAndSuccessor) &#123;</span><br><span class="line">       <span class="comment">// 将 last_key_in_current_block 设置大于他的字符串</span></span><br><span class="line">       comparator_-&gt;<span class="built_in">FindShortSuccessor</span>(last_key_in_current_block);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//...next...</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2-编码-block-handle"><a href="#2-编码-block-handle" class="headerlink" title="2. 编码 block_handle"></a>2. 编码 block_handle</h4><p>经过第一步，找出了待存储的<code>key</code>，即 <code>last_key_in_current_block</code>，它宛如一个分隔符，分开两个block：</p><ul><li><p>基于<code>block_handle</code>来构造<code>IndexValue</code>对象 <code>entry</code>，并将<code>entry</code>编码序列化到<code>encoded_entry</code>中。</p></li><li><p>如果<code>ShortenedIndexBuilder</code>支持<code>use_value_delta_encoding_</code>，并且当前待添加的block不是首个block，那么就可以改变<code>entry</code>的序列化方式，进一步压缩存储空间，如此就得到<code>delta_encoded_entry</code>；</p></li></ul><p>这一部分的代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIndexEntry</span><span class="params">(std::string* last_key_in_current_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..续..</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">//!!! key</span></span><br><span class="line">   <span class="keyword">auto</span> sep = <span class="built_in">Slice</span>(*last_key_in_current_block);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 要么 include_first_key_ 为false</span></span><br><span class="line">   <span class="comment">// 要么 include_first_key_ 为true，且 current_block_first_internal_key_ 不能为空</span></span><br><span class="line">   <span class="built_in">assert</span>(!include_first_key_ || !current_block_first_internal_key_.<span class="built_in">empty</span>());</span><br><span class="line">   <span class="comment">//!!! value</span></span><br><span class="line">   <span class="function">IndexValue <span class="title">entry</span><span class="params">(block_handle, current_block_first_internal_key_)</span></span>;</span><br><span class="line">   std::string encoded_entry;</span><br><span class="line">   std::string delta_encoded_entry;</span><br><span class="line">   <span class="comment">// 将 entry 的内容编码到 encoded_entry 中</span></span><br><span class="line">   <span class="comment">// 如果 include_first_key_ 为 true,</span></span><br><span class="line">   <span class="comment">// 则 encoded_entry 中的数据是 block_handle + current_block_first_internal_key_</span></span><br><span class="line">   entry.<span class="built_in">EncodeTo</span>(&amp;encoded_entry, include_first_key_, <span class="literal">nullptr</span>);</span><br><span class="line">   <span class="keyword">if</span> (use_value_delta_encoding_ &amp;&amp; !last_encoded_handle_.<span class="built_in">IsNull</span>()) &#123;</span><br><span class="line">     <span class="comment">// 此时 block 不是首个 block</span></span><br><span class="line">     <span class="comment">// 使用 delta eccoding 的方式</span></span><br><span class="line">     entry.<span class="built_in">EncodeTo</span>(&amp;delta_encoded_entry, include_first_key_,</span><br><span class="line">                    &amp;last_encoded_handle_);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">// 此时 block 是首个 block 或者 use_value_delta_encoding_ 功能关闭了</span></span><br><span class="line">     <span class="comment">// BlockBuilder::Add() below won&#x27;t use delta-encoded slice.</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 更新最后添加的 handle</span></span><br><span class="line">   last_encoded_handle_ = block_handle;</span><br><span class="line">   <span class="function"><span class="type">const</span> Slice <span class="title">delta_encoded_entry_slice</span><span class="params">(delta_encoded_entry)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...next...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-添加-k-v"><a href="#3-添加-k-v" class="headerlink" title="3. 添加 {k, v}"></a>3. 添加 {k, v}</h4><p>到此，<code>key</code>已经获得，<code>value</code>也已经编码序列化完毕。</p><p>最后，根据``seperator_is_key_plus_seq_<code>选择将序列化结果存储到</code>index_block_builder_<code> 还是</code>index_block_builder_without_seq_` 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIndexEntry</span><span class="params">(std::string* last_key_in_current_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                            <span class="type">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="comment">// ..续..</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果 use_value_delta_encoding_ 为 true,</span></span><br><span class="line">   <span class="comment">// 此时 delta_encoded_entry_slice 也不为空</span></span><br><span class="line">   <span class="comment">// 则 index_block_builder_ 也会使用进一步压缩value的存储空间</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 添加 &#123;k,v&#125;，即 &#123;sep, &#125; </span></span><br><span class="line">   index_block_builder_.<span class="built_in">Add</span>(sep, encoded_entry, &amp;delta_encoded_entry_slice);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 不需要加上 seq</span></span><br><span class="line">   <span class="keyword">if</span> (!seperator_is_key_plus_seq_) &#123;</span><br><span class="line">     index_block_builder_without_seq_.<span class="built_in">Add</span>(<span class="built_in">ExtractUserKey</span>(sep), </span><br><span class="line">                                           encoded_entry,</span><br><span class="line">                                           &amp;delta_encoded_entry_slice);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 过了第一个key，就需要清除</span></span><br><span class="line">   current_block_first_internal_key_.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此，一个<code>AddIndexEntry</code> 函数分析完毕，可以说是在尽可能的在压缩存储空间，关键的三个点：</p><ul><li><code>IndexShorteningMode</code>：用来确定待存储的<code>key</code>是否为最短；</li><li><code>seperator_is_key_plus_seq_</code>：存储key时，可以是否需要带上<code>&#123;seq, type&#125;；</code></li><li><code>use_value_delta_encoding_</code>：来确定是否需要进一步对<code>value</code> 进行<code>delta encoding</code>。</li></ul><p>下面，就来看看<code>::Finish</code> 函数。</p><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p><code>Finish</code>函数的语义很简单，就是将通过<code>AddIndexEntry</code> 添加的 <code>&#123;k, v&#125;</code>保存到<code>index_blocks-&gt;index_block_contents</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexBlocks</span> &#123;</span><br><span class="line">   Slice index_block_contents;</span><br><span class="line">   std::unordered_map&lt;std::string, Slice&gt; meta_blocks;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/// @brief 将当前使用 @c AddIndexEntry 添加block handle, @c index_blocks 中</span></span><br><span class="line"> <span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> BlockHandle&amp; <span class="comment">/*last_partition_block_handle*/</span>)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (seperator_is_key_plus_seq_) &#123;</span><br><span class="line">     index_blocks-&gt;index_block_contents = index_block_builder_.<span class="built_in">Finish</span>();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     index_blocks-&gt;index_block_contents =</span><br><span class="line">         index_block_builder_without_seq_.<span class="built_in">Finish</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   index_size_ = index_blocks-&gt;index_block_contents.<span class="built_in">size</span>();</span><br><span class="line">   <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="HashIndexBuilder"><a href="#HashIndexBuilder" class="headerlink" title="HashIndexBuilder"></a>HashIndexBuilder</h2><p><code>HashIndexBuilder</code> 包含了了两部分：</p><ul><li><p>可用于二分查找的<code>primary index</code>，即类中的 <code>primary_index_builder_</code>;</p></li><li><p>用于构造二级hash index的metadata</p><p>这个metadata 由两部分 metablock 组成：</p><ul><li><code>prefix_block_</code>：这个 metablock 连续存储着前缀；</li><li><code>prefix_meta_block_</code>：这个metablock存储着<code>prefix_block_</code>的信息</li></ul></li></ul><p><font color=red> 两个之间的联系 </font></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HashIndexBuilder</span> : <span class="keyword">public</span> IndexBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">HashIndexBuilder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> InternalKeyComparator* comparator,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> SliceTransform* hash_key_extractor,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">int</span> index_block_restart_interval, </span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">int</span> format_version,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="params"><span class="function">      BlockBasedTableOptions::IndexShorteningMode shortening_mode)</span></span></span><br><span class="line"><span class="function">      : IndexBuilder(comparator),</span></span><br><span class="line"><span class="function">        primary_index_builder_(comparator, </span></span><br><span class="line"><span class="function">                               index_block_restart_interval,</span></span><br><span class="line"><span class="function">                               format_version, </span></span><br><span class="line"><span class="function">                               use_value_delta_encoding,</span></span><br><span class="line"><span class="function">                               shortening_mode, </span></span><br><span class="line"><span class="function">                               false /* include_first_key */),</span></span><br><span class="line"><span class="function">        hash_key_extractor_(hash_key_extractor) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIndexEntry</span><span class="params">(std::string* last_key_in_current_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnKeyAdded</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="type">const</span> BlockHandle&amp; last_partition_block_handle)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">IndexSize</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> primary_index_builder_.<span class="built_in">IndexSize</span>() </span><br><span class="line">       + prefix_block_.<span class="built_in">size</span>() </span><br><span class="line">       + prefix_meta_block_.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">seperator_is_key_plus_seq</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> primary_index_builder_.<span class="built_in">seperator_is_key_plus_seq</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FlushPendingPrefix</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ShortenedIndexBuilder primary_index_builder_;</span><br><span class="line">  <span class="type">const</span> SliceTransform* hash_key_extractor_;</span><br><span class="line"></span><br><span class="line">  std::string prefix_block_;</span><br><span class="line">  std::string prefix_meta_block_;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> pending_block_num_ = <span class="number">0</span>;</span><br><span class="line">  <span class="type">uint32_t</span> pending_entry_index_ = <span class="number">0</span>;</span><br><span class="line">  std::string pending_entry_prefix_;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint64_t</span> current_restart_index_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="AddIndexEntry-1"><a href="#AddIndexEntry-1" class="headerlink" title="AddIndexEntry"></a>AddIndexEntry</h3><p><code>HashIndexBuilder</code> 的 <code>restart interval == 1</code> ，因此每次调用<code>AddIndexEntry</code> 函数时 <code>++current_restart_index_</code>。</p><p>因此，<code>current_restart_index_</code> 可用于指示当前添加的<code>block</code>的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIndexEntry</span><span class="params">(std::string* last_key_in_current_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  ++current_restart_index_;</span><br><span class="line">  primary_index_builder_.<span class="built_in">AddIndexEntry</span>(last_key_in_current_block,</span><br><span class="line">                                       first_key_in_next_block, </span><br><span class="line">                                       block_handle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="OnKeyAdded"><a href="#OnKeyAdded" class="headerlink" title="OnKeyAdded"></a>OnKeyAdded</h3><p><code>OnKeyAdded</code>函数，是个回调函数，即在每次添加 <code>key</code>的时候调用。</p><ul><li><p><code>pending_entry_prefix_</code>：是当前pending的前缀；</p><p>如果待加入的<code>key</code>的前缀 <code>key_prefix != pending_entry_prefix_</code>，则说明遇到新的前缀，那么就<code>pending_entry_prefix_</code> 要设置为新的前缀<code>key_prefix</code></p></li><li><p><code>pending_block_num_</code>：表征的是前缀是<code>pending_entry_prefix_</code>的key的数量；</p></li><li><p><code>pending_entry_index_</code>：当前<code>pending_entry_prefix_</code> 所属的<code>restart index</code>。</p><p>通过后面两个参数，就可以知道 <code>[pending_entry_index_, pending_entry_index_ + pending_block_num_)</code>范围内的key的前缀都是<code>pending_entry_prefix_</code>。</p></li></ul><p>此外，这里的<code>pending</code>的意思，还没有 <code>flush</code> 到 <code>prefix_block_</code> 和 <code>prefix_meta_block_</code> 中。</p><p>下面先来看看<code>onKeyAdd</code>函数的逻辑。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">OnKeyAdded</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> key_prefix = hash_key_extractor_-&gt;<span class="built_in">Transform</span>(key);</span><br><span class="line">  <span class="comment">// 当前没有等待 flush 的 entry，那么此次添加的 key 就是 first_entry</span></span><br><span class="line">  <span class="type">bool</span> is_first_entry = pending_block_num_ == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_first_entry || pending_entry_prefix_ != key_prefix) &#123;</span><br><span class="line">    <span class="comment">// 如果是遇到新的前缀了，则 flush</span></span><br><span class="line">    <span class="keyword">if</span> (!is_first_entry) &#123;</span><br><span class="line">      <span class="built_in">FlushPendingPrefix</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 更新其他状态</span></span><br><span class="line">    pending_entry_prefix_ = key_prefix.<span class="built_in">ToString</span>();</span><br><span class="line">    pending_block_num_ = <span class="number">1</span>;</span><br><span class="line">    pending_entry_index_ = <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(current_restart_index_);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/// 相同前缀，即 pending_entry_prefix_ == key_prefix</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> last_restart_index = pending_entry_index_ + pending_block_num_ - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">assert</span>(last_restart_index &lt;= current_restart_index_);</span><br><span class="line">    <span class="keyword">if</span> (last_restart_index != current_restart_index_) &#123;</span><br><span class="line">      ++pending_block_num_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FlushPendingPrefix"><a href="#FlushPendingPrefix" class="headerlink" title="FlushPendingPrefix"></a>FlushPendingPrefix</h3><p>这里的 <code>flush</code>，即将 <code>pending_entry_prefix_</code> 及其元数据分别存储到<code>prefix_block_</code>、<code>prefix_meta_block_</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FlushPendingPrefix</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// prefix_block_ 添加 pending_entry_prefix_</span></span><br><span class="line">  prefix_block_.<span class="built_in">append</span>(pending_entry_prefix_.<span class="built_in">data</span>(),</span><br><span class="line">                       pending_entry_prefix_.<span class="built_in">size</span>());</span><br><span class="line">  <span class="comment">// prefix_meta_block_ 存储前缀的元数据 </span></span><br><span class="line">  <span class="built_in">PutVarint32Varint32Varint32</span>(</span><br><span class="line">      &amp;prefix_meta_block_,</span><br><span class="line">      <span class="built_in">static_cast</span>&lt;<span class="type">uint32_t</span>&gt;(pending_entry_prefix_.<span class="built_in">size</span>()), <span class="comment">// pending_entry_prefix_ 大小</span></span><br><span class="line">      pending_entry_index_, <span class="comment">// pending_entry_prefix_ 所属的 restart index</span></span><br><span class="line">      pending_block_num_);  <span class="comment">// 前缀 pending_entry_prefix_  的 key 数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish-1"><a href="#Finish-1" class="headerlink" title="Finish"></a>Finish</h3><p>当调用<code>::Finish</code> 函数时，就是为将之前添加的数据都序列化到 <code>index_blocks</code>中。此时有两部分需要序列化：</p><ul><li><code>primary index</code>： 即 <code>primary_index_builder_</code></li><li>元数据：即 <code>prefix_block_</code> 和 <code>prefix_meta_block_</code></li></ul><p>逻辑简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="params"><span class="function">                      <span class="type">const</span> BlockHandle&amp; last_partition_block_handle)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (pending_block_num_ != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">FlushPendingPrefix</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 先序列化已添加的数据</span></span><br><span class="line">  Status s = primary_index_builder_.<span class="built_in">Finish</span>(index_blocks,</span><br><span class="line">                                           last_partition_block_handle);</span><br><span class="line">  <span class="comment">// 再添加元数据</span></span><br><span class="line">  index_blocks-&gt;meta_blocks.<span class="built_in">insert</span>(</span><br><span class="line">      &#123;kHashIndexPrefixesBlock.<span class="built_in">c_str</span>(), prefix_block_&#125;);</span><br><span class="line">  index_blocks-&gt;meta_blocks.<span class="built_in">insert</span>(</span><br><span class="line">      &#123;kHashIndexPrefixesMetadataBlock.<span class="built_in">c_str</span>(), prefix_meta_block_&#125;);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TopLevelIndex"><a href="#TopLevelIndex" class="headerlink" title="TopLevelIndex"></a>TopLevelIndex</h2><p>既然，已经有了上述两个<code>IndexBuilder</code>，那为啥还需要<code>PartitionedIndexBuilder</code>。</p><p>顾名思义，<code>Partition</code>，即分割的语义，由上面的源码分析可知，每次<code>IndexBuilder::Finish</code>函数都会将之前添加的<code>&#123;k, v&#125;</code>序列化并返回。那么反过来，当需要超找一个<code>key</code>时，是不是也要把之前的存储整个<code>IndexBuilder::Finish</code>返回的内容读取出来？</p><p>但是cache资源是有限的，你一次性把读取了太多数据，会导致其他cache中数据被挤出去。</p><p>因此，有了<code>PartitionedIndexBuilder</code>，即将一整个<code>Index</code> 分割为许多个。此时在硬盘的存储格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">I I I I I I IP</span><br></pre></td></tr></table></figure><p>其中，<code>I</code> 是使用 <code>ShortenedIndexBuilder</code> 构建的 <code>partition index block</code>。<code>IP</code>，记录的是前面已构建的 <code>partitions</code>的元数据。</p><blockquote><p>  图？？？</p></blockquote><h2 id="PartitionedIndexBuilder"><a href="#PartitionedIndexBuilder" class="headerlink" title="PartitionedIndexBuilder"></a>PartitionedIndexBuilder</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PartitionedIndexBuilder</span> : <span class="keyword">public</span> IndexBuilder &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> PartitionedIndexBuilder* <span class="title">CreateIndexBuilder</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> InternalKeyComparator* comparator,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> <span class="type">bool</span> use_value_delta_encoding,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> BlockBasedTableOptions&amp; table_opt)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PartitionedIndexBuilder</span><span class="params">(<span class="type">const</span> InternalKeyComparator* comparator,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> BlockBasedTableOptions&amp; table_opt,</span></span></span><br><span class="line"><span class="params"><span class="function">                                   <span class="type">const</span> <span class="type">bool</span> use_value_delta_encoding)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">virtual</span> ~<span class="built_in">PartitionedIndexBuilder</span>();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">AddIndexEntry</span><span class="params">(std::string* last_key_in_current_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="type">const</span> BlockHandle&amp; block_handle)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Finish</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      IndexBlocks* index_blocks,</span></span></span><br><span class="line"><span class="params"><span class="function">      <span class="type">const</span> BlockHandle&amp; last_partition_block_handle)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">IndexSize</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> index_size_; &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">TopLevelIndexSize</span><span class="params">(<span class="type">uint64_t</span>)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> top_level_index_size_; &#125;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">NumPartitions</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/// 用于 PartitionFilterBlock 中</span></span><br><span class="line">  <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ShouldCutFilterBlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function">  <span class="comment">/// 用于 PartitionFilterBlock 中</span></span></span><br><span class="line"><span class="function">  <span class="type">void</span> <span class="title">RequestPartitionCut</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::string&amp; <span class="title">GetPartitionKey</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sub_index_last_key_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">seperator_is_key_plus_seq</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> seperator_is_key_plus_seq_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">get_use_value_delta_encoding</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> use_value_delta_encoding_; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  </span><br><span class="line">  <span class="type">size_t</span> top_level_index_size_ = <span class="number">0</span>;<span class="comment">// Set after ::Finish is called</span></span><br><span class="line">  <span class="type">size_t</span> partition_cnt_ = <span class="number">0</span>;    <span class="comment">// Set after ::Finish is called</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成二级索引</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">MakeNewSubIndexBuilder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">    std::string key;</span><br><span class="line">    std::unique_ptr&lt;ShortenedIndexBuilder&gt; value; <span class="comment">// partition index</span></span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  std::list&lt;Entry&gt; entries_; </span><br><span class="line">  BlockBuilder index_block_builder_;              <span class="comment">// top-level index builder</span></span><br><span class="line">  BlockBuilder index_block_builder_without_seq_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// the active partition index builder</span></span><br><span class="line">  ShortenedIndexBuilder* sub_index_builder_;</span><br><span class="line">  <span class="comment">// the last key in the active partition index builder</span></span><br><span class="line">  std::string sub_index_last_key_;</span><br><span class="line">  std::unique_ptr&lt;FlushBlockPolicy&gt; flush_policy_;</span><br><span class="line"> </span><br><span class="line">  <span class="type">bool</span> finishing_indexes = <span class="literal">false</span>; <span class="comment">// Finish 函数已被调用但是尚未完成</span></span><br><span class="line">  <span class="type">const</span> BlockBasedTableOptions&amp; table_opt_;</span><br><span class="line">  <span class="type">bool</span> seperator_is_key_plus_seq_;</span><br><span class="line">  <span class="type">bool</span> use_value_delta_encoding_;</span><br><span class="line">  <span class="type">bool</span> partition_cut_requested_ = <span class="literal">true</span>;</span><br><span class="line">  <span class="type">bool</span> cut_filter_block = <span class="literal">false</span>;</span><br><span class="line">  BlockHandle last_encoded_handle_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="AddIndexEntry-2"><a href="#AddIndexEntry-2" class="headerlink" title="AddIndexEntry"></a>AddIndexEntry</h3><p>在<code>PartitionedIndexBuilder</code>类中，有个内嵌类<code>PartitionedIndexBuilder::Entry</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line">   std::string key;</span><br><span class="line">   std::unique_ptr&lt;ShortenedIndexBuilder&gt; value; <span class="comment">// partition index</span></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">std::list&lt;Entry&gt; entries_; </span><br></pre></td></tr></table></figure><ul><li><code>key</code>字段，即<code>sub_index_last_key_</code>；</li><li><code>value</code>字段，指向的是即<code>sub_index_builder_</code>。</li></ul><p>因此，<code>entries_</code>的每一个元素都是一个<code>Partition</code>。<code>entries_</code> 有三种可能添加一个对象 <code>Entry(key, value)</code>：</p><ul><li>如果本次调用<code>AddIndexEntru</code>会导致<code>sub_index_builder_</code> 的大小超过了阈值，即<code>FlushBlockPolicy::Update</code> 返回true，那么就会将<code>&#123;sub_index_last_key_, sub_index_builder_&#125;</code> 添加到<code>entries_</code>，并重新将<code>sub_index_builder_ = nullptr</code>；</li><li>其他类，比如<code>PartitionFilterBlock</code>  发起请求；</li><li>这是最后一个block。如果添加的<code>block_handle</code>是最后一个，即 <code>first_key_in_next_block == nullptr</code>。</li></ul><p>下面，看代码注释。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PartitionedIndexBuilder::AddIndexEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    std::string* last_key_in_current_block,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> Slice* first_key_in_next_block, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> BlockHandle&amp; block_handle)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 最后一个blockhandle</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(first_key_in_next_block == <span class="literal">nullptr</span>)) &#123;  <span class="comment">// no more keys</span></span><br><span class="line">    <span class="keyword">if</span> (sub_index_builder_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">MakeNewSubIndexBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    sub_index_builder_-&gt;<span class="built_in">AddIndexEntry</span>(last_key_in_current_block,</span><br><span class="line">                                      first_key_in_next_block, </span><br><span class="line">                                      block_handle);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果 sub_index_builder_-&gt;seperator_is_key_plus_seq_ 是 true</span></span><br><span class="line">    <span class="comment">// 而 seperator_is_key_plus_seq_ 是 false吗，两者不一致</span></span><br><span class="line">    <span class="comment">// 说明 sub_index_builder_ 的 seperator_is_key_plus_seq_ 发生了改变</span></span><br><span class="line">    <span class="comment">// 需要使得 sub_index_builder_ 的相应设置</span></span><br><span class="line">    <span class="keyword">if</span> (!seperator_is_key_plus_seq_ &amp;&amp;</span><br><span class="line">        sub_index_builder_-&gt;seperator_is_key_plus_seq_) &#123;</span><br><span class="line">      seperator_is_key_plus_seq_ = <span class="literal">true</span>;</span><br><span class="line">      flush_policy_.<span class="built_in">reset</span>(FlushBlockBySizePolicyFactory::<span class="built_in">NewFlushBlockPolicy</span>(</span><br><span class="line">          table_opt_.metadata_block_size, table_opt_.block_size_deviation,</span><br><span class="line">          sub_index_builder_-&gt;index_block_builder_));</span><br><span class="line">    &#125;</span><br><span class="line">    sub_index_last_key_ = std::<span class="built_in">string</span>(*last_key_in_current_block);</span><br><span class="line">    entries_.<span class="built_in">push_back</span>(</span><br><span class="line">        &#123;sub_index_last_key_,</span><br><span class="line">         std::<span class="built_in">unique_ptr</span>&lt;ShortenedIndexBuilder&gt;(sub_index_builder_)&#125;);</span><br><span class="line">    sub_index_builder_ = <span class="literal">nullptr</span>;</span><br><span class="line">    cut_filter_block = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">    <span class="keyword">if</span> (sub_index_builder_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 判断添加 block_handle 之后是否需要刷新</span></span><br><span class="line">      <span class="comment">// 如果需要，在添加之前就先flush</span></span><br><span class="line"></span><br><span class="line">      std::string handle_encoding;</span><br><span class="line">      block_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">      <span class="comment">// 判断是否需要 flush</span></span><br><span class="line">      <span class="type">bool</span> do_flush =</span><br><span class="line">          partition_cut_requested_ ||</span><br><span class="line">          flush_policy_-&gt;<span class="built_in">Update</span>(*last_key_in_current_block, handle_encoding);</span><br><span class="line">      <span class="comment">// 需要刷新，则将之前的未 flush 的数据都存储到 entries_ 中</span></span><br><span class="line">      <span class="keyword">if</span> (do_flush) &#123;</span><br><span class="line">        entries_.<span class="built_in">push_back</span>(</span><br><span class="line">            &#123;sub_index_last_key_,</span><br><span class="line">             std::<span class="built_in">unique_ptr</span>&lt;ShortenedIndexBuilder&gt;(sub_index_builder_)&#125;);</span><br><span class="line">        cut_filter_block = <span class="literal">true</span>;</span><br><span class="line">        sub_index_builder_ = <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sub_index_builder_ == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="built_in">MakeNewSubIndexBuilder</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 考虑添加本次的数据 : block_handle</span></span><br><span class="line">    sub_index_builder_-&gt;<span class="built_in">AddIndexEntry</span>(last_key_in_current_block,</span><br><span class="line">                                      first_key_in_next_block, </span><br><span class="line">                                      block_handle);</span><br><span class="line"></span><br><span class="line">    sub_index_last_key_ = std::<span class="built_in">string</span>(*last_key_in_current_block);</span><br><span class="line">    <span class="keyword">if</span> (!seperator_is_key_plus_seq_ &amp;&amp;</span><br><span class="line">        sub_index_builder_-&gt;seperator_is_key_plus_seq_) &#123;</span><br><span class="line">      <span class="comment">// then we need to apply it to all sub-index builders and reset</span></span><br><span class="line">      <span class="comment">// flush_policy to point to Block Builder of sub_index_builder_ that store</span></span><br><span class="line">      <span class="comment">// internal keys.</span></span><br><span class="line">      seperator_is_key_plus_seq_ = <span class="literal">true</span>;</span><br><span class="line">      flush_policy_.<span class="built_in">reset</span>(FlushBlockBySizePolicyFactory::<span class="built_in">NewFlushBlockPolicy</span>(</span><br><span class="line">          table_opt_.metadata_block_size, table_opt_.block_size_deviation,</span><br><span class="line">          sub_index_builder_-&gt;index_block_builder_));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish-2"><a href="#Finish-2" class="headerlink" title="Finish"></a>Finish</h3><p>在<code>Partition</code>模式下，<code>Finish</code>函数的流程如下：</p><ul><li>每次调用<code>PartitionedIndexBuilder::Finish</code> 函数，会按照<code>FIFO</code>的原则，从<code>entries_</code>中弹出一个<code>sub_index_builder_</code>，并将其内容序列化到<code>index_blocks-&gt;index_block_contents</code> 中；</li><li>上层（即<code>TableBuilder</code>）会把<code>index_blocks</code>的内容存储到<code>SST</code>文件中，并把存储的位置和数据大小记录在 <code>last_partition_block_handle</code>中；</li><li>等下一次调用 <code>PartitionedIndexBuilder::Finish</code> 时，会把<code>last_partition_block_handle</code>序列化到<code>index_block_builder_</code>中</li><li>等 <code>PartitionedIndexBuilder::Finish</code> 函数返回<code>Status::OK()</code>，说明<code>entries_</code> 中的数据已全部存储到SST中。但是，此时<code>index_blocks</code> 中记录的是之前所有<code>sub_index_builer</code>的信息，即在SST中的存储位置和大小。</li></ul><p>也就是说，<code>PartitionedIndexBuilder</code>在SST文件中存储的格式是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">partition_index_block_1</span><br><span class="line">...</span><br><span class="line">partition_index_block_N</span><br><span class="line">TopLevelIndexBlock</span><br></pre></td></tr></table></figure><p>下面，顺着注释来看看源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">PartitionedIndexBuilder::Finish</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    IndexBlocks* index_blocks, <span class="type">const</span> BlockHandle&amp; last_partition_block_handle)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (partition_cnt_ == <span class="number">0</span>) &#123;</span><br><span class="line">    partition_cnt_ = entries_.<span class="built_in">size</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最后一个block已经被添加了</span></span><br><span class="line">  <span class="built_in">assert</span>(sub_index_builder_ == <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 重复调用 Finish 函数</span></span><br><span class="line">  <span class="keyword">if</span> (finishing_indexes == <span class="literal">true</span>) &#123;</span><br><span class="line">    Entry&amp; last_entry = entries_.<span class="built_in">front</span>();</span><br><span class="line">    std::string handle_encoding;</span><br><span class="line">    last_partition_block_handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding);</span><br><span class="line">    std::string handle_delta_encoding;</span><br><span class="line">    <span class="comment">// delta 编码</span></span><br><span class="line">    <span class="built_in">PutVarsignedint64</span>(</span><br><span class="line">        &amp;handle_delta_encoding,</span><br><span class="line">        last_partition_block_handle.<span class="built_in">size</span>() - last_encoded_handle_.<span class="built_in">size</span>());</span><br><span class="line">    last_encoded_handle_ = last_partition_block_handle;</span><br><span class="line">    <span class="function"><span class="type">const</span> Slice <span class="title">handle_delta_encoding_slice</span><span class="params">(handle_delta_encoding)</span></span>;</span><br><span class="line">    <span class="comment">// 记录 &#123;key, last_partition_block_handle&#125;</span></span><br><span class="line">    index_block_builder_.<span class="built_in">Add</span>(last_entry.key, </span><br><span class="line">                              handle_encoding,</span><br><span class="line">                             &amp;handle_delta_encoding_slice);</span><br><span class="line">    <span class="keyword">if</span> (!seperator_is_key_plus_seq_) &#123;</span><br><span class="line">      index_block_builder_without_seq_.<span class="built_in">Add</span>(<span class="built_in">ExtractUserKey</span>(last_entry.key),</span><br><span class="line">                                           handle_encoding,</span><br><span class="line">                                           &amp;handle_delta_encoding_slice);</span><br><span class="line">    &#125;</span><br><span class="line">    entries_.<span class="built_in">pop_front</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// If there is no sub_index left, then return the 2nd level index.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">UNLIKELY</span>(entries_.<span class="built_in">empty</span>())) &#123;</span><br><span class="line">    <span class="comment">// 这里的 index_block 获得的才是 </span></span><br><span class="line">    <span class="keyword">if</span> (seperator_is_key_plus_seq_) &#123;</span><br><span class="line">      index_blocks-&gt;index_block_contents = index_block_builder_.<span class="built_in">Finish</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      index_blocks-&gt;index_block_contents =</span><br><span class="line">          index_block_builder_without_seq_.<span class="built_in">Finish</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    top_level_index_size_ = index_blocks-&gt;index_block_contents.<span class="built_in">size</span>();</span><br><span class="line">    index_size_ += top_level_index_size_;</span><br><span class="line">    <span class="keyword">return</span> Status::<span class="built_in">OK</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Finish the next partition index in line and Incomplete() to indicate we</span></span><br><span class="line">    <span class="comment">// expect more calls to Finish</span></span><br><span class="line">    Entry&amp; entry = entries_.<span class="built_in">front</span>();</span><br><span class="line">    <span class="comment">// Apply the policy to all sub-indexes</span></span><br><span class="line">    entry.value-&gt;seperator_is_key_plus_seq_ = seperator_is_key_plus_seq_;</span><br><span class="line">    <span class="comment">// 这里为了获得当前block的内容</span></span><br><span class="line">    <span class="comment">// 并将其返回，返回的只是一个 partition</span></span><br><span class="line">    <span class="keyword">auto</span> s = entry.value-&gt;<span class="built_in">Finish</span>(index_blocks);</span><br><span class="line">    index_size_ += index_blocks-&gt;index_block_contents.<span class="built_in">size</span>();</span><br><span class="line">    finishing_indexes = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> s.<span class="built_in">ok</span>() ? Status::<span class="built_in">Incomplete</span>() : s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;IndexBuilder&quot;&gt;&lt;a href=&quot;#IndexBuilder&quot; class=&quot;headerlink&quot; title=&quot;IndexBuilder&quot;&gt;&lt;/a&gt;IndexBuilder&lt;/h2&gt;&lt;p&gt;&lt;code&gt;IndexBuilder&lt;/code&gt; 是个基类</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>BlockBasedTableBuilder 源码分析</title>
    <link href="https://szza.github.io/2021/11/26/rocksdb/Table/builder/4_BlockBaseTableBuilder/"/>
    <id>https://szza.github.io/2021/11/26/rocksdb/Table/builder/4_BlockBaseTableBuilder/</id>
    <published>2021-11-26T06:15:35.000Z</published>
    <updated>2023-07-31T16:46:16.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BlockBasedTableBuilder-ParallelCompressionRep"><a href="#BlockBasedTableBuilder-ParallelCompressionRep" class="headerlink" title="BlockBasedTableBuilder::ParallelCompressionRep"></a>BlockBasedTableBuilder::ParallelCompressionRep</h2><p>先来看看<code>BlockBasedTableBuilder</code>中的多线程压缩部分 <code> BlockBasedTableBuilder::ParallelCompressionRep</code>。</p><p>以下代码不加说明，都是在类 <code>BlockBasedTableBuilder::ParallelCompressionRep</code> 里面。</p><h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p>在 <code>class ParallelCompressionRep</code> 中，有个<code>class Keys</code>，这是一个为了提高内存利用率的类。涉及点：</p><ul><li>预分配 <code>kKeysInitSize</code>个元素的内存：若向<code>Keys</code>中添加的元素个数小于 <code>kKeysInitSize</code>，则使用可以使用预分配的内存，避免了动态内存分配；</li><li>每次<code>Keys::Clear()</code>的时候，并不是真的释放了之前的内存，仅仅是调整了计数器<code>size_</code>，即常见的『惰性删除』。</li></ul><p>这是常见而有效的设计，代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">Keys</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Keys</span>() : <span class="built_in">keys_</span>(kKeysInitSize), <span class="built_in">size_</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">PushBack</span><span class="params">(<span class="type">const</span> Slice&amp; key)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (size_ == keys_.<span class="built_in">size</span>()) &#123;</span><br><span class="line">       <span class="comment">// 说明 keys_的元素个数超过预分配</span></span><br><span class="line">       keys_.<span class="built_in">emplace_back</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 使用预分配内存</span></span><br><span class="line">       keys_[size_].<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">     &#125;</span><br><span class="line">     size_++;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">SwapAssign</span><span class="params">(std::vector&lt;std::string&gt;&amp; keys)</span> </span>&#123;</span><br><span class="line">     size_ = keys.<span class="built_in">size</span>();</span><br><span class="line">     std::<span class="built_in">swap</span>(keys_, keys);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 惰性删除</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Clear</span><span class="params">()</span> </span>&#123; size_ = <span class="number">0</span>; &#125;</span><br><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line">   <span class="function">std::string&amp; <span class="title">Back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> keys_[size_ - <span class="number">1</span>]; &#125;</span><br><span class="line">   std::string&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> idx) &#123;</span><br><span class="line">     <span class="built_in">assert</span>(idx &lt; size_);</span><br><span class="line">     <span class="keyword">return</span> keys_[idx];</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   <span class="type">const</span> <span class="type">size_t</span> kKeysInitSize = <span class="number">32</span>;</span><br><span class="line">   std::vector&lt;std::string&gt; keys_;</span><br><span class="line">   <span class="type">size_t</span> size_;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line">std::unique_ptr&lt;Keys&gt; curr_block_keys;</span><br></pre></td></tr></table></figure><h3 id="WorkQueue"><a href="#WorkQueue" class="headerlink" title="WorkQueue"></a>WorkQueue</h3><p>在继续讲解之前，先讲解下Rocksdb保证多线程安全的队列。</p><p>在rocksdb中，是怎么保证多线程压缩的顺序性呢，依赖<code>WorkQueue</code>，<code>WorkQueue</code>其实就是个很简单的『生产-消费』多线程模型：写线程和多线程之间共享一个任务队列 <code>queue_</code>，以及保护这个共享队列<code>queue_</code>的互斥锁<code>mutex_</code>。</p><p><code>WorkQueue</code>在<code>::Finish</code>函数之后，就不可用了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WorkQueue</span> &#123;</span><br><span class="line">  std::mutex mutex_;</span><br><span class="line">  std::condition_variable readerCv_;</span><br><span class="line">  std::condition_variable writerCv_;</span><br><span class="line">  std::condition_variable finishCv_;</span><br><span class="line"></span><br><span class="line">  std::queue&lt;T&gt; queue_;</span><br><span class="line">  <span class="type">bool</span> done_;</span><br><span class="line">  std::<span class="type">size_t</span> maxSize_;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 必须在锁中调用这个函数</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">full</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (maxSize_ == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue_.<span class="built_in">size</span>() &gt;= maxSize_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">WorkQueue</span>(std::<span class="type">size_t</span> maxSize = <span class="number">0</span>) : <span class="built_in">done_</span>(<span class="literal">false</span>), <span class="built_in">maxSize_</span>(maxSize) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">push</span><span class="params">(U&amp;&amp; item)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">  <span class="type">bool</span> <span class="title">pop</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">finish</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">waitUntilFinished</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 更改 queue_ 大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">setMaxSize</span><span class="params">(std::<span class="type">size_t</span> maxSize)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">      maxSize_ = maxSize;</span><br><span class="line">     &#125;</span><br><span class="line">    writerCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="push"><a href="#push" class="headerlink" title="push"></a>push</h4><p><code>push</code> 函数，向共享队列<code>queue_</code> 中添加一个任务，成功则返回true。如果已经调用了<code>::Finish</code> 函数，则返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">WorkQueue::push</span><span class="params">(U&amp;&amp; item)</span> </span>&#123;</span><br><span class="line">   &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// 等待 queue_ 队列为空</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">full</span>() &amp;&amp; !done_) &#123;</span><br><span class="line">      writerCv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果调用了 Finish 函数</span></span><br><span class="line">    <span class="comment">// 则不再接受新的元素</span></span><br><span class="line">    <span class="keyword">if</span> (done_) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加新的元素</span></span><br><span class="line">    queue_.<span class="built_in">push</span>(std::forward&lt;U&gt;(item));</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">// 通知读线程</span></span><br><span class="line">  readerCv_.<span class="built_in">notify_one</span>();</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="pop"><a href="#pop" class="headerlink" title="pop"></a>pop</h4><p><code>pop</code>函数，按照FIFO规则从共享任务队列 <code>queue_</code> 中弹出一个待处理任务，并返回true。</p><p>如果已经调用了<code>::Finish</code> 函数，则返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"> <span class="type">bool</span> <span class="title">WorkQueue::pop</span><span class="params">(T&amp; item)</span> </span>&#123;</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">// 等写线程添加元素</span></span><br><span class="line">     <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">     <span class="keyword">while</span> (queue_.<span class="built_in">empty</span>() &amp;&amp; !done_) &#123;</span><br><span class="line">       readerCv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="comment">// 如果已经调用了 ::Finish 函数</span></span><br><span class="line">     <span class="comment">// 则不再处理</span></span><br><span class="line">     <span class="keyword">if</span> (queue_.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">       <span class="built_in">assert</span>(done_);</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 弹出</span></span><br><span class="line">     item = queue_.<span class="built_in">front</span>();</span><br><span class="line">     queue_.<span class="built_in">pop</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 通知写线程</span></span><br><span class="line">   writerCv_.<span class="built_in">notify_one</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="waitUntilFinished"><a href="#waitUntilFinished" class="headerlink" title="waitUntilFinished"></a>waitUntilFinished</h4><p><code>waitUntilFinished</code> 函数，用于阻塞等待 <code>WorkQueue::Finish</code> 函数调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">waitUntilFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">  <span class="keyword">while</span> (!done_) &#123;</span><br><span class="line">    finishCv_.<span class="built_in">wait</span>(lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="finish"><a href="#finish" class="headerlink" title="finish"></a>finish</h4><p><code>::Finish</code> 函数调用后，<code>WorkQueue</code> 不再处理接受新的元素，也不再弹出旧的元素，<code>waitUntilFinished</code> 函数就能返回了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">WorkQueue::finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="built_in">assert</span>(!done_);</span><br><span class="line">    done_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  readerCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  writerCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">  finishCv_.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="BlockRepSlot"><a href="#BlockRepSlot" class="headerlink" title="BlockRepSlot"></a>BlockRepSlot</h3><p><code>BlockRepSlot</code> 是基于<code>WorkQueue</code>实现的线程安全队列。</p><p>每个节点<code>BlockRep*</code>记录一个block的相关数据及其状态，那么就可以由写线程将<code>BlockRep</code>节点加入到<code>BlockRepSlot</code>中，压缩等工作线程从<code>BlockRepSlot</code>中通过<code>take</code>函数取出<code>BlockRep</code>节点，对其进行压缩等操作。</p><p>如此，就能完成多线程操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// BlockRep 记录一个 block 的数据及其相关信息</span></span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">BlockRep</span> &#123;</span><br><span class="line">   Slice contents;                      <span class="comment">// 原始内容</span></span><br><span class="line">   Slice compressed_contents;                     <span class="comment">// 压缩内容</span></span><br><span class="line">   std::unique_ptr&lt;std::string&gt; data;             <span class="comment">// 原始内容， 与 contents 区别</span></span><br><span class="line">   std::unique_ptr&lt;std::string&gt; compressed_data;  <span class="comment">// 压缩之后的数据</span></span><br><span class="line">   CompressionType compression_type;              <span class="comment">// 压缩类型</span></span><br><span class="line">   std::unique_ptr&lt;std::string&gt; first_key_in_next_block;</span><br><span class="line">   std::unique_ptr&lt;Keys&gt; keys;                    <span class="comment">// 此block的所有keys</span></span><br><span class="line">   std::unique_ptr&lt;BlockRepSlot&gt; slot;            <span class="comment">// 所属的 BlockRepSlot  ???          </span></span><br><span class="line">   Status status;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockRepSlot</span> &#123;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">BlockRepSlot</span>() : <span class="built_in">slot_</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 向 slot_ 中添加一</span></span><br><span class="line">   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Fill</span><span class="params">(T&amp;&amp; rep)</span> </span>&#123;</span><br><span class="line">     slot_.<span class="built_in">push</span>(std::forward&lt;T&gt;(rep));</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">Take</span><span class="params">(BlockRep*&amp; rep)</span> </span>&#123; slot_.<span class="built_in">pop</span>(rep); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">   WorkQueue&lt;BlockRep*&gt; slot_;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><h3 id="FileSizeEstimator"><a href="#FileSizeEstimator" class="headerlink" title="FileSizeEstimator"></a>FileSizeEstimator</h3><p>当并行压缩开启时，类 <code>FileSizeEstimator</code> 用于计算输出文件大小。主要是有两个回调函数 <code>EmitBlock</code>  、<code>ReapBlock</code>：</p><ul><li><code>EmitBlock</code>：在添加到压缩线程之前调用</li><li><code>ReapBlock</code>：在压缩完成之后调用</li></ul><p><code>FileSizeEstimator</code> 的源码简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileSizeEstimator</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">FileSizeEstimator</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      : raw_bytes_compressed(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        raw_bytes_curr_block(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        raw_bytes_curr_block_set(false),</span></span><br><span class="line"><span class="function">        raw_bytes_inflight(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        blocks_inflight(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        curr_compression_ratio(<span class="number">0</span>),</span></span><br><span class="line"><span class="function">        estimated_file_size(<span class="number">0</span>) &#123;</span>&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 当一个 block 要 emit to 压缩线程时，则计算一个文件大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(<span class="type">uint64_t</span> raw_block_size, <span class="type">uint64_t</span> curr_file_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 当一个 block 从压缩线程压缩完毕时</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(<span class="type">uint64_t</span> compressed_block_size, <span class="type">uint64_t</span> curr_file_size)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 设置文件近似大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetEstimatedFileSize</span><span class="params">(<span class="type">uint64_t</span> size)</span> </span>&#123;</span><br><span class="line">    estimated_file_size.<span class="built_in">store</span>(size, std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 获得文件近似大小</span></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">GetEstimatedFileSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> estimated_file_size.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="comment">/// 设置block大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">SetCurrBlockRawSize</span><span class="params">(<span class="type">uint64_t</span> size)</span> </span>&#123;</span><br><span class="line">    raw_bytes_curr_block = size;</span><br><span class="line">    raw_bytes_curr_block_set = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="type">uint64_t</span> raw_bytes_compressed;  <span class="comment">// 到目前为止压缩的字节，即这么多的字节是要要压缩的</span></span><br><span class="line">  <span class="type">uint64_t</span> raw_bytes_curr_block;  <span class="comment">// Size of current block being appended.</span></span><br><span class="line">  <span class="type">bool</span> raw_bytes_curr_block_set;  <span class="comment">// </span></span><br><span class="line">  std::atomic&lt;<span class="type">uint64_t</span>&gt; raw_bytes_inflight; <span class="comment">// 正在压缩，但尚未添加到sst文件的字节大小</span></span><br><span class="line">  std::atomic&lt;<span class="type">uint64_t</span>&gt; blocks_inflight;    <span class="comment">// Number of blocks under compression and not appended yet.</span></span><br><span class="line">  std::atomic&lt;<span class="type">double</span>&gt; curr_compression_ratio; <span class="comment">// 压缩率</span></span><br><span class="line">  std::atomic&lt;<span class="type">uint64_t</span>&gt; estimated_file_size;  <span class="comment">// SST 文件的近似大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="EmitBlock"><a href="#EmitBlock" class="headerlink" title="EmitBlock"></a>EmitBlock</h4><p><code>EmitBlock</code>函数，在将一个待压缩的block发送给压缩线程之前调用，用于计算当所有block压缩完成后sst文件的近似大小。主要有三部分组成：</p><ol><li><code>curr_file_size</code>：已写入到sst的部分</li><li><code>new_raw_bytes_inflight</code>：当前正在压缩，还没写入sst的部分。这部分按照压缩率<code>curr_compression_ratio</code> 大致折算成最终写入sst的大小。</li><li><code>kBlockTrailerSize</code>：每个block都有<code>footer</code>，这部分不压缩，按照正在压缩的block数<code>new_blocks_inflight</code> 乘以每个<code>footer</code>的大小<code>kBlockTrailerSize</code>，即这部分写入sst的大小。</li></ol><p>源码简单如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param raw_block_size 待压缩的 block 大小</span></span><br><span class="line"><span class="comment">/// @param curr_file_size </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(<span class="type">uint64_t</span> raw_block_size, <span class="type">uint64_t</span> curr_file_size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前正在压缩的字节数</span></span><br><span class="line">    <span class="type">uint64_t</span> new_raw_bytes_inflight =</span><br><span class="line">        raw_bytes_inflight.<span class="built_in">fetch_add</span>(raw_block_size,</span><br><span class="line">                                     std::memory_order_relaxed) +</span><br><span class="line">        raw_block_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在压缩的block数据</span></span><br><span class="line">    <span class="type">uint64_t</span> new_blocks_inflight =</span><br><span class="line">        blocks_inflight.<span class="built_in">fetch_add</span>(<span class="number">1</span>, std::memory_order_relaxed) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    estimated_file_size.<span class="built_in">store</span>(</span><br><span class="line">        curr_file_size +  <span class="comment">// 1. 已经写入 sst 的大小</span></span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(new_raw_bytes_inflight) * <span class="comment">// 2. 压缩完成的大小 = 当前正在压缩 * 压缩率</span></span><br><span class="line">                curr_compression_ratio.<span class="built_in">load</span>(std::memory_order_relaxed)) +</span><br><span class="line">            new_blocks_inflight * kBlockTrailerSize, <span class="comment">// 3. new_blocks_inflight * 脚注大小</span></span><br><span class="line">        std::memory_order_relaxed);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="ReapBlock"><a href="#ReapBlock" class="headerlink" title="ReapBlock"></a>ReapBlock</h4><p><code>ReapBlock</code>，也是个回调函数 ，当一个block压缩完毕时调用，来更新当前压缩的状态：</p><ul><li><code>raw_bytes_compressed</code>：到目前为止，有多少字节的数据被压缩了；</li><li><code>curr_compression_ratio</code>：已压缩的字节数 / 当前对应的原始字节数</li><li>重新估算最终写入sst文件的大小</li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(<span class="type">uint64_t</span> compressed_block_size, <span class="type">uint64_t</span> curr_file_size)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(raw_bytes_curr_block_set);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前一共被压缩的字节数</span></span><br><span class="line">    <span class="type">uint64_t</span> new_raw_bytes_compressed =</span><br><span class="line">        raw_bytes_compressed + raw_bytes_curr_block;</span><br><span class="line">    <span class="built_in">assert</span>(new_raw_bytes_compressed &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新压缩率</span></span><br><span class="line">    <span class="comment">// 分子：压缩的字节，分母：原始字节</span></span><br><span class="line">    curr_compression_ratio.<span class="built_in">store</span>(</span><br><span class="line">        (curr_compression_ratio.<span class="built_in">load</span>(std::memory_order_relaxed) *</span><br><span class="line">             raw_bytes_compressed +</span><br><span class="line">         compressed_block_size) /</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(new_raw_bytes_compressed),</span><br><span class="line">        std::memory_order_relaxed);</span><br><span class="line">    <span class="comment">// 更新</span></span><br><span class="line">    raw_bytes_compressed = new_raw_bytes_compressed;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复</span></span><br><span class="line">    <span class="type">uint64_t</span> new_raw_bytes_inflight =</span><br><span class="line">        raw_bytes_inflight.<span class="built_in">fetch_sub</span>(raw_bytes_curr_block,</span><br><span class="line">                                     std::memory_order_relaxed) -</span><br><span class="line">        raw_bytes_curr_block;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint64_t</span> new_blocks_inflight =</span><br><span class="line">        blocks_inflight.<span class="built_in">fetch_sub</span>(<span class="number">1</span>, std::memory_order_relaxed) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新计算下文件大小</span></span><br><span class="line">    estimated_file_size.<span class="built_in">store</span>(</span><br><span class="line">        curr_file_size +</span><br><span class="line">            <span class="built_in">static_cast</span>&lt;<span class="type">uint64_t</span>&gt;(</span><br><span class="line">                <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(new_raw_bytes_inflight) * </span><br><span class="line">                curr_compression_ratio.<span class="built_in">load</span>(std::memory_order_relaxed)) +</span><br><span class="line">            new_blocks_inflight * kBlockTrailerSize,</span><br><span class="line">        std::memory_order_relaxed);</span><br><span class="line"></span><br><span class="line">    raw_bytes_curr_block_set = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ParallelCompressionRep"><a href="#ParallelCompressionRep" class="headerlink" title="ParallelCompressionRep"></a>ParallelCompressionRep</h3><p>为了更好地理解 <code>class ParallelCompressionRep</code>，下面在讲解源码时，会调整下不同字段的顺序。</p><p><code>ParallelCompressionRep</code>，使用顺序如下：</p><ul><li>在<code>ParallelCompressionRep</code>内部，会调用<code>ParallelCompressionRep::PrepareBlock</code>接口，准备此block的数据；</li><li>调用 <code>EmitBlock</code>函数发送给压缩线程；</li><li>当压缩完成，会调用<code>ParallelCompressionRep::ReapBlock</code>接口。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">BlockBasedTableBuilder</span>::ParallelCompressionRep &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Keys</span>              &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">BlockRepSlot</span>      &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">BlockRep</span>         &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">FileSizeEstimator</span> &#123; <span class="comment">/***/</span> &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">typedef</span> std::vector&lt;BlockRep&gt;    BlockRepBuffer;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRep*&gt;     BlockRepPool;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRep*&gt;     CompressQueue;</span><br><span class="line">  <span class="keyword">typedef</span> WorkQueue&lt;BlockRepSlot*&gt; WriteQueue;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 字段</span></span><br><span class="line">  std::unique_ptr&lt;Keys&gt;         curr_block_keys;      <span class="comment">// 当前block的key</span></span><br><span class="line">  BlockRepBuffer                block_rep_buf;        <span class="comment">// 记录各个block的数据状态</span></span><br><span class="line">  BlockRepPool                  block_rep_pool;       <span class="comment">// block_rep_pool 中记录的是 block_rep_buf</span></span><br><span class="line">  CompressQueue                 compress_queue;       <span class="comment">// 待压缩的任务队列</span></span><br><span class="line">  std::vector&lt;port::Thread&gt;     compress_thread_pool; <span class="comment">// 压缩线程</span></span><br><span class="line">  WriteQueue                    write_queue;          <span class="comment">// 写入文件的队列</span></span><br><span class="line">  std::unique_ptr&lt;port::Thread&gt; write_thread;    <span class="comment">// 写线程</span></span><br><span class="line">  FileSizeEstimator             file_size_estimator;  <span class="comment">// 评估文件大小</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待第一个 block 压缩完成</span></span><br><span class="line">  std::atomic&lt;<span class="type">bool</span>&gt;             first_block_processed;</span><br><span class="line">  std::condition_variable       first_block_cond;</span><br><span class="line">  std::mutex                    first_block_mutex;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">ParallelCompressionRep</span><span class="params">(<span class="type">uint32_t</span> parallel_threads)</span></span></span><br><span class="line"><span class="function">      : curr_block_keys(new Keys()),</span></span><br><span class="line"><span class="function">        block_rep_buf(parallel_threads),</span></span><br><span class="line"><span class="function">        block_rep_pool(parallel_threads),</span></span><br><span class="line"><span class="function">        compress_queue(parallel_threads),</span></span><br><span class="line"><span class="function">        write_queue(parallel_threads),</span></span><br><span class="line"><span class="function">        first_block_processed(false) &#123;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; parallel_threads; i++) &#123;</span><br><span class="line">      block_rep_buf[i].contents = <span class="built_in">Slice</span>();</span><br><span class="line">      block_rep_buf[i].compressed_contents = <span class="built_in">Slice</span>();</span><br><span class="line">      block_rep_buf[i].data.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].compressed_data.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].compression_type = <span class="built_in">CompressionType</span>();</span><br><span class="line">      block_rep_buf[i].first_key_in_next_block.<span class="built_in">reset</span>(<span class="keyword">new</span> std::<span class="built_in">string</span>());</span><br><span class="line">      block_rep_buf[i].keys.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">Keys</span>());</span><br><span class="line">      block_rep_buf[i].slot.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">BlockRepSlot</span>());</span><br><span class="line">      block_rep_buf[i].status = Status::<span class="built_in">OK</span>();</span><br><span class="line">      <span class="comment">// 放到线程池</span></span><br><span class="line">      <span class="comment">// 因此，block_rep_pool 中每个元素的生命周期是由 block_rep_buf 中的每个元素负责</span></span><br><span class="line">      <span class="comment">// block_rep_buf 中存储着原始数据</span></span><br><span class="line">      block_rep_pool.<span class="built_in">push</span>(&amp;block_rep_buf[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/// 等待完成</span></span><br><span class="line">  ~<span class="built_in">ParallelCompressionRep</span>() &#123; block_rep_pool.<span class="built_in">finish</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 使用在 non-buffered 模式</span></span><br><span class="line">  <span class="comment">/// 准备好一个 block，并准备发送给 压缩线程</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                         BlockBuilder* data_block)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Used in EnterUnbuffered</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::string* data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                         std::vector&lt;std::string&gt;* keys)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将 block 发送给 压缩线程</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 接受从压缩线程的结果</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(BlockRep* block_rep)</span></span>;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">/// 生成 block</span></span><br><span class="line">  <span class="function">BlockRep* <span class="title">PrepareBlockInternal</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> Slice* first_key_in_next_block)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="PrepareBlockInternal"><a href="#PrepareBlockInternal" class="headerlink" title="PrepareBlockInternal"></a>PrepareBlockInternal</h4><p>下面，先来讲讲怎么创建一个 <code>BlockRep</code>对象。</p><h5 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h5><p><code>block_rep_pool</code> 的意义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成 block</span></span><br><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlockInternal</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                               <span class="type">const</span> Slice* first_key_in_next_block)</span> </span>&#123;</span><br><span class="line">  BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 从 block_rep_pool 头部出来</span></span><br><span class="line">  block_rep_pool.<span class="built_in">pop</span>(block_rep);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">assert</span>(block_rep-&gt;data);</span><br><span class="line"></span><br><span class="line">  block_rep-&gt;compression_type = compression_type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_key_in_next_block == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// 表示最后一个block</span></span><br><span class="line">    block_rep-&gt;first_key_in_next_block.<span class="built_in">reset</span>(<span class="literal">nullptr</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 非最后一个block</span></span><br><span class="line">    block_rep-&gt;first_key_in_next_block-&gt;<span class="built_in">assign</span>(</span><br><span class="line">        first_key_in_next_block-&gt;<span class="built_in">data</span>(), first_key_in_next_block-&gt;<span class="built_in">size</span>());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PrepareBlock"><a href="#PrepareBlock" class="headerlink" title="PrepareBlock"></a>PrepareBlock</h4><p>在将待压缩的block发送给压缩线程之前，要先准备好这个block。</p><p><code>PrepareBlock</code> 函数，即用于完成这个过程。</p><ul><li><code>compression_type</code>：压缩类型</li><li><code>first_key_in_next_block</code>：下一个block的第一个<code>key</code></li><li><code>data_block</code>：待压缩的block的数据部分</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                       BlockBuilder* data_block)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 block_req</span></span><br><span class="line">  BlockRep* block_rep =</span><br><span class="line">      <span class="built_in">PrepareBlockInternal</span>(compression_type, first_key_in_next_block);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 将 data_block 中数据给 block_rep-&gt;data</span></span><br><span class="line">  data_block-&gt;<span class="built_in">SwapAndReset</span>(*(block_rep-&gt;data));</span><br><span class="line">  <span class="comment">// 数据复制给 block_rep-&gt;contents</span></span><br><span class="line">  block_rep-&gt;contents = *(block_rep-&gt;data);</span><br><span class="line">  <span class="comment">// 再将当前block的数据给 block_rep-&gt;keys</span></span><br><span class="line">  std::<span class="built_in">swap</span>(block_rep-&gt;keys, curr_block_keys);</span><br><span class="line">  curr_block_keys-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PrepareBlock-1"><a href="#PrepareBlock-1" class="headerlink" title="PrepareBlock"></a>PrepareBlock</h4><p><code>PrepareBlock</code> 只是上述函数的重载。上述函数传入的是一个<code>BlockBuilder*</code>，这里只是把原本一个<code>BlockBuilder</code> 记录的数据分别传入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BlockRep* <span class="title">PrepareBlock</span><span class="params">(CompressionType compression_type,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">const</span> Slice* first_key_in_next_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::string* data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                       std::vector&lt;std::string&gt;* keys)</span> </span>&#123;</span><br><span class="line">  BlockRep* block_rep =</span><br><span class="line">      <span class="built_in">PrepareBlockInternal</span>(compression_type, first_key_in_next_block);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  std::<span class="built_in">swap</span>(*(block_rep-&gt;data), *data_block);</span><br><span class="line">  block_rep-&gt;contents = *(block_rep-&gt;data);</span><br><span class="line">  block_rep-&gt;keys-&gt;<span class="built_in">SwapAssign</span>(*keys);</span><br><span class="line">  <span class="keyword">return</span> block_rep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="EmitBlock-1"><a href="#EmitBlock-1" class="headerlink" title="EmitBlock"></a>EmitBlock</h4><p>将上述准备好的block发送给压缩线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 block 发送给 压缩线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">assert</span>(block_rep-&gt;status.<span class="built_in">ok</span>());</span><br><span class="line">  <span class="comment">// 将准备好的block加入工作队列</span></span><br><span class="line">  <span class="keyword">if</span> (!write_queue.<span class="built_in">push</span>(block_rep-&gt;slot.<span class="built_in">get</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!compress_queue.<span class="built_in">push</span>(block_rep)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 等待压缩完成 </span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到 first_block_processed 为 true</span></span><br><span class="line">    first_block_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">return</span> first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReapBlock-1"><a href="#ReapBlock-1" class="headerlink" title="ReapBlock"></a>ReapBlock</h4><h5 id="TODO-1"><a href="#TODO-1" class="headerlink" title="TODO"></a>TODO</h5><p><code>ReapBlock</code>，当压缩完成时的回调函数。??? 应该是写入文件???</p><p>用于清除压缩数据，通知emit线程，可以继续压缩</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Reap a block from compression thread</span></span><br><span class="line"><span class="comment">// 接受从压缩线程的结果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReapBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 清除压缩数据</span></span><br><span class="line">  block_rep-&gt;compressed_data-&gt;<span class="built_in">clear</span>();</span><br><span class="line">  <span class="comment">// ??? </span></span><br><span class="line">  block_rep_pool.<span class="built_in">push</span>(block_rep);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知 emit Block，可以继续压缩</span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    first_block_processed.<span class="built_in">store</span>(<span class="literal">true</span>, std::memory_order_relaxed);</span><br><span class="line">    first_block_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BlockBasedTableBuilder"><a href="#BlockBasedTableBuilder" class="headerlink" title="BlockBasedTableBuilder"></a>BlockBasedTableBuilder</h2><p>初始化操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">BlockBasedTableBuilder::<span class="built_in">BlockBasedTableBuilder</span>(</span><br><span class="line">    <span class="type">const</span> BlockBasedTableOptions&amp; table_options, <span class="type">const</span> TableBuilderOptions&amp; tbo,</span><br><span class="line">    WritableFileWriter* file) &#123;</span><br><span class="line">  <span class="function">BlockBasedTableOptions <span class="title">sanitized_table_options</span><span class="params">(table_options)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 压缩格式</span></span><br><span class="line">  <span class="keyword">if</span> (sanitized_table_options.format_version == <span class="number">0</span> &amp;&amp;</span><br><span class="line">      sanitized_table_options.checksum != kCRC32c) &#123;</span><br><span class="line">    <span class="built_in">ROCKS_LOG_WARN</span>(</span><br><span class="line">        tbo.ioptions.logger,</span><br><span class="line">        <span class="string">&quot;Silently converting format_version to 1 because checksum is &quot;</span></span><br><span class="line">        <span class="string">&quot;non-default&quot;</span>);</span><br><span class="line">    <span class="comment">// silently convert format_version to 1 to keep consistent with current</span></span><br><span class="line">    <span class="comment">// behavior</span></span><br><span class="line">    sanitized_table_options.format_version = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 rep_</span></span><br><span class="line">  rep_ = <span class="keyword">new</span> <span class="built_in">Rep</span>(sanitized_table_options, tbo, file);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// filter block 此时还没创建，初始化</span></span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    rep_-&gt;filter_builder-&gt;<span class="built_in">StartBlock</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 生成前缀</span></span><br><span class="line">  <span class="keyword">if</span> (table_options.block_cache_compressed.<span class="built_in">get</span>() != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    BlockBasedTable::<span class="built_in">GenerateCachePrefix</span>&lt;Cache, FSWritableFile&gt;(</span><br><span class="line">        table_options.block_cache_compressed.<span class="built_in">get</span>(), </span><br><span class="line">        file-&gt;<span class="built_in">writable_file</span>(),</span><br><span class="line">        &amp;rep_-&gt;compressed_cache_key_prefix[<span class="number">0</span>],    <span class="comment">// 输出参数</span></span><br><span class="line">        &amp;rep_-&gt;compressed_cache_key_prefix_size,  <span class="comment">// 输出参数</span></span><br><span class="line">        tbo.db_session_id,</span><br><span class="line">        tbo.cur_file_num);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 开启多线程压缩</span></span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">StartParallelCompression</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ParallelCompression"><a href="#ParallelCompression" class="headerlink" title="ParallelCompression"></a>ParallelCompression</h3><p>下面从压缩开始。</p><p>每个data_block在写入sst之前，如果设置了压缩，则都会经过一个压缩的过程。</p><h4 id="IsParallelCompressionEnabled"><a href="#IsParallelCompressionEnabled" class="headerlink" title="IsParallelCompressionEnabled"></a>IsParallelCompressionEnabled</h4><p>是否开启多线程压缩，则由 <code>CompressionOptions::parallel_threads</code> 字段的值指示。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> BlockBasedTableBuilder::Rep::<span class="built_in">IsParallelCompressionEnabled</span>() <span class="type">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> compression_opts.parallel_threads &gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StartParallelCompression"><a href="#StartParallelCompression" class="headerlink" title="StartParallelCompression"></a>StartParallelCompression</h4><p>如果开启了多线程压缩，压缩流程如下：</p><ul><li>在每次压缩前，主线程，使用<code>ParallelCompressionRep::PrepareBlock</code>函数，准备好待压缩的block；</li><li>主线程调用<code>ParallelCompressionRep::EmitBlock</code>函数，将block送入压缩线程；</li><li>压缩线程再进行压缩</li><li>将压缩完毕的data_block，写入到sst文件中</li></ul><p>下面是开启多个压缩线程的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::StartParallelCompression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化 ParallelCompressionRep 对象</span></span><br><span class="line">  rep_-&gt;pc_rep.<span class="built_in">reset</span>(</span><br><span class="line">      <span class="keyword">new</span> <span class="built_in">ParallelCompressionRep</span>(rep_-&gt;compression_opts.parallel_threads));</span><br><span class="line">  rep_-&gt;pc_rep-&gt;compress_thread_pool.<span class="built_in">reserve</span>(</span><br><span class="line">      rep_-&gt;compression_opts.parallel_threads);</span><br><span class="line">  <span class="comment">// 开启 parallel_threads 个压缩线程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; rep_-&gt;compression_opts.parallel_threads; i++) &#123;</span><br><span class="line">    rep_-&gt;pc_rep-&gt;compress_thread_pool.<span class="built_in">emplace_back</span>([<span class="keyword">this</span>, i] &#123;</span><br><span class="line">      <span class="built_in">BGWorkCompression</span>(*(rep_-&gt;compression_ctxs[i]),  <span class="comment">// 压缩上下文</span></span><br><span class="line">                          rep_-&gt;verify_ctxs[i].<span class="built_in">get</span>()); <span class="comment">// 解压上下文</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 开启 1 个写线程</span></span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_thread.<span class="built_in">reset</span>(</span><br><span class="line">      <span class="keyword">new</span> port::<span class="built_in">Thread</span>([<span class="keyword">this</span>] &#123; <span class="built_in">BGWorkWriteRawBlock</span>(); &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BGWorkCompression"><a href="#BGWorkCompression" class="headerlink" title="BGWorkCompression"></a>BGWorkCompression</h5><p>压缩线程的入口函数，<code>BGWorkCompression</code> ，仅用于压缩<code>data_block</code>，他一直在等待主线程发送待压缩的block，然后取出来，进行压缩。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::BGWorkCompression</span><span class="params">(<span class="type">const</span> CompressionContext&amp; compression_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                               UncompressionContext* verify_ctx)</span> </span>&#123;</span><br><span class="line">  ParallelCompressionRep::BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (rep_-&gt;pc_rep-&gt;compress_queue.<span class="built_in">pop</span>(block_rep)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">CompressAndVerifyBlock</span>(block_rep-&gt;contents, </span><br><span class="line">                           <span class="literal">true</span>, <span class="comment">/* is_data_block*/</span></span><br><span class="line">                           compression_ctx, </span><br><span class="line">                           verify_ctx,</span><br><span class="line">                           block_rep-&gt;compressed_data.<span class="built_in">get</span>(), <span class="comment">// 输出参数，unused ?</span></span><br><span class="line">                           &amp;block_rep-&gt;compressed_contents,  <span class="comment">// 保存压缩结果</span></span><br><span class="line">                           &amp;(block_rep-&gt;compression_type),   <span class="comment">// 压缩结果的字节数</span></span><br><span class="line">                           &amp;block_rep-&gt;status);              <span class="comment">// 压缩是否成功</span></span><br><span class="line">    <span class="comment">// 将压缩完毕的 block 加入到 block_rep-&gt;slot 中</span></span><br><span class="line">    <span class="comment">// 为后面写入sst准备</span></span><br><span class="line">    block_rep-&gt;slot-&gt;<span class="built_in">Fill</span>(block_rep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="CompressAndVerifyBlock"><a href="#CompressAndVerifyBlock" class="headerlink" title="CompressAndVerifyBlock"></a>CompressAndVerifyBlock</h5><p>CompressAndVerifyBlock` 函数，不仅尝试去压缩，而且会统计压缩过程中的一些信息。为便于下面的代码简洁，易于理解，把这部分去掉了，专注于功能。</p><p>sst是由一系列的<code>block</code>组成，每个<code>block</code>的格式都是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">block_data: uint8[n] <span class="comment"># block 存储的数据</span></span><br><span class="line"><span class="built_in">type</span>: uint8          <span class="comment"># 压缩类型</span></span><br><span class="line">crc: uint32          <span class="comment"># 校验和</span></span><br></pre></td></tr></table></figure><p>顺序的压缩过程如下：</p><ol><li>当前待压缩的数据是<code>raw_block_contents</code>，其大小不能超过 <code>kCompressionSizeLimit</code> 限制；</li><li>先尝试调用 <code>CompressBlock</code> 函数压缩，结果保存至<code>block_contents</code>；</li><li>如果设置了校验压缩结果，即设置了 <code>table_options.verify_compression</code> 标志位，则会对<code>block_contents</code>进行解压，保存至<code>contents</code>，顺利的压缩，需要保证 <code>block_contents</code> 和 <code>contents</code> 相同；</li></ol><p>如果一切顺利，则：</p><ul><li> <code>block_contents</code> 中保存了<code>raw_block_contents</code>的压缩结果，</li><li><code>type</code> 保存了压缩类型；</li></ul><p>代码简洁后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::CompressAndVerifyBlock</span><span class="params">(<span class="type">const</span> Slice&amp; raw_block_contents, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">bool</span> is_data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    <span class="type">const</span> CompressionContext&amp; compression_ctx, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    UncompressionContext* verify_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    std::string* compressed_output,  <span class="comment">// unused</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Slice* block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                                    CompressionType* type, </span></span></span><br><span class="line"><span class="params"><span class="function">                                                    Status* out_status)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="type">bool</span> is_status_ok = <span class="built_in">ok</span>();</span><br><span class="line">  <span class="keyword">if</span> (!r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(is_status_ok);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  *type = r-&gt;compression_type;</span><br><span class="line">  <span class="comment">// 采样多少个字节用于压缩</span></span><br><span class="line">  <span class="type">uint64_t</span> sample_for_compression = r-&gt;sample_for_compression;</span><br><span class="line">  <span class="comment">// 中止压缩</span></span><br><span class="line">  <span class="type">bool</span> abort_compression = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">StopWatchNano <span class="title">timer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      r-&gt;ioptions.clock,</span></span></span><br><span class="line"><span class="params"><span class="function">      ShouldReportDetailedTime(r-&gt;ioptions.env, r-&gt;ioptions.stats))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 每次压缩字节大小有限制</span></span><br><span class="line">  <span class="keyword">if</span> (is_status_ok &amp;&amp; raw_block_contents.<span class="built_in">size</span>() &lt; kCompressionSizeLimit) &#123;</span><br><span class="line">    <span class="comment">// 1. 获取 compression_dict</span></span><br><span class="line">    <span class="type">const</span> CompressionDict* compression_dict;</span><br><span class="line">    <span class="keyword">if</span> (!is_data_block || r-&gt;compression_dict == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      compression_dict = &amp;CompressionDict::<span class="built_in">GetEmptyDict</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      compression_dict = r-&gt;compression_dict.<span class="built_in">get</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert</span>(compression_dict != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 构造对象</span></span><br><span class="line">    <span class="function">CompressionInfo <span class="title">compression_info</span><span class="params">(r-&gt;compression_opts, </span></span></span><br><span class="line"><span class="params"><span class="function">                                     compression_ctx,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     *compression_dict, </span></span></span><br><span class="line"><span class="params"><span class="function">                                     *type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                     sample_for_compression)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::string sampled_output_fast;</span><br><span class="line">    std::string sampled_output_slow;</span><br><span class="line">    <span class="comment">/// 尝试将 @c raw_block_contents 进行压缩，并返回至 @c compressed_output</span></span><br><span class="line">    *block_contents = <span class="built_in">CompressBlock</span>(raw_block_contents, </span><br><span class="line">                                    compression_info, </span><br><span class="line">                                    type,</span><br><span class="line">                                    r-&gt;table_options.format_version, </span><br><span class="line">                                    is_data_block <span class="comment">/* do_sample */</span>,</span><br><span class="line">                                    compressed_output, </span><br><span class="line">                                    &amp;sampled_output_fast, </span><br><span class="line">                                    &amp;sampled_output_slow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 由于一些压缩算法不太可靠，因此如果设置了 verify_compression</span></span><br><span class="line">    <span class="comment">// 则需要校验</span></span><br><span class="line">    <span class="keyword">if</span> (*type != kNoCompression &amp;&amp; r-&gt;table_options.verify_compression) &#123;</span><br><span class="line">      <span class="comment">// Retrieve the uncompressed contents into a new buffer</span></span><br><span class="line">      <span class="type">const</span> UncompressionDict* verify_dict;</span><br><span class="line">      <span class="keyword">if</span> (!is_data_block || r-&gt;verify_dict == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        verify_dict = &amp;UncompressionDict::<span class="built_in">GetEmptyDict</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        verify_dict = r-&gt;verify_dict.<span class="built_in">get</span>();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">assert</span>(verify_dict != <span class="literal">nullptr</span>);</span><br><span class="line">      BlockContents contents;</span><br><span class="line">      <span class="function">UncompressionInfo <span class="title">uncompression_info</span><span class="params">(*verify_ctx, </span></span></span><br><span class="line"><span class="params"><span class="function">                                           *verify_dict,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           r-&gt;compression_type)</span></span>;</span><br><span class="line">      Status stat = <span class="built_in">UncompressBlockContentsForCompressionType</span>(</span><br><span class="line">          uncompression_info, block_contents-&gt;<span class="built_in">data</span>(), block_contents-&gt;<span class="built_in">size</span>(),</span><br><span class="line">          &amp;contents, r-&gt;table_options.format_version, r-&gt;ioptions);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (stat.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="comment">// 将解压的内容与压缩之前的源内容比较</span></span><br><span class="line">        <span class="type">bool</span> compressed_ok = contents.data.<span class="built_in">compare</span>(raw_block_contents) == <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!compressed_ok) &#123;</span><br><span class="line">          <span class="comment">// 解压内容与原来的待压缩的内容，不匹配，终止压缩</span></span><br><span class="line">          abort_compression = <span class="literal">true</span>;</span><br><span class="line">          <span class="built_in">ROCKS_LOG_ERROR</span>(r-&gt;ioptions.logger,</span><br><span class="line">                          <span class="string">&quot;Decompressed block did not match raw block&quot;</span>);</span><br><span class="line">          *out_status =</span><br><span class="line">              Status::<span class="built_in">Corruption</span>(<span class="string">&quot;Decompressed block did not match raw block&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 解压失败，终止压缩</span></span><br><span class="line">        *out_status = Status::<span class="built_in">Corruption</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Could not decompress: &quot;</span>) +</span><br><span class="line">                                         stat.<span class="built_in">getState</span>());</span><br><span class="line">        abort_compression = <span class="literal">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// block 内容太多，无法一次性压缩，也要终止压缩</span></span><br><span class="line">    <span class="keyword">if</span> (is_data_block) &#123;</span><br><span class="line">      r-&gt;uncompressible_input_data_bytes.<span class="built_in">fetch_add</span>(raw_block_contents.<span class="built_in">size</span>(),</span><br><span class="line">                                                   std::memory_order_relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    abort_compression = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 校验压缩结果</span></span><br><span class="line">  <span class="keyword">if</span> (abort_compression) &#123;</span><br><span class="line">    *type = kNoCompression;</span><br><span class="line">    *block_contents = raw_block_contents;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="BGWorkWriteRawBlock"><a href="#BGWorkWriteRawBlock" class="headerlink" title="BGWorkWriteRawBlock"></a>BGWorkWriteRawBlock</h5><p>在<code>BGWorkCompression</code> 函数，我们可以看到，压缩线程主要有两个动作：</p><ul><li>先压缩 <code>data block</code>，并将相关信息记录在<code>block_rep</code>中</li><li>再将 <code>block_rep</code> 保存在 <code>block_rep-&gt;slot</code> 中</li></ul><p>此时呢，可以回顾下 <code>ParallelCompressionRep::EmitBlock</code> 函数，<code>block_rep-&gt;slot</code> 一开始就就加入到 <code>write_queue</code> 中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EmitBlock</span><span class="params">(BlockRep* block_rep)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!write_queue.<span class="built_in">push</span>(block_rep-&gt;slot.<span class="built_in">get</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!compress_queue.<span class="built_in">push</span>(block_rep)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待压缩完成 </span></span><br><span class="line">  <span class="keyword">if</span> (!first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed)) &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(first_block_mutex)</span></span>;</span><br><span class="line">    <span class="comment">// 阻塞等待，直到 ReapBlock 函数调用</span></span><br><span class="line">    first_block_cond.<span class="built_in">wait</span>(lock, [<span class="keyword">this</span>] &#123;</span><br><span class="line">      <span class="keyword">return</span> first_block_processed.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这说明什么？</p><p>如果前面的压缩部分没有完成，则当执行到<code>BGWorkWriteRawBlock</code> 函数时，会一直阻塞在：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">slot-&gt;<span class="built_in">Take</span>(block_rep);</span><br></pre></td></tr></table></figure><p>无论前面的 <code>CompressAndVerifyBlock</code>函数是否压缩成功，都需要调用<code>ReapBlock</code> 函数，以防止<code>EmitBlock</code>处产生死锁。</p><p>Of Course，若前面压缩成功，则还大致需要执行以下流程：</p><ul><li>先将当前<code>block</code>中的每个key添加到 <code>filter_builder</code>、<code>index_builder</code>；</li><li>再生成 <code>filter_block</code>、<code>idnex_block</code>；</li><li>将block压缩后的数据写入sst</li></ul><p>下面来看看细节。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::BGWorkWriteRawBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  ParallelCompressionRep::BlockRepSlot* slot = <span class="literal">nullptr</span>;</span><br><span class="line">  ParallelCompressionRep::BlockRep* block_rep = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">while</span> (r-&gt;pc_rep-&gt;write_queue.<span class="built_in">pop</span>(slot)) &#123;</span><br><span class="line">    <span class="built_in">assert</span>(slot != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 阻塞于此，直到压缩完成，Take 函数才能返回</span></span><br><span class="line">    slot-&gt;<span class="built_in">Take</span>(block_rep);</span><br><span class="line">    <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">if</span> (!block_rep-&gt;status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      r-&gt;<span class="built_in">SetStatus</span>(block_rep-&gt;status);</span><br><span class="line">      <span class="comment">// Flush() 中存在 Emit(), 需要 ReapBlock</span></span><br><span class="line">      block_rep-&gt;status = Status::<span class="built_in">OK</span>();</span><br><span class="line">      r-&gt;pc_rep-&gt;<span class="built_in">ReapBlock</span>(block_rep);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; block_rep-&gt;keys-&gt;<span class="built_in">Size</span>(); i++) &#123;</span><br><span class="line">      <span class="keyword">auto</span>&amp; key = (*block_rep-&gt;keys)[i];</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">size_t</span> ts_sz =</span><br><span class="line">            r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">         <span class="comment">// 为后面创建 filter block 准备</span></span><br><span class="line">        r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 为后面创建 index block 准备</span></span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 为后续重新估算 sst 文件大小准备</span></span><br><span class="line">    r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">SetCurrBlockRawSize</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将压缩后的数据写入sst</span></span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(block_rep-&gt;compressed_contents, <span class="comment">// 压缩的数据</span></span><br><span class="line">                 block_rep-&gt;compression_type,     <span class="comment">// 压缩类型</span></span><br><span class="line">                 &amp;r-&gt;pending_handle, </span><br><span class="line">                 <span class="literal">true</span> <span class="comment">/* is_data_block*/</span>,</span><br><span class="line">                 &amp;block_rep-&gt;contents);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于前面添加的key，生成 filter block</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      r-&gt;filter_builder-&gt;<span class="built_in">StartBlock</span>(r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;props.data_size = r-&gt;<span class="built_in">get_offset</span>();</span><br><span class="line">    ++r-&gt;props.num_data_blocks;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 基于前面添加的key， 生成 index block</span></span><br><span class="line">    <span class="keyword">if</span> (block_rep-&gt;first_key_in_next_block == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="comment">// 最后一个data block</span></span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;(block_rep-&gt;keys-&gt;<span class="built_in">Back</span>()), <span class="literal">nullptr</span>,</span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 非最后一个data block</span></span><br><span class="line">      Slice first_key_in_next_block =</span><br><span class="line">          <span class="built_in">Slice</span>(*block_rep-&gt;first_key_in_next_block);</span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;(block_rep-&gt;keys-&gt;<span class="built_in">Back</span>()),</span><br><span class="line">                                      &amp;first_key_in_next_block,</span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通知 ParallelCompressionRep::EmitBlock</span></span><br><span class="line">    r-&gt;pc_rep-&gt;<span class="built_in">ReapBlock</span>(block_rep);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WriteRawBlock"><a href="#WriteRawBlock" class="headerlink" title="WriteRawBlock"></a>WriteRawBlock</h5><p>最后一步，就是要将压缩完的数据按照如下格式写入到sst文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">block_data: uint8[n] <span class="comment"># block 存储的数据</span></span><br><span class="line"><span class="built_in">type</span>: uint8          <span class="comment"># 压缩类型</span></span><br><span class="line">crc: uint32          <span class="comment"># 校验和</span></span><br><span class="line">padding              <span class="comment"># 填充</span></span><br></pre></td></tr></table></figure><p>注意，<code>WriteRawBlock</code> 函数的传入的参数<code>handle</code> ，在函数返回时记录了关于block的两个元信息：</p><ul><li>此block在sst文件中存储的起始位置</li><li>此block压缩后的大小。</li></ul><p>这个参数，实际上由<code>Add（key, value）</code>函数中的<code>r-&gt;pending_handle</code>传入，后续写入<code>index builder</code>，建立<code>index block</code>，这个在后面会讲解。</p><p>下面，简洁了部分代码后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteRawBlock</span><span class="params">(<span class="type">const</span> Slice&amp; block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           CompressionType type,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           BlockHandle* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">bool</span> is_data_block,</span></span></span><br><span class="line"><span class="params"><span class="function">                                           <span class="type">const</span> Slice* raw_block_contents)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  Status s = Status::<span class="built_in">OK</span>();</span><br><span class="line">  IOStatus io_s = IOStatus::<span class="built_in">OK</span>();</span><br><span class="line">  <span class="function">StopWatch <span class="title">sw</span><span class="params">(r-&gt;ioptions.clock, r-&gt;ioptions.stats, WRITE_RAW_BLOCK_MICROS)</span></span>;</span><br><span class="line">  <span class="comment">// 1. 初始化 handle</span></span><br><span class="line">  handle-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>());     <span class="comment">// block 在sst文件中的offset</span></span><br><span class="line">  handle-&gt;<span class="built_in">set_size</span>(block_contents.<span class="built_in">size</span>()); <span class="comment">// 这个block 压缩后的大小</span></span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">io_status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="comment">// 2. 向sst文件中追加内容 block_contents</span></span><br><span class="line">  io_s = r-&gt;file-&gt;<span class="built_in">Append</span>(block_contents); </span><br><span class="line">  <span class="comment">// 3. 下面写入footer</span></span><br><span class="line">  <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="type">char</span> trailer[kBlockTrailerSize];</span><br><span class="line">    trailer[<span class="number">0</span>] = type;     <span class="comment">// 压缩类型</span></span><br><span class="line">    <span class="type">uint32_t</span> checksum = <span class="number">0</span>; <span class="comment">// 校验和</span></span><br><span class="line">    <span class="keyword">switch</span> (r-&gt;table_options.checksum) &#123;</span><br><span class="line">      <span class="comment">// 计算校验和</span></span><br><span class="line">      <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 存储校验和</span></span><br><span class="line">    <span class="built_in">EncodeFixed32</span>(trailer + <span class="number">1</span>, checksum);</span><br><span class="line">    <span class="built_in">assert</span>(io_s.<span class="built_in">ok</span>());</span><br><span class="line">    <span class="built_in">TEST_SYNC_POINT_CALLBACK</span>(</span><br><span class="line">        <span class="string">&quot;BlockBasedTableBuilder::WriteRawBlock:TamperWithChecksum&quot;</span>,</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;<span class="type">char</span>*&gt;(trailer));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 写入 footer</span></span><br><span class="line">    io_s = r-&gt;file-&gt;<span class="built_in">Append</span>(<span class="built_in">Slice</span>(trailer, kBlockTrailerSize));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">ok</span>() &amp;&amp; io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">      <span class="comment">// 设置文件偏移量 : 当前偏移量 + block 数据大小 + footer </span></span><br><span class="line">      r-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>() + block_contents.<span class="built_in">size</span>() +</span><br><span class="line">                    kBlockTrailerSize);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 4. 填充</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;table_options.block_align &amp;&amp; is_data_block) &#123;</span><br><span class="line">        <span class="type">size_t</span> pad_bytes =</span><br><span class="line">            (r-&gt;alignment - ((block_contents.<span class="built_in">size</span>() + kBlockTrailerSize) &amp; (r-&gt;alignment - <span class="number">1</span>))) &amp;</span><br><span class="line">            (r-&gt;alignment - <span class="number">1</span>);</span><br><span class="line">        io_s = r-&gt;file-&gt;<span class="built_in">Pad</span>(pad_bytes);</span><br><span class="line">        <span class="keyword">if</span> (io_s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">          <span class="comment">// 填充后，重新更新文件偏移量</span></span><br><span class="line">          r-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>() + pad_bytes);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;<span class="built_in">SetIOStatus</span>(io_s);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5. 这个时候再重新计算文件大小</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is_data_block) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">ReapBlock</span>(block_contents.<span class="built_in">size</span>(),</span><br><span class="line">                                                   r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">SetEstimatedFileSize</span>(r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r-&gt;<span class="built_in">SetIOStatus</span>(io_s);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!io_s.<span class="built_in">ok</span>() &amp;&amp; s.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    r-&gt;<span class="built_in">SetStatus</span>(io_s);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StopParallelCompression"><a href="#StopParallelCompression" class="headerlink" title="StopParallelCompression"></a>StopParallelCompression</h4><p>和启动多线程部分相应，停止压缩线程、写线程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::StopParallelCompression</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  rep_-&gt;pc_rep-&gt;compress_queue.<span class="built_in">finish</span>();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; thread : rep_-&gt;pc_rep-&gt;compress_thread_pool) &#123;</span><br><span class="line">    thread.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_queue.<span class="built_in">finish</span>();</span><br><span class="line">  rep_-&gt;pc_rep-&gt;write_thread-&gt;<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Add"><a href="#Add" class="headerlink" title="Add"></a>Add</h3><p>好嘞，终于到了这里。</p><p>经过前面压缩部分的铺垫，相信这里会让你更加易懂。</p><p>每个key的编码信息中，都包含着一个<code>value_type</code>信息，关于<code>value_type</code>，详细地后续再说，这里一点，<code>IsValueType</code> 返回值为true，表示这对<code>&#123;k, v&#125;</code>可以写入到sst文件中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsValueType</span><span class="params">(ValueType t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> t &lt;= kTypeMerge || t == kTypeSingleDeletion || t == kTypeBlobIndex</span><br><span class="line">         || kTypeDeletionWithTimestamp == t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">IsExtendedValueType</span><span class="params">(ValueType t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">IsValueType</span>(t) || t == kTypeRangeDeletion;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BlockBasedTableBuilder</code> 在添加<code>&#123;k, v&#125;</code>并写入到sst文件的过程，会经历三个阶段<code>State</code>。</p><h4 id="State"><a href="#State" class="headerlink" title="State"></a>State</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">State</span> &#123;</span><br><span class="line">  kBuffered,</span><br><span class="line">  kUnbuffered,</span><br><span class="line">  kClosed,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在<code>kBuffered</code>模式下，将待压缩、待写入sst文件的<code>data_block</code> 暂时缓存在<code>r-&gt;data_block_buffer</code>中。当缓存中的数据长度<code>r-&gt;data_begin_offset</code>超过限制<code>buffer_limit</code> 时，就会进入到<code>kUnbuffered</code>模式。</p><p>一旦进入到<code>kUnbuffered</code>，就不可逆转到<code>kBuffered</code>。最终只能在调用 <code>BlockBasedTableBuilder::Finish</code> 时进入<code>kClosed</code>模式。</p><h4 id="should-flush"><a href="#should-flush" class="headerlink" title="should_flush"></a>should_flush</h4><p>每个<code>BlockBasedTableBuilder</code>  中都有个刷新策略<code>r-&gt;flush_block_policy</code>：将当前<code>&#123;k, v&#125;</code>添加到 <code>r-&gt;data_block</code>，若会触发更新，则会先将当前 <code>r-&gt;data_block</code> 的数据进行<code>flush</code>：</p><ul><li>若 <code>r-&gt;data_begin_offset &lt; r-&gt;buffer_limit</code>：暂时缓存到  <code>r-&gt;data_block_buffer</code>中；</li><li>否则，会先压缩，再写入sst文件。</li></ul><p>此外，由于多线程的压缩、写入sst的过程在相应的子线程中完成，当没有开启多线程时，一些细节需要在主线程中单独进行处理，因此在下面的代码中会经常看到下面的代码结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (r-&gt;IsParallelCompressionEnabled()) &#123; </span><br><span class="line">&#125; else &#123; </span><br><span class="line">  // 对单线程进行处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要理解了之前讲解的多线程逻辑，下面的<code>Add</code>函数会很好理解。</p><p>代码简略后如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 向 cur_block 中添加 &#123;key, value&#125;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::Add</span><span class="params">(<span class="type">const</span> Slice&amp; key, <span class="type">const</span> Slice&amp; value)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  ValueType value_type = <span class="built_in">ExtractValueType</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsValueType</span>(value_type)) &#123;</span><br><span class="line">    <span class="comment">// 判断是否需要 flush</span></span><br><span class="line">    <span class="keyword">auto</span> should_flush = r-&gt;flush_block_policy-&gt;<span class="built_in">Update</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (should_flush) &#123;</span><br><span class="line">      <span class="built_in">assert</span>(!r-&gt;data_block.<span class="built_in">empty</span>());</span><br><span class="line">      r-&gt;first_key_in_next_block = &amp;key;</span><br><span class="line">      <span class="built_in">Flush</span>();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 从 kBuffer 模式进入 kUnbuffered 模式</span></span><br><span class="line">      <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered </span><br><span class="line">          &amp;&amp; r-&gt;buffer_limit != <span class="number">0</span> </span><br><span class="line">          &amp;&amp;r-&gt;data_begin_offset &gt; r-&gt;buffer_limit) &#123;</span><br><span class="line">        <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">          r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">Clear</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 单线程：在 index builder 中添加一个 &#123;k, pending_handle&#125; </span></span><br><span class="line">          <span class="comment">// 其中 pending_handle 记录了写入sst的位置及大小</span></span><br><span class="line">          r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;r-&gt;last_key, </span><br><span class="line">                                          &amp;key,</span><br><span class="line">                                          r-&gt;pending_handle);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> PartitionedFilterBlockBuilder 需要在 key先添加到 index builder 之后，</span></span><br><span class="line">    <span class="comment">//       再添加到 PartitionedFilterBlockBuilder 中</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">      <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        r-&gt;pc_rep-&gt;curr_block_keys-&gt;<span class="built_in">PushBack</span>(key);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 单线程：在 filter builder 中添加一个记录</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="type">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">          r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新当前data_block的last_key</span></span><br><span class="line">    r-&gt;last_key.<span class="built_in">assign</span>(key.<span class="built_in">data</span>(), key.<span class="built_in">size</span>());</span><br><span class="line">    <span class="comment">// 添加 &#123;k, v&#125; 到当前 data_block</span></span><br><span class="line">    r-&gt;data_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">      <span class="comment">// Buffered keys will be replayed from data_block_buffers during</span></span><br><span class="line">      <span class="comment">// `Finish()` once compression dictionary has been finalized.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">        <span class="comment">// 单线程</span></span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NotifyCollectTableCollectorsOnAdd</span>(key, value, r-&gt;<span class="built_in">get_offset</span>(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value_type == kTypeRangeDeletion) &#123;</span><br><span class="line">    r-&gt;range_del_block.<span class="built_in">Add</span>(key, value);</span><br><span class="line">    <span class="built_in">NotifyCollectTableCollectorsOnAdd</span>(key, value, r-&gt;<span class="built_in">get_offset</span>(),</span><br><span class="line">                                      r-&gt;table_properties_collectors,</span><br><span class="line">                                      r-&gt;ioptions.logger);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="comment">// 统计</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h4 id="Flush"><a href="#Flush" class="headerlink" title="Flush"></a>Flush</h4><p>在<code>Flush</code> 函数中，针对多线程和单线程两种模式：</p><ul><li>如果开启了多线程 &amp;&amp; 已经处于 <code>kUnbuffered</code> 模式，则调用多线程压缩、写入sst文件。</li><li>否则，直接调用单线程的压缩写入。</li></ul><p>下面来看看源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::Flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(rep_-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (r-&gt;data_block.<span class="built_in">empty</span>()) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>() &amp;&amp; r-&gt;state == Rep::State::kUnbuffered) &#123;</span><br><span class="line">    <span class="comment">// 序列化 r-&gt;data_block 中的数据</span></span><br><span class="line">    r-&gt;data_block.<span class="built_in">Finish</span>();</span><br><span class="line">    <span class="comment">// 利用 r-&gt;data_block 中的数据生成 block_rep</span></span><br><span class="line">    ParallelCompressionRep::BlockRep* block_rep = r-&gt;pc_rep-&gt;<span class="built_in">PrepareBlock</span>(</span><br><span class="line">        r-&gt;compression_type, r-&gt;first_key_in_next_block, &amp;(r-&gt;data_block));</span><br><span class="line">    <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">    <span class="comment">// 此时，r-&gt;data_block 中是空的了</span></span><br><span class="line">    <span class="built_in">assert</span>(r-&gt;data_block.<span class="built_in">emoty</span>());</span><br><span class="line">    <span class="comment">// 在压缩前，估计下 sst 文件大小</span></span><br><span class="line">    r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">EmitBlock</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                             r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">    <span class="comment">// 将 data_block 送入压缩线程，后台线程会压缩、写入sst文件</span></span><br><span class="line">    r-&gt;pc_rep-&gt;<span class="built_in">EmitBlock</span>(block_rep);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 单线程压缩</span></span><br><span class="line">    <span class="built_in">WriteBlock</span>(&amp;r-&gt;data_block, &amp;r-&gt;pending_handle, <span class="literal">true</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="WriteBlock"><a href="#WriteBlock" class="headerlink" title="WriteBlock"></a>WriteBlock</h5><p>调用 <code>WriteBlock</code> 函数，不仅会来自于上面的 <code>Flush</code> 函数，还有会后面的<code>WriteIndexBlock</code>、<code>EnterUnbuffered</code>函数等。因此，<code>WriteBlock</code> 函数做了统一接口，来应对 <code>State::kBuffered</code> 和 <code>State::kUnBuffered</code>两种状态。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteBlock</span><span class="params">(BlockBuilder* block,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        BlockHandle* handle,  <span class="comment">// 正在pending的</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">bool</span> is_data_block)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 序列化 block 中的数据</span></span><br><span class="line">  block-&gt;<span class="built_in">Finish</span>();</span><br><span class="line">  std::string raw_block_contents;</span><br><span class="line">  <span class="comment">// 将block序列化后的内容swap到 raw_block_contents 中</span></span><br><span class="line">  block-&gt;<span class="built_in">SwapAndReset</span>(raw_block_contents);</span><br><span class="line">  <span class="keyword">if</span> (rep_-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">    <span class="comment">// 只有 data_block 存在 kbuffered 模式</span></span><br><span class="line">    <span class="built_in">assert</span>(is_data_block);</span><br><span class="line">    <span class="comment">// 将数据先写入 data_block_buffers</span></span><br><span class="line">    rep_-&gt;data_block_buffers.<span class="built_in">emplace_back</span>(std::<span class="built_in">move</span>(raw_block_contents));</span><br><span class="line">    rep_-&gt;data_begin_offset += rep_-&gt;data_block_buffers.<span class="built_in">back</span>().<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="comment">// else 就是 KUnBuffer 模式 </span></span><br><span class="line">  <span class="built_in">WriteBlock</span>(raw_block_contents, handle, is_data_block);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="WriteBlock-1"><a href="#WriteBlock-1" class="headerlink" title="WriteBlock"></a>WriteBlock</h5><p>重载形式的<code>WriteBlock</code> ，只用于单线程压缩（没有写入sst文件的操作），且<code>BlockBasedTableBuilder</code>当前处于<code>kUnbuffered</code>模式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @brief 用于 kUnbuffered 模式：单线程压缩</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteBlock</span><span class="params">(<span class="type">const</span> Slice&amp; raw_block_contents,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        BlockHandle* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="type">bool</span> is_data_block)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state == Rep::State::kUnbuffered);</span><br><span class="line">  Slice block_contents;</span><br><span class="line">  CompressionType type;</span><br><span class="line">  Status compress_status;</span><br><span class="line">  <span class="comment">// 进行压缩</span></span><br><span class="line">  <span class="built_in">CompressAndVerifyBlock</span>(raw_block_contents, </span><br><span class="line">                         is_data_block,</span><br><span class="line">                         *(r-&gt;compression_ctxs[<span class="number">0</span>]), </span><br><span class="line">                         r-&gt;verify_ctxs[<span class="number">0</span>].<span class="built_in">get</span>(),</span><br><span class="line">                         &amp;(r-&gt;compressed_output), </span><br><span class="line">                         &amp;(block_contents), </span><br><span class="line">                         &amp;type,</span><br><span class="line">                         &amp;compress_status);</span><br><span class="line">  r-&gt;<span class="built_in">SetStatus</span>(compress_status);</span><br><span class="line">  <span class="comment">// 如果压缩不成功</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="EnterUnbuffered"><a href="#EnterUnbuffered" class="headerlink" title="EnterUnbuffered"></a>EnterUnbuffered</h4><p><code>EnterUnbuffered</code>函数，将<code>BlockBasedTableBuilder</code>的状态，从<code>kBuffered</code>推向<code>kUnBuffered</code>，仅会执行一次。</p><p>那么这个函数的使命？</p><p>我们知道在 <code>kBuffered</code> 模式下，每次调用<code>Flush</code>函数时，都是将<code>r-&gt;data_block</code>的数据缓存到<code>r-&gt;data_block_buffers</code>。</p><p>当从<code>kBuffered</code>专向<code>kUnBuffered</code>时，很自然，就需要让<code>r-&gt;data_block_buffers</code> 中的数据也经历两个过程：</p><ul><li>压缩</li><li>写入sst</li></ul><p>带着这个思路，下面的代码就很好理解。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::EnterUnbuffered</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state == Rep::State::kBuffered);</span><br><span class="line">  r-&gt;state = Rep::State::kUnbuffered;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 获得 r-&gt;data_block_buffers[i] 的读迭代器</span></span><br><span class="line">  <span class="keyword">auto</span> get_iterator_for_block = [&amp;r](<span class="type">size_t</span> i) &#123;</span><br><span class="line">    <span class="keyword">auto</span>&amp; data_block = r-&gt;data_block_buffers[i];</span><br><span class="line">    <span class="built_in">assert</span>(!data_block.<span class="built_in">empty</span>());</span><br><span class="line"></span><br><span class="line">    Block reader&#123;BlockContents&#123;data_block&#125;&#125;;</span><br><span class="line">    DataBlockIter* iter = reader.<span class="built_in">NewDataIterator</span>(r-&gt;internal_comparator.<span class="built_in">user_comparator</span>(), </span><br><span class="line">                                                 kDisableGlobalSequenceNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定位到这个 data_block 的起始处</span></span><br><span class="line">    iter-&gt;<span class="built_in">SeekToFirst</span>();</span><br><span class="line">    <span class="built_in">assert</span>(iter-&gt;<span class="built_in">Valid</span>());</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">unique_ptr</span>&lt;DataBlockIter&gt;(iter);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  std::unique_ptr&lt;DataBlockIter&gt; iter = <span class="literal">nullptr</span>, next_block_iter = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; <span class="built_in">ok</span>() &amp;&amp; i &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="comment">// 初始化迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (iter == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      iter = <span class="built_in">get_iterator_for_block</span>(i);</span><br><span class="line">      <span class="built_in">assert</span>(iter != <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下一个 data_block 的迭代器</span></span><br><span class="line">    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">      next_block_iter = <span class="built_in">get_iterator_for_block</span>(i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 data_block</span></span><br><span class="line">    <span class="keyword">auto</span>&amp; data_block = r-&gt;data_block_buffers[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*** 下面对data_block进行压缩、写入***/</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">      <span class="comment">/*** 开启了多线程压缩 ***/</span></span><br><span class="line">      </span><br><span class="line">      Slice first_key_in_next_block;</span><br><span class="line">      <span class="type">const</span> Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line">      <span class="keyword">if</span> (i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="comment">// 下一个 data_block 的第一个key</span></span><br><span class="line">        first_key_in_next_block = next_block_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// r-&gt;first_key_in_next_block </span></span><br><span class="line">        <span class="comment">// 即处于 kUnBuffered 状态的 data_block 第一个key</span></span><br><span class="line">        first_key_in_next_block_ptr = r-&gt;first_key_in_next_block;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 迭代当前 data_block, 将所有的key，全部添加到 keys</span></span><br><span class="line">      std::vector&lt;std::string&gt; keys;</span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">        keys.<span class="built_in">emplace_back</span>(iter-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 生成 block_req </span></span><br><span class="line">      ParallelCompressionRep::BlockRep* block_rep = r-&gt;pc_rep-&gt;<span class="built_in">PrepareBlock</span>(</span><br><span class="line">          r-&gt;compression_type, first_key_in_next_block_ptr, &amp;data_block, &amp;keys);</span><br><span class="line"></span><br><span class="line">      <span class="built_in">assert</span>(block_rep != <span class="literal">nullptr</span>);</span><br><span class="line">      <span class="comment">// 在发送前，估计下sst文件大小</span></span><br><span class="line">      r-&gt;pc_rep-&gt;file_size_estimator.<span class="built_in">EmitBlock</span>(block_rep-&gt;data-&gt;<span class="built_in">size</span>(),</span><br><span class="line">                                               r-&gt;<span class="built_in">get_offset</span>());</span><br><span class="line">      <span class="comment">// 发送至压缩线程</span></span><br><span class="line">      r-&gt;pc_rep-&gt;<span class="built_in">EmitBlock</span>(block_rep);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*** 没有开启多线程压缩 ***/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// fileter block，index block</span></span><br><span class="line">      <span class="keyword">for</span> (; iter-&gt;<span class="built_in">Valid</span>(); iter-&gt;<span class="built_in">Next</span>()) &#123;</span><br><span class="line">        Slice key = iter-&gt;<span class="built_in">key</span>();</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;filter_builder != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">          <span class="type">size_t</span> ts_sz =</span><br><span class="line">              r-&gt;internal_comparator.<span class="built_in">user_comparator</span>()-&gt;<span class="built_in">timestamp_size</span>();</span><br><span class="line">          r-&gt;filter_builder-&gt;<span class="built_in">Add</span>(<span class="built_in">ExtractUserKeyAndStripTimestamp</span>(key, ts_sz));</span><br><span class="line">        &#125;</span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">OnKeyAdded</span>(key);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(<span class="built_in">Slice</span>(data_block),</span><br><span class="line">                 &amp;r-&gt;pending_handle,  <span class="comment">// 记录了 data_block 在文件中的位置及其大小</span></span><br><span class="line">                 <span class="literal">true</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//! 此for循环，不包含最后一个data block</span></span><br><span class="line">      <span class="comment">//! 因此，在 ::Finish 函数中，需要为最后一个 data block 单独调用一次 AddIndexEntry</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; i + <span class="number">1</span> &lt; r-&gt;data_block_buffers.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="built_in">assert</span>(next_block_iter != <span class="literal">nullptr</span>);</span><br><span class="line">        Slice first_key_in_next_block = next_block_iter-&gt;<span class="built_in">key</span>();</span><br><span class="line"></span><br><span class="line">        Slice* first_key_in_next_block_ptr = &amp;first_key_in_next_block;</span><br><span class="line"></span><br><span class="line">        iter-&gt;<span class="built_in">SeekToLast</span>();</span><br><span class="line">        std::string last_key = iter-&gt;<span class="built_in">key</span>().<span class="built_in">ToString</span>();</span><br><span class="line">        <span class="comment">// 添加一个 &#123;key, handle&#125;</span></span><br><span class="line">        r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;last_key, first_key_in_next_block_ptr,</span><br><span class="line">                                        r-&gt;pending_handle);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*** 遍历完当前 data_block ***/</span></span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">swap</span>(iter, next_block_iter);</span><br><span class="line">  &#125; <span class="comment">// 遍历完所有的 data_block</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 清除数据</span></span><br><span class="line">  r-&gt;data_block_buffers.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Finish"><a href="#Finish" class="headerlink" title="Finish"></a>Finish</h3><p>在前文说过，一个table序列化到sst文件的格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;beginning_of_file&gt;</span><br><span class="line">[data block 1]</span><br><span class="line">[data block 2]</span><br><span class="line">...</span><br><span class="line">[data block N]</span><br><span class="line">[meta block 1: filter block]                 </span><br><span class="line">[meta block 2: index block]</span><br><span class="line">[meta block 3: compression dictionary block]</span><br><span class="line">[meta block 4: range deletion block]        </span><br><span class="line">[meta block 5: stats block]</span><br><span class="line">...</span><br><span class="line">[meta block K: future extended block]</span><br><span class="line">[metaindex block]</span><br><span class="line">[Footer]</span><br><span class="line">&lt;end_of_file&gt;</span><br></pre></td></tr></table></figure><p>当调用<code>::Finish</code>函数时，<code>data block</code>部分已经构建完毕，下面就需要开始构建<code>meta block</code> 。</p><h4 id="MetaIndexBuilder"><a href="#MetaIndexBuilder" class="headerlink" title="MetaIndexBuilder"></a>MetaIndexBuilder</h4><p>前面的<code>filter block</code>、<code>index block</code>、<code>compression dictionary block</code>、<code>range deletion block</code>、<code>prop block</code>等记录着<code>data block</code>各种信息，我们把这些记录<code>data block</code>信息的<code>block</code>统一叫做<code>meta block</code>。所谓<code>meta</code>，即信息的信息。</p><p><code>MetaIndexBuilder</code>，则用于存储前面这些<code>meta block</code>在sst中的存储位置及其大小，最终用于构建整个<code>Table</code>的<code>footer</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MetaIndexBuilder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">MetaIndexBuilder</span>()</span><br><span class="line">  : <span class="built_in">meta_index_block_</span>(<span class="keyword">new</span> <span class="built_in">BlockBuilder</span>(<span class="number">1</span> <span class="comment">/* restart interval */</span>)) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">MetaIndexBuilder</span>(<span class="type">const</span> MetaIndexBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  MetaIndexBuilder&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MetaIndexBuilder&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// 添加 &#123;k, v&#125;</span></span><br><span class="line">  <span class="comment">/// handle 中记录了指向的 meta block 在sst中的位置及其大小</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Add</span><span class="params">(<span class="type">const</span> std::string&amp; key, <span class="type">const</span> BlockHandle&amp; handle)</span> </span>&#123; </span><br><span class="line">     std::string handle_encoding;</span><br><span class="line">     handle.<span class="built_in">EncodeTo</span>(&amp;handle_encoding); <span class="comment">// 编码为字符串</span></span><br><span class="line">     meta_block_handles_.<span class="built_in">emplace</span>(key, std::<span class="built_in">move</span>(handle_encoding));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// 将所有添加到 meta_block_handles_ 中的&#123;k, v&#125; 序列化后返回</span></span><br><span class="line">  <span class="function">Slice <span class="title">Finish</span><span class="params">()</span> </span>&#123; </span><br><span class="line">     <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; metablock : meta_block_handles_) &#123;</span><br><span class="line">       meta_index_block_-&gt;<span class="built_in">Add</span>(metablock.first, metablock.second);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> meta_index_block_-&gt;<span class="built_in">Finish</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  stl_wrappers::KVMap meta_block_handles_;          <span class="comment">// 存着所有meta block的信息</span></span><br><span class="line">  std::unique_ptr&lt;BlockBuilder&gt; meta_index_block_;  <span class="comment">// 由这些meta block的元信息构建的block</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了这个思路，下面，就可以先来看看整体代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">BlockBasedTableBuilder::Finish</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;state != Rep::State::kClosed);</span><br><span class="line">  <span class="type">bool</span> empty_data_block = r-&gt;data_block.<span class="built_in">empty</span>();</span><br><span class="line">  <span class="comment">// 在flush时，暗示最后一个data block</span></span><br><span class="line">  r-&gt;first_key_in_next_block = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// flush最后一个data block</span></span><br><span class="line">  <span class="built_in">Flush</span>();</span><br><span class="line">  <span class="comment">// 如果状态不是 kUnBuffered，则直接进入</span></span><br><span class="line">  <span class="keyword">if</span> (r-&gt;state == Rep::State::kBuffered) &#123;</span><br><span class="line">    <span class="built_in">EnterUnbuffered</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (r-&gt;<span class="built_in">IsParallelCompressionEnabled</span>()) &#123;</span><br><span class="line">    <span class="built_in">StopParallelCompression</span>();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对于单线程，EnterUnbuffered 函数没发为最后一个 data block 建立 index </span></span><br><span class="line">    <span class="comment">// 因此，需要手动添加</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_data_block) &#123;</span><br><span class="line">      r-&gt;index_builder-&gt;<span class="built_in">AddIndexEntry</span>(&amp;r-&gt;last_key, </span><br><span class="line">                                     <span class="literal">nullptr</span> <span class="comment">/* no next data block */</span>, </span><br><span class="line">                                      r-&gt;pending_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 开始构建 meta-block</span></span><br><span class="line">  BlockHandle metaindex_block_handle, index_block_handle;</span><br><span class="line">  MetaIndexBuilder meta_index_builder;</span><br><span class="line">  <span class="built_in">WriteFilterBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WriteIndexBlock</span>(&amp;meta_index_builder, &amp;index_block_handle);</span><br><span class="line">  <span class="built_in">WriteCompressionDictBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WriteRangeDelBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="built_in">WritePropertiesBlock</span>(&amp;meta_index_builder);</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 将meta-block写入sst文件</span></span><br><span class="line">    <span class="built_in">WriteRawBlock</span>(meta_index_builder.<span class="built_in">Finish</span>(), kNoCompression,</span><br><span class="line">                  &amp;metaindex_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// metaindex_block_handle 记录着 meta-block的信息</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="built_in">WriteFooter</span>(metaindex_block_handle, index_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">  r-&gt;state = Rep::State::kClosed;</span><br><span class="line">  r-&gt;<span class="built_in">SetStatus</span>(r-&gt;<span class="built_in">CopyIOStatus</span>());</span><br><span class="line">  Status ret_status = r-&gt;<span class="built_in">CopyStatus</span>();</span><br><span class="line">  <span class="built_in">assert</span>(!ret_status.<span class="built_in">ok</span>() || <span class="built_in">io_status</span>().<span class="built_in">ok</span>());</span><br><span class="line">  <span class="keyword">return</span> ret_status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteFilterBlock"><a href="#WriteFilterBlock" class="headerlink" title="WriteFilterBlock"></a>WriteFilterBlock</h4><p><code>WriteFilterBlock</code>函数的逻辑如下：</p><ul><li>如果不是 <code>PartitionFilterBuilder</code>，则直接将整个<code>FilterBuiler</code>构建的数据，在直接序列化后写入sst文件。</li><li>如果是<code>PartitionFilterBuilder</code>，则以<code>partition</code>为单位，逐个写入到sst文件；</li><li>等上述过程完毕，再将将此 <code>FilterBuilder</code> 的属性作为<code>&#123;k, v&#125;</code>添加到 <code>meta_index_builder</code>中：<ul><li><code>k</code>：是<code>FilterBuilderType.FilterPolicyName</code>；</li><li><code>v</code>：是写入sst文件的<code>filter block</code>的元信息。</li></ul></li></ul><p>代码如下。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteFilterBlock</span><span class="params">(MetaIndexBuilder* meta_index_builder)</span> </span>&#123;</span><br><span class="line">  BlockHandle filter_block_handle;</span><br><span class="line">  <span class="type">bool</span> empty_filter_block =</span><br><span class="line">      (rep_-&gt;filter_builder == <span class="literal">nullptr</span> || rep_-&gt;filter_builder-&gt;<span class="built_in">IsEmpty</span>());</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_filter_block) &#123;</span><br><span class="line">    <span class="comment">// 添加的key数</span></span><br><span class="line">    rep_-&gt;props.num_filter_entries +=</span><br><span class="line">        rep_-&gt;filter_builder-&gt;<span class="built_in">EstimateEntriesAdded</span>();</span><br><span class="line">    Status s = Status::<span class="built_in">Incomplete</span>();</span><br><span class="line">    <span class="comment">// 如果是 PartitionFilterBuilder</span></span><br><span class="line">    <span class="comment">// 返回值是 IsIncomplete</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ok</span>() &amp;&amp; s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">      <span class="comment">// 此处的 filter_block_handle 表示上一个partition的handle</span></span><br><span class="line">      Slice filter_content =</span><br><span class="line">          rep_-&gt;filter_builder-&gt;<span class="built_in">Finish</span>(filter_block_handle, &amp;s);</span><br><span class="line">      <span class="built_in">assert</span>(s.<span class="built_in">ok</span>() || s.<span class="built_in">IsIncomplete</span>());</span><br><span class="line">      rep_-&gt;props.filter_size += filter_content.<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">// filter_content : 当前 filter partition 的内容</span></span><br><span class="line">      <span class="comment">// filter_block_handle : 记录该 partition 在sst中大小及偏移量</span></span><br><span class="line">      <span class="built_in">WriteRawBlock</span>(filter_content, kNoCompression, &amp;filter_block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/*** 全部写入sst ***/</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !empty_filter_block) &#123;</span><br><span class="line">    <span class="comment">// 获取 FilterBuilder 的名字</span></span><br><span class="line">    std::string key;</span><br><span class="line">    <span class="keyword">if</span> (rep_-&gt;filter_builder-&gt;<span class="built_in">IsBlockBased</span>()) &#123;</span><br><span class="line">      key = BlockBasedTable::kFilterBlockPrefix;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      key = rep_-&gt;table_options.partition_filters</span><br><span class="line">                ? BlockBasedTable::kPartitionedFilterBlockPrefix</span><br><span class="line">                : BlockBasedTable::kFullFilterBlockPrefix;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 FilterPolicy 的名字</span></span><br><span class="line">    key.<span class="built_in">append</span>(rep_-&gt;table_options.filter_policy-&gt;<span class="built_in">Name</span>());</span><br><span class="line">    <span class="comment">// 添加元信息</span></span><br><span class="line">    meta_index_builder-&gt;<span class="built_in">Add</span>(key, filter_block_handle);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteIndexBlock"><a href="#WriteIndexBlock" class="headerlink" title="WriteIndexBlock"></a>WriteIndexBlock</h4><p>由前文可知，<code>IndexBuiler</code>对外提供了两种：</p><ul><li>HashIndexBuilder</li><li>PartitionIndexBuiler</li></ul><p>无论是哪种，最后的<code>index block</code>结果都是由 <code>IndexBuilder::IndexBlocks::index_block_contents</code> 保存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">IndexBuilder</span>::IndexBlocks &#123;</span><br><span class="line">  Slice index_block_contents;</span><br><span class="line">  std::unordered_map&lt;std::string, Slice&gt; meta_blocks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>区别在于：</p><ul><li><code>PartitionIndexBuiler</code> 有很多个partition，而且这个partition的数量和 PartitionFilterBuilder 中的 partition 的数量一致。而<code>HashIndexBuilder</code>可等效的看做只有一个partition；</li><li><code>IndexBuilder::IndexBlocks::meta_blocks</code> 字段仅有<code>HashIndexBuilder</code>使用。</li></ul><p>因此，<code>WriteIndexBlock</code> 函数的最终目的也是将所有<code>partitions</code>的内容写入sst。写入sst的所有信息都记录在<code>index_block_handle</code>中，这用于后续的<code>footer</code>。</p><p>下面，带着上述理解，并顺着代码注释来阅读源码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// @param index_block_handle 用于记录 partition 的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteIndexBlock</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    MetaIndexBuilder* meta_index_builder, BlockHandle* index_block_handle)</span> </span>&#123;</span><br><span class="line">  IndexBuilder::IndexBlocks index_blocks;</span><br><span class="line">  <span class="comment">// 可等效看做获取 first partition 的内容</span></span><br><span class="line">  <span class="keyword">auto</span> index_builder_status = rep_-&gt;index_builder-&gt;<span class="built_in">Finish</span>(&amp;index_blocks);</span><br><span class="line">  <span class="keyword">if</span> (index_builder_status.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">    <span class="comment">// meta_blocks 仅用于 HashIndexBuilder，在 PartitionIndexBuilder 下不支持</span></span><br><span class="line">    <span class="built_in">assert</span>(index_blocks.meta_blocks.<span class="built_in">empty</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ok</span>() &amp;&amp; !index_builder_status.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    rep_-&gt;<span class="built_in">SetStatus</span>(index_builder_status);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// 这一部分是针对 HashIndexBuilder</span></span><br><span class="line">    <span class="comment">// item: &#123;name, content&#125;</span></span><br><span class="line">    <span class="comment">//  + &#123;hashindex.prefixes, prefix_block_&#125;</span></span><br><span class="line">    <span class="comment">//  + &#123;&quot;rocksdb.hashindex.metadata&quot;, prefix_meta_block_&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : index_blocks.meta_blocks) &#123;</span><br><span class="line">      BlockHandle block_handle;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(item.second, &amp;block_handle, <span class="literal">false</span> <span class="comment">/* is_data_block */</span>);</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ok</span>()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      meta_index_builder-&gt;<span class="built_in">Add</span>(item.first, block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这一部分是通用的</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    <span class="comment">// first patition </span></span><br><span class="line">    <span class="keyword">if</span> (rep_-&gt;table_options.enable_index_compression) &#123;</span><br><span class="line">      <span class="built_in">WriteBlock</span>(index_blocks.index_block_contents, index_block_handle, <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">WriteRawBlock</span>(index_blocks.index_block_contents, kNoCompression,</span><br><span class="line">                    index_block_handle);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 下面是针对 PartitionIndexBuiler </span></span><br><span class="line">  <span class="keyword">if</span> (index_builder_status.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">    Status s = Status::<span class="built_in">Incomplete</span>();</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">ok</span>() &amp;&amp; s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">      <span class="comment">// index_block_handle 表示上一个 partition</span></span><br><span class="line">      s = rep_-&gt;index_builder-&gt;<span class="built_in">Finish</span>(&amp;index_blocks, *index_block_handle);</span><br><span class="line">      <span class="keyword">if</span> (!s.<span class="built_in">ok</span>() &amp;&amp; !s.<span class="built_in">IsIncomplete</span>()) &#123;</span><br><span class="line">        rep_-&gt;<span class="built_in">SetStatus</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将每个partition写入sst文件</span></span><br><span class="line">      <span class="keyword">if</span> (rep_-&gt;table_options.enable_index_compression) &#123;</span><br><span class="line">        <span class="built_in">WriteBlock</span>(index_blocks.index_block_contents, index_block_handle,</span><br><span class="line">                   <span class="literal">false</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">WriteRawBlock</span>(index_blocks.index_block_contents, kNoCompression,</span><br><span class="line">                      index_block_handle);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The last index_block_handle will be for the partition index block</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="WriteFooter"><a href="#WriteFooter" class="headerlink" title="WriteFooter"></a>WriteFooter</h4><p>最后就是写入footer。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BlockBasedTableBuilder::WriteFooter</span><span class="params">(BlockHandle&amp; metaindex_block_handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                                         BlockHandle&amp; index_block_handle)</span> </span>&#123;</span><br><span class="line">  Rep* r = rep_;</span><br><span class="line">  <span class="type">bool</span> legacy = (r-&gt;table_options.format_version == <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">assert</span>(r-&gt;table_options.checksum == kCRC32c ||</span><br><span class="line">         r-&gt;table_options.format_version != <span class="number">0</span>);</span><br><span class="line">  <span class="function">Footer <span class="title">footer</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      legacy ? kLegacyBlockBasedTableMagicNumber : kBlockBasedTableMagicNumber,</span></span></span><br><span class="line"><span class="params"><span class="function">      r-&gt;table_options.format_version)</span></span>;</span><br><span class="line">  footer.<span class="built_in">set_metaindex_handle</span>(metaindex_block_handle);</span><br><span class="line">  footer.<span class="built_in">set_index_handle</span>(index_block_handle);</span><br><span class="line">  footer.<span class="built_in">set_checksum</span>(r-&gt;table_options.checksum);</span><br><span class="line">  std::string footer_encoding;</span><br><span class="line">  footer.<span class="built_in">EncodeTo</span>(&amp;footer_encoding);</span><br><span class="line">  <span class="built_in">assert</span>(<span class="built_in">ok</span>());</span><br><span class="line">  <span class="comment">// 最后在此写入</span></span><br><span class="line">  IOStatus ios = r-&gt;file-&gt;<span class="built_in">Append</span>(footer_encoding);</span><br><span class="line">  <span class="keyword">if</span> (ios.<span class="built_in">ok</span>()) &#123;</span><br><span class="line">    r-&gt;<span class="built_in">set_offset</span>(r-&gt;<span class="built_in">get_offset</span>() + footer_encoding.<span class="built_in">size</span>());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    r-&gt;<span class="built_in">SetIOStatus</span>(ios);</span><br><span class="line">    r-&gt;<span class="built_in">SetStatus</span>(ios);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;BlockBasedTableBuilder-ParallelCompressionRep&quot;&gt;&lt;a href=&quot;#BlockBasedTableBuilder-ParallelCompressionRep&quot; class=&quot;headerlink&quot; title=&quot;Bl</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>Footer 格式</title>
    <link href="https://szza.github.io/2021/11/25/rocksdb/Table/builder/5_Footer/"/>
    <id>https://szza.github.io/2021/11/25/rocksdb/Table/builder/5_Footer/</id>
    <published>2021-11-25T06:15:35.000Z</published>
    <updated>2023-07-31T16:46:20.628Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Footer</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Constructs a footer without specifying its table magic number.</span></span><br><span class="line">  <span class="comment">// In such case, the table magic number of such footer should be</span></span><br><span class="line">  <span class="comment">// initialized via @ReadFooterFromFile().</span></span><br><span class="line">  <span class="comment">// Use this when you plan to load Footer with DecodeFrom(). Never use this</span></span><br><span class="line">  <span class="comment">// when you plan to EncodeTo.</span></span><br><span class="line">  <span class="built_in">Footer</span>() : <span class="built_in">Footer</span>(kInvalidTableMagicNumber, <span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Use this constructor when you plan to write out the footer using</span></span><br><span class="line">  <span class="comment">// EncodeTo(). Never use this constructor with DecodeFrom().</span></span><br><span class="line">  <span class="built_in">Footer</span>(<span class="type">uint64_t</span> table_magic_number, <span class="type">uint32_t</span> version);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The version of the footer in this file</span></span><br><span class="line">  <span class="function"><span class="type">uint32_t</span> <span class="title">version</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> version_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The checksum type used in this file</span></span><br><span class="line">  <span class="function">ChecksumType <span class="title">checksum</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> checksum_; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_checksum</span><span class="params">(<span class="type">const</span> ChecksumType c)</span> </span>&#123; checksum_ = c; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The block handle for the metaindex block of the table</span></span><br><span class="line">  <span class="function"><span class="type">const</span> BlockHandle&amp; <span class="title">metaindex_handle</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> metaindex_handle_; &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_metaindex_handle</span><span class="params">(<span class="type">const</span> BlockHandle&amp; h)</span> </span>&#123; metaindex_handle_ = h; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The block handle for the index block of the table</span></span><br><span class="line">  <span class="function"><span class="type">const</span> BlockHandle&amp; <span class="title">index_handle</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> index_handle_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_index_handle</span><span class="params">(<span class="type">const</span> BlockHandle&amp; h)</span> </span>&#123; index_handle_ = h; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">uint64_t</span> <span class="title">table_magic_number</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> table_magic_number_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">EncodeTo</span><span class="params">(std::string* dst)</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set the current footer based on the input slice.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// REQUIRES: table_magic_number_ is not set (i.e.,</span></span><br><span class="line">  <span class="comment">// HasInitializedTableMagicNumber() is true). The function will initialize the</span></span><br><span class="line">  <span class="comment">// magic number</span></span><br><span class="line">  <span class="function">Status <span class="title">DecodeFrom</span><span class="params">(Slice* input)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Encoded length of a Footer.  Note that the serialization of a Footer will</span></span><br><span class="line">  <span class="comment">// always occupy at least kMinEncodedLength bytes.  If fields are changed</span></span><br><span class="line">  <span class="comment">// the version number should be incremented and kMaxEncodedLength should be</span></span><br><span class="line">  <span class="comment">// increased accordingly.</span></span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// Footer version 0 (legacy) will always occupy exactly this many bytes.</span></span><br><span class="line">    <span class="comment">// It consists of two block handles, padding, and a magic number.</span></span><br><span class="line">    kVersion0EncodedLength = <span class="number">2</span> * BlockHandle::kMaxEncodedLength + <span class="number">8</span>,</span><br><span class="line">    <span class="comment">// Footer of versions 1 and higher will always occupy exactly this many</span></span><br><span class="line">    <span class="comment">// bytes. It consists of the checksum type, two block handles, padding,</span></span><br><span class="line">    <span class="comment">// a version number (bigger than 1), and a magic number</span></span><br><span class="line">    kNewVersionsEncodedLength = <span class="number">1</span> + <span class="number">2</span> * BlockHandle::kMaxEncodedLength + <span class="number">4</span> + <span class="number">8</span>,</span><br><span class="line">    kMinEncodedLength = kVersion0EncodedLength,</span><br><span class="line">    kMaxEncodedLength = kNewVersionsEncodedLength,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="type">static</span> <span class="type">const</span> <span class="type">uint64_t</span> kInvalidTableMagicNumber = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// convert this object to a human readable form</span></span><br><span class="line">  <span class="function">std::string <span class="title">ToString</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// REQUIRES: magic number wasn&#x27;t initialized.</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">set_table_magic_number</span><span class="params">(<span class="type">uint64_t</span> magic_number)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">HasInitializedTableMagicNumber</span>());</span><br><span class="line">    table_magic_number_ = magic_number;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// return true if @table_magic_number_ is set to a value different</span></span><br><span class="line">  <span class="comment">// from @kInvalidTableMagicNumber.</span></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">HasInitializedTableMagicNumber</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (table_magic_number_ != kInvalidTableMagicNumber);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">uint32_t</span> version_;</span><br><span class="line">  ChecksumType checksum_;</span><br><span class="line">  BlockHandle metaindex_handle_;</span><br><span class="line">  BlockHandle index_handle_;</span><br><span class="line">  <span class="type">uint64_t</span> table_magic_number_ = <span class="number">0</span>;</span><br><span class="line">&#125;; <span class="comment">// class Footer</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Footer&quot;&gt;&lt;a href=&quot;#Footer&quot; class=&quot;headerlink&quot; title=&quot;Footer&quot;&gt;&lt;/a&gt;Footer&lt;/h2&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    <category term="RocksDB 剖析" scheme="https://szza.github.io/categories/RocksDB-%E5%89%96%E6%9E%90/"/>
    
    
  </entry>
  
  <entry>
    <title>基于vscode 打造C++编码环境</title>
    <link href="https://szza.github.io/2021/03/09/Tools/vscode/"/>
    <id>https://szza.github.io/2021/03/09/Tools/vscode/</id>
    <published>2021-03-09T03:40:15.000Z</published>
    <updated>2023-07-31T16:29:54.990Z</updated>
    
    <content type="html"><![CDATA[<p>本期分享下自己的C++编码环境。自己目前C++编码环境是基于vscode打造的，再通过vscode远程登录到Linux（remote Linux）。对于Linux环境，可选方式有两种：</p><ul><li>WSL（<strong>W</strong>indows <strong>S</strong>ubsystem <strong>L</strong>inux）</li><li>虚拟机</li></ul><p>WSL有诸多好处，它可以和WINDOWs-10更为紧密地联系在一起。比如，随处按下快捷键：<code>shift + 右击</code>，都可以开启 <code>linux shell</code>，然后使用linux的命令来操作WINDOWs。</p><p><img src="./images/1.jpg"></p><p><img src="/images/2.jpg"></p><p>但是WSL也有不足，其中关于调试网络的工具一般是用不了，比如有：<code>tcpdump</code>，这个bug自从WSL诞生至今尚未解决：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">tcpdump</span></span><br><span class="line">tcpdump: socket: Socket type not supported  # 无法启动</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">date</span></span></span><br><span class="line">Sun Mar  7 22:01:11 CST 2021</span><br></pre></td></tr></table></figure><p>此时就需要借用虚拟机来完成相关操作。我自己的使用场景：</p><ul><li>WSL能满足要求时，基本都用WSL</li><li>当WSL无法满足时，就使用虚拟机</li></ul><p>当然，嫌麻烦完全可以仅使用虚拟机，除了无法在WINDOWs-10随处开启 <code>Linux shell</code>外，基本无差别。下面讲解下vscode怎么联合WSL / 虚拟机打造C++编码环境。</p><h3 id="vscode-WSL"><a href="#vscode-WSL" class="headerlink" title="vscode +  WSL"></a>vscode +  WSL</h3><ol><li><p>安装WSL。在微软官方文档中有安装WSL的详细教程，照着步骤安装即可。地址：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://docs.microsoft.com/zh-cn/WINDOWs/wsl/install-win10</span><br></pre></td></tr></table></figure></li><li><p>vscode安装<code>Remote-WSL</code>插件。打开vscode，按快捷键：<code>ctr + shift + X</code> 或者直接点击左侧栏的<code>Extensions</code>，然后在插件商店里，搜索并安装  <code>Remote-WSL</code> 插件：</p><p><img src="/images/4.jpg"></p></li><li><p>在正式介绍之前，先介绍一个vscode的快捷键：<code>ctr + shift + p</code>。按下后，会显示出一个对话框（如下图），可以在里面输入一些命令来设置vscode的相关选项。</p><p><img src="/images/3.jpg"></p><p> 此时，在对话框中输入<code>Remote-WSL</code>，下方列表会显示相关的选项，选择第一个<code>Remote-WSL:New WINDOWs</code>：</p><p><img src="/images/5.jpg"></p><p>不需要任何配置、输入密码的过程，就自动进入<code>WSL</code>环境中：在左下角的状态栏中会有个<code>WSL:Ubuntu-x</code>的标志，表示你进入了WSL环境，此时按下快捷键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctr + `   # 注意后面还有个 `</span><br></pre></td></tr></table></figure><p>可以直接唤起终端，比如图中的<code>TERMINAL</code>：</p><p><img src="/images/6.jpg"></p></li><li><p>安装编译、调试等必要软件。到此，vscode环境已经基本配置完毕。此时WSL里什么软件也没有，连基本的make命令都不支持，需要自己手动安装C++编译器、调试器：</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gcc/g++ ： `sudo apt install g++`</span><br><span class="line">make：`sudo apt install make`</span><br><span class="line">cmake：`sudo apt install cmake`</span><br><span class="line">gdb：`sudo apt install gdb`</span><br></pre></td></tr></table></figure><p>由于vscode本身就可以当作一个终端来使用，因此进入WSL环境后，直接在vscode-terminal中输入上述安装命令。由于我已经安装了上述软件，因此继续安装会显示如下：</p><p><img src="/images/7.jpg"></p></li><li><p>创建文件夹。下面先写简单的demo测试下怎么继续使用。先创建一个名字是<code>demo</code> 的文件夹：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">szza@szza:~$ <span class="built_in">mkdir</span> demo</span><br><span class="line">szza@szza:~$ <span class="built_in">cd</span> demo/</span><br><span class="line">szza@szza:~/demo$ </span><br></pre></td></tr></table></figure><p>那么怎么打开刚刚创建的<code>demo</code>文件夹？方法有两种：</p><p><strong>1）</strong> 直接点击vscode左侧的  <code>Open Folder</code>按钮，然后选择刚才创建的<code>/home/szza/demo</code>文件夹即可。</p><p><img src="/images/8.jpg"></p><p><strong>2）</strong> 按下快捷键<code>ctr + shift + P</code>，再输入 <code>Open Folder</code>，再选择<code>home/szza/demo</code>文件夹即可。</p><p><img src="/images/9.jpg"></p></li><li><p>安装C++相关插件。</p><ul><li>C/C++</li><li>C++ Intellisense</li><li>Visual Studio Intellisense</li><li>Visual Studio Intellisense Insider</li></ul><p><img src="/images/10.jpg"></p><p>这样在写C++代码时，才会智能提示、调整等一些列功能。上述是基本插件，其他的插件可以自己多去探索发现。写完一个demo，就可以直接在<code>TERMINAL</code>上运行编译，结果如下：</p><p><img src="/images/11.jpg"></p></li></ol><p>到此，从安装WSL到在WSL中编译运行一个cpp程序，大致讲解完毕，整个过程基本没有配置、便于使用。可能你发现了，是不是还缺少一个环节：debug。</p><p>由于在上面步骤【5】中，已经安装了<code>gdb</code>调试软件。如果你会gdb，那么就可以直接使用gdb进行调试了。如果不熟悉，可以自己先行学习，也可以等等我，关于gdb调试的文章我准备等毕业答辩结束再来做个专题吧。回想自己在阅读开源项目redis6.0、libuv时，都是靠gdb帮我理清了回调函数链路。</p><h3 id="虚拟机-vscode"><a href="#虚拟机-vscode" class="headerlink" title="虚拟机 +  vscode"></a>虚拟机 +  vscode</h3><p>继续提供一个【虚拟机+vscode】的方案，最终可以实现和WSL几乎一致的体验。顺便提一下，WINDOWs-10 20H1之前，是不允许同时开启WSL和虚拟机，必须要升级到WINDOWs-10 20H1版本及其之后，才能同时开启。</p><p>关于虚拟机，本文以Ubuntu为准。至于怎么安装虚拟机不介绍了，上网搜索一下即可。</p><h4 id="开启SSH服务"><a href="#开启SSH服务" class="headerlink" title="开启SSH服务"></a>开启SSH服务</h4><p>个人建议：图方便可以直接安装<code>Ubuntu-Studio 2020</code>，它包含了常用的编译器和软件，不用自己去下载和安装了，比较省事，相对也比较稳定。我自己安装的<code>Ubuntu-2020</code>简洁版的虚拟机经常断开链接，但是我同学的又没事。</p><p>查看虚拟机的IP地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.183.130  netmask 255.255.255.0  broadcast 192.168.183.255</span><br><span class="line">        inet6 fe80::e8ab:d905:32f5:729e  prefixlen 64  scopeid 0x20&lt;<span class="built_in">link</span>&gt;</span><br><span class="line">        ether 00:0c:29:cb:4a:97  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 575  bytes 452238 (452.2 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 446  bytes 150254 (150.2 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 337  bytes 259455 (259.4 KB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 337  bytes 259455 (259.4 KB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>如果是安装的是简洁版，可能连<code>ifconfig</code>命令都不支持，那么需要安装网络工具：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt instal net-tools</span><br></pre></td></tr></table></figure><p>在安装<code>SSH</code>服务之前，先使用<code> ps  -e | grep ssh</code>命令查看自己的虚拟机上是否已经安装了<code>SSH</code>服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -e | grep ssh</span><br><span class="line">1017 ?        00:00:00 sshd<span class="comment"># OK</span></span><br><span class="line">1294 ?        00:00:00 ssh-agent</span><br><span class="line">1757 ?        00:00:00 sshd</span><br><span class="line">1836 ?        00:00:00 sshd</span><br></pre></td></tr></table></figure><p>否则，下面开始安装、启动SSH服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install openssh-server<span class="comment"># 安装SSH服务</span></span><br><span class="line">$ sudo service ssh start     <span class="comment"># 启动SSH服务</span></span><br></pre></td></tr></table></figure><p>对于之前没有开启SSH服务的，现在可以再次查看是否启动<code>SSH</code>服务了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ps -e | grep ssh</span><br><span class="line">1017 ?        00:00:00 sshd</span><br><span class="line">1294 ?        00:00:00 ssh-agent</span><br><span class="line">1757 ?        00:00:00 sshd</span><br><span class="line">1836 ?        00:00:00 sshd</span><br></pre></td></tr></table></figure><p>到此，SSH服务器已经开启，下面讲解怎么从vscode remote到虚拟机中。</p><h4 id="vscode链接虚拟机"><a href="#vscode链接虚拟机" class="headerlink" title="vscode链接虚拟机"></a>vscode链接虚拟机</h4><ol><li><p>在<code>Extensions</code>中，安装<code>Remote-SSH</code>插件</p></li><li><p>按住快捷键：<code>ctr + shift + P</code>，在对话中输入：<code>connect</code>，然后选择第一个<code>Remote-SSH:Connect to Host</code>选项即可：</p><p><img src="/images/12.jpg"></p></li><li><p>配置虚拟机的IP和端口。在步骤【2】后，会弹出下面的窗口。</p><ul><li>如果你已经连接过虚拟机，那么该虚拟机的IP地址会直接呈现下面。如果确定虚拟机是开启的，那么可以以直接连接即可。</li><li>否则，就需要添加新的虚拟机配置，有两种添加方法：<code>Add New SSH Host</code>选项是引导用户完成<code>Configure SSH Hosts...</code>选项，因此本文直接讲解<code>Configure SSH Hosts...</code>选项。这个选项是直接将虚拟<code>IP</code>地址到配置<code>C:\Users\szza\.ssh\config</code>文件中，极其方便。</li></ul><p><img src="/images/13.jpg"></p><p><img src="/images/14.jpg"></p><p>在<code>C:\Users\szza\.ssh\config</code>文件中，添加虚拟机的信息：</p><p><img src="/images/15.jpg"></p><p>设置好后，重复【2】的步骤，再次向虚拟机发起连接，就会发现自己新添加的虚拟机信息已经显示在下方了，直接点击连接即可：</p><p><img src="/images/16.jpg"></p><p>然后进入下面的界面，输入虚拟机的登录密码即可：</p><p><img src="/images/17.jpg"></p><p>输入完毕，则会进入虚拟机的Linux系统，到此连接任务就算完成了。至于该安装的软件和WSL的步骤【5】【6】【7】一致，按照步骤走即可。</p></li></ol><h4 id="免密登录虚拟机"><a href="#免密登录虚拟机" class="headerlink" title="免密登录虚拟机"></a>免密登录虚拟机</h4><p>vscode连接WSL是不需要输入密码，后续任何操作也不需要输入密码。但是vscode和虚拟机的任何操作每次都需要输入密码，就会很影响使用体验，下面讲解如何免密登录虚拟机。</p><p><strong>1）WINDOWs侧</strong></p><p>首先在WINDOWs上的vscode终端上，输入如下的命令，其中<code>&quot;这里任意输入&quot;</code>部分建议使用github账号的邮箱。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;这里任意输入&quot;</span></span><br></pre></td></tr></table></figure><p>一直按<code>enter</code>即可，最终会在<code>C:\Users\szza\.ssh</code>目录下，生成两个文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">id_rsa</span><br><span class="line">id_rsa.pub</span><br></pre></td></tr></table></figure><p><strong>2） 虚拟机侧</strong></p><p>在vscode的虚拟终端中输入同样的命令，在<code>/home/codespace/.ssh</code>文件下也会生成<code>id_rsa</code> 和<code>id_rsa.pub</code>文件。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;这里任意输入&quot;</span></span><br></pre></td></tr></table></figure><p>然后在<code>/home/codespace/.ssh</code>文件下，新建一个文件，名字是<code>authorized_keys</code>，直接将WINDOWs侧目录<code>C:\Users\szza\.ssh</code>下的<code>id_rsa.pub</code>文件内容复制到<code>authorized_keys</code>中，整个免密设置就完成了。</p><p><strong>by the way</strong></p><p>如何将WINDOWs侧的<code>C:\Users\szza\.ssh\id_rsa.pub</code>文件内容复制到虚拟机的<code>/home/codespace/.ssh/authorized_keys</code>中？？？很简单，分别用vscode打开两个文件夹，然后直接复制即可，不需要安装<code>VMWare Tools</code>就能完成。</p><p><img src="/images/18.jpg"></p><p>这个方式，也适用于想将WINDOWs的文件传输到虚拟机中，用vscode打开WINDOWs侧的文件，另一个vscode连接上虚拟机并打开到相应的文件夹，直接复制文件。</p><p>到此，整个vscode免密登录虚拟机的过程讲解完毕，以后任何操作都不需要输入密码了。</p><h4 id="过程中可能出现的问题"><a href="#过程中可能出现的问题" class="headerlink" title="过程中可能出现的问题"></a>过程中可能出现的问题</h4><p>vscode +WSL一般都没啥问题，都是WINDOWs原生产品。在remote到虚拟机时，可能会出现问题，我之前遇到过vscode一直连接不上虚拟机，发现是WINDOWs自带的<code>SSH-Client</code>有问题，自己下载一个<code>git</code>客户端，然后重复上述配置，就完成了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本期分享下自己的C++编码环境。自己目前C++编码环境是基于vscode打造的，再通过vscode远程登录到Linux（remote Linux）。对于Linux环境，可选方式有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WSL（&lt;strong&gt;W&lt;/strong&gt;indows &lt;s</summary>
      
    
    
    
    <category term="工具" scheme="https://szza.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="工具" scheme="https://szza.github.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
</feed>
