<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本文档详细介绍 Milvus 中 MVCC timestamp 信息在数据写入 Segment 过程中的处理机制，包括正常 Flush 流程和 Compaction 流程。 目录 1. 概述 2. Timestamp 字段定义 3. Flush 写入流程（主流程） 4. Compaction 写入流程 5. Storage 层的 Timestamp 处理 6. 两种存储版本对比 7. 总结   1">
<meta property="og:type" content="article">
<meta property="og:title" content="Milvus 数据写入流程中的 MVCC Timestamp 处理">
<meta property="og:url" content="https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="本文档详细介绍 Milvus 中 MVCC timestamp 信息在数据写入 Segment 过程中的处理机制，包括正常 Flush 流程和 Compaction 流程。 目录 1. 概述 2. Timestamp 字段定义 3. Flush 写入流程（主流程） 4. Compaction 写入流程 5. Storage 层的 Timestamp 处理 6. 两种存储版本对比 7. 总结   1">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-08-09T13:00:00.000Z">
<meta property="article:modified_time" content="2026-01-06T13:10:47.195Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Milvus">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>Milvus 数据写入流程中的 MVCC Timestamp 处理</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2025/08/09/Milvus/12_arrow_parquet_advantages_analysis/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2025/08/09/Milvus/11_index_sync_flow_analysis/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&text=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&title=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&is_video=false&description=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Milvus 数据写入流程中的 MVCC Timestamp 处理&body=Check out this article: https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&title=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&title=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&title=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&title=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&name=Milvus 数据写入流程中的 MVCC Timestamp 处理&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&t=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A0%B8%E5%BF%83%E7%BB%93%E8%AE%BA"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 核心结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Timestamp-%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 Timestamp 的用途</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Timestamp-%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89"><span class="toc-number">3.</span> <span class="toc-text">2. Timestamp 字段定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B3%BB%E7%BB%9F%E9%A2%84%E7%95%99%E5%AD%97%E6%AE%B5"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 系统预留字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Flush-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%BB%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">3. Flush 写入流程（主流程）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 整体流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 关键代码位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-WriteBuffer-%E5%88%9B%E5%BB%BA-SyncTask"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.2.1 WriteBuffer 创建 SyncTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-SyncTask-%E6%89%A7%E8%A1%8C%E5%86%99%E5%85%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">3.2.2 SyncTask 执行写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-StorageV1-%E5%BA%8F%E5%88%97%E5%8C%96-Binlog"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.2.3 StorageV1 序列化 Binlog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-StorageV2-%E5%86%99%E5%85%A5-Parquet"><span class="toc-number">4.2.4.</span> <span class="toc-text">3.2.4 StorageV2 写入 Parquet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Compaction-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">4. Compaction 写入流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 整体流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 关键代码位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-Mix-Compaction-%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">4.2.1 Mix Compaction 主流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%86%99%E5%85%A5%E5%8D%95%E4%B8%AA-Segment"><span class="toc-number">5.2.2.</span> <span class="toc-text">4.2.2 写入单个 Segment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-MultiSegmentWriter-%E5%86%99%E5%85%A5"><span class="toc-number">5.2.3.</span> <span class="toc-text">4.2.3 MultiSegmentWriter 写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E5%BA%95%E5%B1%82-Record-Writer"><span class="toc-number">5.2.4.</span> <span class="toc-text">4.2.4 底层 Record Writer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Storage-%E5%B1%82%E7%9A%84-Timestamp-%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">5. Storage 层的 Timestamp 处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Growing-Segment-%E4%B8%AD%E7%9A%84-Timestamp"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 Growing Segment 中的 Timestamp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Segment-Writer-%E4%B8%AD%E7%9A%84-Timestamp-%E8%BF%BD%E8%B8%AA"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 Segment Writer 中的 Timestamp 追踪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94"><span class="toc-number">7.</span> <span class="toc-text">6. 两种存储版本对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-StorageV1-Binlog-%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 StorageV1 (Binlog 格式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-StorageV2-Parquet-%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 StorageV2 (Parquet 格式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 对比表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">7. 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 核心要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91%E5%9B%BE"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 数据流向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 相关文件索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8"><span class="toc-number">9.</span> <span class="toc-text">附录：术语表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95-A%EF%BC%9ASegment-%E5%86%85%E9%83%A8-Layout"><span class="toc-number"></span> <span class="toc-text">附录 A：Segment 内部 Layout</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-1-Segment-%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">A.1 Segment 类型概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Growing-Segment-%E5%A2%9E%E9%95%BF%E4%B8%AD%E7%9A%84-Segment"><span class="toc-number">1.1.</span> <span class="toc-text">Growing Segment (增长中的 Segment)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sealed-Segment-%E5%B0%81%E5%AD%98%E7%9A%84-Segment"><span class="toc-number">1.2.</span> <span class="toc-text">Sealed Segment (封存的 Segment)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-2-Growing-Segment-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">A.2 Growing Segment 内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-2-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">A.2.1 核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-2-2-InsertRecord-%E6%95%B0%E6%8D%AE%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.</span> <span class="toc-text">A.2.2 InsertRecord 数据布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-2-3-%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">A.2.3 数据组织方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-2-4-Chunk-%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">A.2.4 Chunk 机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-3-Sealed-Segment-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">A.3 Sealed Segment 内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-3-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">A.3.1 核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-3-2-%E6%95%B0%E6%8D%AE%E5%B8%83%E5%B1%80"><span class="toc-number">3.2.</span> <span class="toc-text">A.3.2 数据布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-3-3-ChunkedColumn-%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">A.3.3 ChunkedColumn 结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-Layout"><span class="toc-number">4.</span> <span class="toc-text">A.4 文件系统中的 Layout</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-4-1-StorageV1-Binlog-%E5%B8%83%E5%B1%80"><span class="toc-number">4.1.</span> <span class="toc-text">A.4.1 StorageV1 (Binlog) 布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-4-2-StorageV2-Parquet-%E5%B8%83%E5%B1%80"><span class="toc-number">4.2.</span> <span class="toc-text">A.4.2 StorageV2 (Parquet) 布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-4-3-Binlog-%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.</span> <span class="toc-text">A.4.3 Binlog 文件内部结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-5-%E6%9F%A5%E8%AF%A2%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-number">5.</span> <span class="toc-text">A.5 查询时的数据访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-5-1-%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">5.1.</span> <span class="toc-text">A.5.1 访问路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-5-2-Timestamp-%E8%BF%87%E6%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.</span> <span class="toc-text">A.5.2 Timestamp 过滤示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">A.6 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-6-1-Growing-Segment-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">A.6.1 Growing Segment 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-6-2-Sealed-Segment-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">A.6.2 Sealed Segment 内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-7-%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">A.7 关键数据结构总结</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Milvus 数据写入流程中的 MVCC Timestamp 处理
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-08-09T13:00:00.000Z" itemprop="datePublished">2025-08-09</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Milvus/" rel="tag">Milvus</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>本文档详细介绍 Milvus 中 MVCC timestamp 信息在数据写入 Segment 过程中的处理机制，包括正常 Flush 流程和 Compaction 流程。</p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#1-%E6%A6%82%E8%BF%B0">1. 概述</a></li>
<li><a href="#2-timestamp-%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89">2. Timestamp 字段定义</a></li>
<li><a href="#3-flush-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B%E4%B8%BB%E6%B5%81%E7%A8%8B">3. Flush 写入流程（主流程）</a></li>
<li><a href="#4-compaction-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B">4. Compaction 写入流程</a></li>
<li><a href="#5-storage-%E5%B1%82%E7%9A%84-timestamp-%E5%A4%84%E7%90%86">5. Storage 层的 Timestamp 处理</a></li>
<li><a href="#6-%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94">6. 两种存储版本对比</a></li>
<li><a href="#7-%E6%80%BB%E7%BB%93">7. 总结</a></li>
</ul>
<hr>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-核心结论"><a href="#1-1-核心结论" class="headerlink" title="1.1 核心结论"></a>1.1 核心结论</h3><p><strong>是的，MVCC timestamp 信息会完整写入到 Segment 中。</strong></p>
<p>Timestamp 作为系统预留字段（FieldID&#x3D;1），在数据写入过程中会像其他用户字段一样被序列化并持久化到存储中。主要有两个写入路径：</p>
<ol>
<li><strong>Flush 流程</strong>（主要路径）：正常数据写入时的持久化</li>
<li><strong>Compaction 流程</strong>：Segment 合并优化时的重新写入</li>
</ol>
<h3 id="1-2-Timestamp-的用途"><a href="#1-2-Timestamp-的用途" class="headerlink" title="1.2 Timestamp 的用途"></a>1.2 Timestamp 的用途</h3><ul>
<li><strong>MVCC 版本控制</strong>：支持时间旅行查询（Time Travel Query）</li>
<li><strong>数据可见性判断</strong>：根据 timestamp 过滤不可见的数据</li>
<li><strong>数据过期处理</strong>：基于 TTL 和 timestamp 清理过期数据</li>
<li><strong>查询优化</strong>：通过 timestamp 范围快速过滤 Segment</li>
</ul>
<hr>
<h2 id="2-Timestamp-字段定义"><a href="#2-Timestamp-字段定义" class="headerlink" title="2. Timestamp 字段定义"></a>2. Timestamp 字段定义</h2><h3 id="2-1-系统预留字段"><a href="#2-1-系统预留字段" class="headerlink" title="2.1 系统预留字段"></a>2.1 系统预留字段</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pkg/common/common.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// TimeStampField is the ID of the Timestamp field reserved by the system</span></span><br><span class="line">    TimeStampField = <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// RowIDField is the ID of the RowID field reserved by the system</span></span><br><span class="line">    RowIDField = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TimeStampFieldName defines the name of the Timestamp field</span></span><br><span class="line">    TimeStampFieldName = <span class="string">&quot;Timestamp&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h3 id="2-2-数据类型"><a href="#2-2-数据类型" class="headerlink" title="2.2 数据类型"></a>2.2 数据类型</h3><p>Timestamp 是 <code>int64</code> 类型，在 C++ 和 Go 代码中都被定义为 <code>uint64</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// internal/core/src/common/Types.h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> Timestamp = <span class="type">uint64_t</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">auto</span> MAX_TIMESTAMP = std::numeric_limits&lt;Timestamp&gt;::<span class="built_in">max</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="3-Flush-写入流程（主流程）"><a href="#3-Flush-写入流程（主流程）" class="headerlink" title="3. Flush 写入流程（主流程）"></a>3. Flush 写入流程（主流程）</h2><h3 id="3-1-整体流程图"><a href="#3-1-整体流程图" class="headerlink" title="3.1 整体流程图"></a>3.1 整体流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">用户 Insert/Delete 请求</span><br><span class="line">    ↓</span><br><span class="line">WriteBuffer.BufferData()        // 缓存数据到内存</span><br><span class="line">    ↓</span><br><span class="line">triggerSync()                   // 根据策略触发同步</span><br><span class="line">    ↓</span><br><span class="line">getSegmentsToSync()             // 选择需要 sync 的 segments</span><br><span class="line">    ↓</span><br><span class="line">syncSegments()</span><br><span class="line">    ↓</span><br><span class="line">getSyncTask()                   // 创建 SyncTask</span><br><span class="line">    ├─ yieldBuffer()            // 从 buffer 获取数据</span><br><span class="line">    └─ NewSyncTask()            // 创建同步任务</span><br><span class="line">    ↓</span><br><span class="line">SyncManager.SyncData()</span><br><span class="line">    ↓</span><br><span class="line">SyncTask.Run()</span><br><span class="line">    ↓</span><br><span class="line">    ├─ [StorageV1] BulkPackWriter.Write()</span><br><span class="line">    │   ├─ writeInserts()</span><br><span class="line">    │   │   └─ storageV1Serializer.serializeBinlog()</span><br><span class="line">    │   │       └─ InsertCodec.Serialize()        ★ 序列化所有字段（包括 timestamp）</span><br><span class="line">    │   │           └─ 为每个 field 创建独立的 binlog 文件</span><br><span class="line">    │   │</span><br><span class="line">    │   ├─ writeStats()                           ★ 写入统计信息（含 timestamp 范围）</span><br><span class="line">    │   └─ writeBM25Stats()</span><br><span class="line">    │</span><br><span class="line">    └─ [StorageV2] BulkPackWriterV2.Write()</span><br><span class="line">        ├─ writeInserts()</span><br><span class="line">        │   ├─ serializeBinlog()                  // 转换为 Arrow Record</span><br><span class="line">        │   ├─ 提取 timestamp 列计算范围</span><br><span class="line">        │   └─ PackedRecordWriter.Write()         ★ 写入 Parquet 格式</span><br><span class="line">        │</span><br><span class="line">        └─ writeStats()</span><br></pre></td></tr></table></figure>

<h3 id="3-2-关键代码位置"><a href="#3-2-关键代码位置" class="headerlink" title="3.2 关键代码位置"></a>3.2 关键代码位置</h3><h4 id="3-2-1-WriteBuffer-创建-SyncTask"><a href="#3-2-1-WriteBuffer-创建-SyncTask" class="headerlink" title="3.2.1 WriteBuffer 创建 SyncTask"></a>3.2.1 WriteBuffer 创建 SyncTask</h4><p><strong>文件</strong>: <code>internal/flushcommon/writebuffer/write_buffer.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wb *writeBufferBase)</span></span> getSyncTask(ctx context.Context, segmentID <span class="type">int64</span>) (syncmgr.Task, <span class="type">error</span>) &#123;</span><br><span class="line">    segmentInfo, ok := wb.metaCache.GetSegmentByID(segmentID)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, merr.WrapErrSegmentNotFound(segmentID)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> batchSize <span class="type">int64</span></span><br><span class="line">    <span class="keyword">var</span> tsFrom, tsTo <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 buffer 中获取数据，包括 insert data 和 timestamp 范围</span></span><br><span class="line">    insert, bm25, delta, schema, timeRange, startPos := wb.yieldBuffer(segmentID)</span><br><span class="line">    <span class="keyword">if</span> timeRange != <span class="literal">nil</span> &#123;</span><br><span class="line">        tsFrom, tsTo = timeRange.timestampMin, timeRange.timestampMax</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, chunk := <span class="keyword">range</span> insert &#123;</span><br><span class="line">        batchSize += <span class="type">int64</span>(chunk.GetRowNum())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 SyncPack，包含所有需要持久化的数据</span></span><br><span class="line">    pack := &amp;syncmgr.SyncPack&#123;&#125;</span><br><span class="line">    pack.WithInsertData(insert).        <span class="comment">// ★ InsertData 包含 timestamp 字段</span></span><br><span class="line">        WithDeleteData(delta).</span><br><span class="line">        WithCollectionID(wb.collectionID).</span><br><span class="line">        WithPartitionID(segmentInfo.PartitionID()).</span><br><span class="line">        WithSegmentID(segmentID).</span><br><span class="line">        WithTimeRange(tsFrom, tsTo).    <span class="comment">// ★ Timestamp 范围</span></span><br><span class="line">        WithBatchRows(batchSize)</span><br><span class="line"></span><br><span class="line">    task := syncmgr.NewSyncTask().</span><br><span class="line">        WithMetaCache(wb.metaCache).</span><br><span class="line">        WithSchema(schema).</span><br><span class="line">        WithSyncPack(pack)</span><br><span class="line">    <span class="keyword">return</span> task, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-SyncTask-执行写入"><a href="#3-2-2-SyncTask-执行写入" class="headerlink" title="3.2.2 SyncTask 执行写入"></a>3.2.2 SyncTask 执行写入</h4><p><strong>文件</strong>: <code>internal/flushcommon/syncmgr/task.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SyncTask)</span></span> Run(ctx context.Context) (err <span class="type">error</span>) &#123;</span><br><span class="line">    segmentInfo, has := t.metacache.GetSegmentByID(t.segmentID)</span><br><span class="line">    <span class="keyword">if</span> !has &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    columnGroups := t.getColumnGroups(segmentInfo)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 StorageVersion 选择不同的写入方式</span></span><br><span class="line">    <span class="keyword">switch</span> segmentInfo.GetStorageVersion() &#123;</span><br><span class="line">    <span class="keyword">case</span> storage.StorageV2:</span><br><span class="line">        writer := NewBulkPackWriterV2(t.metacache, t.schema, t.chunkManager, </span><br><span class="line">            t.allocator, <span class="number">0</span>, packed.DefaultMultiPartUploadSize, </span><br><span class="line">            t.storageConfig, columnGroups, t.writeRetryOpts...)</span><br><span class="line">        t.insertBinlogs, t.deltaBinlog, t.statsBinlogs, t.bm25Binlogs, </span><br><span class="line">            t.manifestPath, t.flushedSize, err = writer.Write(ctx, t.pack)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">default</span>:  <span class="comment">// StorageV1</span></span><br><span class="line">        writer := NewBulkPackWriter(t.metacache, t.schema, </span><br><span class="line">            t.chunkManager, t.allocator, t.writeRetryOpts...)</span><br><span class="line">        t.insertBinlogs, t.deltaBinlog, t.statsBinlogs, t.bm25Binlogs, </span><br><span class="line">            t.flushedSize, err = writer.Write(ctx, t.pack)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-StorageV1-序列化-Binlog"><a href="#3-2-3-StorageV1-序列化-Binlog" class="headerlink" title="3.2.3 StorageV1 序列化 Binlog"></a>3.2.3 StorageV1 序列化 Binlog</h4><p><strong>文件</strong>: <code>internal/flushcommon/syncmgr/storage_serializer.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *storageV1Serializer)</span></span> serializeBinlog(ctx context.Context, pack *SyncPack) (<span class="keyword">map</span>[<span class="type">int64</span>]*storage.Blob, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pack.insertData) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*storage.Blob), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用 InsertCodec 序列化所有字段</span></span><br><span class="line">    blobs, err := s.inCodec.Serialize(pack.partitionID, pack.segmentID, pack.insertData...)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回 map[fieldID]*Blob，包括 timestamp field (fieldID=1)</span></span><br><span class="line">    result := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*storage.Blob)</span><br><span class="line">    <span class="keyword">for</span> _, blob := <span class="keyword">range</span> blobs &#123;</span><br><span class="line">        fieldID, err := strconv.ParseInt(blob.GetKey(), <span class="number">10</span>, <span class="number">64</span>)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        result[fieldID] = blob</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>文件</strong>: <code>internal/storage/data_codec.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(insertCodec *InsertCodec)</span></span> Serialize(partitionID UniqueID, segmentID UniqueID, data ...*InsertData) ([]*Blob, <span class="type">error</span>) &#123;</span><br><span class="line">    blobs := <span class="built_in">make</span>([]*Blob, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> rowNum <span class="type">int64</span></span><br><span class="line">    <span class="keyword">var</span> startTs, endTs Timestamp</span><br><span class="line">    startTs, endTs = math.MaxUint64, <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 首先从 timestamp 字段提取时间范围</span></span><br><span class="line">    <span class="keyword">for</span> _, block := <span class="keyword">range</span> data &#123;</span><br><span class="line">        timeFieldData, ok := block.Data[common.TimeStampField]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">&quot;data doesn&#x27;t contains timestamp field&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        rowNum += <span class="type">int64</span>(timeFieldData.RowNum())</span><br><span class="line">        ts := timeFieldData.(*Int64FieldData).Data</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> _, t := <span class="keyword">range</span> ts &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="type">uint64</span>(t) &gt; endTs &#123;</span><br><span class="line">                endTs = <span class="type">uint64</span>(t)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> <span class="type">uint64</span>(t) &lt; startTs &#123;</span><br><span class="line">                startTs = <span class="type">uint64</span>(t)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 为每个字段创建 binlog writer（包括 timestamp）</span></span><br><span class="line">    serializeField := <span class="function"><span class="keyword">func</span><span class="params">(field *schemapb.FieldSchema)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="comment">// 创建字段对应的 binlog writer</span></span><br><span class="line">        writer = NewInsertBinlogWriter(field.DataType, insertCodec.Schema.ID, </span><br><span class="line">            partitionID, segmentID, field.FieldID, field.GetNullable())</span><br><span class="line"></span><br><span class="line">        eventWriter, err := writer.NextInsertEventWriter()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置 timestamp 范围到 binlog 元数据</span></span><br><span class="line">        eventWriter.SetEventTimestamp(startTs, endTs)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将字段数据写入 payload</span></span><br><span class="line">        <span class="keyword">for</span> _, block := <span class="keyword">range</span> data &#123;</span><br><span class="line">            singleData := block.Data[field.FieldID]</span><br><span class="line">            <span class="keyword">if</span> err = AddFieldDataToPayload(eventWriter, field.DataType, singleData); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成并获取 blob</span></span><br><span class="line">        buffer, err := writer.GetBuffer()</span><br><span class="line">        blobs = <span class="built_in">append</span>(blobs, &amp;Blob&#123;</span><br><span class="line">            Key:        fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, field.FieldID),</span><br><span class="line">            Value:      buffer,</span><br><span class="line">            RowNum:     rowNum,</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 遍历所有字段进行序列化（包括 timestamp field）</span></span><br><span class="line">    <span class="keyword">for</span> _, field := <span class="keyword">range</span> insertCodec.Schema.Schema.Fields &#123;</span><br><span class="line">        <span class="keyword">if</span> err := serializeField(field); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> blobs, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-4-StorageV2-写入-Parquet"><a href="#3-2-4-StorageV2-写入-Parquet" class="headerlink" title="3.2.4 StorageV2 写入 Parquet"></a>3.2.4 StorageV2 写入 Parquet</h4><p><strong>文件</strong>: <code>internal/flushcommon/syncmgr/pack_writer_v2.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BulkPackWriterV2)</span></span> writeInserts(ctx context.Context, pack *SyncPack) (<span class="keyword">map</span>[<span class="type">int64</span>]*datapb.FieldBinlog, <span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pack.insertData) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*datapb.FieldBinlog), <span class="string">&quot;&quot;</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 序列化为 Arrow Record</span></span><br><span class="line">    rec, err := bw.serializeBinlog(ctx, pack)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*datapb.FieldBinlog)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 从 Record 中提取 timestamp 列并计算范围</span></span><br><span class="line">    tsArray := rec.Column(common.TimeStampField).(*array.Int64)</span><br><span class="line">    rows := rec.Len()</span><br><span class="line">    <span class="keyword">var</span> tsFrom <span class="type">uint64</span> = math.MaxUint64</span><br><span class="line">    <span class="keyword">var</span> tsTo <span class="type">uint64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        ts := typeutil.Timestamp(tsArray.Value(i))</span><br><span class="line">        <span class="keyword">if</span> ts &lt; tsFrom &#123;</span><br><span class="line">            tsFrom = ts</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ts &gt; tsTo &#123;</span><br><span class="line">            tsTo = ts</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入 Parquet 文件（包含所有字段，含 timestamp）</span></span><br><span class="line">    doWrite := <span class="function"><span class="keyword">func</span><span class="params">(w storage.RecordWriter)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err = w.Write(rec); err != <span class="literal">nil</span> &#123;  <span class="comment">// ★ Arrow Record 包含 timestamp 列</span></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w.Close()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 创建 PackedRecordWriter 并写入</span></span><br><span class="line">    <span class="keyword">if</span> paramtable.Get().CommonCfg.UseLoonFFI.GetAsBool() &#123;</span><br><span class="line">        <span class="comment">// Manifest 模式</span></span><br><span class="line">        w, err := storage.NewPackedRecordManifestWriter(...)</span><br><span class="line">        <span class="keyword">if</span> err = doWrite(w); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        manifestPath = w.GetWrittenManifest()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 普通模式</span></span><br><span class="line">        w, err := storage.NewPackedRecordWriter(...)</span><br><span class="line">        <span class="keyword">if</span> err = doWrite(w); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 记录 binlog 信息（含 timestamp 范围）</span></span><br><span class="line">    <span class="keyword">for</span> _, columnGroup := <span class="keyword">range</span> columnGroups &#123;</span><br><span class="line">        logs[columnGroup.GroupID] = &amp;datapb.FieldBinlog&#123;</span><br><span class="line">            FieldID:     columnGroup.GroupID,</span><br><span class="line">            ChildFields: columnGroup.Fields,</span><br><span class="line">            Binlogs: []*datapb.Binlog&#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    LogPath:       path,</span><br><span class="line">                    EntriesNum:    rowNum,</span><br><span class="line">                    TimestampFrom: tsFrom,  <span class="comment">// ★ Timestamp 范围</span></span><br><span class="line">                    TimestampTo:   tsTo,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> logs, manifestPath, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化为 Arrow Record</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BulkPackWriterV2)</span></span> serializeBinlog(_ context.Context, pack *SyncPack) (storage.Record, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 转换 schema 为 Arrow Schema</span></span><br><span class="line">    arrowSchema, err := storage.ConvertToArrowSchema(bw.schema, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    builder := array.NewRecordBuilder(memory.DefaultAllocator, arrowSchema)</span><br><span class="line">    <span class="keyword">defer</span> builder.Release()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建 Arrow Record（包含所有字段）</span></span><br><span class="line">    <span class="keyword">for</span> _, chunk := <span class="keyword">range</span> pack.insertData &#123;</span><br><span class="line">        <span class="keyword">if</span> err := storage.BuildRecord(builder, chunk, bw.schema); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rec := builder.NewRecord()</span><br><span class="line">    <span class="keyword">return</span> storage.NewSimpleArrowRecord(rec, field2Col), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-Compaction-写入流程"><a href="#4-Compaction-写入流程" class="headerlink" title="4. Compaction 写入流程"></a>4. Compaction 写入流程</h2><p>Compaction 是对已有 Segment 的合并和优化，也会重新写入 timestamp 信息。</p>
<h3 id="4-1-整体流程图"><a href="#4-1-整体流程图" class="headerlink" title="4.1 整体流程图"></a>4.1 整体流程图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Compaction Task 创建</span><br><span class="line">    ↓</span><br><span class="line">mixCompactionTask.Compact()</span><br><span class="line">    ↓</span><br><span class="line">mixCompactionTask.mergeSplit()</span><br><span class="line">    ↓</span><br><span class="line">NewMultiSegmentWriter()                    // 创建多 segment 写入器</span><br><span class="line">    ↓</span><br><span class="line">对每个源 Segment:</span><br><span class="line">    ├─ storage.NewBinlogRecordReader()     // 读取原始数据</span><br><span class="line">    └─ mixCompactionTask.writeSegment()</span><br><span class="line">        └─ [循环读取 Record]</span><br><span class="line">            ├─ reader.Next()               // 读取 Arrow Record（含 timestamp）</span><br><span class="line">            ├─ 过滤已删除/过期数据</span><br><span class="line">            └─ mWriter.Write(rec)          ★ 写入合并后的数据</span><br><span class="line">                └─ MultiSegmentWriter.Write()</span><br><span class="line">                    └─ BinlogValueWriter.Write()</span><br><span class="line">                        └─ BinlogRecordWriter.Write()</span><br><span class="line">                            ├─ [V1] CompositeBinlogRecordWriter.Write()</span><br><span class="line">                            │   ├─ 提取 timestamp 范围</span><br><span class="line">                            │   └─ 序列化为 binlog</span><br><span class="line">                            │</span><br><span class="line">                            └─ [V2] PackedBinlogRecordWriter.Write()</span><br><span class="line">                                ├─ 提取 timestamp 范围</span><br><span class="line">                                └─ 写入 Parquet</span><br></pre></td></tr></table></figure>

<h3 id="4-2-关键代码位置"><a href="#4-2-关键代码位置" class="headerlink" title="4.2 关键代码位置"></a>4.2 关键代码位置</h3><h4 id="4-2-1-Mix-Compaction-主流程"><a href="#4-2-1-Mix-Compaction-主流程" class="headerlink" title="4.2.1 Mix Compaction 主流程"></a>4.2.1 Mix Compaction 主流程</h4><p><strong>文件</strong>: <code>internal/datanode/compactor/mix_compactor.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *mixCompactionTask)</span></span> mergeSplit(ctx context.Context) ([]*datapb.CompactionSegment, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 创建 ID 分配器</span></span><br><span class="line">    segIDAlloc := allocator.NewLocalAllocator(</span><br><span class="line">        t.plan.GetPreAllocatedSegmentIDs().GetBegin(), </span><br><span class="line">        t.plan.GetPreAllocatedSegmentIDs().GetEnd())</span><br><span class="line">    logIDAlloc := allocator.NewLocalAllocator(</span><br><span class="line">        t.plan.GetPreAllocatedLogIDs().GetBegin(), </span><br><span class="line">        t.plan.GetPreAllocatedLogIDs().GetEnd())</span><br><span class="line">    compAlloc := NewCompactionAllocator(segIDAlloc, logIDAlloc)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建 MultiSegmentWriter</span></span><br><span class="line">    mWriter, err := NewMultiSegmentWriter(ctx, t.binlogIO, compAlloc, </span><br><span class="line">        t.plan.GetMaxSize(), t.plan.GetSchema(), t.compactionParams, </span><br><span class="line">        t.maxRows, t.partitionID, t.collectionID, t.GetChannelName(), <span class="number">4096</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    deletedRowCount := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line">    expiredRowCount := <span class="type">int64</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理每个源 segment</span></span><br><span class="line">    <span class="keyword">for</span> _, seg := <span class="keyword">range</span> t.plan.GetSegmentBinlogs() &#123;</span><br><span class="line">        del, exp, err := t.writeSegment(ctx, seg, mWriter, pkField)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        deletedRowCount += del</span><br><span class="line">        expiredRowCount += exp</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭 writer 完成写入</span></span><br><span class="line">    <span class="keyword">if</span> err := mWriter.Close(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> mWriter.GetCompactionSegments(), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-2-写入单个-Segment"><a href="#4-2-2-写入单个-Segment" class="headerlink" title="4.2.2 写入单个 Segment"></a>4.2.2 写入单个 Segment</h4><p><strong>文件</strong>: <code>internal/datanode/compactor/mix_compactor.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *mixCompactionTask)</span></span> writeSegment(ctx context.Context,</span><br><span class="line">    seg *datapb.CompactionSegmentBinlogs,</span><br><span class="line">    mWriter *MultiSegmentWriter, </span><br><span class="line">    pkField *schemapb.FieldSchema) (deletedRowCount, expiredRowCount <span class="type">int64</span>, err <span class="type">error</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 读取 delta log（删除记录）</span></span><br><span class="line">    deltaPaths := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, fieldBinlog := <span class="keyword">range</span> seg.GetDeltalogs() &#123;</span><br><span class="line">        <span class="keyword">for</span> _, binlog := <span class="keyword">range</span> fieldBinlog.GetBinlogs() &#123;</span><br><span class="line">            deltaPaths = <span class="built_in">append</span>(deltaPaths, binlog.GetLogPath())</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    delta, err := compaction.ComposeDeleteFromDeltalogs(ctx, t.binlogIO, deltaPaths)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    entityFilter := compaction.NewEntityFilter(delta, t.plan.GetCollectionTtl(), t.currentTime)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建 RecordReader 读取原始数据</span></span><br><span class="line">    <span class="keyword">var</span> reader storage.RecordReader</span><br><span class="line">    <span class="keyword">if</span> seg.GetManifest() != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">        reader, err = storage.NewManifestRecordReader(ctx, seg.GetManifest(), </span><br><span class="line">            t.plan.GetSchema(), ...)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reader, err = storage.NewBinlogRecordReader(ctx, seg.GetFieldBinlogs(), </span><br><span class="line">            t.plan.GetSchema(), ...)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> reader.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 循环读取并写入数据</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> r storage.Record</span><br><span class="line">        r, err = reader.Next()</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> err == sio.EOF &#123;</span><br><span class="line">                err = <span class="literal">nil</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 过滤删除和过期的数据</span></span><br><span class="line">        <span class="keyword">var</span> (</span><br><span class="line">            pkArray    = r.Column(pkField.FieldID)</span><br><span class="line">            tsArray    = r.Column(common.TimeStampField).(*array.Int64)  <span class="comment">// ★ 读取 timestamp</span></span><br><span class="line">            sliceStart = <span class="number">-1</span></span><br><span class="line">            rb         *storage.RecordBuilder</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> r.Len() &#123;</span><br><span class="line">            <span class="comment">// 获取 PK 和 Timestamp</span></span><br><span class="line">            <span class="keyword">var</span> pk any</span><br><span class="line">            <span class="keyword">switch</span> pkField.DataType &#123;</span><br><span class="line">            <span class="keyword">case</span> schemapb.DataType_Int64:</span><br><span class="line">                pk = pkArray.(*array.Int64).Value(i)</span><br><span class="line">            <span class="keyword">case</span> schemapb.DataType_VarChar:</span><br><span class="line">                pk = pkArray.(*array.String).Value(i)</span><br><span class="line">            &#125;</span><br><span class="line">            ts := typeutil.Timestamp(tsArray.Value(i))</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 根据 timestamp 和删除记录过滤</span></span><br><span class="line">            <span class="keyword">if</span> entityFilter.Filtered(pk, ts) &#123;</span><br><span class="line">                <span class="keyword">if</span> rb == <span class="literal">nil</span> &#123;</span><br><span class="line">                    rb = storage.NewRecordBuilder(t.plan.GetSchema())</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> sliceStart != <span class="number">-1</span> &#123;</span><br><span class="line">                    rb.Append(r, sliceStart, i)</span><br><span class="line">                &#125;</span><br><span class="line">                sliceStart = <span class="number">-1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> sliceStart == <span class="number">-1</span> &#123;</span><br><span class="line">                sliceStart = i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5. 写入过滤后的数据</span></span><br><span class="line">        <span class="keyword">if</span> rb != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> sliceStart != <span class="number">-1</span> &#123;</span><br><span class="line">                rb.Append(r, sliceStart, r.Len())</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> rb.GetRowNum() &gt; <span class="number">0</span> &#123;</span><br><span class="line">                rec := rb.Build()</span><br><span class="line">                <span class="keyword">defer</span> rec.Release()</span><br><span class="line">                err := mWriter.Write(rec)  <span class="comment">// ★ 写入 Record（包含 timestamp）</span></span><br><span class="line">                <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, err</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            err := mWriter.Write(r)</span><br><span class="line">            <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>, <span class="number">0</span>, err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-3-MultiSegmentWriter-写入"><a href="#4-2-3-MultiSegmentWriter-写入" class="headerlink" title="4.2.3 MultiSegmentWriter 写入"></a>4.2.3 MultiSegmentWriter 写入</h4><p><strong>文件</strong>: <code>internal/datanode/compactor/segment_writer.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MultiSegmentWriter <span class="keyword">struct</span> &#123;</span><br><span class="line">    ctx       context.Context</span><br><span class="line">    binlogIO  io.BinlogIO</span><br><span class="line">    allocator *compactionAlloactor</span><br><span class="line"></span><br><span class="line">    writer           *storage.BinlogValueWriter  <span class="comment">// 底层 writer</span></span><br><span class="line">    currentSegmentID typeutil.UniqueID</span><br><span class="line"></span><br><span class="line">    maxRows     <span class="type">int64</span></span><br><span class="line">    segmentSize <span class="type">int64</span></span><br><span class="line">    </span><br><span class="line">    schema        *schemapb.CollectionSchema</span><br><span class="line">    partitionID   <span class="type">int64</span></span><br><span class="line">    collectionID  <span class="type">int64</span></span><br><span class="line">    </span><br><span class="line">    res []*datapb.CompactionSegment</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *MultiSegmentWriter)</span></span> Write(r storage.Record) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 检查是否需要轮转到新 segment</span></span><br><span class="line">    <span class="keyword">if</span> w.writer == <span class="literal">nil</span> || w.writer.GetWrittenUncompressed() &gt;= <span class="type">uint64</span>(w.segmentSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> err := w.rotateWriter(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用底层 writer 写入 Record</span></span><br><span class="line">    <span class="keyword">return</span> w.writer.Write(r)  <span class="comment">// ★ Record 包含所有字段（含 timestamp）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *MultiSegmentWriter)</span></span> rotateWriter() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭当前 writer</span></span><br><span class="line">    <span class="keyword">if</span> err := w.closeWriter(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分配新的 segment ID</span></span><br><span class="line">    newSegmentID, err := w.allocator.allocSegmentID()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    w.currentSegmentID = newSegmentID</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的 BinlogRecordWriter</span></span><br><span class="line">    rw, err := storage.NewBinlogRecordWriter(w.ctx, w.collectionID, </span><br><span class="line">        w.partitionID, newSegmentID, w.schema, w.allocator.logIDAlloc, </span><br><span class="line">        chunkSize, w.maxRows, w.rwOption...)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包装为 BinlogValueWriter</span></span><br><span class="line">    w.writer = storage.NewBinlogValueWriter(rw, w.batchSize)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2-4-底层-Record-Writer"><a href="#4-2-4-底层-Record-Writer" class="headerlink" title="4.2.4 底层 Record Writer"></a>4.2.4 底层 Record Writer</h4><p><strong>文件</strong>: <code>internal/storage/binlog_record_writer.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pw *PackedBinlogRecordWriter)</span></span> Write(r Record) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := pw.initWriters(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 提取 timestamp 范围</span></span><br><span class="line">    tsArray := r.Column(common.TimeStampField).(*array.Int64)</span><br><span class="line">    rows := r.Len()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        ts := typeutil.Timestamp(tsArray.Value(i))</span><br><span class="line">        <span class="keyword">if</span> ts &lt; pw.tsFrom &#123;</span><br><span class="line">            pw.tsFrom = ts</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ts &gt; pw.tsTo &#123;</span><br><span class="line">            pw.tsTo = ts</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 收集统计信息</span></span><br><span class="line">    <span class="keyword">if</span> err := pw.pkCollector.Collect(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := pw.bm25Collector.Collect(r); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 写入数据（包含所有字段）</span></span><br><span class="line">    err := pw.writer.Write(r)  <span class="comment">// ★ 完整的 Arrow Record</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    pw.writtenUncompressed = pw.writer.GetWrittenUncompressed()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="5-Storage-层的-Timestamp-处理"><a href="#5-Storage-层的-Timestamp-处理" class="headerlink" title="5. Storage 层的 Timestamp 处理"></a>5. Storage 层的 Timestamp 处理</h2><h3 id="5-1-Growing-Segment-中的-Timestamp"><a href="#5-1-Growing-Segment-中的-Timestamp" class="headerlink" title="5.1 Growing Segment 中的 Timestamp"></a>5.1 Growing Segment 中的 Timestamp</h3><p><strong>文件</strong>: <code>internal/core/src/segcore/SegmentGrowingImpl.cpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SegmentGrowingImpl::load_field_data_common</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    FieldId field_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> reserved_offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">const</span> std::vector&lt;FieldDataPtr&gt;&amp; field_data,</span></span></span><br><span class="line"><span class="params"><span class="function">    FieldId primary_field_id,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> num_rows)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 特殊处理 timestamp 字段</span></span><br><span class="line">    <span class="keyword">if</span> (field_id == TimestampFieldID) &#123;</span><br><span class="line">        <span class="comment">// query node already guarantees that the timestamp is ordered</span></span><br><span class="line">        <span class="comment">// fill into Segment.ConcurrentVector</span></span><br><span class="line">        insert_record_.timestamps_.<span class="built_in">set_data_raw</span>(reserved_offset, field_data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理其他字段...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-Segment-Writer-中的-Timestamp-追踪"><a href="#5-2-Segment-Writer-中的-Timestamp-追踪" class="headerlink" title="5.2 Segment Writer 中的 Timestamp 追踪"></a>5.2 Segment Writer 中的 Timestamp 追踪</h3><p><strong>文件</strong>: <code>internal/datanode/compactor/segment_writer.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *SegmentWriter)</span></span> WriteRecord(r storage.Record) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 提取 timestamp 并更新范围</span></span><br><span class="line">    tsArray := r.Column(common.TimeStampField).(*array.Int64)</span><br><span class="line">    rows := r.Len()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        ts := typeutil.Timestamp(tsArray.Value(i))</span><br><span class="line">        <span class="keyword">if</span> ts &lt; w.tsFrom &#123;</span><br><span class="line">            w.tsFrom = ts</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ts &gt; w.tsTo &#123;</span><br><span class="line">            w.tsTo = ts</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 更新 PK 统计信息</span></span><br><span class="line">        <span class="keyword">switch</span> schemapb.DataType(w.pkstats.PkType) &#123;</span><br><span class="line">        <span class="keyword">case</span> schemapb.DataType_Int64:</span><br><span class="line">            pkArray := r.Column(w.GetPkID()).(*array.Int64)</span><br><span class="line">            pk := &amp;storage.Int64PrimaryKey&#123;Value: pkArray.Value(i)&#125;</span><br><span class="line">            w.pkstats.Update(pk)</span><br><span class="line">        <span class="keyword">case</span> schemapb.DataType_VarChar:</span><br><span class="line">            pkArray := r.Column(w.GetPkID()).(*array.String)</span><br><span class="line">            pk := &amp;storage.VarCharPrimaryKey&#123;Value: pkArray.Value(i)&#125;</span><br><span class="line">            w.pkstats.Update(pk)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        w.rowCount.Inc()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 写入完整的 Record（包含 timestamp）</span></span><br><span class="line">    <span class="keyword">return</span> w.writer.Write(r)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(w *SegmentWriter)</span></span> GetTimeRange() *writebuffer.TimeRange &#123;</span><br><span class="line">    <span class="keyword">return</span> writebuffer.NewTimeRange(w.tsFrom, w.tsTo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="6-两种存储版本对比"><a href="#6-两种存储版本对比" class="headerlink" title="6. 两种存储版本对比"></a>6. 两种存储版本对比</h2><h3 id="6-1-StorageV1-Binlog-格式"><a href="#6-1-StorageV1-Binlog-格式" class="headerlink" title="6.1 StorageV1 (Binlog 格式)"></a>6.1 StorageV1 (Binlog 格式)</h3><p><strong>特点</strong>：</p>
<ul>
<li>每个字段一个独立的 binlog 文件</li>
<li>Timestamp 字段对应文件：<code>&#123;segmentID&#125;/insert_log/1/&#123;logID&#125;</code></li>
<li>使用 <code>InsertCodec</code> 序列化</li>
<li>Protobuf 格式存储</li>
</ul>
<p><strong>文件结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;collectionID&#125;/&#123;partitionID&#125;/&#123;segmentID&#125;/</span><br><span class="line">├── insert_log/</span><br><span class="line">│   ├── 0/          # RowID field</span><br><span class="line">│   │   └── &#123;logID&#125;</span><br><span class="line">│   ├── 1/          # Timestamp field ★</span><br><span class="line">│   │   └── &#123;logID&#125;</span><br><span class="line">│   ├── 100/        # User field 1</span><br><span class="line">│   │   └── &#123;logID&#125;</span><br><span class="line">│   └── 101/        # User field 2</span><br><span class="line">│       └── &#123;logID&#125;</span><br><span class="line">├── delta_log/</span><br><span class="line">│   └── &#123;logID&#125;</span><br><span class="line">└── stats_log/</span><br><span class="line">    └── &#123;logID&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码路径</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BulkPackWriter.Write()</span><br><span class="line">  └─&gt; storageV1Serializer.serializeBinlog()</span><br><span class="line">      └─&gt; InsertCodec.Serialize()</span><br><span class="line">          └─&gt; 为每个 field 创建 binlog</span><br></pre></td></tr></table></figure>

<h3 id="6-2-StorageV2-Parquet-格式"><a href="#6-2-StorageV2-Parquet-格式" class="headerlink" title="6.2 StorageV2 (Parquet 格式)"></a>6.2 StorageV2 (Parquet 格式)</h3><p><strong>特点</strong>：</p>
<ul>
<li>列式存储，使用 Apache Arrow + Parquet</li>
<li>Timestamp 作为 Arrow Record 的一列</li>
<li>支持列组（Column Group）优化</li>
<li>更高的压缩率和查询性能</li>
</ul>
<p><strong>文件结构</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;collectionID&#125;/&#123;partitionID&#125;/&#123;segmentID&#125;/</span><br><span class="line">├── insert_log/</span><br><span class="line">│   ├── &#123;columnGroupID&#125;/</span><br><span class="line">│   │   └── &#123;logID&#125;.parquet  # 包含多个字段（含 timestamp）</span><br><span class="line">│   └── manifest.json         # 元数据清单</span><br><span class="line">├── delta_log/</span><br><span class="line">│   └── &#123;logID&#125;</span><br><span class="line">└── stats_log/</span><br><span class="line">    └── &#123;logID&#125;</span><br></pre></td></tr></table></figure>

<p><strong>代码路径</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BulkPackWriterV2.Write()</span><br><span class="line">  └─&gt; serializeBinlog() -&gt; Arrow Record</span><br><span class="line">      └─&gt; PackedRecordWriter.Write()</span><br><span class="line">          └─&gt; Parquet Writer (通过 FFI 调用 C++)</span><br></pre></td></tr></table></figure>

<h3 id="6-3-对比表"><a href="#6-3-对比表" class="headerlink" title="6.3 对比表"></a>6.3 对比表</h3><table>
<thead>
<tr>
<th>特性</th>
<th>StorageV1 (Binlog)</th>
<th>StorageV2 (Parquet)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>文件格式</strong></td>
<td>Protobuf + 自定义编码</td>
<td>Apache Parquet</td>
</tr>
<tr>
<td><strong>Timestamp 存储</strong></td>
<td>独立 binlog 文件（FieldID&#x3D;1）</td>
<td>Arrow Record 的一列</td>
</tr>
<tr>
<td><strong>文件数量</strong></td>
<td>多个（每个 field 一个）</td>
<td>少量（按列组组织）</td>
</tr>
<tr>
<td><strong>压缩率</strong></td>
<td>中等</td>
<td>高</td>
</tr>
<tr>
<td><strong>查询性能</strong></td>
<td>需要读取多个文件</td>
<td>列式访问更高效</td>
</tr>
<tr>
<td><strong>元数据</strong></td>
<td>每个 binlog 独立元数据</td>
<td>统一 manifest 管理</td>
</tr>
<tr>
<td><strong>序列化类</strong></td>
<td><code>InsertCodec</code></td>
<td>Arrow Builder</td>
</tr>
<tr>
<td><strong>写入类</strong></td>
<td><code>BulkPackWriter</code></td>
<td><code>BulkPackWriterV2</code></td>
</tr>
</tbody></table>
<hr>
<h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><h3 id="7-1-核心要点"><a href="#7-1-核心要点" class="headerlink" title="7.1 核心要点"></a>7.1 核心要点</h3><ol>
<li><p><strong>Timestamp 完整存储</strong></p>
<ul>
<li>Timestamp 作为 FieldID&#x3D;1 的系统字段，在所有写入路径中都会完整持久化</li>
<li>无论是 Flush 还是 Compaction，都会保留完整的 timestamp 信息</li>
</ul>
</li>
<li><p><strong>两种主要写入路径</strong></p>
<ul>
<li><strong>Flush</strong>：正常数据写入的主流程，从 WriteBuffer 触发</li>
<li><strong>Compaction</strong>：Segment 合并优化流程，读取旧数据重新写入</li>
</ul>
</li>
<li><p><strong>存储格式演进</strong></p>
<ul>
<li><strong>StorageV1</strong>：每个字段独立 binlog 文件</li>
<li><strong>StorageV2</strong>：列式 Parquet 格式，更高效</li>
</ul>
</li>
<li><p><strong>Timestamp 的多重用途</strong></p>
<ul>
<li>MVCC 版本控制和可见性判断</li>
<li>TTL 过期数据清理</li>
<li>查询优化（通过 timestamp 范围过滤）</li>
<li>Binlog 元数据（TimestampFrom&#x2F;TimestampTo）</li>
</ul>
</li>
</ol>
<h3 id="7-2-数据流向图"><a href="#7-2-数据流向图" class="headerlink" title="7.2 数据流向图"></a>7.2 数据流向图</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">用户数据 Insert/Delete</span><br><span class="line">    ↓</span><br><span class="line">[内存] WriteBuffer</span><br><span class="line">    ↓ (Buffer Full / Time Trigger)</span><br><span class="line">[Flush] SyncTask</span><br><span class="line">    ↓</span><br><span class="line">[序列化] InsertCodec / Arrow Builder</span><br><span class="line">    ↓</span><br><span class="line">[持久化] Binlog / Parquet 文件</span><br><span class="line">    ↓ (多个小 Segment)</span><br><span class="line">[Compaction] Mix/Clustering/L0 Compactor</span><br><span class="line">    ↓</span><br><span class="line">[合并] MultiSegmentWriter</span><br><span class="line">    ↓</span><br><span class="line">[持久化] 新的 Segment 文件</span><br></pre></td></tr></table></figure>

<h3 id="7-3-相关文件索引"><a href="#7-3-相关文件索引" class="headerlink" title="7.3 相关文件索引"></a>7.3 相关文件索引</h3><p><strong>Flush 流程</strong>：</p>
<ul>
<li><code>internal/flushcommon/writebuffer/write_buffer.go</code> - WriteBuffer 管理</li>
<li><code>internal/flushcommon/syncmgr/task.go</code> - SyncTask 执行</li>
<li><code>internal/flushcommon/syncmgr/pack_writer.go</code> - StorageV1 写入</li>
<li><code>internal/flushcommon/syncmgr/pack_writer_v2.go</code> - StorageV2 写入</li>
<li><code>internal/flushcommon/syncmgr/storage_serializer.go</code> - 序列化器</li>
</ul>
<p><strong>Compaction 流程</strong>：</p>
<ul>
<li><code>internal/datanode/compactor/mix_compactor.go</code> - Mix Compaction</li>
<li><code>internal/datanode/compactor/segment_writer.go</code> - Segment Writer</li>
<li><code>internal/datanode/compactor/clustering_compactor.go</code> - Clustering Compaction</li>
</ul>
<p><strong>Storage 层</strong>：</p>
<ul>
<li><code>internal/storage/data_codec.go</code> - InsertCodec 序列化</li>
<li><code>internal/storage/binlog_record_writer.go</code> - Binlog 写入</li>
<li><code>internal/storage/record_writer.go</code> - Parquet 写入</li>
<li><code>internal/storage/serde_events.go</code> - 事件序列化</li>
</ul>
<p><strong>C++ 核心</strong>：</p>
<ul>
<li><code>internal/core/src/segcore/SegmentGrowingImpl.cpp</code> - Growing Segment</li>
<li><code>internal/core/src/segcore/ChunkedSegmentSealedImpl.cpp</code> - Sealed Segment</li>
</ul>
<h3 id="7-4-扩展阅读"><a href="#7-4-扩展阅读" class="headerlink" title="7.4 扩展阅读"></a>7.4 扩展阅读</h3><p>相关设计文档：</p>
<ul>
<li><code>docs/developer_guides/flush_pipeline_write_buffer_manager.md</code></li>
<li><code>docs/developer_guides/flush_pipeline_flush_checkpoint.md</code></li>
<li><code>docs/design_docs/segcore/segment_sealed.md</code></li>
</ul>
<hr>
<h2 id="附录：术语表"><a href="#附录：术语表" class="headerlink" title="附录：术语表"></a>附录：术语表</h2><table>
<thead>
<tr>
<th>术语</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>MVCC</strong></td>
<td>Multi-Version Concurrency Control，多版本并发控制</td>
</tr>
<tr>
<td><strong>Timestamp</strong></td>
<td>系统预留字段（FieldID&#x3D;1），用于 MVCC 版本控制</td>
</tr>
<tr>
<td><strong>Flush</strong></td>
<td>将内存中的数据持久化到存储的过程</td>
</tr>
<tr>
<td><strong>Compaction</strong></td>
<td>Segment 合并优化，将多个小 Segment 合并为大 Segment</td>
</tr>
<tr>
<td><strong>WriteBuffer</strong></td>
<td>数据写入的内存缓冲区</td>
</tr>
<tr>
<td><strong>SyncTask</strong></td>
<td>数据同步任务，负责将 buffer 数据持久化</td>
</tr>
<tr>
<td><strong>Binlog</strong></td>
<td>Binary Log，二进制日志，Milvus 的数据文件格式之一</td>
</tr>
<tr>
<td><strong>Parquet</strong></td>
<td>Apache Parquet，列式存储格式，StorageV2 使用</td>
</tr>
<tr>
<td><strong>Arrow Record</strong></td>
<td>Apache Arrow 的数据记录格式，内存中的列式数据表示</td>
</tr>
<tr>
<td><strong>Growing Segment</strong></td>
<td>增长中的 Segment，正在接收写入</td>
</tr>
<tr>
<td><strong>Sealed Segment</strong></td>
<td>已封存的 Segment，不再接收新数据</td>
</tr>
<tr>
<td><strong>InsertCodec</strong></td>
<td>Insert 数据的编解码器，用于 StorageV1</td>
</tr>
<tr>
<td><strong>TTL</strong></td>
<td>Time To Live，数据存活时间</td>
</tr>
</tbody></table>
<hr>
<p><strong>文档版本</strong>: v1.1<br><strong>最后更新</strong>: 2025-01-24<br><strong>适用 Milvus 版本</strong>: 2.5.x</p>
<hr>
<h1 id="附录-A：Segment-内部-Layout"><a href="#附录-A：Segment-内部-Layout" class="headerlink" title="附录 A：Segment 内部 Layout"></a>附录 A：Segment 内部 Layout</h1><h2 id="A-1-Segment-类型概述"><a href="#A-1-Segment-类型概述" class="headerlink" title="A.1 Segment 类型概述"></a>A.1 Segment 类型概述</h2><p>Milvus 中有两种主要的 Segment 类型：</p>
<h3 id="Growing-Segment-增长中的-Segment"><a href="#Growing-Segment-增长中的-Segment" class="headerlink" title="Growing Segment (增长中的 Segment)"></a>Growing Segment (增长中的 Segment)</h3><ul>
<li><strong>状态</strong>: <code>SegmentState_Growing</code></li>
<li><strong>特点</strong>: 正在接收写入操作</li>
<li><strong>实现类</strong>: <code>SegmentGrowingImpl</code></li>
<li><strong>数据结构</strong>: 使用 <code>ConcurrentVector</code> 存储，支持并发写入</li>
<li><strong>索引</strong>: 可选的 interim index（临时索引）</li>
</ul>
<h3 id="Sealed-Segment-封存的-Segment"><a href="#Sealed-Segment-封存的-Segment" class="headerlink" title="Sealed Segment (封存的 Segment)"></a>Sealed Segment (封存的 Segment)</h3><ul>
<li><strong>状态</strong>: <code>SegmentState_Sealed</code> &#x2F; <code>SegmentState_Flushing</code> &#x2F; <code>SegmentState_Flushed</code></li>
<li><strong>特点</strong>: 不再接收写入，数据已持久化</li>
<li><strong>实现类</strong>: <code>ChunkedSegmentSealedImpl</code></li>
<li><strong>数据结构</strong>: 使用 <code>ChunkedColumnInterface</code> 存储，支持 mmap 和延迟加载</li>
<li><strong>索引</strong>: 可以加载永久索引</li>
</ul>
<hr>
<h2 id="A-2-Growing-Segment-内部结构"><a href="#A-2-Growing-Segment-内部结构" class="headerlink" title="A.2 Growing Segment 内部结构"></a>A.2 Growing Segment 内部结构</h2><h3 id="A-2-1-核心组件"><a href="#A-2-1-核心组件" class="headerlink" title="A.2.1 核心组件"></a>A.2.1 核心组件</h3><p><strong>文件</strong>: <code>internal/core/src/segcore/SegmentGrowingImpl.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SegmentGrowingImpl</span> : <span class="keyword">public</span> SegmentGrowing &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 1. Schema 和元数据</span></span><br><span class="line">    SchemaPtr schema_;                    <span class="comment">// Collection schema</span></span><br><span class="line">    IndexMetaPtr index_meta_;             <span class="comment">// Index metadata</span></span><br><span class="line">    SegcoreConfig segcore_config_;        <span class="comment">// Segment 配置</span></span><br><span class="line">    <span class="type">int64_t</span> id_;                          <span class="comment">// Segment ID</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 插入数据记录 ★ 核心数据结构</span></span><br><span class="line">    InsertRecord&lt;<span class="literal">false</span>&gt; insert_record_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 索引记录 (Growing Index)</span></span><br><span class="line">    IndexingRecord indexing_record_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 删除记录</span></span><br><span class="line">    DeletedRecord&lt;<span class="literal">false</span>&gt; deleted_record_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 统计信息</span></span><br><span class="line">    SegmentStats stats_&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 并发控制</span></span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex chunk_mutex_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. mmap 管理</span></span><br><span class="line">    storage::MmapChunkDescriptorPtr mmap_descriptor_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="A-2-2-InsertRecord-数据布局"><a href="#A-2-2-InsertRecord-数据布局" class="headerlink" title="A.2.2 InsertRecord 数据布局"></a>A.2.2 InsertRecord 数据布局</h3><p><strong>文件</strong>: <code>internal/core/src/segcore/InsertRecord.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InsertRecordGrowing</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ★ Timestamp 列 (系统字段)</span></span><br><span class="line">    ConcurrentVector&lt;Timestamp&gt; timestamps_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ★ Timestamp 索引（用于时间旅行查询）</span></span><br><span class="line">    TimestampIndex timestamp_index_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ★ PK 到 Offset 的映射（用于快速查找）</span></span><br><span class="line">    std::unique_ptr&lt;OffsetMap&gt; pk2offset_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ★ 预分配的空间</span></span><br><span class="line">    std::atomic&lt;<span class="type">int64_t</span>&gt; reserved = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ★ 响应器（用于并发控制）</span></span><br><span class="line">    AckResponder ack_responder_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ★ 字段数据存储 (map[FieldID] -&gt; Vector)</span></span><br><span class="line">    std::unordered_map&lt;FieldId, std::unique_ptr&lt;VectorBase&gt;&gt; data_&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ★ Nullable 字段的 valid 数据</span></span><br><span class="line">    std::unordered_map&lt;FieldId, ThreadSafeValidDataPtr&gt; valid_data_&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 并发保护</span></span><br><span class="line">    <span class="keyword">mutable</span> std::shared_mutex shared_mutex_&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="A-2-3-数据组织方式"><a href="#A-2-3-数据组织方式" class="headerlink" title="A.2.3 数据组织方式"></a>A.2.3 数据组织方式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Growing Segment Memory Layout:</span><br><span class="line">┌─────────────────────────────────────────────────┐</span><br><span class="line">│  SegmentGrowingImpl                              │</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  insert_record_ (InsertRecordGrowing)           │</span><br><span class="line">│  ├─ timestamps_: ConcurrentVector&lt;Timestamp&gt;    │  ★ Timestamp 列</span><br><span class="line">│  ├─ timestamp_index_: TimestampIndex           │  ★ Timestamp 索引</span><br><span class="line">│  ├─ pk2offset_: OffsetMap                       │  ★ PK 索引</span><br><span class="line">│  └─ data_: map&lt;FieldId, VectorBase&gt;            │  ★ 字段数据</span><br><span class="line">│      ├─ FieldID=100: ConcurrentVector&lt;int64&gt;   │     (用户字段1)</span><br><span class="line">│      ├─ FieldID=101: ConcurrentVector&lt;float&gt;   │     (用户字段2)</span><br><span class="line">│      ├─ FieldID=102: ConcurrentVector&lt;vector&gt;  │     (向量字段)</span><br><span class="line">│      └─ ...                                     │</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  indexing_record_ (IndexingRecord)              │</span><br><span class="line">│  ├─ Chunk-level indexes                        │  ★ 分块索引</span><br><span class="line">│  └─ Interim vector indexes                     │  ★ 临时向量索引</span><br><span class="line">├─────────────────────────────────────────────────┤</span><br><span class="line">│  deleted_record_ (DeletedRecord)                │</span><br><span class="line">│  └─ Deleted PKs with timestamps                │  ★ 删除记录</span><br><span class="line">└─────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="A-2-4-Chunk-机制"><a href="#A-2-4-Chunk-机制" class="headerlink" title="A.2.4 Chunk 机制"></a>A.2.4 Chunk 机制</h3><p>Growing Segment 使用 <strong>Chunk</strong> 机制组织数据：</p>
<ul>
<li><strong>Chunk Size</strong>: 默认 32768 行（可配置）</li>
<li><strong>目的</strong>: 支持大规模数据的高效存储和查询</li>
<li><strong>索引</strong>: 每个 chunk 可以独立建立索引</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码示例</span></span><br><span class="line"><span class="type">int64_t</span> chunk_rows = segcore_config_.<span class="built_in">get_chunk_rows</span>();  <span class="comment">// 默认 32768</span></span><br><span class="line"><span class="keyword">auto</span> chunk_id = offset / chunk_rows;</span><br><span class="line"><span class="keyword">auto</span> offset_in_chunk = offset % chunk_rows;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="A-3-Sealed-Segment-内部结构"><a href="#A-3-Sealed-Segment-内部结构" class="headerlink" title="A.3 Sealed Segment 内部结构"></a>A.3 Sealed Segment 内部结构</h2><h3 id="A-3-1-核心组件"><a href="#A-3-1-核心组件" class="headerlink" title="A.3.1 核心组件"></a>A.3.1 核心组件</h3><p><strong>文件</strong>: <code>internal/core/src/segcore/ChunkedSegmentSealedImpl.h</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChunkedSegmentSealedImpl</span> : <span class="keyword">public</span> SegmentSealed &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 1. Schema 和元数据</span></span><br><span class="line">    SchemaPtr schema_;</span><br><span class="line">    IndexMetaPtr col_index_meta_;</span><br><span class="line">    <span class="type">int64_t</span> id_;</span><br><span class="line">    SegcoreConfig segcore_config_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 行数</span></span><br><span class="line">    std::optional&lt;<span class="type">int64_t</span>&gt; num_rows_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 加载状态</span></span><br><span class="line">    BitsetType field_data_ready_bitset_;     <span class="comment">// 字段数据是否已加载</span></span><br><span class="line">    BitsetType index_ready_bitset_;          <span class="comment">// 索引是否已加载</span></span><br><span class="line">    BitsetType binlog_index_bitset_;         <span class="comment">// Binlog 索引标记</span></span><br><span class="line">    std::atomic&lt;<span class="type">int</span>&gt; system_ready_count_;    <span class="comment">// 系统字段计数器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. ★ 字段数据存储（列式存储）</span></span><br><span class="line">    folly::Synchronized&lt;std::unordered_map&lt;</span><br><span class="line">        FieldId, </span><br><span class="line">        std::shared_ptr&lt;ChunkedColumnInterface&gt;</span><br><span class="line">    &gt;&gt; fields_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. ★ 索引存储</span></span><br><span class="line">    <span class="comment">// 5.1 Scalar 索引</span></span><br><span class="line">    folly::Synchronized&lt;std::unordered_map&lt;</span><br><span class="line">        FieldId, </span><br><span class="line">        index::CacheIndexBasePtr</span><br><span class="line">    &gt;&gt; scalar_indexings_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.2 Vector 索引</span></span><br><span class="line">    SealedIndexingRecord vector_indexings_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5.3 N-gram 索引（用于文本）</span></span><br><span class="line">    folly::Synchronized&lt;std::unordered_map&lt;</span><br><span class="line">        FieldId,</span><br><span class="line">        std::unordered_map&lt;std::string, index::CacheIndexBasePtr&gt;</span><br><span class="line">    &gt;&gt; ngram_indexings_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. ★ InsertRecord (仅包含系统字段和 PK)</span></span><br><span class="line">    InsertRecord&lt;<span class="literal">true</span>&gt; insert_record_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 7. 删除记录</span></span><br><span class="line">    DeletedRecord&lt;<span class="literal">true</span>&gt; deleted_record_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 8. Mmap 字段</span></span><br><span class="line">    std::unordered_set&lt;FieldId&gt; mmap_field_ids_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 9. 统计信息</span></span><br><span class="line">    SegmentStats stats_&#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 10. PK 排序标记</span></span><br><span class="line">    <span class="type">bool</span> is_sorted_by_pk_ = <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 11. Storage V2 Reader</span></span><br><span class="line">    std::unique_ptr&lt;milvus_storage::api::Reader&gt; reader_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="A-3-2-数据布局"><a href="#A-3-2-数据布局" class="headerlink" title="A.3.2 数据布局"></a>A.3.2 数据布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">Sealed Segment Memory Layout:</span><br><span class="line">┌────────────────────────────────────────────────┐</span><br><span class="line">│  ChunkedSegmentSealedImpl                      │</span><br><span class="line">├────────────────────────────────────────────────┤</span><br><span class="line">│  insert_record_ (InsertRecordSealed)           │</span><br><span class="line">│  ├─ timestamps_: ConcurrentVector&lt;Timestamp&gt;   │  ★ 仅系统字段</span><br><span class="line">│  ├─ timestamp_index_: TimestampIndex          │</span><br><span class="line">│  └─ pk2offset_: OffsetOrderedArray            │  ★ PK 索引（已排序）</span><br><span class="line">├────────────────────────────────────────────────┤</span><br><span class="line">│  fields_: map&lt;FieldId, ChunkedColumnInterface&gt;│  ★ 列数据</span><br><span class="line">│  ├─ FieldID=100: ChunkedColumn&lt;int64&gt;         │     (Scalar 字段)</span><br><span class="line">│  │   ├─ Chunk 0: [data...]                    │</span><br><span class="line">│  │   ├─ Chunk 1: [data...]                    │</span><br><span class="line">│  │   └─ ...                                    │</span><br><span class="line">│  ├─ FieldID=102: ChunkedColumn&lt;vector&gt;        │     (向量字段)</span><br><span class="line">│  │   └─ 可能被索引替代                          │</span><br><span class="line">│  └─ ...                                        │</span><br><span class="line">├────────────────────────────────────────────────┤</span><br><span class="line">│  scalar_indexings_: map&lt;FieldId, Index&gt;       │  ★ Scalar 索引</span><br><span class="line">│  └─ FieldID=100: ScalarIndex                  │</span><br><span class="line">├────────────────────────────────────────────────┤</span><br><span class="line">│  vector_indexings_: SealedIndexingRecord       │  ★ Vector 索引</span><br><span class="line">│  ├─ FieldID=102: VectorIndex (HNSW/IVF/...)  │</span><br><span class="line">│  └─ index_has_raw_data_: bool                 │     (是否保留原始数据)</span><br><span class="line">├────────────────────────────────────────────────┤</span><br><span class="line">│  deleted_record_: DeletedRecord                │  ★ 删除记录</span><br><span class="line">└────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="A-3-3-ChunkedColumn-结构"><a href="#A-3-3-ChunkedColumn-结构" class="headerlink" title="A.3.3 ChunkedColumn 结构"></a>A.3.3 ChunkedColumn 结构</h3><p>Sealed Segment 使用分块列存储：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChunkedColumnInterface</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">num_chunks</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">size_t</span> <span class="title">chunk_size</span><span class="params">(<span class="type">size_t</span> chunk_id)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> SpanBase <span class="title">chunk_data</span><span class="params">(<span class="type">size_t</span> chunk_id)</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 支持 mmap</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">is_mmaped</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="keyword">auto</span> column = fields_[field_id];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> chunk_id = <span class="number">0</span>; chunk_id &lt; column-&gt;<span class="built_in">num_chunks</span>(); ++chunk_id) &#123;</span><br><span class="line">    <span class="keyword">auto</span> data = column-&gt;<span class="built_in">chunk_data</span>(chunk_id);</span><br><span class="line">    <span class="comment">// 处理 chunk 数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="A-4-文件系统中的-Layout"><a href="#A-4-文件系统中的-Layout" class="headerlink" title="A.4 文件系统中的 Layout"></a>A.4 文件系统中的 Layout</h2><h3 id="A-4-1-StorageV1-Binlog-布局"><a href="#A-4-1-StorageV1-Binlog-布局" class="headerlink" title="A.4.1 StorageV1 (Binlog) 布局"></a>A.4.1 StorageV1 (Binlog) 布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;root_path&#125;/&#123;collectionID&#125;/&#123;partitionID&#125;/&#123;segmentID&#125;/</span><br><span class="line">├── insert_log/              # 插入数据</span><br><span class="line">│   ├── 0/                   # RowID field</span><br><span class="line">│   │   └── &#123;logID&#125;          # Binlog 文件</span><br><span class="line">│   ├── 1/                   # ★ Timestamp field</span><br><span class="line">│   │   └── &#123;logID&#125;</span><br><span class="line">│   ├── 100/                 # User field 1</span><br><span class="line">│   │   └── &#123;logID&#125;</span><br><span class="line">│   ├── 101/                 # User field 2</span><br><span class="line">│   │   └── &#123;logID&#125;</span><br><span class="line">│   └── 102/                 # Vector field</span><br><span class="line">│       └── &#123;logID&#125;</span><br><span class="line">│</span><br><span class="line">├── delta_log/               # 删除数据</span><br><span class="line">│   └── &#123;logID&#125;</span><br><span class="line">│</span><br><span class="line">├── stats_log/               # 统计数据（PK stats）</span><br><span class="line">│   └── &#123;logID&#125;</span><br><span class="line">│</span><br><span class="line">└── index/                   # 索引文件</span><br><span class="line">    └── &#123;fieldID&#125;/</span><br><span class="line">        ├── &#123;indexBuildID&#125;/</span><br><span class="line">        │   ├── index_params</span><br><span class="line">        │   ├── index_info</span><br><span class="line">        │   └── index_data_*</span><br><span class="line">        └── ...</span><br></pre></td></tr></table></figure>

<h3 id="A-4-2-StorageV2-Parquet-布局"><a href="#A-4-2-StorageV2-Parquet-布局" class="headerlink" title="A.4.2 StorageV2 (Parquet) 布局"></a>A.4.2 StorageV2 (Parquet) 布局</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;root_path&#125;/&#123;collectionID&#125;/&#123;partitionID&#125;/&#123;segmentID&#125;/</span><br><span class="line">├── insert_log/</span><br><span class="line">│   ├── &#123;columnGroupID&#125;/</span><br><span class="line">│   │   └── &#123;logID&#125;.parquet    # Parquet 文件（包含多个字段）</span><br><span class="line">│   │                           # ★ Timestamp 作为其中一列</span><br><span class="line">│   ├── manifest.json           # 元数据清单</span><br><span class="line">│   │   ├── schema</span><br><span class="line">│   │   ├── column_groups</span><br><span class="line">│   │   │   ├─ group_id: 1</span><br><span class="line">│   │   │   │  └─ fields: [0, 1, 100]  # RowID, Timestamp, Field1</span><br><span class="line">│   │   │   └─ group_id: 2</span><br><span class="line">│   │   │      └─ fields: [101, 102]   # Field2, VectorField</span><br><span class="line">│   │   └── files</span><br><span class="line">│   └── ...</span><br><span class="line">│</span><br><span class="line">├── delta_log/</span><br><span class="line">│   └── &#123;logID&#125;</span><br><span class="line">│</span><br><span class="line">├── stats_log/</span><br><span class="line">│   └── &#123;logID&#125;</span><br><span class="line">│</span><br><span class="line">└── index/</span><br><span class="line">    └── ... (同 V1)</span><br></pre></td></tr></table></figure>

<h3 id="A-4-3-Binlog-文件内部结构"><a href="#A-4-3-Binlog-文件内部结构" class="headerlink" title="A.4.3 Binlog 文件内部结构"></a>A.4.3 Binlog 文件内部结构</h3><p>每个 binlog 文件包含：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Binlog File Structure:</span><br><span class="line">┌─────────────────────────────┐</span><br><span class="line">│  Magic Number               │  4 bytes</span><br><span class="line">├─────────────────────────────┤</span><br><span class="line">│  Descriptor Event           │</span><br><span class="line">│  ├─ CollectionID            │</span><br><span class="line">│  ├─ PartitionID             │</span><br><span class="line">│  ├─ SegmentID               │</span><br><span class="line">│  ├─ FieldID                 │</span><br><span class="line">│  ├─ StartTimestamp          │  ★ Min timestamp</span><br><span class="line">│  ├─ EndTimestamp            │  ★ Max timestamp</span><br><span class="line">│  └─ PayloadDataType         │</span><br><span class="line">├─────────────────────────────┤</span><br><span class="line">│  Insert Event 1             │</span><br><span class="line">│  ├─ StartTimestamp          │</span><br><span class="line">│  ├─ EndTimestamp            │</span><br><span class="line">│  └─ Payload (field data)    │  ★ 实际字段数据</span><br><span class="line">├─────────────────────────────┤</span><br><span class="line">│  Insert Event 2             │</span><br><span class="line">│  └─ ...                     │</span><br><span class="line">├─────────────────────────────┤</span><br><span class="line">│  ...                        │</span><br><span class="line">└─────────────────────────────┘</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="A-5-查询时的数据访问"><a href="#A-5-查询时的数据访问" class="headerlink" title="A.5 查询时的数据访问"></a>A.5 查询时的数据访问</h2><h3 id="A-5-1-访问路径"><a href="#A-5-1-访问路径" class="headerlink" title="A.5.1 访问路径"></a>A.5.1 访问路径</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Query Request</span><br><span class="line">    ↓</span><br><span class="line">Plan Node</span><br><span class="line">    ↓</span><br><span class="line">Segment Interface</span><br><span class="line">    ↓</span><br><span class="line">    ├─ [Growing Segment]</span><br><span class="line">    │   └─&gt; InsertRecord.data_[fieldID]</span><br><span class="line">    │       └─&gt; ConcurrentVector::get(offset)</span><br><span class="line">    │</span><br><span class="line">    └─ [Sealed Segment]</span><br><span class="line">        ├─&gt; [Has Index?]</span><br><span class="line">        │   ├─ Yes → vector_indexings_[fieldID]</span><br><span class="line">        │   │         └─&gt; Index Search</span><br><span class="line">        │   └─ No  → fields_[fieldID]</span><br><span class="line">        │             └─&gt; ChunkedColumn::chunk_data(chunk_id)</span><br><span class="line">        │</span><br><span class="line">        └─&gt; [Filter by Timestamp]</span><br><span class="line">            └─&gt; insert_record_.timestamps_</span><br><span class="line">                └─&gt; TimestampIndex (Binary Search)</span><br></pre></td></tr></table></figure>

<h3 id="A-5-2-Timestamp-过滤示例"><a href="#A-5-2-Timestamp-过滤示例" class="headerlink" title="A.5.2 Timestamp 过滤示例"></a>A.5.2 Timestamp 过滤示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件: internal/core/src/segcore/SegmentGrowingImpl.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SegmentGrowingImpl::mask_with_timestamps</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    BitsetTypeView&amp; bitset_chunk,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp timestamp,</span></span></span><br><span class="line"><span class="params"><span class="function">    Timestamp ttl)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> timestamps_data_ptr = insert_record_.timestamps_.<span class="built_in">data</span>();</span><br><span class="line">    <span class="keyword">auto</span> size = insert_record_.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 timestamp 过滤数据</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int64_t</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">auto</span> ts = timestamps_data_ptr[i];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 过滤未来的数据（ts &gt; query_timestamp）</span></span><br><span class="line">        <span class="keyword">if</span> (ts &gt; timestamp) &#123;</span><br><span class="line">            bitset_chunk[i] = <span class="literal">true</span>;  <span class="comment">// mask out</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 过滤过期的数据（根据 TTL）</span></span><br><span class="line">        <span class="keyword">if</span> (ttl &gt; <span class="number">0</span> &amp;&amp; timestamp - ts &gt; ttl) &#123;</span><br><span class="line">            bitset_chunk[i] = <span class="literal">true</span>;  <span class="comment">// mask out</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="A-6-内存管理"><a href="#A-6-内存管理" class="headerlink" title="A.6 内存管理"></a>A.6 内存管理</h2><h3 id="A-6-1-Growing-Segment-内存管理"><a href="#A-6-1-Growing-Segment-内存管理" class="headerlink" title="A.6.1 Growing Segment 内存管理"></a>A.6.1 Growing Segment 内存管理</h3><ol>
<li><strong>动态增长</strong>: <code>ConcurrentVector</code> 按需分配内存</li>
<li><strong>Chunk 管理</strong>: 数据按 chunk 组织，支持增量加载</li>
<li><strong>Mmap 支持</strong>: 可选地使用 mmap 减少内存占用</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Chunk 大小配置</span></span><br><span class="line"><span class="type">int64_t</span> chunk_rows = segcore_config_.<span class="built_in">get_chunk_rows</span>();  <span class="comment">// 默认 32768</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 估算内存使用</span></span><br><span class="line"><span class="type">size_t</span> memory_per_row = <span class="built_in">EstimateRowSize</span>(schema);</span><br><span class="line"><span class="type">size_t</span> total_memory = num_rows * memory_per_row;</span><br></pre></td></tr></table></figure>

<h3 id="A-6-2-Sealed-Segment-内存管理"><a href="#A-6-2-Sealed-Segment-内存管理" class="headerlink" title="A.6.2 Sealed Segment 内存管理"></a>A.6.2 Sealed Segment 内存管理</h3><ol>
<li><strong>延迟加载</strong>: 字段和索引按需加载</li>
<li><strong>Mmap</strong>: 支持 mmap 模式，减少内存拷贝</li>
<li><strong>缓存管理</strong>: 使用 LRU 缓存管理索引和字段数据</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 加载状态检查</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CanQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> system_ready_count_ == <span class="number">2</span>  <span class="comment">// RowID &amp; Timestamp loaded</span></span><br><span class="line">        &amp;&amp; <span class="built_in">AllRequiredFieldsReady</span>()   <span class="comment">// Query fields loaded</span></span><br><span class="line">        &amp;&amp; (<span class="built_in">HasIndex</span>() || <span class="built_in">HasRawData</span>()); <span class="comment">// Index or raw data available</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="A-7-关键数据结构总结"><a href="#A-7-关键数据结构总结" class="headerlink" title="A.7 关键数据结构总结"></a>A.7 关键数据结构总结</h2><table>
<thead>
<tr>
<th>组件</th>
<th>Growing Segment</th>
<th>Sealed Segment</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Timestamp</strong></td>
<td><code>ConcurrentVector&lt;Timestamp&gt;</code></td>
<td><code>ConcurrentVector&lt;Timestamp&gt;</code></td>
<td>两者都存储完整 timestamp</td>
</tr>
<tr>
<td><strong>TimestampIndex</strong></td>
<td><code>TimestampIndex</code></td>
<td><code>TimestampIndex</code></td>
<td>用于时间旅行查询</td>
</tr>
<tr>
<td><strong>PK Index</strong></td>
<td><code>OffsetOrderedMap</code></td>
<td><code>OffsetOrderedArray</code></td>
<td>Growing 用 Map，Sealed 用 Array</td>
</tr>
<tr>
<td><strong>Field Data</strong></td>
<td><code>map&lt;FieldId, ConcurrentVector&gt;</code></td>
<td><code>map&lt;FieldId, ChunkedColumn&gt;</code></td>
<td>列式存储</td>
</tr>
<tr>
<td><strong>Vector Index</strong></td>
<td><code>IndexingRecord</code> (interim)</td>
<td><code>SealedIndexingRecord</code> (permanent)</td>
<td>索引类型不同</td>
</tr>
<tr>
<td><strong>Scalar Index</strong></td>
<td>可选</td>
<td><code>map&lt;FieldId, Index&gt;</code></td>
<td>Sealed 支持更多索引</td>
</tr>
<tr>
<td><strong>Delete Record</strong></td>
<td><code>DeletedRecord&lt;false&gt;</code></td>
<td><code>DeletedRecord&lt;true&gt;</code></td>
<td>删除记录</td>
</tr>
<tr>
<td><strong>并发控制</strong></td>
<td><code>std::shared_mutex</code></td>
<td><code>folly::Synchronized</code></td>
<td>不同的同步机制</td>
</tr>
</tbody></table>
<hr>
<p><strong>文档版本</strong>: v1.1<br><strong>最后更新</strong>: 2025-01-24<br><strong>适用 Milvus 版本</strong>: 2.5.x</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-number">2.</span> <span class="toc-text">1. 概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%A0%B8%E5%BF%83%E7%BB%93%E8%AE%BA"><span class="toc-number">2.1.</span> <span class="toc-text">1.1 核心结论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-Timestamp-%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">2.2.</span> <span class="toc-text">1.2 Timestamp 的用途</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Timestamp-%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89"><span class="toc-number">3.</span> <span class="toc-text">2. Timestamp 字段定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E7%B3%BB%E7%BB%9F%E9%A2%84%E7%95%99%E5%AD%97%E6%AE%B5"><span class="toc-number">3.1.</span> <span class="toc-text">2.1 系统预留字段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.2.</span> <span class="toc-text">2.2 数据类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-Flush-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%BB%E6%B5%81%E7%A8%8B%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">3. Flush 写入流程（主流程）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">4.1.</span> <span class="toc-text">3.1 整体流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE"><span class="toc-number">4.2.</span> <span class="toc-text">3.2 关键代码位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-WriteBuffer-%E5%88%9B%E5%BB%BA-SyncTask"><span class="toc-number">4.2.1.</span> <span class="toc-text">3.2.1 WriteBuffer 创建 SyncTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-SyncTask-%E6%89%A7%E8%A1%8C%E5%86%99%E5%85%A5"><span class="toc-number">4.2.2.</span> <span class="toc-text">3.2.2 SyncTask 执行写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-StorageV1-%E5%BA%8F%E5%88%97%E5%8C%96-Binlog"><span class="toc-number">4.2.3.</span> <span class="toc-text">3.2.3 StorageV1 序列化 Binlog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-StorageV2-%E5%86%99%E5%85%A5-Parquet"><span class="toc-number">4.2.4.</span> <span class="toc-text">3.2.4 StorageV2 写入 Parquet</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-Compaction-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">4. Compaction 写入流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">5.1.</span> <span class="toc-text">4.1 整体流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E4%BD%8D%E7%BD%AE"><span class="toc-number">5.2.</span> <span class="toc-text">4.2 关键代码位置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-Mix-Compaction-%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">5.2.1.</span> <span class="toc-text">4.2.1 Mix Compaction 主流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E5%86%99%E5%85%A5%E5%8D%95%E4%B8%AA-Segment"><span class="toc-number">5.2.2.</span> <span class="toc-text">4.2.2 写入单个 Segment</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-MultiSegmentWriter-%E5%86%99%E5%85%A5"><span class="toc-number">5.2.3.</span> <span class="toc-text">4.2.3 MultiSegmentWriter 写入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-4-%E5%BA%95%E5%B1%82-Record-Writer"><span class="toc-number">5.2.4.</span> <span class="toc-text">4.2.4 底层 Record Writer</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-Storage-%E5%B1%82%E7%9A%84-Timestamp-%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">5. Storage 层的 Timestamp 处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Growing-Segment-%E4%B8%AD%E7%9A%84-Timestamp"><span class="toc-number">6.1.</span> <span class="toc-text">5.1 Growing Segment 中的 Timestamp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Segment-Writer-%E4%B8%AD%E7%9A%84-Timestamp-%E8%BF%BD%E8%B8%AA"><span class="toc-number">6.2.</span> <span class="toc-text">5.2 Segment Writer 中的 Timestamp 追踪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E7%89%88%E6%9C%AC%E5%AF%B9%E6%AF%94"><span class="toc-number">7.</span> <span class="toc-text">6. 两种存储版本对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-StorageV1-Binlog-%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text">6.1 StorageV1 (Binlog 格式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-StorageV2-Parquet-%E6%A0%BC%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">6.2 StorageV2 (Parquet 格式)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">7.3.</span> <span class="toc-text">6.3 对比表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">7. 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%A0%B8%E5%BF%83%E8%A6%81%E7%82%B9"><span class="toc-number">8.1.</span> <span class="toc-text">7.1 核心要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91%E5%9B%BE"><span class="toc-number">8.2.</span> <span class="toc-text">7.2 数据流向图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95"><span class="toc-number">8.3.</span> <span class="toc-text">7.3 相关文件索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB"><span class="toc-number">8.4.</span> <span class="toc-text">7.4 扩展阅读</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%84%E5%BD%95%EF%BC%9A%E6%9C%AF%E8%AF%AD%E8%A1%A8"><span class="toc-number">9.</span> <span class="toc-text">附录：术语表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%84%E5%BD%95-A%EF%BC%9ASegment-%E5%86%85%E9%83%A8-Layout"><span class="toc-number"></span> <span class="toc-text">附录 A：Segment 内部 Layout</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#A-1-Segment-%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">A.1 Segment 类型概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Growing-Segment-%E5%A2%9E%E9%95%BF%E4%B8%AD%E7%9A%84-Segment"><span class="toc-number">1.1.</span> <span class="toc-text">Growing Segment (增长中的 Segment)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sealed-Segment-%E5%B0%81%E5%AD%98%E7%9A%84-Segment"><span class="toc-number">1.2.</span> <span class="toc-text">Sealed Segment (封存的 Segment)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-2-Growing-Segment-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">A.2 Growing Segment 内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-2-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">2.1.</span> <span class="toc-text">A.2.1 核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-2-2-InsertRecord-%E6%95%B0%E6%8D%AE%E5%B8%83%E5%B1%80"><span class="toc-number">2.2.</span> <span class="toc-text">A.2.2 InsertRecord 数据布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-2-3-%E6%95%B0%E6%8D%AE%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">A.2.3 数据组织方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-2-4-Chunk-%E6%9C%BA%E5%88%B6"><span class="toc-number">2.4.</span> <span class="toc-text">A.2.4 Chunk 机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-3-Sealed-Segment-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">A.3 Sealed Segment 内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-3-1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6"><span class="toc-number">3.1.</span> <span class="toc-text">A.3.1 核心组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-3-2-%E6%95%B0%E6%8D%AE%E5%B8%83%E5%B1%80"><span class="toc-number">3.2.</span> <span class="toc-text">A.3.2 数据布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-3-3-ChunkedColumn-%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">A.3.3 ChunkedColumn 结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-4-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84-Layout"><span class="toc-number">4.</span> <span class="toc-text">A.4 文件系统中的 Layout</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-4-1-StorageV1-Binlog-%E5%B8%83%E5%B1%80"><span class="toc-number">4.1.</span> <span class="toc-text">A.4.1 StorageV1 (Binlog) 布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-4-2-StorageV2-Parquet-%E5%B8%83%E5%B1%80"><span class="toc-number">4.2.</span> <span class="toc-text">A.4.2 StorageV2 (Parquet) 布局</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-4-3-Binlog-%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.</span> <span class="toc-text">A.4.3 Binlog 文件内部结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-5-%E6%9F%A5%E8%AF%A2%E6%97%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE"><span class="toc-number">5.</span> <span class="toc-text">A.5 查询时的数据访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-5-1-%E8%AE%BF%E9%97%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">5.1.</span> <span class="toc-text">A.5.1 访问路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-5-2-Timestamp-%E8%BF%87%E6%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.2.</span> <span class="toc-text">A.5.2 Timestamp 过滤示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-6-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">A.6 内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#A-6-1-Growing-Segment-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">A.6.1 Growing Segment 内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-6-2-Sealed-Segment-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">A.6.2 Sealed Segment 内存管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#A-7-%E5%85%B3%E9%94%AE%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">A.7 关键数据结构总结</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&text=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&title=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&is_video=false&description=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Milvus 数据写入流程中的 MVCC Timestamp 处理&body=Check out this article: https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&title=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&title=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&title=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&title=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&name=Milvus 数据写入流程中的 MVCC Timestamp 处理&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2025/08/09/Milvus/11_milvus_timestamp_write_flow/&t=Milvus 数据写入流程中的 MVCC Timestamp 处理"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2026
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
