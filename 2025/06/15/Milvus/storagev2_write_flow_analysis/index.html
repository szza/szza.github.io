<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Milvus StorageV2 写入流程分析概述StorageV2 是 Milvus 的新一代存储格式，使用 Apache Arrow + Parquet 技术栈，相比 StorageV1（Binlog 格式）具有更高的压缩率和查询性能。本文档详细分析 StorageV2 的完整写入流程。 一、整体架构1.1 数据流向12345678910111213141516171819202122用户 I">
<meta property="og:type" content="article">
<meta property="og:title" content="Milvus StorageV2 写入流程分析">
<meta property="og:url" content="https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="Milvus StorageV2 写入流程分析概述StorageV2 是 Milvus 的新一代存储格式，使用 Apache Arrow + Parquet 技术栈，相比 StorageV1（Binlog 格式）具有更高的压缩率和查询性能。本文档详细分析 StorageV2 的完整写入流程。 一、整体架构1.1 数据流向12345678910111213141516171819202122用户 I">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-15T02:20:00.000Z">
<meta property="article:modified_time" content="2026-01-04T12:57:55.571Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Milvus">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>Milvus StorageV2 写入流程分析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2025/06/15/Milvus/shard_delegator_query_analysis/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2025/06/15/Milvus/tso_generation_and_usage_analysis/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&text=Milvus StorageV2 写入流程分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&title=Milvus StorageV2 写入流程分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&is_video=false&description=Milvus StorageV2 写入流程分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Milvus StorageV2 写入流程分析&body=Check out this article: https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&title=Milvus StorageV2 写入流程分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&title=Milvus StorageV2 写入流程分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&title=Milvus StorageV2 写入流程分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&title=Milvus StorageV2 写入流程分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&name=Milvus StorageV2 写入流程分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&t=Milvus StorageV2 写入流程分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Milvus-StorageV2-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Milvus StorageV2 写入流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">一、整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1 数据流向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2 关键组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">二、详细流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%EF%BC%88WriteBuffer-%E2%86%92-SyncPack%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 数据准备阶段（WriteBuffer → SyncPack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-SyncTask-%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2 SyncTask 执行阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-BulkPackWriterV2-%E5%86%99%E5%85%A5%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3 BulkPackWriterV2 写入阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-Write-%E6%96%B9%E6%B3%95%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">2.3.1 Write 方法主流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-serializeBinlog%EF%BC%9AInsertData-%E2%86%92-Arrow-Record"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2.3.2 serializeBinlog：InsertData → Arrow Record</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-writeInserts%EF%BC%9AArrow-Record-%E2%86%92-Parquet-%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">2.3.3 writeInserts：Arrow Record → Parquet 文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-PackedRecordWriter%EF%BC%9AArrow-%E2%86%92-Parquet-%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.4.</span> <span class="toc-text">2.4 PackedRecordWriter：Arrow → Parquet 转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-Write-%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">2.4.1 Write 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-PackedWriter%EF%BC%88C-FFI%EF%BC%89"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">2.4.2 PackedWriter（C++ FFI）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%88%97%E7%BB%84%EF%BC%88Column-Group%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">三、列组（Column Group）机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%88%97%E7%BB%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 列组概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%88%97%E7%BB%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 列组的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3 文件路径结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B3%E9%94%AE%E4%BC%98%E5%8C%96%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">四、关键优化点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 零拷贝转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%89%B9%E9%87%8F%E5%86%99%E5%85%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 批量写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3 压缩优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.4 元数据管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%8E-StorageV1-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.</span> <span class="toc-text">五、与 StorageV1 的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">六、总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">6.1 核心流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">6.2 关键技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BC%98%E5%8A%BF"><span class="toc-number">1.7.3.</span> <span class="toc-text">6.3 优势</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Milvus StorageV2 写入流程分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-06-15T02:20:00.000Z" itemprop="datePublished">2025-06-15</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Milvus/" rel="tag">Milvus</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="Milvus-StorageV2-写入流程分析"><a href="#Milvus-StorageV2-写入流程分析" class="headerlink" title="Milvus StorageV2 写入流程分析"></a>Milvus StorageV2 写入流程分析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>StorageV2 是 Milvus 的新一代存储格式，使用 Apache Arrow + Parquet 技术栈，相比 StorageV1（Binlog 格式）具有更高的压缩率和查询性能。本文档详细分析 StorageV2 的完整写入流程。</p>
<h2 id="一、整体架构"><a href="#一、整体架构" class="headerlink" title="一、整体架构"></a>一、整体架构</h2><h3 id="1-1-数据流向"><a href="#1-1-数据流向" class="headerlink" title="1.1 数据流向"></a>1.1 数据流向</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">用户 Insert/Delete 请求</span><br><span class="line">    ↓</span><br><span class="line">WriteBuffer.BufferData()        // 缓存数据到内存</span><br><span class="line">    ↓</span><br><span class="line">triggerSync()                   // 触发同步</span><br><span class="line">    ↓</span><br><span class="line">getSyncTask()                   // 创建 SyncTask</span><br><span class="line">    ├─ yieldBuffer()            // 从 buffer 获取数据</span><br><span class="line">    └─ NewSyncTask()            // 创建同步任务</span><br><span class="line">    ↓</span><br><span class="line">SyncTask.Run()</span><br><span class="line">    ↓</span><br><span class="line">BulkPackWriterV2.Write()        // StorageV2 写入</span><br><span class="line">    ├─ serializeBinlog()        // InsertData → Arrow Record</span><br><span class="line">    ├─ writeInserts()           // Arrow Record → Parquet</span><br><span class="line">    ├─ writeStats()             // 写入统计信息</span><br><span class="line">    ├─ writeDelta()             // 写入删除数据</span><br><span class="line">    └─ writeBM25Stasts()        // 写入 BM25 统计</span><br><span class="line">    ↓</span><br><span class="line">PackedRecordWriter.Write()      // 写入 Parquet 文件</span><br><span class="line">    ↓</span><br><span class="line">对象存储 (MinIO/S3/Local)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-关键组件"><a href="#1-2-关键组件" class="headerlink" title="1.2 关键组件"></a>1.2 关键组件</h3><table>
<thead>
<tr>
<th>组件</th>
<th>职责</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td><strong>WriteBuffer</strong></td>
<td>内存缓冲区，缓存写入数据</td>
<td><code>internal/flushcommon/writebuffer/</code></td>
</tr>
<tr>
<td><strong>SyncTask</strong></td>
<td>同步任务，负责将数据写入存储</td>
<td><code>internal/flushcommon/syncmgr/task.go</code></td>
</tr>
<tr>
<td><strong>BulkPackWriterV2</strong></td>
<td>StorageV2 写入器</td>
<td><code>internal/flushcommon/syncmgr/pack_writer_v2.go</code></td>
</tr>
<tr>
<td><strong>PackedRecordWriter</strong></td>
<td>Arrow Record → Parquet 转换器</td>
<td><code>internal/storage/record_writer.go</code></td>
</tr>
<tr>
<td><strong>PackedWriter</strong></td>
<td>底层 Parquet 写入器（C++ FFI）</td>
<td><code>internal/storagev2/packed/</code></td>
</tr>
</tbody></table>
<h2 id="二、详细流程分析"><a href="#二、详细流程分析" class="headerlink" title="二、详细流程分析"></a>二、详细流程分析</h2><h3 id="2-1-数据准备阶段（WriteBuffer-→-SyncPack）"><a href="#2-1-数据准备阶段（WriteBuffer-→-SyncPack）" class="headerlink" title="2.1 数据准备阶段（WriteBuffer → SyncPack）"></a>2.1 数据准备阶段（WriteBuffer → SyncPack）</h3><p><strong>文件</strong>: <code>internal/flushcommon/writebuffer/write_buffer.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wb *writeBufferBase)</span></span> getSyncTask(ctx context.Context, segmentID <span class="type">int64</span>) (syncmgr.Task, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 从 WriteBuffer 中提取数据</span></span><br><span class="line">    insert, bm25, delta, schema, timeRange, startPos := wb.yieldBuffer(segmentID)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 构建 SyncPack</span></span><br><span class="line">    pack := &amp;syncmgr.SyncPack&#123;&#125;</span><br><span class="line">    pack.WithInsertData(insert).      <span class="comment">// InsertData 数组</span></span><br><span class="line">        WithDeleteData(delta).         <span class="comment">// DeleteData</span></span><br><span class="line">        WithBM25Stats(bm25).           <span class="comment">// BM25 统计</span></span><br><span class="line">        WithCollectionID(wb.collectionID).</span><br><span class="line">        WithPartitionID(segmentInfo.PartitionID()).</span><br><span class="line">        WithSegmentID(segmentID).</span><br><span class="line">        WithTimeRange(tsFrom, tsTo).   <span class="comment">// Timestamp 范围</span></span><br><span class="line">        WithBatchRows(batchSize)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 创建 SyncTask</span></span><br><span class="line">    task := syncmgr.NewSyncTask(...)</span><br><span class="line">    <span class="keyword">return</span> task, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键数据结构</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// InsertData 包含所有字段的数据</span></span><br><span class="line"><span class="keyword">type</span> InsertData <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="keyword">map</span>[FieldID]FieldData  <span class="comment">// map[fieldID]FieldData</span></span><br><span class="line">    RowNum() <span class="type">int</span></span><br><span class="line">    GetMemorySize() <span class="type">int64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SyncPack 包含一次同步的所有数据</span></span><br><span class="line"><span class="keyword">type</span> SyncPack <span class="keyword">struct</span> &#123;</span><br><span class="line">    insertData []*storage.InsertData  <span class="comment">// 插入数据</span></span><br><span class="line">    deltaData  *storage.DeleteData     <span class="comment">// 删除数据</span></span><br><span class="line">    bm25Stats  <span class="keyword">map</span>[<span class="type">int64</span>]*storage.BM25Stats</span><br><span class="line">    tsFrom, tsTo typeutil.Timestamp   <span class="comment">// Timestamp 范围</span></span><br><span class="line">    collectionID, partitionID, segmentID <span class="type">int64</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-SyncTask-执行阶段"><a href="#2-2-SyncTask-执行阶段" class="headerlink" title="2.2 SyncTask 执行阶段"></a>2.2 SyncTask 执行阶段</h3><p><strong>文件</strong>: <code>internal/flushcommon/syncmgr/task.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *SyncTask)</span></span> Run(ctx context.Context) (err <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 获取段信息和列组配置</span></span><br><span class="line">    segmentInfo, has := t.metacache.GetSegmentByID(t.segmentID)</span><br><span class="line">    columnGroups := t.getColumnGroups(segmentInfo)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 根据 StorageVersion 选择写入器</span></span><br><span class="line">    <span class="keyword">switch</span> segmentInfo.GetStorageVersion() &#123;</span><br><span class="line">    <span class="keyword">case</span> storage.StorageV2:</span><br><span class="line">        writer := NewBulkPackWriterV2(</span><br><span class="line">            t.metacache, t.schema, t.chunkManager, t.allocator,</span><br><span class="line">            <span class="number">0</span>, packed.DefaultMultiPartUploadSize,</span><br><span class="line">            t.storageConfig, columnGroups, t.writeRetryOpts...)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 执行写入</span></span><br><span class="line">        t.insertBinlogs, t.deltaBinlog, t.statsBinlogs, </span><br><span class="line">        t.bm25Binlogs, t.manifestPath, t.flushedSize, err = </span><br><span class="line">            writer.Write(ctx, t.pack)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-BulkPackWriterV2-写入阶段"><a href="#2-3-BulkPackWriterV2-写入阶段" class="headerlink" title="2.3 BulkPackWriterV2 写入阶段"></a>2.3 BulkPackWriterV2 写入阶段</h3><p><strong>文件</strong>: <code>internal/flushcommon/syncmgr/pack_writer_v2.go</code></p>
<h4 id="2-3-1-Write-方法主流程"><a href="#2-3-1-Write-方法主流程" class="headerlink" title="2.3.1 Write 方法主流程"></a>2.3.1 Write 方法主流程</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BulkPackWriterV2)</span></span> Write(ctx context.Context, pack *SyncPack) (</span><br><span class="line">    inserts <span class="keyword">map</span>[<span class="type">int64</span>]*datapb.FieldBinlog,</span><br><span class="line">    deltas *datapb.FieldBinlog,</span><br><span class="line">    stats <span class="keyword">map</span>[<span class="type">int64</span>]*datapb.FieldBinlog,</span><br><span class="line">    bm25Stats <span class="keyword">map</span>[<span class="type">int64</span>]*datapb.FieldBinlog,</span><br><span class="line">    manifest <span class="type">string</span>,</span><br><span class="line">    size <span class="type">int64</span>,</span><br><span class="line">    err <span class="type">error</span>,</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 1. 预分配 ID</span></span><br><span class="line">    err = bw.prefetchIDs(pack)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 写入插入数据（核心步骤）</span></span><br><span class="line">    <span class="keyword">if</span> inserts, manifest, err = bw.writeInserts(ctx, pack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 写入统计信息</span></span><br><span class="line">    <span class="keyword">if</span> stats, err = bw.writeStats(ctx, pack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 写入删除数据</span></span><br><span class="line">    <span class="keyword">if</span> deltas, err = bw.writeDelta(ctx, pack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 写入 BM25 统计</span></span><br><span class="line">    <span class="keyword">if</span> bm25Stats, err = bw.writeBM25Stasts(ctx, pack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    size = bw.sizeWritten</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-3-2-serializeBinlog：InsertData-→-Arrow-Record"><a href="#2-3-2-serializeBinlog：InsertData-→-Arrow-Record" class="headerlink" title="2.3.2 serializeBinlog：InsertData → Arrow Record"></a>2.3.2 serializeBinlog：InsertData → Arrow Record</h4><p><strong>关键步骤</strong>：将内存中的 InsertData 转换为 Arrow Record</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BulkPackWriterV2)</span></span> serializeBinlog(_ context.Context, pack *SyncPack) (storage.Record, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(pack.insertData) == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 将 Milvus Schema 转换为 Arrow Schema</span></span><br><span class="line">    arrowSchema, err := storage.ConvertToArrowSchema(bw.schema, <span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 创建 Arrow RecordBuilder</span></span><br><span class="line">    builder := array.NewRecordBuilder(memory.DefaultAllocator, arrowSchema)</span><br><span class="line">    <span class="keyword">defer</span> builder.Release()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 遍历所有 InsertData chunk，构建 Arrow Record</span></span><br><span class="line">    <span class="keyword">for</span> _, chunk := <span class="keyword">range</span> pack.insertData &#123;</span><br><span class="line">        <span class="keyword">if</span> err := storage.BuildRecord(builder, chunk, bw.schema); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 创建 Arrow Record</span></span><br><span class="line">    rec := builder.NewRecord()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 构建 FieldID 到列索引的映射</span></span><br><span class="line">    allFields := typeutil.GetAllFieldSchemas(bw.schema)</span><br><span class="line">    field2Col := <span class="built_in">make</span>(<span class="keyword">map</span>[storage.FieldID]<span class="type">int</span>, <span class="built_in">len</span>(allFields))</span><br><span class="line">    <span class="keyword">for</span> c, field := <span class="keyword">range</span> allFields &#123;</span><br><span class="line">        field2Col[field.FieldID] = c</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 返回 SimpleArrowRecord（包含 FieldID 映射）</span></span><br><span class="line">    <span class="keyword">return</span> storage.NewSimpleArrowRecord(rec, field2Col), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>BuildRecord 详细过程</strong>（<code>internal/storage/serde.go</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BuildRecord</span><span class="params">(b *array.RecordBuilder, data *InsertData, schema *schemapb.CollectionSchema)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    idx := <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    serializeField := <span class="function"><span class="keyword">func</span><span class="params">(field *schemapb.FieldSchema)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        fBuilder := b.Field(idx)  <span class="comment">// 获取对应字段的 Builder</span></span><br><span class="line">        idx++</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取字段数据</span></span><br><span class="line">        fieldData, exists := data.Data[field.FieldID]</span><br><span class="line">        <span class="keyword">if</span> !exists &#123;</span><br><span class="line">            <span class="keyword">return</span> merr.WrapErrFieldNotFound(field.FieldID, ...)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据字段类型获取序列化函数</span></span><br><span class="line">        typeEntry := serdeMap[field.DataType]</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 逐行序列化数据到 Arrow Builder</span></span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; fieldData.RowNum(); j++ &#123;</span><br><span class="line">            ok = typeEntry.serialize(fBuilder, fieldData.GetRow(j), elementType)</span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                <span class="keyword">return</span> merr.WrapErrServiceInternal(...)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化所有字段（包括 timestamp field）</span></span><br><span class="line">    <span class="keyword">for</span> _, field := <span class="keyword">range</span> schema.GetFields() &#123;</span><br><span class="line">        <span class="keyword">if</span> err := serializeField(field); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 序列化结构体数组字段</span></span><br><span class="line">    <span class="keyword">for</span> _, structField := <span class="keyword">range</span> schema.GetStructArrayFields() &#123;</span><br><span class="line">        <span class="keyword">for</span> _, field := <span class="keyword">range</span> structField.GetFields() &#123;</span><br><span class="line">            <span class="keyword">if</span> err := serializeField(field); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> err</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类型映射示例</strong>：</p>
<table>
<thead>
<tr>
<th>Milvus 类型</th>
<th>Arrow 类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>DataType_Int64</code></td>
<td><code>arrow.Int64Type</code></td>
<td>64 位整数</td>
</tr>
<tr>
<td><code>DataType_FloatVector</code></td>
<td><code>arrow.FixedSizeBinaryType&#123;ByteWidth: dim * 4&#125;</code></td>
<td>固定大小二进制（向量）</td>
</tr>
<tr>
<td><code>DataType_Timestamp</code></td>
<td><code>arrow.Int64Type</code></td>
<td>Timestamp 作为 Int64 存储</td>
</tr>
<tr>
<td><code>DataType_JSON</code></td>
<td><code>arrow.BinaryType</code></td>
<td>JSON 作为二进制存储</td>
</tr>
</tbody></table>
<h4 id="2-3-3-writeInserts：Arrow-Record-→-Parquet-文件"><a href="#2-3-3-writeInserts：Arrow-Record-→-Parquet-文件" class="headerlink" title="2.3.3 writeInserts：Arrow Record → Parquet 文件"></a>2.3.3 writeInserts：Arrow Record → Parquet 文件</h4><p><strong>核心流程</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bw *BulkPackWriterV2)</span></span> writeInserts(ctx context.Context, pack *SyncPack) (</span><br><span class="line">    <span class="keyword">map</span>[<span class="type">int64</span>]*datapb.FieldBinlog, <span class="type">string</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 序列化为 Arrow Record</span></span><br><span class="line">    rec, err := bw.serializeBinlog(ctx, pack)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 提取 Timestamp 列并计算范围</span></span><br><span class="line">    tsArray := rec.Column(common.TimeStampField).(*array.Int64)</span><br><span class="line">    rows := rec.Len()</span><br><span class="line">    <span class="keyword">var</span> tsFrom <span class="type">uint64</span> = math.MaxUint64</span><br><span class="line">    <span class="keyword">var</span> tsTo <span class="type">uint64</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; rows; i++ &#123;</span><br><span class="line">        ts := typeutil.Timestamp(tsArray.Value(i))</span><br><span class="line">        <span class="keyword">if</span> ts &lt; tsFrom &#123;</span><br><span class="line">            tsFrom = ts</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ts &gt; tsTo &#123;</span><br><span class="line">            tsTo = ts</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 准备写入函数</span></span><br><span class="line">    doWrite := <span class="function"><span class="keyword">func</span><span class="params">(w storage.RecordWriter)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> err = w.Write(rec); err != <span class="literal">nil</span> &#123;  <span class="comment">// 写入 Arrow Record</span></span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> w.Close()  <span class="comment">// 关闭并刷新到磁盘</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 根据配置选择写入模式</span></span><br><span class="line">    <span class="keyword">if</span> paramtable.Get().CommonCfg.UseLoonFFI.GetAsBool() &#123;</span><br><span class="line">        <span class="comment">// Manifest 模式：使用 FFI 写入器</span></span><br><span class="line">        basePath := path.Join(bw.getRootPath(), common.SegmentInsertLogPath, k)</span><br><span class="line">        w, err := storage.NewPackedRecordManifestWriter(</span><br><span class="line">            bucketName, basePath, bw.schema, </span><br><span class="line">            bw.bufferSize, bw.multiPartUploadSize, </span><br><span class="line">            columnGroups, bw.storageConfig, pluginContextPtr)</span><br><span class="line">        <span class="keyword">if</span> err = doWrite(w); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">        manifestPath = w.GetWrittenManifest()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 普通模式：每个列组一个文件</span></span><br><span class="line">        paths := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> _, columnGroup := <span class="keyword">range</span> columnGroups &#123;</span><br><span class="line">            path := metautil.BuildInsertLogPath(</span><br><span class="line">                bw.getRootPath(), pack.collectionID, </span><br><span class="line">                pack.partitionID, pack.segmentID, </span><br><span class="line">                columnGroup.GroupID, bw.nextID())</span><br><span class="line">            paths = <span class="built_in">append</span>(paths, path)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        w, err := storage.NewPackedRecordWriter(</span><br><span class="line">            bucketName, paths, bw.schema, </span><br><span class="line">            bw.bufferSize, bw.multiPartUploadSize, </span><br><span class="line">            columnGroups, bw.storageConfig, pluginContextPtr)</span><br><span class="line">        <span class="keyword">if</span> err = doWrite(w); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>, <span class="string">&quot;&quot;</span>, err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 构建 Binlog 元数据</span></span><br><span class="line">    logs := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*datapb.FieldBinlog)</span><br><span class="line">    <span class="keyword">for</span> _, columnGroup := <span class="keyword">range</span> columnGroups &#123;</span><br><span class="line">        logs[columnGroupID] = &amp;datapb.FieldBinlog&#123;</span><br><span class="line">            FieldID:     columnGroupID,</span><br><span class="line">            ChildFields: columnGroup.Fields,</span><br><span class="line">            Binlogs: []*datapb.Binlog&#123;</span><br><span class="line">                &#123;</span><br><span class="line">                    LogSize:       <span class="type">int64</span>(w.GetColumnGroupWrittenCompressed(columnGroup.GroupID)),</span><br><span class="line">                    MemorySize:    <span class="type">int64</span>(w.GetColumnGroupWrittenUncompressed(columnGroup.GroupID)),</span><br><span class="line">                    LogPath:       w.GetWrittenPaths(columnGroupID),</span><br><span class="line">                    EntriesNum:    w.GetWrittenRowNum(),</span><br><span class="line">                    TimestampFrom: tsFrom,</span><br><span class="line">                    TimestampTo:   tsTo,</span><br><span class="line">                &#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> logs, manifestPath, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-PackedRecordWriter：Arrow-→-Parquet-转换"><a href="#2-4-PackedRecordWriter：Arrow-→-Parquet-转换" class="headerlink" title="2.4 PackedRecordWriter：Arrow → Parquet 转换"></a>2.4 PackedRecordWriter：Arrow → Parquet 转换</h3><p><strong>文件</strong>: <code>internal/storage/record_writer.go</code></p>
<h4 id="2-4-1-Write-方法"><a href="#2-4-1-Write-方法" class="headerlink" title="2.4.1 Write 方法"></a>2.4.1 Write 方法</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pw *packedRecordWriter)</span></span> Write(r Record) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 将 Record 转换为 Arrow Record</span></span><br><span class="line">    <span class="keyword">var</span> rec arrow.Record</span><br><span class="line">    <span class="keyword">if</span> sar, ok := r.(*simpleArrowRecord); ok &#123;</span><br><span class="line">        rec = sar.r  <span class="comment">// 直接使用 Arrow Record</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从 Record 接口构建 Arrow Record</span></span><br><span class="line">        allFields := typeutil.GetAllFieldSchemas(pw.schema)</span><br><span class="line">        arrays := <span class="built_in">make</span>([]arrow.Array, <span class="built_in">len</span>(allFields))</span><br><span class="line">        <span class="keyword">for</span> i, field := <span class="keyword">range</span> allFields &#123;</span><br><span class="line">            arrays[i] = r.Column(field.FieldID)</span><br><span class="line">        &#125;</span><br><span class="line">        rec = array.NewRecord(pw.arrowSchema, arrays, <span class="type">int64</span>(r.Len()))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 统计写入大小（按列组）</span></span><br><span class="line">    pw.rowNum += <span class="type">int64</span>(r.Len())</span><br><span class="line">    <span class="keyword">for</span> col, arr := <span class="keyword">range</span> rec.Columns() &#123;</span><br><span class="line">        size := calculateActualDataSize(arr)</span><br><span class="line">        pw.writtenUncompressed += size</span><br><span class="line">        <span class="keyword">for</span> _, columnGroup := <span class="keyword">range</span> pw.columnGroups &#123;</span><br><span class="line">            <span class="keyword">if</span> lo.Contains(columnGroup.Columns, col) &#123;</span><br><span class="line">                pw.columnGroupUncompressed[columnGroup.GroupID] += size</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 调用底层 PackedWriter 写入</span></span><br><span class="line">    <span class="keyword">defer</span> rec.Release()</span><br><span class="line">    <span class="keyword">return</span> pw.writer.WriteRecordBatch(rec)  <span class="comment">// 写入 Arrow RecordBatch</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-4-2-PackedWriter（C-FFI）"><a href="#2-4-2-PackedWriter（C-FFI）" class="headerlink" title="2.4.2 PackedWriter（C++ FFI）"></a>2.4.2 PackedWriter（C++ FFI）</h4><p><strong>文件</strong>: <code>internal/storagev2/packed/packed_writer.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pw *PackedWriter)</span></span> WriteRecordBatch(recordBatch arrow.Record) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 导出 Arrow Array 和 Schema 到 C 结构</span></span><br><span class="line">    cArrays := <span class="built_in">make</span>([]CArrowArray, recordBatch.NumCols())</span><br><span class="line">    cSchemas := <span class="built_in">make</span>([]CArrowSchema, recordBatch.NumCols())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> recordBatch.NumCols() &#123;</span><br><span class="line">        <span class="keyword">var</span> caa cdata.CArrowArray</span><br><span class="line">        <span class="keyword">var</span> cas cdata.CArrowSchema</span><br><span class="line">        cdata.ExportArrowArray(recordBatch.Column(<span class="type">int</span>(i)), &amp;caa, &amp;cas)</span><br><span class="line">        cArrays[i] = *(*CArrowArray)(unsafe.Pointer(&amp;caa))</span><br><span class="line">        cSchemas[i] = *(*CArrowSchema)(unsafe.Pointer(&amp;cas))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 导出 Arrow Schema</span></span><br><span class="line">    <span class="keyword">var</span> cas cdata.CArrowSchema</span><br><span class="line">    cdata.ExportArrowSchema(recordBatch.Schema(), &amp;cas)</span><br><span class="line">    cSchema := (*C.struct_ArrowSchema)(unsafe.Pointer(&amp;cas))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 调用 C++ 函数写入 Parquet</span></span><br><span class="line">    status := C.WriteRecordBatch(pw.cPackedWriter, &amp;cArrays[<span class="number">0</span>], &amp;cSchemas[<span class="number">0</span>], cSchema)</span><br><span class="line">    <span class="keyword">if</span> err := ConsumeCStatusIntoError(&amp;status); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>底层 C++ 实现</strong>（<code>internal/core/src/segcore/packed_writer_c.cpp</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 端接收 Arrow RecordBatch，写入 Parquet 文件</span></span><br><span class="line"><span class="function">Status <span class="title">WriteRecordBatch</span><span class="params">(PackedWriter* writer, </span></span></span><br><span class="line"><span class="params"><span class="function">                        ArrowArray* arrays, </span></span></span><br><span class="line"><span class="params"><span class="function">                        ArrowSchema* schemas, </span></span></span><br><span class="line"><span class="params"><span class="function">                        ArrowSchema* schema)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 导入 Arrow 数据到 C++ Arrow 对象</span></span><br><span class="line">    <span class="keyword">auto</span> record_batch = <span class="built_in">ImportRecordBatch</span>(arrays, schemas, schema);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 调用 PackedRecordBatchWriter 写入 Parquet</span></span><br><span class="line">    <span class="keyword">return</span> writer-&gt;packed_writer_-&gt;<span class="built_in">Write</span>(record_batch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、列组（Column-Group）机制"><a href="#三、列组（Column-Group）机制" class="headerlink" title="三、列组（Column Group）机制"></a>三、列组（Column Group）机制</h2><h3 id="3-1-列组概念"><a href="#3-1-列组概念" class="headerlink" title="3.1 列组概念"></a>3.1 列组概念</h3><p>列组是 StorageV2 的重要优化机制，将相关字段组织在一起，减少文件数量，提高查询效率。</p>
<p><strong>示例</strong>：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列组配置示例</span></span><br><span class="line">columnGroups := []storagecommon.ColumnGroup&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        GroupID: <span class="number">100</span>,  <span class="comment">// 主键组</span></span><br><span class="line">        Fields:  []<span class="type">int64</span>&#123;<span class="number">0</span>&#125;,  <span class="comment">// 主键字段</span></span><br><span class="line">        Columns: []<span class="type">int</span>&#123;<span class="number">0</span>&#125;,    <span class="comment">// Arrow 列索引</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        GroupID: <span class="number">101</span>,  <span class="comment">// 向量组</span></span><br><span class="line">        Fields:  []<span class="type">int64</span>&#123;<span class="number">100</span>&#125;,  <span class="comment">// 向量字段</span></span><br><span class="line">        Columns: []<span class="type">int</span>&#123;<span class="number">1</span>&#125;,      <span class="comment">// Arrow 列索引</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        GroupID: <span class="number">102</span>,  <span class="comment">// 标量字段组</span></span><br><span class="line">        Fields:  []<span class="type">int64</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,  <span class="comment">// 多个标量字段</span></span><br><span class="line">        Columns: []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,     <span class="comment">// Arrow 列索引</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-列组的作用"><a href="#3-2-列组的作用" class="headerlink" title="3.2 列组的作用"></a>3.2 列组的作用</h3><ol>
<li><strong>减少文件数量</strong>：多个字段可以写入同一个 Parquet 文件</li>
<li><strong>优化查询</strong>：相关字段在一起，减少 I&#x2F;O</li>
<li><strong>支持列剪枝</strong>：查询时只读取需要的列组</li>
</ol>
<h3 id="3-3-文件路径结构"><a href="#3-3-文件路径结构" class="headerlink" title="3.3 文件路径结构"></a>3.3 文件路径结构</h3><p><strong>普通模式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;rootPath&#125;/&#123;collectionID&#125;/&#123;partitionID&#125;/&#123;segmentID&#125;/</span><br><span class="line">├── insert_log/</span><br><span class="line">│   ├── &#123;columnGroupID1&#125;/&#123;logID&#125;.parquet</span><br><span class="line">│   ├── &#123;columnGroupID2&#125;/&#123;logID&#125;.parquet</span><br><span class="line">│   └── &#123;columnGroupID3&#125;/&#123;logID&#125;.parquet</span><br></pre></td></tr></table></figure>

<p><strong>Manifest 模式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;rootPath&#125;/&#123;collectionID&#125;/&#123;partitionID&#125;/&#123;segmentID&#125;/</span><br><span class="line">├── insert_log/</span><br><span class="line">│   ├── &#123;columnGroupID1&#125;/</span><br><span class="line">│   │   └── &#123;logID&#125;.parquet</span><br><span class="line">│   ├── &#123;columnGroupID2&#125;/</span><br><span class="line">│   │   └── &#123;logID&#125;.parquet</span><br><span class="line">│   └── manifest.json  # 统一元数据清单</span><br></pre></td></tr></table></figure>

<h2 id="四、关键优化点"><a href="#四、关键优化点" class="headerlink" title="四、关键优化点"></a>四、关键优化点</h2><h3 id="4-1-零拷贝转换"><a href="#4-1-零拷贝转换" class="headerlink" title="4.1 零拷贝转换"></a>4.1 零拷贝转换</h3><ul>
<li><strong>Arrow Record</strong> 在内存中直接使用，无需序列化</li>
<li><strong>Go → C++</strong> 通过 FFI 传递 Arrow C Data Interface，零拷贝</li>
<li><strong>Arrow → Parquet</strong> 使用 Arrow 的 Parquet 写入器，高效转换</li>
</ul>
<h3 id="4-2-批量写入"><a href="#4-2-批量写入" class="headerlink" title="4.2 批量写入"></a>4.2 批量写入</h3><ul>
<li>使用 <code>RecordBatch</code> 批量写入，减少 I&#x2F;O 次数</li>
<li>支持缓冲写入，提高吞吐量</li>
</ul>
<h3 id="4-3-压缩优化"><a href="#4-3-压缩优化" class="headerlink" title="4.3 压缩优化"></a>4.3 压缩优化</h3><ul>
<li>Parquet 使用列式压缩，压缩率高</li>
<li>支持多种压缩算法（Zstd, Snappy, Gzip 等）</li>
<li>在 Milvus 中默认使用 Zstd 压缩</li>
</ul>
<h3 id="4-4-元数据管理"><a href="#4-4-元数据管理" class="headerlink" title="4.4 元数据管理"></a>4.4 元数据管理</h3><ul>
<li><strong>Timestamp 范围</strong>：在写入时计算并记录</li>
<li><strong>统计信息</strong>：记录压缩前后大小、行数等</li>
<li><strong>Manifest</strong>：统一管理文件元数据（Manifest 模式）</li>
</ul>
<h2 id="五、与-StorageV1-的对比"><a href="#五、与-StorageV1-的对比" class="headerlink" title="五、与 StorageV1 的对比"></a>五、与 StorageV1 的对比</h2><table>
<thead>
<tr>
<th>特性</th>
<th>StorageV1 (Binlog)</th>
<th>StorageV2 (Parquet)</th>
</tr>
</thead>
<tbody><tr>
<td><strong>文件格式</strong></td>
<td>Protobuf + 自定义编码</td>
<td>Apache Parquet</td>
</tr>
<tr>
<td><strong>文件组织</strong></td>
<td>每个字段一个文件</td>
<td>按列组组织，多个字段一个文件</td>
</tr>
<tr>
<td><strong>压缩率</strong></td>
<td>中等</td>
<td><strong>高（3-10倍）</strong></td>
</tr>
<tr>
<td><strong>查询性能</strong></td>
<td>需要读取多个文件</td>
<td><strong>列式访问，更高效</strong></td>
</tr>
<tr>
<td><strong>元数据</strong></td>
<td>每个文件独立元数据</td>
<td><strong>统一 Manifest 管理</strong></td>
</tr>
<tr>
<td><strong>Timestamp 存储</strong></td>
<td>独立 binlog 文件</td>
<td><strong>Arrow Record 的一列</strong></td>
</tr>
<tr>
<td><strong>类型支持</strong></td>
<td>基础类型</td>
<td><strong>支持复杂类型（JSON、嵌套结构等）</strong></td>
</tr>
</tbody></table>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><h3 id="6-1-核心流程"><a href="#6-1-核心流程" class="headerlink" title="6.1 核心流程"></a>6.1 核心流程</h3><ol>
<li><strong>数据准备</strong>：WriteBuffer → SyncPack</li>
<li><strong>数据转换</strong>：InsertData → Arrow Record（<code>serializeBinlog</code>）</li>
<li><strong>数据写入</strong>：Arrow Record → Parquet 文件（<code>writeInserts</code>）</li>
<li><strong>底层存储</strong>：通过 C++ FFI 调用 Parquet 写入器</li>
</ol>
<h3 id="6-2-关键技术"><a href="#6-2-关键技术" class="headerlink" title="6.2 关键技术"></a>6.2 关键技术</h3><ul>
<li>✅ <strong>Apache Arrow</strong>：内存中的列式数据格式</li>
<li>✅ <strong>Apache Parquet</strong>：持久化的列式存储格式</li>
<li>✅ <strong>列组机制</strong>：优化文件组织和查询性能</li>
<li>✅ <strong>零拷贝转换</strong>：Arrow → Parquet 高效转换</li>
<li>✅ <strong>FFI 集成</strong>：Go 和 C++ 无缝协作</li>
</ul>
<h3 id="6-3-优势"><a href="#6-3-优势" class="headerlink" title="6.3 优势"></a>6.3 优势</h3><ol>
<li><strong>高压缩率</strong>：节省 50-80% 存储空间</li>
<li><strong>高性能</strong>：列式访问减少 60-90% I&#x2F;O</li>
<li><strong>灵活性</strong>：支持复杂数据类型和 Schema Evolution</li>
<li><strong>兼容性</strong>：与其他大数据工具无缝集成</li>
</ol>
<p>StorageV2 通过 Arrow + Parquet 技术栈，为 Milvus 提供了高效、灵活、可扩展的存储解决方案。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Milvus-StorageV2-%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">Milvus StorageV2 写入流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">一、整体架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%95%B0%E6%8D%AE%E6%B5%81%E5%90%91"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1 数据流向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2 关键组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">二、详细流程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5%EF%BC%88WriteBuffer-%E2%86%92-SyncPack%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 数据准备阶段（WriteBuffer → SyncPack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-SyncTask-%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2 SyncTask 执行阶段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-BulkPackWriterV2-%E5%86%99%E5%85%A5%E9%98%B6%E6%AE%B5"><span class="toc-number">1.3.3.</span> <span class="toc-text">2.3 BulkPackWriterV2 写入阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-Write-%E6%96%B9%E6%B3%95%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">2.3.1 Write 方法主流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-serializeBinlog%EF%BC%9AInsertData-%E2%86%92-Arrow-Record"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">2.3.2 serializeBinlog：InsertData → Arrow Record</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-writeInserts%EF%BC%9AArrow-Record-%E2%86%92-Parquet-%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">2.3.3 writeInserts：Arrow Record → Parquet 文件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-PackedRecordWriter%EF%BC%9AArrow-%E2%86%92-Parquet-%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.4.</span> <span class="toc-text">2.4 PackedRecordWriter：Arrow → Parquet 转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-Write-%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">2.4.1 Write 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-PackedWriter%EF%BC%88C-FFI%EF%BC%89"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">2.4.2 PackedWriter（C++ FFI）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%88%97%E7%BB%84%EF%BC%88Column-Group%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.</span> <span class="toc-text">三、列组（Column Group）机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%88%97%E7%BB%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 列组概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E5%88%97%E7%BB%84%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 列组的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3 文件路径结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B3%E9%94%AE%E4%BC%98%E5%8C%96%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">四、关键优化点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%9B%B6%E6%8B%B7%E8%B4%9D%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 零拷贝转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%89%B9%E9%87%8F%E5%86%99%E5%85%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 批量写入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%8E%8B%E7%BC%A9%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3 压缩优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%85%83%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.4.</span> <span class="toc-text">4.4 元数据管理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%8E-StorageV1-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.</span> <span class="toc-text">五、与 StorageV1 的对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">六、总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">6.1 核心流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF"><span class="toc-number">1.7.2.</span> <span class="toc-text">6.2 关键技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BC%98%E5%8A%BF"><span class="toc-number">1.7.3.</span> <span class="toc-text">6.3 优势</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&text=Milvus StorageV2 写入流程分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&title=Milvus StorageV2 写入流程分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&is_video=false&description=Milvus StorageV2 写入流程分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Milvus StorageV2 写入流程分析&body=Check out this article: https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&title=Milvus StorageV2 写入流程分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&title=Milvus StorageV2 写入流程分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&title=Milvus StorageV2 写入流程分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&title=Milvus StorageV2 写入流程分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&name=Milvus StorageV2 写入流程分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2025/06/15/Milvus/storagev2_write_flow_analysis/&t=Milvus StorageV2 写入流程分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2026
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
