<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="TSO（Timestamp Oracle）生成及其作用分析概述TSO（Timestamp Oracle）是 Milvus 分布式系统中的核心组件，负责生成全局唯一、单调递增的时间戳。所有数据操作（Insert、Delete、Search 等）都需要从 TSO 获取时间戳，确保分布式环境下的事件顺序一致性。 一、TSO 的基本概念1.1 为什么需要 TSO？在分布式系统中，存在以下问题：  时钟不同">
<meta property="og:type" content="article">
<meta property="og:title" content="Milvus TSO（Timestamp Oracle）生成及其作用分析">
<meta property="og:url" content="https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="TSO（Timestamp Oracle）生成及其作用分析概述TSO（Timestamp Oracle）是 Milvus 分布式系统中的核心组件，负责生成全局唯一、单调递增的时间戳。所有数据操作（Insert、Delete、Search 等）都需要从 TSO 获取时间戳，确保分布式环境下的事件顺序一致性。 一、TSO 的基本概念1.1 为什么需要 TSO？在分布式系统中，存在以下问题：  时钟不同">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-15T02:20:00.000Z">
<meta property="article:modified_time" content="2026-01-04T12:58:01.385Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Milvus">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>Milvus TSO（Timestamp Oracle）生成及其作用分析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2025/06/15/Milvus/storagev2_write_flow_analysis/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2025/06/15/Milvus/search_flow_comprehensive_analysis/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&text=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&title=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&is_video=false&description=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Milvus TSO（Timestamp Oracle）生成及其作用分析&body=Check out this article: https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&title=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&title=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&title=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&title=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&name=Milvus TSO（Timestamp Oracle）生成及其作用分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&t=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TSO%EF%BC%88Timestamp-Oracle%EF%BC%89%E7%94%9F%E6%88%90%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">TSO（Timestamp Oracle）生成及其作用分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81TSO-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">一、TSO 的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TSO%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1 为什么需要 TSO？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-TSO-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2 TSO 的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TSO-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">二、TSO 的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%B7%B7%E5%90%88%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88Hybrid-Timestamp%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 混合时间戳（Hybrid Timestamp）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%90%84%E9%83%A8%E5%88%86%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2 各部分的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81TSO-%E7%9A%84%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">三、TSO 的生成流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 整体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-RootCoord-%E4%B8%AD%E7%9A%84-TSO-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 RootCoord 中的 TSO 服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-timestampOracle-%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">3.2.1 timestampOracle 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88InitTimestamp%EF%BC%89"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">3.2.2 初始化（InitTimestamp）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88UpdateTimestamp%EF%BC%89"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3.2.3 更新时间戳（UpdateTimestamp）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%94%9F%E6%88%90%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88GenerateTSO%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3 生成时间戳（GenerateTSO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-RootCoord-%E7%9A%84-AllocTimestamp-RPC"><span class="toc-number">1.4.4.</span> <span class="toc-text">3.4 RootCoord 的 AllocTimestamp RPC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Proxy-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-TSO"><span class="toc-number">1.5.</span> <span class="toc-text">四、Proxy 如何使用 TSO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-TimestampAllocator"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 TimestampAllocator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Insert-%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84-TSO-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 Insert 操作中的 TSO 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Delete-%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84-TSO-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3 Delete 操作中的 TSO 使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81TSO-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">五、TSO 的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BF%9D%E8%AF%81%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">5.1 保证全局事件顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%EF%BC%88Time-Synchronization%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">5.2 时间同步（Time Synchronization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">1.6.3.</span> <span class="toc-text">5.3 数据一致性保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">1.6.4.</span> <span class="toc-text">5.4 故障恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81TSO-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">六、TSO 的性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%89%B9%E9%87%8F%E5%88%86%E9%85%8D"><span class="toc-number">1.7.1.</span> <span class="toc-text">6.1 批量分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E9%A2%84%E5%88%86%E9%85%8D"><span class="toc-number">1.7.2.</span> <span class="toc-text">6.2 时间窗口预分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.7.3.</span> <span class="toc-text">6.3 内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E9%80%BB%E8%BE%91%E8%AE%A1%E6%95%B0%E5%99%A8%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86"><span class="toc-number">1.7.4.</span> <span class="toc-text">6.4 逻辑计数器溢出处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81TSO-%E7%9A%84%E9%99%90%E5%88%B6%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.8.</span> <span class="toc-text">七、TSO 的限制和注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5%E8%A6%81%E6%B1%82"><span class="toc-number">1.8.1.</span> <span class="toc-text">7.1 时钟同步要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E9%80%BB%E8%BE%91%E8%AE%A1%E6%95%B0%E5%99%A8%E9%99%90%E5%88%B6"><span class="toc-number">1.8.2.</span> <span class="toc-text">7.2 逻辑计数器限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C"><span class="toc-number">1.8.3.</span> <span class="toc-text">7.3 单点故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%97%B6%E9%97%B4%E6%88%B3%E8%8C%83%E5%9B%B4"><span class="toc-number">1.8.4.</span> <span class="toc-text">7.4 时间戳范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">八、总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-TSO-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC"><span class="toc-number">1.9.1.</span> <span class="toc-text">8.1 TSO 的核心价值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.9.2.</span> <span class="toc-text">8.2 关键设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.9.3.</span> <span class="toc-text">8.3 使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81GenerateTSO-%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.</span> <span class="toc-text">九、GenerateTSO 失败处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-GenerateTSO-%E5%86%85%E9%83%A8%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.1.</span> <span class="toc-text">9.1 GenerateTSO 内部重试机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-Proxy-%E5%B1%82%E7%9A%84%E8%B6%85%E6%97%B6%E5%92%8C%E9%87%8D%E8%AF%95"><span class="toc-number">1.10.2.</span> <span class="toc-text">9.2 Proxy 层的超时和重试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-Context-%E8%B6%85%E6%97%B6"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">9.2.1 Context 超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-gRPC-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E8%AF%95"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">9.2.2 gRPC 客户端重试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E4%BB%BB%E5%8A%A1%E5%85%A5%E9%98%9F%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86"><span class="toc-number">1.10.3.</span> <span class="toc-text">9.3 任务入队失败处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%A4%B1%E8%B4%A5%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.10.4.</span> <span class="toc-text">9.4 失败场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-1%EF%BC%9ARootCoord-%E6%9C%AA%E5%90%AF%E5%8A%A8%E6%88%96%E4%B8%8D%E5%8F%AF%E7%94%A8"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">场景 1：RootCoord 未启动或不可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-2%EF%BC%9ATSO-%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88RootCoord-%E5%88%9A%E5%90%AF%E5%8A%A8%EF%BC%89"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">场景 2：TSO 未初始化（RootCoord 刚启动）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-3%EF%BC%9A%E9%80%BB%E8%BE%91%E8%AE%A1%E6%95%B0%E5%99%A8%E6%BA%A2%E5%87%BA"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">场景 3：逻辑计数器溢出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.5.</span> <span class="toc-text">9.5 总结</span></a></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Milvus TSO（Timestamp Oracle）生成及其作用分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-06-15T02:20:00.000Z" itemprop="datePublished">2025-06-15</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Milvus/" rel="tag">Milvus</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="TSO（Timestamp-Oracle）生成及其作用分析"><a href="#TSO（Timestamp-Oracle）生成及其作用分析" class="headerlink" title="TSO（Timestamp Oracle）生成及其作用分析"></a>TSO（Timestamp Oracle）生成及其作用分析</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TSO（Timestamp Oracle）是 Milvus 分布式系统中的核心组件，负责生成全局唯一、单调递增的时间戳。所有数据操作（Insert、Delete、Search 等）都需要从 TSO 获取时间戳，确保分布式环境下的事件顺序一致性。</p>
<h2 id="一、TSO-的基本概念"><a href="#一、TSO-的基本概念" class="headerlink" title="一、TSO 的基本概念"></a>一、TSO 的基本概念</h2><h3 id="1-1-为什么需要-TSO？"><a href="#1-1-为什么需要-TSO？" class="headerlink" title="1.1 为什么需要 TSO？"></a>1.1 为什么需要 TSO？</h3><p>在分布式系统中，存在以下问题：</p>
<ol>
<li><strong>时钟不同步</strong>：不同节点的本地时钟可能不一致</li>
<li><strong>网络延迟</strong>：消息在网络中传输存在延迟，可能导致乱序</li>
<li><strong>事件顺序</strong>：需要保证全局事件的有序性</li>
</ol>
<p><strong>示例场景</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用户 u1 和 u2 在不同节点上操作：</span><br><span class="line">- t0: u1 创建 Collection C0</span><br><span class="line">- t2: u2 在 C0 上搜索（应该看到空集合）</span><br><span class="line">- t5: u1 插入数据 A1</span><br><span class="line">- t7: u2 在 C0 上搜索（应该看到 A1）</span><br><span class="line">- t15: u1 删除 A1</span><br><span class="line">- t17: u2 在 C0 上搜索（应该看不到 A1）</span><br></pre></td></tr></table></figure>

<p>如果没有 TSO，由于时钟不同步和网络延迟，u2 可能看到不一致的数据状态。</p>
<h3 id="1-2-TSO-的解决方案"><a href="#1-2-TSO-的解决方案" class="headerlink" title="1.2 TSO 的解决方案"></a>1.2 TSO 的解决方案</h3><ul>
<li><strong>统一时间源</strong>：所有组件从 RootCoord 的 TSO 服务获取时间戳，而不是使用本地时钟</li>
<li><strong>全局有序</strong>：TSO 保证生成的时间戳全局唯一且单调递增</li>
<li><strong>时间同步</strong>：通过 TimeTick 机制确保消息流的顺序处理</li>
</ul>
<h2 id="二、TSO-的数据结构"><a href="#二、TSO-的数据结构" class="headerlink" title="二、TSO 的数据结构"></a>二、TSO 的数据结构</h2><h3 id="2-1-混合时间戳（Hybrid-Timestamp）"><a href="#2-1-混合时间戳（Hybrid-Timestamp）" class="headerlink" title="2.1 混合时间戳（Hybrid Timestamp）"></a>2.1 混合时间戳（Hybrid Timestamp）</h3><p>TSO 生成的时间戳是 <code>uint64</code> 类型，采用混合结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────┐</span><br><span class="line">│                   64 bits (uint64)                       │</span><br><span class="line">├──────────────────────────────┬──────────────────────────┤</span><br><span class="line">│   Physical Part (46 bits)    │ Logical Part (18 bits)   │</span><br><span class="line">│   UTC 时间（毫秒）              │   逻辑计数器              │</span><br><span class="line">└──────────────────────────────┴──────────────────────────┘</span><br></pre></td></tr></table></figure>

<p><strong>代码实现</strong>（<code>pkg/util/tsoutil/tso.go</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    logicalBits     = <span class="number">18</span></span><br><span class="line">    logicalBitsMask = (<span class="number">1</span> &lt;&lt; logicalBits) - <span class="number">1</span>  <span class="comment">// 0x3FFFF</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ComposeTS 组合物理时间和逻辑时间</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ComposeTS</span><span class="params">(physical, logical <span class="type">int64</span>)</span></span> <span class="type">uint64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">uint64</span>((physical &lt;&lt; logicalBits) + logical)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ParseTS 解析时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ParseTS</span><span class="params">(ts <span class="type">uint64</span>)</span></span> (time.Time, <span class="type">uint64</span>) &#123;</span><br><span class="line">    logical := ts &amp; logicalBitsMask           <span class="comment">// 提取逻辑部分（低 18 位）</span></span><br><span class="line">    physical := ts &gt;&gt; logicalBits              <span class="comment">// 提取物理部分（高 46 位）</span></span><br><span class="line">    physicalTime := time.Unix(<span class="type">int64</span>(physical/<span class="number">1000</span>), </span><br><span class="line">        <span class="type">int64</span>(physical)%<span class="number">1000</span>*time.Millisecond.Nanoseconds())</span><br><span class="line">    <span class="keyword">return</span> physicalTime, logical</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-各部分的作用"><a href="#2-2-各部分的作用" class="headerlink" title="2.2 各部分的作用"></a>2.2 各部分的作用</h3><table>
<thead>
<tr>
<th>部分</th>
<th>位数</th>
<th>作用</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Physical Part</strong></td>
<td>46 bits</td>
<td>UTC 时间（毫秒）</td>
<td>约 8925 年</td>
</tr>
<tr>
<td><strong>Logical Part</strong></td>
<td>18 bits</td>
<td>逻辑计数器</td>
<td>0 ~ 262,143 (2^18-1)</td>
</tr>
</tbody></table>
<p><strong>优势</strong>：</p>
<ul>
<li><strong>高精度</strong>：同一毫秒内可生成最多 262,143 个时间戳</li>
<li><strong>时间可读</strong>：物理部分可以直接转换为 UTC 时间</li>
<li><strong>全局唯一</strong>：物理时间 + 逻辑计数器保证唯一性</li>
</ul>
<h2 id="三、TSO-的生成流程"><a href="#三、TSO-的生成流程" class="headerlink" title="三、TSO 的生成流程"></a>三、TSO 的生成流程</h2><h3 id="3-1-整体架构"><a href="#3-1-整体架构" class="headerlink" title="3.1 整体架构"></a>3.1 整体架构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐         ┌──────────────┐         ┌─────────────┐</span><br><span class="line">│   Proxy     │────────▶│  RootCoord   │────────▶│    etcd      │</span><br><span class="line">│             │ Request │              │ Save    │              │</span><br><span class="line">│             │◀────────│  TSO Service │◀────────│              │</span><br><span class="line">└─────────────┘ Response└──────────────┘ Load    └─────────────┘</span><br></pre></td></tr></table></figure>

<h3 id="3-2-RootCoord-中的-TSO-服务"><a href="#3-2-RootCoord-中的-TSO-服务" class="headerlink" title="3.2 RootCoord 中的 TSO 服务"></a>3.2 RootCoord 中的 TSO 服务</h3><p><strong>文件</strong>: <code>internal/tso/tso.go</code></p>
<h4 id="3-2-1-timestampOracle-结构"><a href="#3-2-1-timestampOracle-结构" class="headerlink" title="3.2.1 timestampOracle 结构"></a>3.2.1 timestampOracle 结构</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timestampOracle <span class="keyword">struct</span> &#123;</span><br><span class="line">    key   <span class="type">string</span>              <span class="comment">// etcd 中的 key</span></span><br><span class="line">    txnKV kv.TxnKV            <span class="comment">// etcd 客户端</span></span><br><span class="line">    </span><br><span class="line">    saveInterval  time.Duration  <span class="comment">// 保存间隔（默认 3 秒）</span></span><br><span class="line">    maxResetTSGap <span class="function"><span class="keyword">func</span><span class="params">()</span></span> time.Duration</span><br><span class="line">    </span><br><span class="line">    TSO           unsafe.Pointer  <span class="comment">// 当前 TSO（原子指针）</span></span><br><span class="line">    lastSavedTime atomic.Value    <span class="comment">// 最后保存的时间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// atomicObject 存储当前 TSO 状态</span></span><br><span class="line"><span class="keyword">type</span> atomicObject <span class="keyword">struct</span> &#123;</span><br><span class="line">    physical time.Time  <span class="comment">// 物理时间</span></span><br><span class="line">    logical  <span class="type">int64</span>      <span class="comment">// 逻辑计数器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-初始化（InitTimestamp）"><a href="#3-2-2-初始化（InitTimestamp）" class="headerlink" title="3.2.2 初始化（InitTimestamp）"></a>3.2.2 初始化（InitTimestamp）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timestampOracle)</span></span> InitTimestamp() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 从 etcd 加载上次保存的时间戳</span></span><br><span class="line">    last, err := t.loadTimestamp()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 获取当前系统时间</span></span><br><span class="line">    next := time.Now()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 如果系统时间与 etcd 时间差距太小，使用 etcd 时间</span></span><br><span class="line">    <span class="keyword">if</span> typeutil.SubTimeByWallClock(next, last) &lt; updateTimestampGuard &#123;</span><br><span class="line">        next = last.Add(updateTimestampGuard)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 保存未来时间窗口到 etcd（提前保存，避免频繁写 etcd）</span></span><br><span class="line">    save := next.Add(t.saveInterval)  <span class="comment">// saveInterval = 3 秒</span></span><br><span class="line">    <span class="keyword">if</span> err := t.saveTimestamp(save); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 初始化内存中的 TSO</span></span><br><span class="line">    current := &amp;atomicObject&#123;</span><br><span class="line">        physical: next,</span><br><span class="line">        logical:  <span class="number">0</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    atomic.StorePointer(&amp;t.TSO, unsafe.Pointer(current))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li>从 etcd 恢复上次保存的时间戳</li>
<li>提前保存未来 3 秒的时间窗口，减少 etcd 写入</li>
<li>使用原子指针保证线程安全</li>
</ul>
<h4 id="3-2-3-更新时间戳（UpdateTimestamp）"><a href="#3-2-3-更新时间戳（UpdateTimestamp）" class="headerlink" title="3.2.3 更新时间戳（UpdateTimestamp）"></a>3.2.3 更新时间戳（UpdateTimestamp）</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *timestampOracle)</span></span> UpdateTimestamp() <span class="type">error</span> &#123;</span><br><span class="line">    prev := (*atomicObject)(atomic.LoadPointer(&amp;t.TSO))</span><br><span class="line">    now := time.Now()</span><br><span class="line">    </span><br><span class="line">    jetLag := typeutil.SubTimeByWallClock(now, prev.physical)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> next time.Time</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况 1：系统时间比物理时间大，同步到系统时间</span></span><br><span class="line">    <span class="keyword">if</span> jetLag &gt; updateTimestampGuard &#123;</span><br><span class="line">        next = now</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 情况 2：逻辑计数器快用完了，增加物理时间</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> prevLogical &gt; maxLogical/<span class="number">2</span> &#123;</span><br><span class="line">        next = prev.physical.Add(time.Millisecond)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 情况 3：时间窗口足够，不需要更新</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 如果时间窗口不够，需要更新 etcd</span></span><br><span class="line">    <span class="keyword">if</span> typeutil.SubTimeByWallClock(t.lastSavedTime.Load().(time.Time), next) &lt;= updateTimestampGuard &#123;</span><br><span class="line">        save := next.Add(t.saveInterval)</span><br><span class="line">        <span class="keyword">if</span> err := t.saveTimestamp(save); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 更新内存中的 TSO</span></span><br><span class="line">    current := &amp;atomicObject&#123;</span><br><span class="line">        physical: next,</span><br><span class="line">        logical:  <span class="number">0</span>,  <span class="comment">// 重置逻辑计数器</span></span><br><span class="line">    &#125;</span><br><span class="line">    atomic.StorePointer(&amp;t.TSO, unsafe.Pointer(current))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>更新触发条件</strong>：</p>
<ol>
<li>系统时间比物理时间大（时钟同步）</li>
<li>逻辑计数器超过 <code>maxLogical/2</code>（131,071），需要增加物理时间</li>
<li>时间窗口不足，需要更新 etcd</li>
</ol>
<h3 id="3-3-生成时间戳（GenerateTSO）"><a href="#3-3-生成时间戳（GenerateTSO）" class="headerlink" title="3.3 生成时间戳（GenerateTSO）"></a>3.3 生成时间戳（GenerateTSO）</h3><p><strong>文件</strong>: <code>internal/tso/global_allocator.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gta *GlobalTSOAllocator)</span></span> GenerateTSO(count <span class="type">uint32</span>) (<span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> physical, logical <span class="type">int64</span></span><br><span class="line">    </span><br><span class="line">    maxRetryCount := <span class="number">10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxRetryCount; i++ &#123;</span><br><span class="line">        <span class="comment">// 1. 获取当前 TSO 对象</span></span><br><span class="line">        current := (*atomicObject)(atomic.LoadPointer(&amp;gta.tso.TSO))</span><br><span class="line">        <span class="keyword">if</span> current == <span class="literal">nil</span> || current.physical.Equal(typeutil.ZeroTime) &#123;</span><br><span class="line">            <span class="comment">// TSO 未初始化，等待</span></span><br><span class="line">            time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 2. 原子增加逻辑计数器</span></span><br><span class="line">        physical = current.physical.UnixMilli()</span><br><span class="line">        logical = atomic.AddInt64(&amp;current.logical, <span class="type">int64</span>(count))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 3. 检查逻辑计数器是否溢出</span></span><br><span class="line">        <span class="keyword">if</span> logical &gt;= maxLogical &amp;&amp; gta.LimitMaxLogic &#123;</span><br><span class="line">            log.Info(<span class="string">&quot;logical part outside of max logical interval, please check ntp time&quot;</span>)</span><br><span class="line">            time.Sleep(UpdateTimestampStep)  <span class="comment">// 等待 50ms，触发 UpdateTimestamp</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 4. 组合时间戳</span></span><br><span class="line">        <span class="keyword">return</span> tsoutil.ComposeTS(physical, logical), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;can not get timestamp&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li>使用原子操作增加逻辑计数器，保证线程安全</li>
<li>支持批量分配（<code>count</code> 个时间戳）</li>
<li>如果逻辑计数器溢出，等待并触发 <code>UpdateTimestamp</code></li>
</ul>
<h3 id="3-4-RootCoord-的-AllocTimestamp-RPC"><a href="#3-4-RootCoord-的-AllocTimestamp-RPC" class="headerlink" title="3.4 RootCoord 的 AllocTimestamp RPC"></a>3.4 RootCoord 的 AllocTimestamp RPC</h3><p><strong>文件</strong>: <code>internal/rootcoord/root_coord.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span></span> AllocTimestamp(ctx context.Context, in *rootcoordpb.AllocTimestampRequest) </span><br><span class="line">    (*rootcoordpb.AllocTimestampResponse, <span class="type">error</span>) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 检查健康状态</span></span><br><span class="line">    <span class="keyword">if</span> err := merr.CheckHealthy(c.GetStateCode()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;rootcoordpb.AllocTimestampResponse&#123;Status: merr.Status(err)&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 处理阻塞时间戳（用于数据恢复等场景）</span></span><br><span class="line">    <span class="keyword">if</span> in.BlockTimestamp &gt; <span class="number">0</span> &#123;</span><br><span class="line">        blockTime, _ := tsoutil.ParseTS(in.BlockTimestamp)</span><br><span class="line">        lastTime := c.tsoAllocator.GetLastSavedTime()</span><br><span class="line">        deltaDuration := blockTime.Sub(lastTime)</span><br><span class="line">        <span class="keyword">if</span> deltaDuration &gt; <span class="number">0</span> &#123;</span><br><span class="line">            time.Sleep(deltaDuration + time.Millisecond*<span class="number">200</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 生成 TSO</span></span><br><span class="line">    ts, err := c.tsoAllocator.GenerateTSO(in.GetCount())</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &amp;rootcoordpb.AllocTimestampResponse&#123;Status: merr.Status(err)&#125;, <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 返回第一个可用时间戳</span></span><br><span class="line">    <span class="comment">// 注意：GenerateTSO 返回的是最后一个时间戳，需要减去 count-1</span></span><br><span class="line">    ts = ts - <span class="type">uint64</span>(in.GetCount()) + <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> &amp;rootcoordpb.AllocTimestampResponse&#123;</span><br><span class="line">        Status:    merr.Success(),</span><br><span class="line">        Timestamp: ts,  <span class="comment">// 第一个可用时间戳</span></span><br><span class="line">        Count:     in.GetCount(),</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Proto 定义</strong>：</p>
<figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">service </span><span class="title class_">RootCoord</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">rpc</span> AllocTimestamp(AllocTimestampRequest) <span class="keyword">returns</span> (AllocTimestampResponse) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">AllocTimestampRequest</span> &#123;</span><br><span class="line">    common.MsgBase base = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint32</span> count = <span class="number">3</span>;  <span class="comment">// 请求的时间戳数量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">AllocTimestampResponse</span> &#123;</span><br><span class="line">    common.Status status = <span class="number">1</span>;</span><br><span class="line">    <span class="type">uint64</span> timestamp = <span class="number">2</span>;  <span class="comment">// 第一个可用时间戳</span></span><br><span class="line">    <span class="type">uint32</span> count = <span class="number">3</span>;      <span class="comment">// 分配的数量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="四、Proxy-如何使用-TSO"><a href="#四、Proxy-如何使用-TSO" class="headerlink" title="四、Proxy 如何使用 TSO"></a>四、Proxy 如何使用 TSO</h2><h3 id="4-1-TimestampAllocator"><a href="#4-1-TimestampAllocator" class="headerlink" title="4.1 TimestampAllocator"></a>4.1 TimestampAllocator</h3><p><strong>文件</strong>: <code>internal/proxy/timestamp.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> timestampAllocator <span class="keyword">struct</span> &#123;</span><br><span class="line">    peerID <span class="type">int64</span></span><br><span class="line">    tso    types.RootCoordClient</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ta *timestampAllocator)</span></span> alloc(ctx context.Context, count <span class="type">uint32</span>) ([]Timestamp, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 构建请求</span></span><br><span class="line">    req := &amp;rootcoordpb.AllocTimestampRequest&#123;</span><br><span class="line">        Base: commonpbutil.NewMsgBase(</span><br><span class="line">            commonpbutil.WithMsgType(commonpb.MsgType_RequestTSO),</span><br><span class="line">            commonpbutil.WithSourceID(ta.peerID),</span><br><span class="line">        ),</span><br><span class="line">        Count: count,</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 调用 RootCoord 的 AllocTimestamp</span></span><br><span class="line">    resp, err := ta.tso.AllocTimestamp(ctx, req)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 生成时间戳数组</span></span><br><span class="line">    start, cnt := resp.GetTimestamp(), resp.GetCount()</span><br><span class="line">    ret := <span class="built_in">make</span>([]Timestamp, cnt)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="type">uint32</span>(<span class="number">0</span>); i &lt; cnt; i++ &#123;</span><br><span class="line">        ret[i] = start + <span class="type">uint64</span>(i)  <span class="comment">// 连续的时间戳</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> ret, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AllocOne 分配单个时间戳</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ta *timestampAllocator)</span></span> AllocOne(ctx context.Context) (Timestamp, <span class="type">error</span>) &#123;</span><br><span class="line">    ret, err := ta.alloc(ctx, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret[<span class="number">0</span>], <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-Insert-操作中的-TSO-使用"><a href="#4-2-Insert-操作中的-TSO-使用" class="headerlink" title="4.2 Insert 操作中的 TSO 使用"></a>4.2 Insert 操作中的 TSO 使用</h3><p><strong>文件</strong>: <code>internal/proxy/task_insert.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(it *insertTask)</span></span> insertPreExecute(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 分配主键 ID</span></span><br><span class="line">    rowNums := <span class="type">uint32</span>(it.insertMsg.NRows())</span><br><span class="line">    rowIDBegin, rowIDEnd, _ := common.AllocAutoID(it.idAllocator.Alloc, rowNums, clusterID)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 为每行分配时间戳</span></span><br><span class="line">    rowNum := it.insertMsg.NRows()</span><br><span class="line">    it.insertMsg.Timestamps = <span class="built_in">make</span>([]<span class="type">uint64</span>, rowNum)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 批量分配时间戳（性能优化）</span></span><br><span class="line">    timestamps, err := it.timestampAllocator.AllocTimestamp(ctx, <span class="type">uint32</span>(rowNum))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 为每行设置时间戳</span></span><br><span class="line">    <span class="keyword">for</span> index := <span class="keyword">range</span> it.insertMsg.Timestamps &#123;</span><br><span class="line">        it.insertMsg.Timestamps[index] = timestamps[index]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Delete-操作中的-TSO-使用"><a href="#4-3-Delete-操作中的-TSO-使用" class="headerlink" title="4.3 Delete 操作中的 TSO 使用"></a>4.3 Delete 操作中的 TSO 使用</h3><p><strong>文件</strong>: <code>internal/proxy/task_delete.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dr *deleteRunner)</span></span> Run(ctx context.Context) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 分配时间戳</span></span><br><span class="line">    ts, err := dr.tsoAllocatorIns.AllocOne(ctx)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 设置删除消息的时间戳</span></span><br><span class="line">    dr.deleteMsg.Timestamps = []<span class="type">uint64</span>&#123;ts&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 发送删除消息到消息流</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="五、TSO-的作用"><a href="#五、TSO-的作用" class="headerlink" title="五、TSO 的作用"></a>五、TSO 的作用</h2><h3 id="5-1-保证全局事件顺序"><a href="#5-1-保证全局事件顺序" class="headerlink" title="5.1 保证全局事件顺序"></a>5.1 保证全局事件顺序</h3><p><strong>场景</strong>：多个 Proxy 同时写入数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Proxy1: Insert A (ts=100)</span><br><span class="line">Proxy2: Insert B (ts=150)</span><br><span class="line">Proxy1: Insert C (ts=200)</span><br><span class="line">Proxy2: Delete A (ts=250)</span><br></pre></td></tr></table></figure>

<p>所有操作都从同一个 TSO 获取时间戳，保证全局顺序：</p>
<ul>
<li>A 在 B 之前插入（100 &lt; 150）</li>
<li>C 在 B 之后插入（200 &gt; 150）</li>
<li>Delete A 在 Insert C 之后（250 &gt; 200）</li>
</ul>
<h3 id="5-2-时间同步（Time-Synchronization）"><a href="#5-2-时间同步（Time-Synchronization）" class="headerlink" title="5.2 时间同步（Time Synchronization）"></a>5.2 时间同步（Time Synchronization）</h3><p><strong>问题</strong>：如何确保消息流中所有小于某个时间戳的消息都已处理？</p>
<p><strong>解决方案</strong>：TimeTick 机制</p>
<ol>
<li><p><strong>Proxy 上报时间戳</strong>：</p>
<ul>
<li>每个 Proxy 定期（默认 200ms）向 RootCoord 上报每个消息流的最新时间戳</li>
</ul>
</li>
<li><p><strong>RootCoord 计算最小时间戳</strong>：</p>
<ul>
<li>对于每个消息流，RootCoord 计算所有 Proxy 上报的最小时间戳</li>
</ul>
</li>
<li><p><strong>插入 TimeTick 消息</strong>：</p>
<ul>
<li>RootCoord 将最小时间戳作为 TimeTick 消息插入到消息流中</li>
</ul>
</li>
<li><p><strong>消费者处理</strong>：</p>
<ul>
<li>当消费者读取到 TimeTick 消息时，表示所有小于该时间戳的消息都已处理完成</li>
</ul>
</li>
</ol>
<p><strong>代码</strong>（<code>internal/rootcoord/root_coord.go</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Core)</span></span> UpdateChannelTimeTick(ctx context.Context, in *internalpb.ChannelTimeTickMsg) </span><br><span class="line">    (*commonpb.Status, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新每个 Channel 的时间戳</span></span><br><span class="line">    err := c.chanTimeTick.updateTimeTick(in, <span class="string">&quot;gRPC&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> merr.Status(err), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-数据一致性保证"><a href="#5-3-数据一致性保证" class="headerlink" title="5.3 数据一致性保证"></a>5.3 数据一致性保证</h3><p><strong>场景</strong>：查询操作需要看到一致的数据快照</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1: Insert A (ts=100)</span><br><span class="line">t2: Insert B (ts=200)</span><br><span class="line">t3: Search (ts=150)  // 应该只看到 A，看不到 B</span><br><span class="line">t4: Delete A (ts=250)</span><br><span class="line">t5: Search (ts=300)   // 应该只看到 B</span><br></pre></td></tr></table></figure>

<p>通过 TSO 时间戳：</p>
<ul>
<li>查询操作获取时间戳 <code>ts_query</code></li>
<li>只处理时间戳 <code>&lt;= ts_query</code> 的数据</li>
<li>保证查询结果的一致性</li>
</ul>
<h3 id="5-4-故障恢复"><a href="#5-4-故障恢复" class="headerlink" title="5.4 故障恢复"></a>5.4 故障恢复</h3><p><strong>场景</strong>：系统重启后恢复时间戳</p>
<ol>
<li><p><strong>持久化到 etcd</strong>：</p>
<ul>
<li>RootCoord 定期将时间戳保存到 etcd</li>
</ul>
</li>
<li><p><strong>恢复时间戳</strong>：</p>
<ul>
<li>重启后，从 etcd 加载上次保存的时间戳</li>
<li>确保新生成的时间戳大于已保存的时间戳</li>
</ul>
</li>
<li><p><strong>防止时间回退</strong>：</p>
<ul>
<li>如果系统时间回退，使用 etcd 中的时间戳</li>
<li>保证时间戳单调递增</li>
</ul>
</li>
</ol>
<h2 id="六、TSO-的性能优化"><a href="#六、TSO-的性能优化" class="headerlink" title="六、TSO 的性能优化"></a>六、TSO 的性能优化</h2><h3 id="6-1-批量分配"><a href="#6-1-批量分配" class="headerlink" title="6.1 批量分配"></a>6.1 批量分配</h3><ul>
<li><strong>减少 RPC 调用</strong>：Proxy 可以一次请求多个时间戳</li>
<li><strong>提高吞吐量</strong>：减少网络往返次数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次分配 100 个时间戳</span></span><br><span class="line">timestamps, err := tsoAllocator.AllocTimestamp(ctx, <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<h3 id="6-2-时间窗口预分配"><a href="#6-2-时间窗口预分配" class="headerlink" title="6.2 时间窗口预分配"></a>6.2 时间窗口预分配</h3><ul>
<li><strong>减少 etcd 写入</strong>：提前保存未来 3 秒的时间窗口</li>
<li><strong>提高性能</strong>：避免频繁写 etcd</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">saveInterval = <span class="number">3</span> * time.Second  <span class="comment">// 提前保存 3 秒</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-内存分配"><a href="#6-3-内存分配" class="headerlink" title="6.3 内存分配"></a>6.3 内存分配</h3><ul>
<li><strong>原子操作</strong>：使用原子操作更新逻辑计数器，无锁</li>
<li><strong>高性能</strong>：避免锁竞争</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">logical = atomic.AddInt64(&amp;current.logical, <span class="type">int64</span>(count))</span><br></pre></td></tr></table></figure>

<h3 id="6-4-逻辑计数器溢出处理"><a href="#6-4-逻辑计数器溢出处理" class="headerlink" title="6.4 逻辑计数器溢出处理"></a>6.4 逻辑计数器溢出处理</h3><ul>
<li><strong>自动增加物理时间</strong>：当逻辑计数器超过 <code>maxLogical/2</code> 时，自动增加物理时间</li>
<li><strong>保证可用性</strong>：不会因为逻辑计数器用完而阻塞</li>
</ul>
<h2 id="七、TSO-的限制和注意事项"><a href="#七、TSO-的限制和注意事项" class="headerlink" title="七、TSO 的限制和注意事项"></a>七、TSO 的限制和注意事项</h2><h3 id="7-1-时钟同步要求"><a href="#7-1-时钟同步要求" class="headerlink" title="7.1 时钟同步要求"></a>7.1 时钟同步要求</h3><ul>
<li><strong>NTP 同步</strong>：建议所有节点使用 NTP 同步时钟</li>
<li><strong>时钟偏移检测</strong>：如果时钟偏移超过 3 倍 <code>UpdateTimestampStep</code>（150ms），会记录警告日志</li>
</ul>
<h3 id="7-2-逻辑计数器限制"><a href="#7-2-逻辑计数器限制" class="headerlink" title="7.2 逻辑计数器限制"></a>7.2 逻辑计数器限制</h3><ul>
<li><strong>最大逻辑值</strong>：<code>maxLogical = 2^18 = 262,143</code></li>
<li><strong>同一毫秒内最多生成</strong>：262,143 个时间戳</li>
<li><strong>如果超过</strong>：需要等待下一毫秒</li>
</ul>
<h3 id="7-3-单点故障"><a href="#7-3-单点故障" class="headerlink" title="7.3 单点故障"></a>7.3 单点故障</h3><ul>
<li><strong>RootCoord 是单点</strong>：如果 RootCoord 故障，无法分配时间戳</li>
<li><strong>高可用方案</strong>：通过 etcd 的 Leader 选举实现高可用</li>
</ul>
<h3 id="7-4-时间戳范围"><a href="#7-4-时间戳范围" class="headerlink" title="7.4 时间戳范围"></a>7.4 时间戳范围</h3><ul>
<li><strong>物理时间范围</strong>：<ul>
<li>最小值：<code>1546300800000</code>（2019-01-01 00:00:00 UTC）</li>
<li>最大值：<code>253402300799000</code>（9999-12-31 23:59:59 UTC）</li>
</ul>
</li>
</ul>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><h3 id="8-1-TSO-的核心价值"><a href="#8-1-TSO-的核心价值" class="headerlink" title="8.1 TSO 的核心价值"></a>8.1 TSO 的核心价值</h3><ol>
<li>✅ <strong>全局唯一时间戳</strong>：保证分布式环境下事件顺序</li>
<li>✅ <strong>时间同步</strong>：解决时钟不同步和网络延迟问题</li>
<li>✅ <strong>数据一致性</strong>：支持基于时间戳的快照查询</li>
<li>✅ <strong>高性能</strong>：批量分配、时间窗口预分配等优化</li>
</ol>
<h3 id="8-2-关键设计"><a href="#8-2-关键设计" class="headerlink" title="8.2 关键设计"></a>8.2 关键设计</h3><ul>
<li><strong>混合时间戳</strong>：物理时间（46 bits）+ 逻辑计数器（18 bits）</li>
<li><strong>持久化</strong>：定期保存到 etcd，支持故障恢复</li>
<li><strong>原子操作</strong>：使用原子操作保证线程安全</li>
<li><strong>批量分配</strong>：支持一次分配多个时间戳</li>
</ul>
<h3 id="8-3-使用场景"><a href="#8-3-使用场景" class="headerlink" title="8.3 使用场景"></a>8.3 使用场景</h3><ul>
<li><strong>Insert&#x2F;Delete 操作</strong>：为每行数据分配时间戳</li>
<li><strong>查询操作</strong>：获取查询时间戳，保证一致性</li>
<li><strong>消息流处理</strong>：通过 TimeTick 确保消息顺序</li>
<li><strong>故障恢复</strong>：从 etcd 恢复时间戳状态</li>
</ul>
<p>TSO 是 Milvus 分布式系统的核心基础设施，为整个系统提供了全局有序的时间基准，确保了数据一致性和系统可靠性。</p>
<h2 id="九、GenerateTSO-失败处理机制"><a href="#九、GenerateTSO-失败处理机制" class="headerlink" title="九、GenerateTSO 失败处理机制"></a>九、GenerateTSO 失败处理机制</h2><h3 id="9-1-GenerateTSO-内部重试机制"><a href="#9-1-GenerateTSO-内部重试机制" class="headerlink" title="9.1 GenerateTSO 内部重试机制"></a>9.1 GenerateTSO 内部重试机制</h3><p><code>GenerateTSO</code> 方法内部实现了重试机制，不会立即失败：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(gta *GlobalTSOAllocator)</span></span> GenerateTSO(count <span class="type">uint32</span>) (<span class="type">uint64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    maxRetryCount := <span class="number">10</span>  <span class="comment">// 最多重试 10 次</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxRetryCount; i++ &#123;</span><br><span class="line">        current := (*atomicObject)(atomic.LoadPointer(&amp;gta.tso.TSO))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况 1：TSO 未初始化，等待 200ms 后重试</span></span><br><span class="line">        <span class="keyword">if</span> current == <span class="literal">nil</span> || current.physical.Equal(typeutil.ZeroTime) &#123;</span><br><span class="line">            log.Info(<span class="string">&quot;sync hasn&#x27;t completed yet, wait for a while&quot;</span>)</span><br><span class="line">            time.Sleep(<span class="number">200</span> * time.Millisecond)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 情况 2：逻辑计数器溢出，等待 50ms 后重试</span></span><br><span class="line">        logical = atomic.AddInt64(&amp;current.logical, <span class="type">int64</span>(count))</span><br><span class="line">        <span class="keyword">if</span> logical &gt;= maxLogical &amp;&amp; gta.LimitMaxLogic &#123;</span><br><span class="line">            log.Info(<span class="string">&quot;logical part outside of max logical interval&quot;</span>)</span><br><span class="line">            time.Sleep(UpdateTimestampStep)  <span class="comment">// 50ms</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> tsoutil.ComposeTS(physical, logical), <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有重试都失败，返回错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>, errors.New(<span class="string">&quot;can not get timestamp&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>重试场景</strong>：</p>
<ol>
<li><strong>TSO 未初始化</strong>：等待 200ms 后重试（最多 10 次，总等待时间约 2 秒）</li>
<li><strong>逻辑计数器溢出</strong>：等待 50ms 后重试（等待 <code>UpdateTimestamp</code> 更新物理时间）</li>
</ol>
<h3 id="9-2-Proxy-层的超时和重试"><a href="#9-2-Proxy-层的超时和重试" class="headerlink" title="9.2 Proxy 层的超时和重试"></a>9.2 Proxy 层的超时和重试</h3><p>Proxy 调用 TSO 时有多层保护：</p>
<h4 id="9-2-1-Context-超时"><a href="#9-2-1-Context-超时" class="headerlink" title="9.2.1 Context 超时"></a>9.2.1 Context 超时</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ta *timestampAllocator)</span></span> alloc(ctx context.Context, count <span class="type">uint32</span>) ([]Timestamp, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置 10 秒超时</span></span><br><span class="line">    ctx, cancel := context.WithTimeout(ctx, <span class="number">10</span>*time.Second)</span><br><span class="line">    <span class="keyword">defer</span> cancel()</span><br><span class="line">    </span><br><span class="line">    resp, err := ta.tso.AllocTimestamp(ctx, req)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>超时保护</strong>：如果 RootCoord 无响应，10 秒后自动超时，不会永久阻塞。</p>
<h4 id="9-2-2-gRPC-客户端重试"><a href="#9-2-2-gRPC-客户端重试" class="headerlink" title="9.2.2 gRPC 客户端重试"></a>9.2.2 gRPC 客户端重试</h4><p>Proxy 的 gRPC 客户端有自动重试机制：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// internal/util/grpcclient/client.go</span></span><br><span class="line">retry.Handle(ctx, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> (<span class="type">bool</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 执行 RPC 调用</span></span><br><span class="line">    ret, err = caller(wrapper.client)</span><br><span class="line">    <span class="comment">// 检查错误，决定是否重试</span></span><br><span class="line">    <span class="keyword">return</span> needRetry, err</span><br><span class="line">&#125;, </span><br><span class="line">    retry.Attempts(<span class="number">10</span>),                    <span class="comment">// 最多重试 10 次</span></span><br><span class="line">    retry.Sleep(<span class="number">200</span>*time.Millisecond),     <span class="comment">// 初始退避 200ms</span></span><br><span class="line">    retry.MaxSleepTime(<span class="number">10</span>*time.Second))    <span class="comment">// 最大退避 10 秒</span></span><br></pre></td></tr></table></figure>

<p><strong>重试策略</strong>：</p>
<ul>
<li>最多重试 10 次</li>
<li>初始退避：200ms</li>
<li>最大退避：10 秒</li>
<li>总耗时：最多约 52.8 秒（如果所有重试都失败）</li>
</ul>
<h3 id="9-3-任务入队失败处理"><a href="#9-3-任务入队失败处理" class="headerlink" title="9.3 任务入队失败处理"></a>9.3 任务入队失败处理</h3><p>当 TSO 分配失败时，任务无法入队，会立即返回错误：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(queue *baseTaskQueue)</span></span> Enqueue(t task) <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> t.CanSkipAllocTimestamp() &#123;</span><br><span class="line">        <span class="comment">// 某些任务可以跳过 TSO 分配</span></span><br><span class="line">        ts = tsoutil.ComposeTS(time.Now().UnixMilli(), <span class="number">0</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 必须分配 TSO 的任务</span></span><br><span class="line">        ts, err = queue.tsoAllocatorIns.AllocOne(t.TraceCtx())</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err  <span class="comment">// 直接返回错误，任务不入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关键点</strong>：</p>
<ul>
<li>✅ <strong>不会阻塞</strong>：任务入队失败会立即返回错误，不会阻塞其他任务</li>
<li>✅ <strong>错误传播</strong>：错误会返回给调用者（如 Insert&#x2F;Delete 请求）</li>
<li>✅ <strong>用户可见</strong>：用户会收到明确的错误响应</li>
</ul>
<h3 id="9-4-失败场景分析"><a href="#9-4-失败场景分析" class="headerlink" title="9.4 失败场景分析"></a>9.4 失败场景分析</h3><h4 id="场景-1：RootCoord-未启动或不可用"><a href="#场景-1：RootCoord-未启动或不可用" class="headerlink" title="场景 1：RootCoord 未启动或不可用"></a>场景 1：RootCoord 未启动或不可用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GenerateTSO 内部重试（10次 × 200ms = 2秒）</span><br><span class="line">    ↓</span><br><span class="line">Proxy gRPC 重试（10次，最多 52.8 秒）</span><br><span class="line">    ↓</span><br><span class="line">Context 超时（10 秒）</span><br><span class="line">    ↓</span><br><span class="line">任务入队失败，返回错误给用户</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：用户请求会在约 10 秒后收到错误响应，不会永久阻塞。</p>
<h4 id="场景-2：TSO-未初始化（RootCoord-刚启动）"><a href="#场景-2：TSO-未初始化（RootCoord-刚启动）" class="headerlink" title="场景 2：TSO 未初始化（RootCoord 刚启动）"></a>场景 2：TSO 未初始化（RootCoord 刚启动）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GenerateTSO 检测到 TSO 未初始化</span><br><span class="line">    ↓</span><br><span class="line">等待 200ms</span><br><span class="line">    ↓</span><br><span class="line">重试（最多 10 次，总等待约 2 秒）</span><br><span class="line">    ↓</span><br><span class="line">如果初始化完成，成功返回</span><br><span class="line">    ↓</span><br><span class="line">如果仍未初始化，返回错误</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：正常情况下，RootCoord 初始化很快（&lt; 1 秒），不会失败。</p>
<h4 id="场景-3：逻辑计数器溢出"><a href="#场景-3：逻辑计数器溢出" class="headerlink" title="场景 3：逻辑计数器溢出"></a>场景 3：逻辑计数器溢出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GenerateTSO 检测到逻辑计数器溢出</span><br><span class="line">    ↓</span><br><span class="line">等待 50ms（等待 UpdateTimestamp 更新）</span><br><span class="line">    ↓</span><br><span class="line">重试（最多 10 次，总等待约 0.5 秒）</span><br><span class="line">    ↓</span><br><span class="line">如果 UpdateTimestamp 成功，继续分配</span><br><span class="line">    ↓</span><br><span class="line">如果仍然溢出，返回错误</span><br></pre></td></tr></table></figure>

<p><strong>结果</strong>：正常情况下，<code>UpdateTimestamp</code> 会在 50ms 内完成，不会失败。</p>
<h3 id="9-5-总结"><a href="#9-5-总结" class="headerlink" title="9.5 总结"></a>9.5 总结</h3><p><strong>GenerateTSO 失败不会永久阻塞处理</strong>：</p>
<ol>
<li><p>✅ <strong>多层重试机制</strong>：</p>
<ul>
<li>GenerateTSO 内部重试（10 次）</li>
<li>gRPC 客户端重试（10 次）</li>
<li>总重试次数可达 100 次</li>
</ul>
</li>
<li><p>✅ <strong>超时保护</strong>：</p>
<ul>
<li>Context 超时（10 秒）</li>
<li>确保不会无限等待</li>
</ul>
</li>
<li><p>✅ <strong>快速失败</strong>：</p>
<ul>
<li>任务入队失败立即返回错误</li>
<li>不会阻塞其他任务的处理</li>
<li>用户会收到明确的错误响应</li>
</ul>
</li>
<li><p>✅ <strong>正常情况下的性能</strong>：</p>
<ul>
<li>TSO 分配通常在毫秒级完成</li>
<li>重试机制只在异常情况下触发</li>
<li>不会影响正常请求的延迟</li>
</ul>
</li>
</ol>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>确保 RootCoord 高可用（通过 etcd Leader 选举）</li>
<li>监控 TSO 分配失败率</li>
<li>如果频繁失败，检查 RootCoord 健康状态和网络连接</li>
</ul>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TSO%EF%BC%88Timestamp-Oracle%EF%BC%89%E7%94%9F%E6%88%90%E5%8F%8A%E5%85%B6%E4%BD%9C%E7%94%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">TSO（Timestamp Oracle）生成及其作用分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81TSO-%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">一、TSO 的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-TSO%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.1 为什么需要 TSO？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-TSO-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2 TSO 的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81TSO-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">二、TSO 的数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E6%B7%B7%E5%90%88%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88Hybrid-Timestamp%EF%BC%89"><span class="toc-number">1.3.1.</span> <span class="toc-text">2.1 混合时间戳（Hybrid Timestamp）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%90%84%E9%83%A8%E5%88%86%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">2.2 各部分的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81TSO-%E7%9A%84%E7%94%9F%E6%88%90%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">三、TSO 的生成流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">3.1 整体架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-RootCoord-%E4%B8%AD%E7%9A%84-TSO-%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.2.</span> <span class="toc-text">3.2 RootCoord 中的 TSO 服务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-timestampOracle-%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">3.2.1 timestampOracle 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88InitTimestamp%EF%BC%89"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">3.2.2 初始化（InitTimestamp）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-%E6%9B%B4%E6%96%B0%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88UpdateTimestamp%EF%BC%89"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3.2.3 更新时间戳（UpdateTimestamp）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E7%94%9F%E6%88%90%E6%97%B6%E9%97%B4%E6%88%B3%EF%BC%88GenerateTSO%EF%BC%89"><span class="toc-number">1.4.3.</span> <span class="toc-text">3.3 生成时间戳（GenerateTSO）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-RootCoord-%E7%9A%84-AllocTimestamp-RPC"><span class="toc-number">1.4.4.</span> <span class="toc-text">3.4 RootCoord 的 AllocTimestamp RPC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Proxy-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-TSO"><span class="toc-number">1.5.</span> <span class="toc-text">四、Proxy 如何使用 TSO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-TimestampAllocator"><span class="toc-number">1.5.1.</span> <span class="toc-text">4.1 TimestampAllocator</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Insert-%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84-TSO-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">4.2 Insert 操作中的 TSO 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-Delete-%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%9A%84-TSO-%E4%BD%BF%E7%94%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">4.3 Delete 操作中的 TSO 使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81TSO-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.6.</span> <span class="toc-text">五、TSO 的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BF%9D%E8%AF%81%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.6.1.</span> <span class="toc-text">5.1 保证全局事件顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%97%B6%E9%97%B4%E5%90%8C%E6%AD%A5%EF%BC%88Time-Synchronization%EF%BC%89"><span class="toc-number">1.6.2.</span> <span class="toc-text">5.2 时间同步（Time Synchronization）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="toc-number">1.6.3.</span> <span class="toc-text">5.3 数据一致性保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D"><span class="toc-number">1.6.4.</span> <span class="toc-text">5.4 故障恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81TSO-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">六、TSO 的性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E6%89%B9%E9%87%8F%E5%88%86%E9%85%8D"><span class="toc-number">1.7.1.</span> <span class="toc-text">6.1 批量分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3%E9%A2%84%E5%88%86%E9%85%8D"><span class="toc-number">1.7.2.</span> <span class="toc-text">6.2 时间窗口预分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">1.7.3.</span> <span class="toc-text">6.3 内存分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E9%80%BB%E8%BE%91%E8%AE%A1%E6%95%B0%E5%99%A8%E6%BA%A2%E5%87%BA%E5%A4%84%E7%90%86"><span class="toc-number">1.7.4.</span> <span class="toc-text">6.4 逻辑计数器溢出处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81TSO-%E7%9A%84%E9%99%90%E5%88%B6%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.8.</span> <span class="toc-text">七、TSO 的限制和注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E6%97%B6%E9%92%9F%E5%90%8C%E6%AD%A5%E8%A6%81%E6%B1%82"><span class="toc-number">1.8.1.</span> <span class="toc-text">7.1 时钟同步要求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E9%80%BB%E8%BE%91%E8%AE%A1%E6%95%B0%E5%99%A8%E9%99%90%E5%88%B6"><span class="toc-number">1.8.2.</span> <span class="toc-text">7.2 逻辑计数器限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E5%8D%95%E7%82%B9%E6%95%85%E9%9A%9C"><span class="toc-number">1.8.3.</span> <span class="toc-text">7.3 单点故障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E6%97%B6%E9%97%B4%E6%88%B3%E8%8C%83%E5%9B%B4"><span class="toc-number">1.8.4.</span> <span class="toc-text">7.4 时间戳范围</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">八、总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-TSO-%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%B7%E5%80%BC"><span class="toc-number">1.9.1.</span> <span class="toc-text">8.1 TSO 的核心价值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.9.2.</span> <span class="toc-text">8.2 关键设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.9.3.</span> <span class="toc-text">8.3 使用场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81GenerateTSO-%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.</span> <span class="toc-text">九、GenerateTSO 失败处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-GenerateTSO-%E5%86%85%E9%83%A8%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.10.1.</span> <span class="toc-text">9.1 GenerateTSO 内部重试机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-Proxy-%E5%B1%82%E7%9A%84%E8%B6%85%E6%97%B6%E5%92%8C%E9%87%8D%E8%AF%95"><span class="toc-number">1.10.2.</span> <span class="toc-text">9.2 Proxy 层的超时和重试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-Context-%E8%B6%85%E6%97%B6"><span class="toc-number">1.10.2.1.</span> <span class="toc-text">9.2.1 Context 超时</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-gRPC-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%87%8D%E8%AF%95"><span class="toc-number">1.10.2.2.</span> <span class="toc-text">9.2.2 gRPC 客户端重试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E4%BB%BB%E5%8A%A1%E5%85%A5%E9%98%9F%E5%A4%B1%E8%B4%A5%E5%A4%84%E7%90%86"><span class="toc-number">1.10.3.</span> <span class="toc-text">9.3 任务入队失败处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-4-%E5%A4%B1%E8%B4%A5%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.10.4.</span> <span class="toc-text">9.4 失败场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-1%EF%BC%9ARootCoord-%E6%9C%AA%E5%90%AF%E5%8A%A8%E6%88%96%E4%B8%8D%E5%8F%AF%E7%94%A8"><span class="toc-number">1.10.4.1.</span> <span class="toc-text">场景 1：RootCoord 未启动或不可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-2%EF%BC%9ATSO-%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88RootCoord-%E5%88%9A%E5%90%AF%E5%8A%A8%EF%BC%89"><span class="toc-number">1.10.4.2.</span> <span class="toc-text">场景 2：TSO 未初始化（RootCoord 刚启动）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF-3%EF%BC%9A%E9%80%BB%E8%BE%91%E8%AE%A1%E6%95%B0%E5%99%A8%E6%BA%A2%E5%87%BA"><span class="toc-number">1.10.4.3.</span> <span class="toc-text">场景 3：逻辑计数器溢出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-%E6%80%BB%E7%BB%93"><span class="toc-number">1.10.5.</span> <span class="toc-text">9.5 总结</span></a></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&text=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&title=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&is_video=false&description=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Milvus TSO（Timestamp Oracle）生成及其作用分析&body=Check out this article: https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&title=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&title=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&title=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&title=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&name=Milvus TSO（Timestamp Oracle）生成及其作用分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2025/06/15/Milvus/tso_generation_and_usage_analysis/&t=Milvus TSO（Timestamp Oracle）生成及其作用分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2026
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
