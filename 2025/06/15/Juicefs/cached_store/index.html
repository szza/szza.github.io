<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="cached_store核心职责: 实现 JuiceFS 的带缓存的块存储（ChunkStore），提供数据读写、缓存管理、压缩、写回（writeback）等功能。 文件结构1234567891011121314151617181920cached_store.go├── 常量定义│   ├── chunkSize (64MB)│   ├── pageSize (64KB)│   └── Slow">
<meta property="og:type" content="article">
<meta property="og:title" content="Juicefs cached_store 分析">
<meta property="og:url" content="https://szza.github.io/2025/06/15/Juicefs/cached_store/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="cached_store核心职责: 实现 JuiceFS 的带缓存的块存储（ChunkStore），提供数据读写、缓存管理、压缩、写回（writeback）等功能。 文件结构1234567891011121314151617181920cached_store.go├── 常量定义│   ├── chunkSize (64MB)│   ├── pageSize (64KB)│   └── Slow">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2025-06-15T02:20:00.000Z">
<meta property="article:modified_time" content="2026-01-04T12:53:35.958Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="Juicefs">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>Juicefs cached_store 分析</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" href="/2025/06/15/Milvus/arrow_parquet_advantages_analysis/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2025/06/15/Juicefs/cached_store/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&text=Juicefs cached_store 分析"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&title=Juicefs cached_store 分析"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&is_video=false&description=Juicefs cached_store 分析"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Juicefs cached_store 分析&body=Check out this article: https://szza.github.io/2025/06/15/Juicefs/cached_store/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&title=Juicefs cached_store 分析"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&title=Juicefs cached_store 分析"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&title=Juicefs cached_store 分析"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&title=Juicefs cached_store 分析"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&name=Juicefs cached_store 分析&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2025/06/15/Juicefs/cached_store/&t=Juicefs cached_store 分析"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cached-store"><span class="toc-number">1.</span> <span class="toc-text">cached_store</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">常量定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chunkSize"><span class="toc-number">1.2.1.</span> <span class="toc-text">chunkSize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pageSize"><span class="toc-number">1.2.2.</span> <span class="toc-text">pageSize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SlowRequest"><span class="toc-number">1.2.3.</span> <span class="toc-text">SlowRequest</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.</span> <span class="toc-text">核心结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-pendingItem-%E5%BE%85%E4%B8%8A%E4%BC%A0%E9%A1%B9"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. pendingItem - 待上传项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-rSlice-%E8%AF%BB%E5%8F%96%E5%88%87%E7%89%87"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. rSlice - 读取切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-wSlice-%E5%86%99%E5%85%A5%E5%88%87%E7%89%87"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. wSlice - 写入切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Config-%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. Config - 配置结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-cachedStore-%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. cachedStore - 带缓存的存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">核心方法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rSlice-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">rSlice 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-key-%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E9%94%AE"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">1. key - 生成对象存储键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ReadAt-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">2. ReadAt - 读取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Remove-%E5%88%A0%E9%99%A4%E5%88%87%E7%89%87"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">3. Remove - 删除切片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wSlice-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">wSlice 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-WriteAt-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1. WriteAt - 写入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-upload-%E4%B8%8A%E4%BC%A0%E5%9D%97"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2. upload - 上传块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-FlushTo-%E5%88%B7%E6%96%B0%E5%88%B0%E6%8C%87%E5%AE%9A%E5%81%8F%E7%A7%BB"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3. FlushTo - 刷新到指定偏移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Finish-%E5%AE%8C%E6%88%90%E5%86%99%E5%85%A5"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4. Finish - 完成写入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cachedStore-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">cachedStore 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-NewCachedStore-%E5%88%9B%E5%BB%BA%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1. NewCachedStore - 创建带缓存的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-load-%E5%8A%A0%E8%BD%BD%E5%9D%97"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">2. load - 加载块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-upload-%E4%B8%8A%E4%BC%A0%E5%9D%97"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3. upload - 上传块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-put-%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4. put - 上传数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-uploader-%E4%B8%8A%E4%BC%A0%E5%99%A8"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">5. uploader - 上传器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-uploadStagingFile-%E4%B8%8A%E4%BC%A0%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">6. uploadStagingFile - 上传暂存文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">数据流分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">读取流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">写入流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%9B%9E%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">写回流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.</span> <span class="toc-text">设计模式和特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 缓存策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%99%E5%9B%9E%EF%BC%88Writeback%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 写回（Writeback）机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E9%A3%9E%EF%BC%88Singleflight%EF%BC%89%E5%8E%BB%E9%87%8D"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 单飞（Singleflight）去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%90%AD%E4%BE%BF%E8%BD%A6%EF%BC%88Piggyback%EF%BC%89%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. 搭便车（Piggyback）优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%99%90%E6%B5%81%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.5.</span> <span class="toc-text">5. 限流控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8E%8B%E7%BC%A9%E6%94%AF%E6%8C%81"><span class="toc-number">1.6.6.</span> <span class="toc-text">6. 压缩支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%A2%84%E5%8F%96%EF%BC%88Prefetch%EF%BC%89"><span class="toc-number">1.6.7.</span> <span class="toc-text">7. 预取（Prefetch）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E4%BC%98%E5%85%88"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 缓存优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%83%A8%E5%88%86%E8%AF%BB%E5%8F%96%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 部分读取优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E9%A3%9E%E5%8E%BB%E9%87%8D"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 单飞去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%90%AD%E4%BE%BF%E8%BD%A6%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. 搭便车优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%99%E5%9B%9E%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.5.</span> <span class="toc-text">5. 写回优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%89%B9%E9%87%8F%E4%B8%8A%E4%BC%A0"><span class="toc-number">1.7.6.</span> <span class="toc-text">6. 批量上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%A2%84%E5%8F%96"><span class="toc-number">1.7.7.</span> <span class="toc-text">7. 预取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.8.</span> <span class="toc-text">并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%81%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 锁保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E9%81%93%E9%99%90%E6%B5%81"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 通道限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E9%A3%9E%E5%8E%BB%E9%87%8D-1"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 单飞去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.1.</span> <span class="toc-text">1. 重试机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">1.9.2.</span> <span class="toc-text">2. 超时控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%99%E8%AF%AF%E6%8C%87%E6%A0%87"><span class="toc-number">1.9.3.</span> <span class="toc-text">3. 错误指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D"><span class="toc-number">1.9.4.</span> <span class="toc-text">4. 错误恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.10.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Page-%E6%B1%A0"><span class="toc-number">1.10.1.</span> <span class="toc-text">1. Page 池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">2. 引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6"><span class="toc-number">1.10.3.</span> <span class="toc-text">3. 内存限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">关键算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%AE%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.1.</span> <span class="toc-text">1. 键生成算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9D%97%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.11.2.</span> <span class="toc-text">2. 块大小计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8A%E4%BC%A0%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3"><span class="toc-number">1.11.3.</span> <span class="toc-text">3. 上传时间窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.12.</span> <span class="toc-text">数据结构关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96"><span class="toc-number">1.13.</span> <span class="toc-text">关键设计决策</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.13.1.</span> <span class="toc-text">1. 为什么使用多级缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%86%99%E5%9B%9E%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">1.13.2.</span> <span class="toc-text">2. 为什么使用写回机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%95%E9%A3%9E%E5%8E%BB%E9%87%8D%EF%BC%9F"><span class="toc-number">1.13.3.</span> <span class="toc-text">3. 为什么使用单飞去重？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%90%AD%E4%BE%BF%E8%BD%A6%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.13.4.</span> <span class="toc-text">4. 为什么使用搭便车优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%83%A8%E5%88%86%E8%AF%BB%E5%8F%96%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.13.5.</span> <span class="toc-text">5. 为什么使用部分读取优化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BD%9C%E5%9C%A8%E9%97%AE%E9%A2%98%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="toc-number">1.14.</span> <span class="toc-text">潜在问题和改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.14.1.</span> <span class="toc-text">1. 缓存一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-number">1.14.2.</span> <span class="toc-text">2. 缓存淘汰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D"><span class="toc-number">1.14.3.</span> <span class="toc-text">3. 错误恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.14.4.</span> <span class="toc-text">4. 性能优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.15.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Juicefs cached_store 分析
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-06-15T02:20:00.000Z" itemprop="datePublished">2025-06-15</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/Juicefs/" rel="tag">Juicefs</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="cached-store"><a href="#cached-store" class="headerlink" title="cached_store"></a>cached_store</h1><p><strong>核心职责</strong>: 实现 JuiceFS 的带缓存的块存储（ChunkStore），提供数据读写、缓存管理、压缩、写回（writeback）等功能。</p>
<h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">cached_store.go</span><br><span class="line">├── 常量定义</span><br><span class="line">│   ├── chunkSize (64MB)</span><br><span class="line">│   ├── pageSize (64KB)</span><br><span class="line">│   └── SlowRequest (10秒)</span><br><span class="line">│</span><br><span class="line">├── 辅助结构体</span><br><span class="line">│   ├── pendingItem (待上传项)</span><br><span class="line">│   ├── rSlice (读取切片)</span><br><span class="line">│   └── wSlice (写入切片)</span><br><span class="line">│</span><br><span class="line">├── 核心结构体</span><br><span class="line">│   ├── Config (配置)</span><br><span class="line">│   └── cachedStore (带缓存的存储)</span><br><span class="line">│</span><br><span class="line">└── 方法实现</span><br><span class="line">    ├── rSlice 方法</span><br><span class="line">    ├── wSlice 方法</span><br><span class="line">    ├── cachedStore 方法</span><br><span class="line">    └── 辅助函数</span><br></pre></td></tr></table></figure>

<h2 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h2><h3 id="chunkSize"><a href="#chunkSize" class="headerlink" title="chunkSize"></a>chunkSize</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const chunkSize = 1 &lt;&lt; 26 // 64M</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>: 定义 Chunk 的大小（64MB）</p>
<p><strong>使用场景</strong>: 写入时检查边界，计算 Chunk 索引</p>
<h3 id="pageSize"><a href="#pageSize" class="headerlink" title="pageSize"></a>pageSize</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const pageSize = 1 &lt;&lt; 16  // 64K</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>: 定义 Page 的大小（64KB）</p>
<p><strong>使用场景</strong>: Page 池分配，内存管理</p>
<h3 id="SlowRequest"><a href="#SlowRequest" class="headerlink" title="SlowRequest"></a>SlowRequest</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const SlowRequest = time.Second * time.Duration(10)</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>: 定义慢请求阈值（10秒）</p>
<p><strong>使用场景</strong>: 记录慢请求日志</p>
<h2 id="核心结构体"><a href="#核心结构体" class="headerlink" title="核心结构体"></a>核心结构体</h2><h3 id="1-pendingItem-待上传项"><a href="#1-pendingItem-待上传项" class="headerlink" title="1. pendingItem - 待上传项"></a>1. pendingItem - 待上传项</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type pendingItem struct &#123;</span><br><span class="line">	key       string</span><br><span class="line">	fpath     string    // full path of local file corresponding to the key</span><br><span class="line">	ts        time.Time // timestamp when this item is added</span><br><span class="line">	uploading bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>: 表示待上传到对象存储的本地文件</p>
<p><strong>字段说明</strong>:</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>key</code></td>
<td><code>string</code></td>
<td>对象存储的键</td>
</tr>
<tr>
<td><code>fpath</code></td>
<td><code>string</code></td>
<td>本地文件路径</td>
</tr>
<tr>
<td><code>ts</code></td>
<td><code>time.Time</code></td>
<td>添加时间戳</td>
</tr>
<tr>
<td><code>uploading</code></td>
<td><code>bool</code></td>
<td>是否正在上传</td>
</tr>
</tbody></table>
<p><strong>使用场景</strong>: 写回（writeback）模式下的延迟上传</p>
<h3 id="2-rSlice-读取切片"><a href="#2-rSlice-读取切片" class="headerlink" title="2. rSlice - 读取切片"></a>2. rSlice - 读取切片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type rSlice struct &#123;</span><br><span class="line">	id     uint64</span><br><span class="line">	length int</span><br><span class="line">	store  *cachedStore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>: 实现 <code>Reader</code> 接口，用于读取数据块</p>
<p><strong>字段说明</strong>:</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>id</code></td>
<td><code>uint64</code></td>
<td>切片 ID</td>
</tr>
<tr>
<td><code>length</code></td>
<td><code>int</code></td>
<td>切片长度</td>
</tr>
<tr>
<td><code>store</code></td>
<td><code>*cachedStore</code></td>
<td>所属的存储</td>
</tr>
</tbody></table>
<p><strong>核心方法</strong>:</p>
<ul>
<li><code>ReadAt</code>: 从指定偏移读取数据</li>
<li><code>Remove</code>: 删除切片的所有块</li>
<li><code>key</code>: 生成对象存储的键</li>
<li><code>blockSize</code>: 计算块大小</li>
</ul>
<h3 id="3-wSlice-写入切片"><a href="#3-wSlice-写入切片" class="headerlink" title="3. wSlice - 写入切片"></a>3. wSlice - 写入切片</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type wSlice struct &#123;</span><br><span class="line">	rSlice</span><br><span class="line">	pages       [][]*Page</span><br><span class="line">	uploaded    int</span><br><span class="line">	errors      chan error</span><br><span class="line">	uploadError error</span><br><span class="line">	pendings    int</span><br><span class="line">	writeback   bool</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>: 实现 <code>Writer</code> 接口，用于写入数据块</p>
<p><strong>字段说明</strong>:</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>rSlice</code></td>
<td><code>rSlice</code></td>
<td>嵌入的读取切片</td>
</tr>
<tr>
<td><code>pages</code></td>
<td><code>[][]*Page</code></td>
<td>页面数组（按块组织）</td>
</tr>
<tr>
<td><code>uploaded</code></td>
<td><code>int</code></td>
<td>已上传的字节数</td>
</tr>
<tr>
<td><code>errors</code></td>
<td><code>chan error</code></td>
<td>上传错误通道</td>
</tr>
<tr>
<td><code>uploadError</code></td>
<td><code>error</code></td>
<td>上传错误</td>
</tr>
<tr>
<td><code>pendings</code></td>
<td><code>int</code></td>
<td>待上传的块数</td>
</tr>
<tr>
<td><code>writeback</code></td>
<td><code>bool</code></td>
<td>是否启用写回</td>
</tr>
</tbody></table>
<p><strong>核心方法</strong>:</p>
<ul>
<li><code>WriteAt</code>: 写入数据</li>
<li><code>FlushTo</code>: 刷新到指定偏移</li>
<li><code>Finish</code>: 完成写入</li>
<li><code>Abort</code>: 中止写入</li>
<li><code>upload</code>: 上传块</li>
</ul>
<h3 id="4-Config-配置结构"><a href="#4-Config-配置结构" class="headerlink" title="4. Config - 配置结构"></a>4. Config - 配置结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">type Config struct &#123;</span><br><span class="line">	CacheDir               string</span><br><span class="line">	CacheMode              os.FileMode</span><br><span class="line">	CacheSize              uint64</span><br><span class="line">	CacheItems             int64</span><br><span class="line">	CacheChecksum          string</span><br><span class="line">	CacheEviction          string</span><br><span class="line">	CacheScanInterval      time.Duration</span><br><span class="line">	CacheExpire            time.Duration</span><br><span class="line">	OSCache                bool</span><br><span class="line">	FreeSpace              float32</span><br><span class="line">	AutoCreate             bool</span><br><span class="line">	Compress               string</span><br><span class="line">	MaxUpload              int</span><br><span class="line">	MaxStageWrite          int</span><br><span class="line">	MaxRetries             int</span><br><span class="line">	UploadLimit            int64 // bytes per second</span><br><span class="line">	DownloadLimit          int64 // bytes per second</span><br><span class="line">	Writeback              bool</span><br><span class="line">	WritebackThresholdSize int</span><br><span class="line">	UploadDelay            time.Duration</span><br><span class="line">	UploadHours            string</span><br><span class="line">	HashPrefix             bool</span><br><span class="line">	BlockSize              int</span><br><span class="line">	GetTimeout             time.Duration</span><br><span class="line">	PutTimeout             time.Duration</span><br><span class="line">	CacheFullBlock         bool</span><br><span class="line">	CacheLargeWrite        bool</span><br><span class="line">	BufferSize             uint64</span><br><span class="line">	Readahead              int</span><br><span class="line">	Prefetch               int</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>: 存储缓存和存储的配置参数</p>
<p><strong>关键字段</strong>:</p>
<ul>
<li><strong>缓存相关</strong>: <code>CacheDir</code>, <code>CacheSize</code>, <code>CacheEviction</code>, <code>CacheExpire</code></li>
<li><strong>写回相关</strong>: <code>Writeback</code>, <code>WritebackThresholdSize</code>, <code>UploadDelay</code>, <code>UploadHours</code></li>
<li><strong>性能相关</strong>: <code>MaxUpload</code>, <code>UploadLimit</code>, <code>DownloadLimit</code>, <code>Prefetch</code></li>
<li><strong>压缩相关</strong>: <code>Compress</code>, <code>BlockSize</code></li>
</ul>
<h3 id="5-cachedStore-带缓存的存储"><a href="#5-cachedStore-带缓存的存储" class="headerlink" title="5. cachedStore - 带缓存的存储"></a>5. cachedStore - 带缓存的存储</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">type cachedStore struct &#123;</span><br><span class="line">	storage       object.ObjectStorage</span><br><span class="line">	bcache        CacheManager</span><br><span class="line">	fetcher       *prefetcher</span><br><span class="line">	conf          Config</span><br><span class="line">	group         *Controller</span><br><span class="line">	currentUpload chan bool</span><br><span class="line">	pendingCh     chan *pendingItem</span><br><span class="line">	pendingKeys   map[string]*pendingItem</span><br><span class="line">	pendingMutex  sync.Mutex</span><br><span class="line">	startHour     int</span><br><span class="line">	endHour       int</span><br><span class="line">	compressor    compress.Compressor</span><br><span class="line">	seekable      bool</span><br><span class="line">	upLimit       *ratelimit.Bucket</span><br><span class="line">	downLimit     *ratelimit.Bucket</span><br><span class="line"></span><br><span class="line">	cacheHits           prometheus.Counter</span><br><span class="line">	cacheMiss           prometheus.Counter</span><br><span class="line">	cacheHitBytes       prometheus.Counter</span><br><span class="line">	cacheMissBytes      prometheus.Counter</span><br><span class="line">	cacheReadHist       prometheus.Histogram</span><br><span class="line">	objectReqsHistogram *prometheus.HistogramVec</span><br><span class="line">	objectReqErrors     prometheus.Counter</span><br><span class="line">	objectDataBytes     *prometheus.CounterVec</span><br><span class="line">	stageBlockDelay     prometheus.Counter</span><br><span class="line">	stageBlockErrors    prometheus.Counter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用</strong>: 实现 <code>ChunkStore</code> 接口，提供带缓存的块存储功能</p>
<p><strong>字段说明</strong>:</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>storage</code></td>
<td><code>object.ObjectStorage</code></td>
<td>底层对象存储</td>
</tr>
<tr>
<td><code>bcache</code></td>
<td><code>CacheManager</code></td>
<td>缓存管理器</td>
</tr>
<tr>
<td><code>fetcher</code></td>
<td><code>*prefetcher</code></td>
<td>预取器</td>
</tr>
<tr>
<td><code>conf</code></td>
<td><code>Config</code></td>
<td>配置</td>
</tr>
<tr>
<td><code>group</code></td>
<td><code>*Controller</code></td>
<td>单飞控制器（去重）</td>
</tr>
<tr>
<td><code>currentUpload</code></td>
<td><code>chan bool</code></td>
<td>当前上传通道（限流）</td>
</tr>
<tr>
<td><code>pendingCh</code></td>
<td><code>chan *pendingItem</code></td>
<td>待上传通道</td>
</tr>
<tr>
<td><code>pendingKeys</code></td>
<td><code>map[string]*pendingItem</code></td>
<td>待上传键映射</td>
</tr>
<tr>
<td><code>pendingMutex</code></td>
<td><code>sync.Mutex</code></td>
<td>保护待上传映射</td>
</tr>
<tr>
<td><code>startHour</code></td>
<td><code>int</code></td>
<td>上传开始时间（小时）</td>
</tr>
<tr>
<td><code>endHour</code></td>
<td><code>int</code></td>
<td>上传结束时间（小时）</td>
</tr>
<tr>
<td><code>compressor</code></td>
<td><code>compress.Compressor</code></td>
<td>压缩器</td>
</tr>
<tr>
<td><code>seekable</code></td>
<td><code>bool</code></td>
<td>是否支持随机访问</td>
</tr>
<tr>
<td><code>upLimit</code></td>
<td><code>*ratelimit.Bucket</code></td>
<td>上传限流器</td>
</tr>
<tr>
<td><code>downLimit</code></td>
<td><code>*ratelimit.Bucket</code></td>
<td>下载限流器</td>
</tr>
</tbody></table>
<p><strong>指标字段</strong>: Prometheus 指标（缓存命中、对象请求等）</p>
<h2 id="核心方法分析"><a href="#核心方法分析" class="headerlink" title="核心方法分析"></a>核心方法分析</h2><h3 id="rSlice-方法"><a href="#rSlice-方法" class="headerlink" title="rSlice 方法"></a>rSlice 方法</h3><h4 id="1-key-生成对象存储键"><a href="#1-key-生成对象存储键" class="headerlink" title="1. key - 生成对象存储键"></a>1. key - 生成对象存储键</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func (s *rSlice) key(indx int) string &#123;</span><br><span class="line">	if s.store.conf.HashPrefix &#123;</span><br><span class="line">		return fmt.Sprintf(&quot;chunks/%02X/%v/%v_%v_%v&quot;, s.id%256, s.id/1000/1000, s.id, indx, s.blockSize(indx))</span><br><span class="line">	&#125;</span><br><span class="line">	return fmt.Sprintf(&quot;chunks/%v/%v/%v_%v_%v&quot;, s.id/1000/1000, s.id/1000, s.id, indx, s.blockSize(indx))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 根据切片 ID、块索引和块大小生成对象存储的键</p>
<p><strong>键格式</strong>:</p>
<ul>
<li><strong>HashPrefix</strong>: <code>chunks/&#123;hash&#125;/&#123;id/1000/1000&#125;/&#123;id&#125;_&#123;indx&#125;_&#123;size&#125;</code></li>
<li><strong>普通</strong>: <code>chunks/&#123;id/1000/1000&#125;/&#123;id/1000&#125;/&#123;id&#125;_&#123;indx&#125;_&#123;size&#125;</code></li>
</ul>
<p><strong>设计目的</strong>:</p>
<ul>
<li>分散对象存储的负载</li>
<li>支持按 ID 范围查找</li>
</ul>
<h4 id="2-ReadAt-读取数据"><a href="#2-ReadAt-读取数据" class="headerlink" title="2. ReadAt - 读取数据"></a>2. ReadAt - 读取数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">func (s *rSlice) ReadAt(ctx context.Context, page *Page, off int) (n int, err error) &#123;</span><br><span class="line">	p := page.Data</span><br><span class="line">	if len(p) == 0 &#123;</span><br><span class="line">		return 0, nil</span><br><span class="line">	&#125;</span><br><span class="line">	if off &gt;= s.length &#123;</span><br><span class="line">		return 0, io.EOF</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	indx := s.index(off)</span><br><span class="line">	boff := off % s.store.conf.BlockSize</span><br><span class="line">	blockSize := s.blockSize(indx)</span><br><span class="line">	if boff+len(p) &gt; blockSize &#123;</span><br><span class="line">		// read beyond current page</span><br><span class="line">		var got int</span><br><span class="line">		for got &lt; len(p) &#123;</span><br><span class="line">			// aligned to current page</span><br><span class="line">			l := min(len(p)-got, s.blockSize(s.index(off))-off%s.store.conf.BlockSize)</span><br><span class="line">			pp := page.Slice(got, l)</span><br><span class="line">			n, err = s.ReadAt(ctx, pp, off)</span><br><span class="line">			pp.Release()</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				return got + n, err</span><br><span class="line">			&#125;</span><br><span class="line">			if n == 0 &#123;</span><br><span class="line">				return got, io.EOF</span><br><span class="line">			&#125;</span><br><span class="line">			got += n</span><br><span class="line">			off += n</span><br><span class="line">		&#125;</span><br><span class="line">		return got, nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	key := s.key(indx)</span><br><span class="line">	if s.store.conf.CacheEnabled() &#123;</span><br><span class="line">		start := time.Now()</span><br><span class="line">		r, err := s.store.bcache.load(key)</span><br><span class="line">		if err == nil &#123;</span><br><span class="line">			n, err = r.ReadAt(p, int64(boff))</span><br><span class="line">			if !s.store.conf.OSCache &#123;</span><br><span class="line">				dropOSCache(r)</span><br><span class="line">			&#125;</span><br><span class="line">			_ = r.Close()</span><br><span class="line">			if err == nil &#123;</span><br><span class="line">				s.store.cacheHits.Add(1)</span><br><span class="line">				s.store.cacheHitBytes.Add(float64(n))</span><br><span class="line">				s.store.cacheReadHist.Observe(time.Since(start).Seconds())</span><br><span class="line">				return n, nil</span><br><span class="line">			&#125;</span><br><span class="line">			logger.Warnf(&quot;remove partial cached block %s: %d %s&quot;, key, n, err)</span><br><span class="line">			s.store.bcache.remove(key, false)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s.store.cacheMiss.Add(1)</span><br><span class="line">	s.store.cacheMissBytes.Add(float64(len(p)))</span><br><span class="line"></span><br><span class="line">	if s.store.seekable &amp;&amp;</span><br><span class="line">		(!s.store.conf.CacheEnabled() || (boff &gt; 0 &amp;&amp; len(p) &lt;= blockSize/4)) &#123;</span><br><span class="line">		if s.store.downLimit != nil &#123;</span><br><span class="line">			s.store.downLimit.Wait(int64(len(p)))</span><br><span class="line">		&#125;</span><br><span class="line">		fullPage, err := s.store.group.TryPiggyback(key)</span><br><span class="line">		if fullPage != nil &#123;</span><br><span class="line">			defer fullPage.Release()</span><br><span class="line">			if err == nil &#123; // piggybacked a full read</span><br><span class="line">				n = copy(p, fullPage.Data[boff:])</span><br><span class="line">				return n, nil</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		// partial read</span><br><span class="line">		st := time.Now()</span><br><span class="line">		var (</span><br><span class="line">			reqID string</span><br><span class="line">			sc    = object.DefaultStorageClass</span><br><span class="line">		)</span><br><span class="line">		page.Acquire()</span><br><span class="line">		err = utils.WithTimeout(ctx, func(cCtx context.Context) error &#123;</span><br><span class="line">			defer page.Release()</span><br><span class="line">			in, err := s.store.storage.Get(cCtx, key, int64(boff), int64(len(p)), object.WithRequestID(&amp;reqID), object.WithStorageClass(&amp;sc))</span><br><span class="line">			if err == nil &#123;</span><br><span class="line">				n, err = io.ReadFull(in, p)</span><br><span class="line">				_ = in.Close()</span><br><span class="line">			&#125;</span><br><span class="line">			return err</span><br><span class="line">		&#125;, s.store.conf.GetTimeout)</span><br><span class="line">		used := time.Since(st)</span><br><span class="line">		logRequest(&quot;GET&quot;, key, fmt.Sprintf(&quot;RANGE(%d,%d) &quot;, boff, len(p)), reqID, err, used)</span><br><span class="line">		if errors.Is(err, context.Canceled) &#123;</span><br><span class="line">			return 0, err</span><br><span class="line">		&#125;</span><br><span class="line">		s.store.objectDataBytes.WithLabelValues(&quot;GET&quot;, sc).Add(float64(n))</span><br><span class="line">		s.store.objectReqsHistogram.WithLabelValues(&quot;GET&quot;, sc).Observe(used.Seconds())</span><br><span class="line">		if err == nil &#123;</span><br><span class="line">			s.store.fetcher.fetch(key)</span><br><span class="line">			return n, nil</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			s.store.objectReqErrors.Add(1)</span><br><span class="line">			// fall back to full read</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	block, err := s.store.group.Execute(key, func() (*Page, error) &#123;</span><br><span class="line">		tmp := page</span><br><span class="line">		if boff &gt; 0 || len(p) &lt; blockSize &#123;</span><br><span class="line">			tmp = NewOffPage(blockSize)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			tmp.Acquire()</span><br><span class="line">		&#125;</span><br><span class="line">		err = s.store.load(ctx, key, tmp, s.store.shouldCache(blockSize), false)</span><br><span class="line">		return tmp, err</span><br><span class="line">	&#125;)</span><br><span class="line">	defer block.Release()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return 0, err</span><br><span class="line">	&#125;</span><br><span class="line">	if block != page &#123;</span><br><span class="line">		copy(p, block.Data[boff:])</span><br><span class="line">	&#125;</span><br><span class="line">	return len(p), nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 从指定偏移读取数据</p>
<p><strong>执行流程</strong>:</p>
<ol>
<li><p><strong>边界检查</strong>:</p>
<ul>
<li>如果 <code>off &gt;= length</code>，返回 <code>EOF</code></li>
<li>如果跨块，递归读取</li>
</ul>
</li>
<li><p><strong>缓存查找</strong>:</p>
<ul>
<li>如果启用缓存，从缓存加载</li>
<li>如果命中，更新指标，返回数据</li>
<li>如果失败，移除缓存项</li>
</ul>
</li>
<li><p><strong>部分读取优化</strong>（如果支持随机访问）:</p>
<ul>
<li>尝试从正在进行的完整读取中”搭便车”（piggyback）</li>
<li>如果失败，使用 Range 请求读取部分数据</li>
<li>如果成功，触发预取</li>
</ul>
</li>
<li><p><strong>完整读取</strong>（回退）:</p>
<ul>
<li>使用单飞（singleflight）去重</li>
<li>调用 <code>load</code> 方法加载完整块</li>
<li>如果偏移不为 0，复制数据</li>
</ul>
</li>
</ol>
<p><strong>关键优化</strong>:</p>
<ul>
<li><strong>缓存优先</strong>: 先查缓存，减少网络请求</li>
<li><strong>部分读取</strong>: 支持 Range 请求，减少数据传输</li>
<li><strong>单飞去重</strong>: 避免重复请求</li>
<li><strong>搭便车</strong>: 从正在进行的读取中获取数据</li>
</ul>
<h4 id="3-Remove-删除切片"><a href="#3-Remove-删除切片" class="headerlink" title="3. Remove - 删除切片"></a>3. Remove - 删除切片</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func (s *rSlice) Remove() error &#123;</span><br><span class="line">	if s.length == 0 &#123;</span><br><span class="line">		// no block</span><br><span class="line">		return nil</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	lastIndx := (s.length - 1) / s.store.conf.BlockSize</span><br><span class="line">	for i := 0; i &lt;= lastIndx; i++ &#123;</span><br><span class="line">		// there could be multiple clients try to remove the same chunk in the same time,</span><br><span class="line">		// any of them should succeed if any blocks is removed</span><br><span class="line">		key := s.key(i)</span><br><span class="line">		s.store.removePending(key)</span><br><span class="line">		s.store.bcache.remove(key, true)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	var err error</span><br><span class="line">	for i := 0; i &lt;= lastIndx; i++ &#123;</span><br><span class="line">		if e := s.delete(i); e != nil &#123;</span><br><span class="line">			err = e</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 删除切片的所有块</p>
<p><strong>流程</strong>:</p>
<ol>
<li>计算最后一个块索引</li>
<li>遍历所有块:<ul>
<li>移除待上传项</li>
<li>移除缓存项</li>
</ul>
</li>
<li>删除对象存储中的对象</li>
</ol>
<p><strong>并发安全</strong>: 允许多个客户端同时删除，只要有一个成功即可</p>
<h3 id="wSlice-方法"><a href="#wSlice-方法" class="headerlink" title="wSlice 方法"></a>wSlice 方法</h3><h4 id="1-WriteAt-写入数据"><a href="#1-WriteAt-写入数据" class="headerlink" title="1. WriteAt - 写入数据"></a>1. WriteAt - 写入数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">func (s *wSlice) WriteAt(p []byte, off int64) (n int, err error) &#123;</span><br><span class="line">	if int(off)+len(p) &gt; chunkSize &#123;</span><br><span class="line">		return 0, fmt.Errorf(&quot;write out of chunk boudary: %d &gt; %d&quot;, int(off)+len(p), chunkSize)</span><br><span class="line">	&#125;</span><br><span class="line">	if off &lt; int64(s.uploaded) &#123;</span><br><span class="line">		return 0, fmt.Errorf(&quot;Cannot overwrite uploaded block: %d &lt; %d&quot;, off, s.uploaded)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// Fill previous blocks with zeros</span><br><span class="line">	if s.length &lt; int(off) &#123;</span><br><span class="line">		zeros := make([]byte, int(off)-s.length)</span><br><span class="line">		_, _ = s.WriteAt(zeros, int64(s.length))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	for n &lt; len(p) &#123;</span><br><span class="line">		indx := s.index(int(off) + n)</span><br><span class="line">		boff := (int(off) + n) % s.store.conf.BlockSize</span><br><span class="line">		var bs = pageSize</span><br><span class="line">		if indx &gt; 0 || bs &gt; s.store.conf.BlockSize &#123;</span><br><span class="line">			bs = s.store.conf.BlockSize</span><br><span class="line">		&#125;</span><br><span class="line">		bi := boff / bs</span><br><span class="line">		bo := boff % bs</span><br><span class="line">		var page *Page</span><br><span class="line">		if bi &lt; len(s.pages[indx]) &#123;</span><br><span class="line">			page = s.pages[indx][bi]</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			page = allocPage(bs)</span><br><span class="line">			page.Data = page.Data[:0]</span><br><span class="line">			s.pages[indx] = append(s.pages[indx], page)</span><br><span class="line">		&#125;</span><br><span class="line">		left := len(p) - n</span><br><span class="line">		if bo+left &gt; bs &#123;</span><br><span class="line">			page.Data = page.Data[:bs]</span><br><span class="line">		&#125; else if len(page.Data) &lt; bo+left &#123;</span><br><span class="line">			page.Data = page.Data[:bo+left]</span><br><span class="line">		&#125;</span><br><span class="line">		n += copy(page.Data[bo:], p[n:])</span><br><span class="line">	&#125;</span><br><span class="line">	if int(off)+n &gt; s.length &#123;</span><br><span class="line">		s.length = int(off) + n</span><br><span class="line">	&#125;</span><br><span class="line">	return n, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 写入数据到指定偏移</p>
<p><strong>执行流程</strong>:</p>
<ol>
<li><p><strong>边界检查</strong>:</p>
<ul>
<li>检查是否超出 Chunk 边界</li>
<li>检查是否覆盖已上传的数据</li>
</ul>
</li>
<li><p><strong>填充空洞</strong>:</p>
<ul>
<li>如果偏移大于当前长度，用零填充</li>
</ul>
</li>
<li><p><strong>分块写入</strong>:</p>
<ul>
<li>计算块索引和块内偏移</li>
<li>分配或获取 Page</li>
<li>复制数据到 Page</li>
<li>更新长度</li>
</ul>
</li>
</ol>
<p><strong>关键点</strong>:</p>
<ul>
<li>支持稀疏写入（用零填充空洞）</li>
<li>按块组织数据（<code>pages[indx]</code>）</li>
<li>支持跨块写入</li>
</ul>
<h4 id="2-upload-上传块"><a href="#2-upload-上传块" class="headerlink" title="2. upload - 上传块"></a>2. upload - 上传块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">func (s *wSlice) upload(indx int) &#123;</span><br><span class="line">	blen := s.blockSize(indx)</span><br><span class="line">	key := s.key(indx)</span><br><span class="line">	pages := s.pages[indx]</span><br><span class="line">	s.pages[indx] = nil</span><br><span class="line">	s.pendings++</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		var block *Page</span><br><span class="line">		var off int</span><br><span class="line">		if len(pages) == 1 &#123;</span><br><span class="line">			block = pages[0]</span><br><span class="line">			off = len(block.Data)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			block = NewOffPage(blen)</span><br><span class="line">			for _, b := range pages &#123;</span><br><span class="line">				off += copy(block.Data[off:], b.Data)</span><br><span class="line">				freePage(b)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if off != blen &#123;</span><br><span class="line">			panic(fmt.Sprintf(&quot;block length does not match: %v != %v&quot;, off, blen))</span><br><span class="line">		&#125;</span><br><span class="line">		if s.writeback &amp;&amp; blen &lt; s.store.conf.WritebackThresholdSize &#123;</span><br><span class="line">			stagingPath := &quot;unknown&quot;</span><br><span class="line">			stageFailed := false</span><br><span class="line">			block.Acquire()</span><br><span class="line">			err := utils.WithTimeout(context.TODO(), func(context.Context) (err error) &#123; // In case it hangs for more than 5 minutes(see fileWriter.flush), fallback to uploading directly to avoid `EIO`</span><br><span class="line">				defer block.Release()</span><br><span class="line">				stagingPath, err = s.store.bcache.stage(key, block.Data)</span><br><span class="line">				if err == nil &amp;&amp; stageFailed &#123; // upload thread already marked me as failed because of timeout</span><br><span class="line">					_ = s.store.bcache.removeStage(key)</span><br><span class="line">				&#125;</span><br><span class="line">				return err</span><br><span class="line">			&#125;, s.store.conf.PutTimeout)</span><br><span class="line">			if err != nil &#123;</span><br><span class="line">				stageFailed = true</span><br><span class="line">				if !errors.Is(err, errStageConcurrency) &#123;</span><br><span class="line">					s.store.stageBlockErrors.Add(1)</span><br><span class="line">					logger.Warnf(&quot;write %s to disk: %s, upload it directly&quot;, key, err)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				s.errors &lt;- nil</span><br><span class="line">				if s.store.conf.UploadDelay == 0 &amp;&amp; s.store.canUpload() &#123;</span><br><span class="line">					select &#123;</span><br><span class="line">					case s.store.currentUpload &lt;- true:</span><br><span class="line">						defer func() &#123; &lt;-s.store.currentUpload &#125;()</span><br><span class="line">						if err = s.store.upload(key, block, nil); err == nil &#123;</span><br><span class="line">							s.store.bcache.uploaded(key, blen)</span><br><span class="line">							if err := s.store.bcache.removeStage(key); err != nil &#123;</span><br><span class="line">								logger.Warnf(&quot;failed to remove stage %s in upload&quot;, stagingPath)</span><br><span class="line">							&#125;</span><br><span class="line">						&#125; else &#123; // add to delay list and wait for later scanning</span><br><span class="line">							s.store.addDelayedStaging(key, stagingPath, time.Now(), false)</span><br><span class="line">						&#125;</span><br><span class="line">						return</span><br><span class="line">					default:</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				block.Release()</span><br><span class="line">				s.store.addDelayedStaging(key, stagingPath, time.Now(), false)</span><br><span class="line">				return</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		s.store.currentUpload &lt;- true</span><br><span class="line">		defer func() &#123; &lt;-s.store.currentUpload &#125;()</span><br><span class="line">		s.errors &lt;- s.store.upload(key, block, s)</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 异步上传块到对象存储</p>
<p><strong>执行流程</strong>:</p>
<ol>
<li><p><strong>合并页面</strong>:</p>
<ul>
<li>如果只有一个页面，直接使用</li>
<li>否则合并多个页面为一个块</li>
</ul>
</li>
<li><p><strong>写回模式</strong>（如果启用且块大小小于阈值）:</p>
<ul>
<li>先写入本地缓存（<code>stage</code>）</li>
<li>如果成功且满足上传条件，立即上传</li>
<li>否则添加到延迟上传列表</li>
</ul>
</li>
<li><p><strong>直接上传</strong>（回退）:</p>
<ul>
<li>获取上传槽位（限流）</li>
<li>调用 <code>store.upload</code> 上传</li>
</ul>
</li>
</ol>
<p><strong>关键点</strong>:</p>
<ul>
<li><strong>异步执行</strong>: 使用 goroutine 不阻塞写入</li>
<li><strong>写回优化</strong>: 小块先写本地，延迟上传</li>
<li><strong>限流控制</strong>: 使用 <code>currentUpload</code> 通道限流</li>
</ul>
<h4 id="3-FlushTo-刷新到指定偏移"><a href="#3-FlushTo-刷新到指定偏移" class="headerlink" title="3. FlushTo - 刷新到指定偏移"></a>3. FlushTo - 刷新到指定偏移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (s *wSlice) FlushTo(offset int) error &#123;</span><br><span class="line">	if offset &lt; s.uploaded &#123;</span><br><span class="line">		panic(fmt.Sprintf(&quot;Invalid offset: %d &lt; %d&quot;, offset, s.uploaded))</span><br><span class="line">	&#125;</span><br><span class="line">	for i, block := range s.pages &#123;</span><br><span class="line">		start := i * s.store.conf.BlockSize</span><br><span class="line">		end := start + s.store.conf.BlockSize</span><br><span class="line">		if start &gt;= s.uploaded &amp;&amp; end &lt;= offset &#123;</span><br><span class="line">			if block != nil &#123;</span><br><span class="line">				s.upload(i)</span><br><span class="line">			&#125;</span><br><span class="line">			s.uploaded = end</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 刷新指定范围内的所有块</p>
<p><strong>流程</strong>:</p>
<ol>
<li>检查偏移有效性</li>
<li>遍历所有块，如果块在范围内且未上传，上传它</li>
<li>更新已上传偏移</li>
</ol>
<h4 id="4-Finish-完成写入"><a href="#4-Finish-完成写入" class="headerlink" title="4. Finish - 完成写入"></a>4. Finish - 完成写入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func (s *wSlice) Finish(length int) error &#123;</span><br><span class="line">	if s.length != length &#123;</span><br><span class="line">		return fmt.Errorf(&quot;Length mismatch: %v != %v&quot;, s.length, length)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	n := (length-1)/s.store.conf.BlockSize + 1</span><br><span class="line">	if err := s.FlushTo(n * s.store.conf.BlockSize); err != nil &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	for i := 0; i &lt; s.pendings; i++ &#123;</span><br><span class="line">		if err := &lt;-s.errors; err != nil &#123;</span><br><span class="line">			s.uploadError = err</span><br><span class="line">			return err</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 完成写入，等待所有上传完成</p>
<p><strong>流程</strong>:</p>
<ol>
<li>检查长度匹配</li>
<li>刷新所有块</li>
<li>等待所有上传完成（从 <code>errors</code> 通道读取）</li>
<li>如果有错误，返回错误</li>
</ol>
<h3 id="cachedStore-方法"><a href="#cachedStore-方法" class="headerlink" title="cachedStore 方法"></a>cachedStore 方法</h3><h4 id="1-NewCachedStore-创建带缓存的存储"><a href="#1-NewCachedStore-创建带缓存的存储" class="headerlink" title="1. NewCachedStore - 创建带缓存的存储"></a>1. NewCachedStore - 创建带缓存的存储</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">func NewCachedStore(storage object.ObjectStorage, config Config, reg prometheus.Registerer) ChunkStore &#123;</span><br><span class="line">	compressor := compress.NewCompressor(config.Compress)</span><br><span class="line">	if compressor == nil &#123;</span><br><span class="line">		logger.Fatalf(&quot;unknown compress algorithm: %s&quot;, config.Compress)</span><br><span class="line">	&#125;</span><br><span class="line">	if config.MaxRetries == 0 &#123;</span><br><span class="line">		config.MaxRetries = 10</span><br><span class="line">	&#125;</span><br><span class="line">	if config.GetTimeout == 0 &#123;</span><br><span class="line">		config.GetTimeout = time.Second * 60</span><br><span class="line">	&#125;</span><br><span class="line">	if config.PutTimeout == 0 &#123;</span><br><span class="line">		config.PutTimeout = time.Second * 60</span><br><span class="line">	&#125;</span><br><span class="line">	store := &amp;cachedStore&#123;</span><br><span class="line">		storage:       storage,</span><br><span class="line">		conf:          config,</span><br><span class="line">		currentUpload: make(chan bool, config.MaxUpload),</span><br><span class="line">		compressor:    compressor,</span><br><span class="line">		seekable:      compressor.CompressBound(0) == 0,</span><br><span class="line">		pendingCh:     make(chan *pendingItem, 100*config.MaxUpload),</span><br><span class="line">		pendingKeys:   make(map[string]*pendingItem),</span><br><span class="line">		group:         NewController(),</span><br><span class="line">	&#125;</span><br><span class="line">	if config.UploadLimit &gt; 0 &#123;</span><br><span class="line">		// there are overheads coming from HTTP/TCP/IP</span><br><span class="line">		store.upLimit = ratelimit.NewBucketWithRate(float64(config.UploadLimit)*0.85, config.UploadLimit/10)</span><br><span class="line">	&#125;</span><br><span class="line">	if config.DownloadLimit &gt; 0 &#123;</span><br><span class="line">		store.downLimit = ratelimit.NewBucketWithRate(float64(config.DownloadLimit)*0.85, config.DownloadLimit/10)</span><br><span class="line">	&#125;</span><br><span class="line">	store.initMetrics()</span><br><span class="line">	if store.conf.Writeback &#123;</span><br><span class="line">		store.startHour, store.endHour, _ = config.parseHours()</span><br><span class="line">		if store.startHour != store.endHour &#123;</span><br><span class="line">			logger.Infof(&quot;background upload at %d:00 ~ %d:00&quot;, store.startHour, store.endHour)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	store.bcache = newCacheManager(&amp;config, reg, func(key, fpath string, force bool) bool &#123;</span><br><span class="line">		if fi, err := os.Stat(fpath); err == nil &#123;</span><br><span class="line">			return store.addDelayedStaging(key, fpath, fi.ModTime(), force)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			logger.Warnf(&quot;Stat staging block %s: %s&quot;, fpath, err)</span><br><span class="line">			return false</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		for &#123;</span><br><span class="line">			if store.bcache.isEmpty() &#123;</span><br><span class="line">				logger.Warn(&quot;cache store is empty, use memory cache&quot;)</span><br><span class="line">				config.CacheSize = 100 &lt;&lt; 20</span><br><span class="line">				config.CacheDir = &quot;memory&quot;</span><br><span class="line">				store.bcache = newMemStore(&amp;config, store.bcache.getMetrics())</span><br><span class="line">			&#125;</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	if !config.CacheEnabled() &#123;</span><br><span class="line">		config.Prefetch = 0 // disable prefetch if cache is disabled</span><br><span class="line">	&#125;</span><br><span class="line">	store.fetcher = newPrefetcher(config.Prefetch, func(key string) &#123;</span><br><span class="line">		size := parseObjOrigSize(key)</span><br><span class="line">		if size == 0 || size &gt; store.conf.BlockSize &#123;</span><br><span class="line">			return</span><br><span class="line">		&#125;</span><br><span class="line">		p := NewOffPage(size)</span><br><span class="line">		defer p.Release()</span><br><span class="line">		block, err := store.group.Execute(key, func() (*Page, error) &#123; // dedup requests with full read</span><br><span class="line">			p.Acquire()</span><br><span class="line">			err := store.load(context.TODO(), key, p, false, false) // delay writing cache until singleflight ends to prevent blocking waiters</span><br><span class="line">			return p, err</span><br><span class="line">		&#125;)</span><br><span class="line">		defer block.Release()</span><br><span class="line">		if err == nil &amp;&amp; block == p &#123;</span><br><span class="line">			store.bcache.cache(key, block, true, !store.conf.OSCache)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	if store.conf.Writeback &#123;</span><br><span class="line">		for i := 0; i &lt; store.conf.MaxUpload; i++ &#123;</span><br><span class="line">			go store.uploader()</span><br><span class="line">		&#125;</span><br><span class="line">		interval := time.Minute</span><br><span class="line">		if d := store.conf.UploadDelay; d &gt; 0 &#123;</span><br><span class="line">			if d &lt; time.Minute &#123;</span><br><span class="line">				interval = d</span><br><span class="line">				logger.Warnf(&quot;delay uploading by %s (this value is too small, and is not recommended)&quot;, d)</span><br><span class="line">			&#125; else &#123;</span><br><span class="line">				logger.Infof(&quot;delay uploading by %s&quot;, d)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		go func() &#123;</span><br><span class="line">			for &#123;</span><br><span class="line">				time.Sleep(interval)</span><br><span class="line">				store.scanDelayedStaging()</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	store.regMetrics(reg)</span><br><span class="line">	return store</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 创建并初始化带缓存的存储</p>
<p><strong>初始化流程</strong>:</p>
<ol>
<li><strong>创建压缩器</strong>: 根据配置创建压缩器</li>
<li><strong>设置默认值</strong>: 重试次数、超时时间</li>
<li><strong>创建存储结构</strong>: 初始化所有字段</li>
<li><strong>设置限流器</strong>: 上传和下载限流</li>
<li><strong>初始化指标</strong>: Prometheus 指标</li>
<li><strong>解析上传时间</strong>: 如果启用写回</li>
<li><strong>创建缓存管理器</strong>: 带上传回调</li>
<li><strong>启动后台任务</strong>:<ul>
<li>检查缓存是否为空（如果为空，切换到内存缓存）</li>
<li>启动预取器（如果启用）</li>
<li>启动上传器（如果启用写回）</li>
<li>启动延迟上传扫描器</li>
</ul>
</li>
</ol>
<p><strong>关键设计</strong>:</p>
<ul>
<li><strong>自动降级</strong>: 如果缓存目录不可用，自动切换到内存缓存</li>
<li><strong>后台任务</strong>: 多个 goroutine 处理缓存和上传</li>
<li><strong>单飞去重</strong>: 预取时使用单飞避免重复请求</li>
</ul>
<h4 id="2-load-加载块"><a href="#2-load-加载块" class="headerlink" title="2. load - 加载块"></a>2. load - 加载块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">func (store *cachedStore) load(ctx context.Context, key string, page *Page, cache bool, forceCache bool) (err error) &#123;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		e := recover()</span><br><span class="line">		if e != nil &#123;</span><br><span class="line">			err = fmt.Errorf(&quot;recovered from %s&quot;, e)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	needed := store.compressor.CompressBound(len(page.Data))</span><br><span class="line">	compressed := needed &gt; len(page.Data)</span><br><span class="line">	// we don&#x27;t know the actual size for compressed block</span><br><span class="line">	if store.downLimit != nil &amp;&amp; !compressed &#123;</span><br><span class="line">		store.downLimit.Wait(int64(len(page.Data)))</span><br><span class="line">	&#125;</span><br><span class="line">	var (</span><br><span class="line">		in    io.ReadCloser</span><br><span class="line">		n     int</span><br><span class="line">		p     *Page</span><br><span class="line">		reqID string</span><br><span class="line">		sc    = object.DefaultStorageClass</span><br><span class="line">		start = time.Now()</span><br><span class="line">	)</span><br><span class="line">	if compressed &#123;</span><br><span class="line">		c := NewOffPage(needed)</span><br><span class="line">		defer c.Release()</span><br><span class="line">		p = c</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		p = page</span><br><span class="line">	&#125;</span><br><span class="line">	p.Acquire()</span><br><span class="line">	err = utils.WithTimeout(ctx, func(cCtx context.Context) error &#123;</span><br><span class="line">		defer p.Release()</span><br><span class="line">		// it will be retried in the upper layer.</span><br><span class="line">		in, err = store.storage.Get(cCtx, key, 0, -1, object.WithRequestID(&amp;reqID), object.WithStorageClass(&amp;sc))</span><br><span class="line">		if err == nil &#123;</span><br><span class="line">			n, err = io.ReadFull(in, p.Data)</span><br><span class="line">			_ = in.Close()</span><br><span class="line">		&#125;</span><br><span class="line">		if compressed &amp;&amp; err == io.ErrUnexpectedEOF &#123;</span><br><span class="line">			err = nil</span><br><span class="line">		&#125;</span><br><span class="line">		return err</span><br><span class="line">	&#125;, store.conf.GetTimeout)</span><br><span class="line">	if errors.Is(err, context.Canceled) &#123;</span><br><span class="line">		return err</span><br><span class="line">	&#125;</span><br><span class="line">	used := time.Since(start)</span><br><span class="line">	logRequest(&quot;GET&quot;, key, &quot;&quot;, reqID, err, used)</span><br><span class="line">	if store.downLimit != nil &amp;&amp; compressed &#123;</span><br><span class="line">		store.downLimit.Wait(int64(n))</span><br><span class="line">	&#125;</span><br><span class="line">	store.objectDataBytes.WithLabelValues(&quot;GET&quot;, sc).Add(float64(n))</span><br><span class="line">	store.objectReqsHistogram.WithLabelValues(&quot;GET&quot;, sc).Observe(used.Seconds())</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		store.objectReqErrors.Add(1)</span><br><span class="line">		return fmt.Errorf(&quot;get %s: %s&quot;, key, err)</span><br><span class="line">	&#125;</span><br><span class="line">	if compressed &#123;</span><br><span class="line">		n, err = store.compressor.Decompress(page.Data, p.Data[:n])</span><br><span class="line">	&#125;</span><br><span class="line">	if err != nil || n &lt; len(page.Data) &#123;</span><br><span class="line">		return fmt.Errorf(&quot;read %s fully: %v (%d &lt; %d) after %s&quot;, key, err, n, len(page.Data), used)</span><br><span class="line">	&#125;</span><br><span class="line">	if cache &#123;</span><br><span class="line">		store.bcache.cache(key, page, forceCache, !store.conf.OSCache)</span><br><span class="line">	&#125;</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 从对象存储加载块</p>
<p><strong>执行流程</strong>:</p>
<ol>
<li><strong>压缩检查</strong>: 判断是否需要解压</li>
<li><strong>限流</strong>: 如果未压缩，先限流</li>
<li><strong>分配页面</strong>: 如果压缩，分配更大的页面</li>
<li><strong>下载数据</strong>: 从对象存储获取完整数据</li>
<li><strong>限流</strong>: 如果压缩，下载后限流</li>
<li><strong>解压</strong>: 如果压缩，解压数据</li>
<li><strong>缓存</strong>: 如果启用缓存，写入缓存</li>
</ol>
<p><strong>关键点</strong>:</p>
<ul>
<li><strong>超时控制</strong>: 使用 <code>WithTimeout</code> 控制超时</li>
<li><strong>压缩处理</strong>: 支持压缩和解压</li>
<li><strong>错误处理</strong>: 记录错误指标</li>
</ul>
<h4 id="3-upload-上传块"><a href="#3-upload-上传块" class="headerlink" title="3. upload - 上传块"></a>3. upload - 上传块</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">func (store *cachedStore) upload(key string, block *Page, s *wSlice) error &#123;</span><br><span class="line">	sync := s != nil</span><br><span class="line">	blen := len(block.Data)</span><br><span class="line">	bufSize := store.compressor.CompressBound(blen)</span><br><span class="line">	var buf *Page</span><br><span class="line">	if bufSize &gt; blen &#123;</span><br><span class="line">		buf = NewOffPage(bufSize)</span><br><span class="line">	&#125; else &#123;</span><br><span class="line">		buf = block</span><br><span class="line">		buf.Acquire()</span><br><span class="line">	&#125;</span><br><span class="line">	defer buf.Release()</span><br><span class="line">	if sync &amp;&amp; (blen &lt; store.conf.BlockSize || store.conf.CacheLargeWrite) &#123;</span><br><span class="line">		// block will be freed after written into disk</span><br><span class="line">		store.bcache.cache(key, block, false, false)</span><br><span class="line">	&#125;</span><br><span class="line">	n, err := store.compressor.Compress(buf.Data, block.Data)</span><br><span class="line">	block.Release()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		return fmt.Errorf(&quot;Compress block key %s: %s&quot;, key, err)</span><br><span class="line">	&#125;</span><br><span class="line">	buf.Data = buf.Data[:n]</span><br><span class="line"></span><br><span class="line">	try, max := 0, 3</span><br><span class="line">	if sync &#123;</span><br><span class="line">		max = store.conf.MaxRetries + 1</span><br><span class="line">	&#125;</span><br><span class="line">	for ; try &lt; max; try++ &#123;</span><br><span class="line">		time.Sleep(time.Second * time.Duration(try*try))</span><br><span class="line">		if s != nil &amp;&amp; s.uploadError != nil &#123;</span><br><span class="line">			err = fmt.Errorf(&quot;(cancelled) upload block %s: %s (after %d tries)&quot;, key, err, try)</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		if err = store.put(key, buf); err == nil &#123;</span><br><span class="line">			break</span><br><span class="line">		&#125;</span><br><span class="line">		logger.Debugf(&quot;Upload %s: %s (try %d)&quot;, key, err, try+1)</span><br><span class="line">	&#125;</span><br><span class="line">	if err != nil &amp;&amp; try &gt;= max &#123;</span><br><span class="line">		err = fmt.Errorf(&quot;(max tries) upload block %s: %s (after %d tries)&quot;, key, err, try)</span><br><span class="line">	&#125;</span><br><span class="line">	return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 上传块到对象存储</p>
<p><strong>执行流程</strong>:</p>
<ol>
<li><strong>压缩</strong>: 压缩数据块</li>
<li><strong>缓存</strong>: 如果同步且满足条件，写入缓存</li>
<li><strong>重试上传</strong>: 使用指数退避重试</li>
<li><strong>错误处理</strong>: 如果取消或达到最大重试次数，返回错误</li>
</ol>
<p><strong>关键点</strong>:</p>
<ul>
<li><strong>压缩</strong>: 支持数据压缩</li>
<li><strong>重试</strong>: 同步上传使用更多重试次数</li>
<li><strong>指数退避</strong>: 重试间隔递增</li>
</ul>
<h4 id="4-put-上传数据"><a href="#4-put-上传数据" class="headerlink" title="4. put - 上传数据"></a>4. put - 上传数据</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func (store *cachedStore) put(key string, p *Page) error &#123;</span><br><span class="line">	if store.upLimit != nil &#123;</span><br><span class="line">		store.upLimit.Wait(int64(len(p.Data)))</span><br><span class="line">	&#125;</span><br><span class="line">	p.Acquire()</span><br><span class="line">	var (</span><br><span class="line">		reqID string</span><br><span class="line">		sc    = object.DefaultStorageClass</span><br><span class="line">	)</span><br><span class="line">	return utils.WithTimeout(context.TODO(), func(ctx context.Context) error &#123;</span><br><span class="line">		defer p.Release()</span><br><span class="line">		st := time.Now()</span><br><span class="line">		err := store.storage.Put(ctx, key, bytes.NewReader(p.Data), object.WithRequestID(&amp;reqID), object.WithStorageClass(&amp;sc))</span><br><span class="line">		used := time.Since(st)</span><br><span class="line">		logRequest(&quot;PUT&quot;, key, &quot;&quot;, reqID, err, used)</span><br><span class="line">		store.objectDataBytes.WithLabelValues(&quot;PUT&quot;, sc).Add(float64(len(p.Data)))</span><br><span class="line">		store.objectReqsHistogram.WithLabelValues(&quot;PUT&quot;, sc).Observe(used.Seconds())</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			store.objectReqErrors.Add(1)</span><br><span class="line">		&#125;</span><br><span class="line">		return err</span><br><span class="line">	&#125;, store.conf.PutTimeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 上传数据到对象存储</p>
<p><strong>流程</strong>:</p>
<ol>
<li>限流</li>
<li>超时控制</li>
<li>上传数据</li>
<li>记录指标</li>
</ol>
<h4 id="5-uploader-上传器"><a href="#5-uploader-上传器" class="headerlink" title="5. uploader - 上传器"></a>5. uploader - 上传器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func (store *cachedStore) uploader() &#123;</span><br><span class="line">	for it := range store.pendingCh &#123;</span><br><span class="line">		store.uploadStagingFile(it.key, it.fpath)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 后台上传器，从 <code>pendingCh</code> 通道读取待上传项并上传</p>
<p><strong>使用场景</strong>: 写回模式下的延迟上传</p>
<h4 id="6-uploadStagingFile-上传暂存文件"><a href="#6-uploadStagingFile-上传暂存文件" class="headerlink" title="6. uploadStagingFile - 上传暂存文件"></a>6. uploadStagingFile - 上传暂存文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">func (store *cachedStore) uploadStagingFile(key string, stagingPath string) &#123;</span><br><span class="line">	store.currentUpload &lt;- true</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		&lt;-store.currentUpload</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	store.pendingMutex.Lock()</span><br><span class="line">	item, ok := store.pendingKeys[key]</span><br><span class="line">	store.pendingMutex.Unlock()</span><br><span class="line">	if !ok &#123;</span><br><span class="line">		logger.Debugf(&quot;Key %s is not needed, drop it&quot;, key)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	defer func() &#123;</span><br><span class="line">		item.uploading = false</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	if !store.canUpload() &#123;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	blen := parseObjOrigSize(key)</span><br><span class="line">	f, err := openCacheFile(stagingPath, blen, store.conf.CacheChecksum)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		if store.isPendingValid(key) &#123;</span><br><span class="line">			logger.Errorf(&quot;Open staging file %s: %s&quot;, stagingPath, err)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			logger.Debugf(&quot;Key %s is not needed, drop it&quot;, key)</span><br><span class="line">		&#125;</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	block := NewOffPage(blen)</span><br><span class="line">	_, err = f.ReadAt(block.Data, 0)</span><br><span class="line">	_ = f.Close()</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		block.Release()</span><br><span class="line">		logger.Errorf(&quot;Read staging file %s: %s&quot;, stagingPath, err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	if !store.isPendingValid(key) &#123;</span><br><span class="line">		block.Release()</span><br><span class="line">		logger.Debugf(&quot;Key %s is not needed, drop it&quot;, key)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	store.stageBlockDelay.Add(time.Since(item.ts).Seconds())</span><br><span class="line">	if err = store.upload(key, block, nil); err == nil &#123;</span><br><span class="line">		if !store.isPendingValid(key) &#123; // Delete leaked objects if it&#x27;s already deleted by other goroutines</span><br><span class="line">			err := store.delete(key)</span><br><span class="line">			logger.Infof(&quot;Key %s is not needed, abandoned, err: %v&quot;, key, err)</span><br><span class="line">		&#125; else &#123;</span><br><span class="line">			store.bcache.uploaded(key, blen)</span><br><span class="line">			store.removePending(key)</span><br><span class="line">			if err := store.bcache.removeStage(key); err != nil &#123;</span><br><span class="line">				logger.Warnf(&quot;failed to remove stage %s, in upload staging file&quot;, stagingPath)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 上传暂存文件到对象存储</p>
<p><strong>流程</strong>:</p>
<ol>
<li>获取上传槽位（限流）</li>
<li>检查待上传项是否有效</li>
<li>检查是否允许上传（时间窗口）</li>
<li>读取暂存文件</li>
<li>上传数据</li>
<li>清理暂存文件和待上传项</li>
</ol>
<p><strong>关键点</strong>:</p>
<ul>
<li><strong>并发安全</strong>: 检查项是否仍然有效</li>
<li><strong>错误处理</strong>: 如果项已无效，删除已上传的对象</li>
</ul>
<h2 id="数据流分析"><a href="#数据流分析" class="headerlink" title="数据流分析"></a>数据流分析</h2><h3 id="读取流程"><a href="#读取流程" class="headerlink" title="读取流程"></a>读取流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">用户请求</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; rSlice.ReadAt(ctx, page, off)</span><br><span class="line">    │   │</span><br><span class="line">    │   ├─&gt; 检查缓存 (bcache.load)</span><br><span class="line">    │   │   │</span><br><span class="line">    │   │   ├─&gt; 命中: 返回数据，更新指标</span><br><span class="line">    │   │   └─&gt; 未命中: 继续</span><br><span class="line">    │   │</span><br><span class="line">    │   ├─&gt; 部分读取优化 (如果支持随机访问)</span><br><span class="line">    │   │   │</span><br><span class="line">    │   │   ├─&gt; 尝试搭便车 (TryPiggyback)</span><br><span class="line">    │   │   │   │</span><br><span class="line">    │   │   │   └─&gt; 成功: 返回数据，触发预取</span><br><span class="line">    │   │   │</span><br><span class="line">    │   │   └─&gt; Range 请求 (storage.Get with range)</span><br><span class="line">    │   │       │</span><br><span class="line">    │   │       └─&gt; 成功: 返回数据，触发预取</span><br><span class="line">    │   │</span><br><span class="line">    │   └─&gt; 完整读取 (回退)</span><br><span class="line">    │       │</span><br><span class="line">    │       ├─&gt; 单飞去重 (group.Execute)</span><br><span class="line">    │       │</span><br><span class="line">    │       ├─&gt; load(ctx, key, page, cache, forceCache)</span><br><span class="line">    │       │   │</span><br><span class="line">    │       │   ├─&gt; 限流 (downLimit.Wait)</span><br><span class="line">    │       │   │</span><br><span class="line">    │       │   ├─&gt; 下载数据 (storage.Get)</span><br><span class="line">    │       │   │</span><br><span class="line">    │       │   ├─&gt; 解压 (如果压缩)</span><br><span class="line">    │       │   │</span><br><span class="line">    │       │   └─&gt; 写入缓存 (bcache.cache)</span><br><span class="line">    │       │</span><br><span class="line">    │       └─&gt; 返回数据</span><br><span class="line">    │</span><br><span class="line">    └─&gt; 返回给用户</span><br></pre></td></tr></table></figure>

<h3 id="写入流程"><a href="#写入流程" class="headerlink" title="写入流程"></a>写入流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">用户请求</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; wSlice.WriteAt(p, off)</span><br><span class="line">    │   │</span><br><span class="line">    │   ├─&gt; 边界检查</span><br><span class="line">    │   │</span><br><span class="line">    │   ├─&gt; 填充空洞 (如果需要)</span><br><span class="line">    │   │</span><br><span class="line">    │   ├─&gt; 分块写入</span><br><span class="line">    │   │   │</span><br><span class="line">    │   │   ├─&gt; 计算块索引和偏移</span><br><span class="line">    │   │   │</span><br><span class="line">    │   │   ├─&gt; 分配或获取 Page</span><br><span class="line">    │   │   │</span><br><span class="line">    │   │   └─&gt; 复制数据</span><br><span class="line">    │   │</span><br><span class="line">    │   └─&gt; 更新长度</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; wSlice.FlushTo(offset) 或 Finish(length)</span><br><span class="line">    │   │</span><br><span class="line">    │   └─&gt; wSlice.upload(indx)</span><br><span class="line">    │       │</span><br><span class="line">    │       ├─&gt; 合并页面</span><br><span class="line">    │       │</span><br><span class="line">    │       ├─&gt; 写回模式 (如果启用)</span><br><span class="line">    │       │   │</span><br><span class="line">    │       │   ├─&gt; 写入本地缓存 (bcache.stage)</span><br><span class="line">    │       │   │</span><br><span class="line">    │       │   ├─&gt; 立即上传 (如果满足条件)</span><br><span class="line">    │       │   │   │</span><br><span class="line">    │       │   │   └─&gt; store.upload(key, block, nil)</span><br><span class="line">    │       │   │       │</span><br><span class="line">    │       │   │       ├─&gt; 压缩数据</span><br><span class="line">    │       │   │       │</span><br><span class="line">    │       │   │       ├─&gt; 写入缓存 (如果同步)</span><br><span class="line">    │       │   │       │</span><br><span class="line">    │       │   │       └─&gt; store.put(key, buf)</span><br><span class="line">    │       │   │           │</span><br><span class="line">    │       │   │           ├─&gt; 限流 (upLimit.Wait)</span><br><span class="line">    │       │   │           │</span><br><span class="line">    │       │   │           └─&gt; storage.Put</span><br><span class="line">    │       │   │</span><br><span class="line">    │       │   └─&gt; 延迟上传 (添加到 pendingCh)</span><br><span class="line">    │       │       │</span><br><span class="line">    │       │       └─&gt; uploader() → uploadStagingFile()</span><br><span class="line">    │       │</span><br><span class="line">    │       └─&gt; 直接上传 (回退)</span><br><span class="line">    │           │</span><br><span class="line">    │           └─&gt; store.upload(key, block, s)</span><br><span class="line">    │</span><br><span class="line">    └─&gt; 等待上传完成 (Finish)</span><br></pre></td></tr></table></figure>

<h3 id="写回流程"><a href="#写回流程" class="headerlink" title="写回流程"></a>写回流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">写入数据</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; wSlice.upload(indx)</span><br><span class="line">    │   │</span><br><span class="line">    │   └─&gt; 写回模式 &amp;&amp; 块大小 &lt; 阈值</span><br><span class="line">    │       │</span><br><span class="line">    │       ├─&gt; bcache.stage(key, data)</span><br><span class="line">    │       │   │</span><br><span class="line">    │       │   └─&gt; 写入本地缓存文件</span><br><span class="line">    │       │</span><br><span class="line">    │       ├─&gt; 立即上传 (如果满足条件)</span><br><span class="line">    │       │   │</span><br><span class="line">    │       │   ├─&gt; store.upload(key, block, nil)</span><br><span class="line">    │       │   │</span><br><span class="line">    │       │   └─&gt; bcache.uploaded(key, blen)</span><br><span class="line">    │       │       │</span><br><span class="line">    │       │       └─&gt; bcache.removeStage(key)</span><br><span class="line">    │       │</span><br><span class="line">    │       └─&gt; 延迟上传</span><br><span class="line">    │           │</span><br><span class="line">    │           ├─&gt; addDelayedStaging(key, path, time, force)</span><br><span class="line">    │           │   │</span><br><span class="line">    │           │   └─&gt; pendingCh &lt;- item</span><br><span class="line">    │           │</span><br><span class="line">    │           └─&gt; uploader()</span><br><span class="line">    │               │</span><br><span class="line">    │               └─&gt; uploadStagingFile(key, path)</span><br><span class="line">    │                   │</span><br><span class="line">    │                   ├─&gt; 读取暂存文件</span><br><span class="line">    │                   │</span><br><span class="line">    │                   ├─&gt; store.upload(key, block, nil)</span><br><span class="line">    │                   │</span><br><span class="line">    │                   └─&gt; bcache.removeStage(key)</span><br></pre></td></tr></table></figure>

<h2 id="设计模式和特点"><a href="#设计模式和特点" class="headerlink" title="设计模式和特点"></a>设计模式和特点</h2><h3 id="1-缓存策略"><a href="#1-缓存策略" class="headerlink" title="1. 缓存策略"></a>1. 缓存策略</h3><p><strong>多级缓存</strong>:</p>
<ul>
<li><strong>内存缓存</strong>: 热数据在内存中</li>
<li><strong>磁盘缓存</strong>: 温数据在磁盘上</li>
<li><strong>对象存储</strong>: 冷数据在对象存储中</li>
</ul>
<p><strong>缓存查找顺序</strong>:</p>
<ol>
<li>内存缓存</li>
<li>磁盘缓存</li>
<li>对象存储</li>
</ol>
<h3 id="2-写回（Writeback）机制"><a href="#2-写回（Writeback）机制" class="headerlink" title="2. 写回（Writeback）机制"></a>2. 写回（Writeback）机制</h3><p><strong>特点</strong>:</p>
<ul>
<li>小数据块先写入本地缓存</li>
<li>延迟上传到对象存储</li>
<li>支持时间窗口控制</li>
</ul>
<p><strong>优势</strong>:</p>
<ul>
<li>提高写入性能</li>
<li>减少网络请求</li>
<li>支持批量上传</li>
</ul>
<h3 id="3-单飞（Singleflight）去重"><a href="#3-单飞（Singleflight）去重" class="headerlink" title="3. 单飞（Singleflight）去重"></a>3. 单飞（Singleflight）去重</h3><p><strong>实现</strong>: <code>group.Execute(key, func() (*Page, error))</code></p>
<p><strong>作用</strong>: 避免重复请求相同的数据块</p>
<p><strong>使用场景</strong>:</p>
<ul>
<li>读取时的完整块加载</li>
<li>预取时的数据加载</li>
</ul>
<h3 id="4-搭便车（Piggyback）优化"><a href="#4-搭便车（Piggyback）优化" class="headerlink" title="4. 搭便车（Piggyback）优化"></a>4. 搭便车（Piggyback）优化</h3><p><strong>实现</strong>: <code>group.TryPiggyback(key)</code></p>
<p><strong>作用</strong>: 从正在进行的完整读取中获取部分数据</p>
<p><strong>优势</strong>: 减少网络请求，提高效率</p>
<h3 id="5-限流控制"><a href="#5-限流控制" class="headerlink" title="5. 限流控制"></a>5. 限流控制</h3><p><strong>上传限流</strong>: <code>upLimit</code> (ratelimit.Bucket)<br><strong>下载限流</strong>: <code>downLimit</code> (ratelimit.Bucket)</p>
<p><strong>实现</strong>: 使用令牌桶算法</p>
<h3 id="6-压缩支持"><a href="#6-压缩支持" class="headerlink" title="6. 压缩支持"></a>6. 压缩支持</h3><p><strong>压缩时机</strong>: 上传时压缩<br><strong>解压时机</strong>: 下载时解压</p>
<p><strong>判断</strong>: <code>compressor.CompressBound(0) == 0</code> 判断是否支持随机访问</p>
<h3 id="7-预取（Prefetch）"><a href="#7-预取（Prefetch）" class="headerlink" title="7. 预取（Prefetch）"></a>7. 预取（Prefetch）</h3><p><strong>实现</strong>: <code>fetcher.fetch(key)</code></p>
<p><strong>作用</strong>: 后台预取可能访问的数据</p>
<p><strong>触发</strong>: 读取时自动触发</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="1-缓存优先"><a href="#1-缓存优先" class="headerlink" title="1. 缓存优先"></a>1. 缓存优先</h3><p><strong>策略</strong>: 先查缓存，减少网络请求</p>
<p><strong>实现</strong>: <code>ReadAt</code> 中先调用 <code>bcache.load</code></p>
<h3 id="2-部分读取优化"><a href="#2-部分读取优化" class="headerlink" title="2. 部分读取优化"></a>2. 部分读取优化</h3><p><strong>策略</strong>: 如果支持随机访问，使用 Range 请求</p>
<p><strong>实现</strong>: <code>seekable &amp;&amp; boff &gt; 0 &amp;&amp; len(p) &lt;= blockSize/4</code></p>
<h3 id="3-单飞去重"><a href="#3-单飞去重" class="headerlink" title="3. 单飞去重"></a>3. 单飞去重</h3><p><strong>策略</strong>: 避免重复请求相同数据</p>
<p><strong>实现</strong>: <code>group.Execute</code> 确保同一 key 只请求一次</p>
<h3 id="4-搭便车优化"><a href="#4-搭便车优化" class="headerlink" title="4. 搭便车优化"></a>4. 搭便车优化</h3><p><strong>策略</strong>: 从正在进行的读取中获取数据</p>
<p><strong>实现</strong>: <code>group.TryPiggyback</code></p>
<h3 id="5-写回优化"><a href="#5-写回优化" class="headerlink" title="5. 写回优化"></a>5. 写回优化</h3><p><strong>策略</strong>: 小数据块先写本地，延迟上传</p>
<p><strong>实现</strong>: <code>writeback &amp;&amp; blen &lt; WritebackThresholdSize</code></p>
<h3 id="6-批量上传"><a href="#6-批量上传" class="headerlink" title="6. 批量上传"></a>6. 批量上传</h3><p><strong>策略</strong>: 延迟上传，批量处理</p>
<p><strong>实现</strong>: <code>pendingCh</code> 通道 + <code>uploader</code> goroutine</p>
<h3 id="7-预取"><a href="#7-预取" class="headerlink" title="7. 预取"></a>7. 预取</h3><p><strong>策略</strong>: 后台预取可能访问的数据</p>
<p><strong>实现</strong>: <code>fetcher.fetch</code> 在读取后触发</p>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><h3 id="1-锁保护"><a href="#1-锁保护" class="headerlink" title="1. 锁保护"></a>1. 锁保护</h3><p><strong>pendingMutex</strong>: 保护 <code>pendingKeys</code> 映射</p>
<p><strong>使用场景</strong>:</p>
<ul>
<li><code>addDelayedStaging</code></li>
<li><code>removePending</code></li>
<li><code>isPendingValid</code></li>
<li><code>scanDelayedStaging</code></li>
</ul>
<h3 id="2-通道限流"><a href="#2-通道限流" class="headerlink" title="2. 通道限流"></a>2. 通道限流</h3><p><strong>currentUpload</strong>: 限制并发上传数</p>
<p><strong>实现</strong>: <code>make(chan bool, config.MaxUpload)</code></p>
<h3 id="3-单飞去重-1"><a href="#3-单飞去重-1" class="headerlink" title="3. 单飞去重"></a>3. 单飞去重</h3><p><strong>group</strong>: 使用单飞控制器去重请求</p>
<p><strong>实现</strong>: <code>group.Execute</code> 确保同一 key 只执行一次</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><h3 id="1-重试机制"><a href="#1-重试机制" class="headerlink" title="1. 重试机制"></a>1. 重试机制</h3><p><strong>上传重试</strong>: 指数退避，最多 <code>MaxRetries + 1</code> 次</p>
<p><strong>实现</strong>: <code>for try &lt; max; try++ &#123; time.Sleep(time.Second * time.Duration(try*try)) &#125;</code></p>
<h3 id="2-超时控制"><a href="#2-超时控制" class="headerlink" title="2. 超时控制"></a>2. 超时控制</h3><p><strong>读取超时</strong>: <code>GetTimeout</code> (默认 60 秒)<br><strong>上传超时</strong>: <code>PutTimeout</code> (默认 60 秒)</p>
<p><strong>实现</strong>: <code>utils.WithTimeout</code></p>
<h3 id="3-错误指标"><a href="#3-错误指标" class="headerlink" title="3. 错误指标"></a>3. 错误指标</h3><p><strong>指标</strong>:</p>
<ul>
<li><code>objectReqErrors</code>: 对象请求错误数</li>
<li><code>stageBlockErrors</code>: 暂存块错误数</li>
</ul>
<h3 id="4-错误恢复"><a href="#4-错误恢复" class="headerlink" title="4. 错误恢复"></a>4. 错误恢复</h3><p><strong>缓存错误</strong>: 移除缓存项，回退到对象存储</p>
<p><strong>上传错误</strong>: 重试，如果失败返回错误</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><h3 id="1-Page-池"><a href="#1-Page-池" class="headerlink" title="1. Page 池"></a>1. Page 池</h3><p><strong>实现</strong>: <code>pagePool</code> 通道</p>
<p><strong>作用</strong>: 复用 Page，减少内存分配</p>
<h3 id="2-引用计数"><a href="#2-引用计数" class="headerlink" title="2. 引用计数"></a>2. 引用计数</h3><p><strong>Page.Acquire&#x2F;Release</strong>: 管理 Page 的生命周期</p>
<h3 id="3-内存限制"><a href="#3-内存限制" class="headerlink" title="3. 内存限制"></a>3. 内存限制</h3><p><strong>缓存大小</strong>: <code>CacheSize</code> 限制缓存总大小</p>
<p><strong>实现</strong>: 缓存管理器负责淘汰</p>
<h2 id="关键算法"><a href="#关键算法" class="headerlink" title="关键算法"></a>关键算法</h2><h3 id="1-键生成算法"><a href="#1-键生成算法" class="headerlink" title="1. 键生成算法"></a>1. 键生成算法</h3><p><strong>HashPrefix 模式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunks/&#123;id%256&#125;/&#123;(id/1000)/1000&#125;/&#123;id&#125;_&#123;indx&#125;_&#123;size&#125;</span><br></pre></td></tr></table></figure>

<p><strong>普通模式</strong>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunks/&#123;(id/1000)/1000&#125;/&#123;id/1000&#125;/&#123;id&#125;_&#123;indx&#125;_&#123;size&#125;</span><br></pre></td></tr></table></figure>

<p><strong>设计目的</strong>: 分散对象存储负载</p>
<h3 id="2-块大小计算"><a href="#2-块大小计算" class="headerlink" title="2. 块大小计算"></a>2. 块大小计算</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func (s *rSlice) blockSize(indx int) int &#123;</span><br><span class="line">	bsize := s.length - indx*s.store.conf.BlockSize</span><br><span class="line">	if bsize &gt; s.store.conf.BlockSize &#123;</span><br><span class="line">		bsize = s.store.conf.BlockSize</span><br><span class="line">	&#125;</span><br><span class="line">	return bsize</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 计算指定索引的块大小</p>
<p><strong>特点</strong>: 最后一个块可能小于 <code>BlockSize</code></p>
<h3 id="3-上传时间窗口"><a href="#3-上传时间窗口" class="headerlink" title="3. 上传时间窗口"></a>3. 上传时间窗口</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func (store *cachedStore) canUpload() bool &#123;</span><br><span class="line">	if store.startHour == store.endHour &#123;</span><br><span class="line">		return true</span><br><span class="line">	&#125;</span><br><span class="line">	h := time.Now().Hour()</span><br><span class="line">	return store.startHour &lt; store.endHour &amp;&amp; h &gt;= store.startHour &amp;&amp; h &lt; store.endHour ||</span><br><span class="line">		store.startHour &gt; store.endHour &amp;&amp; (h &gt;= store.startHour || h &lt; store.endHour)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>功能</strong>: 判断当前时间是否允许上传</p>
<p><strong>支持</strong>: 跨天时间窗口（如 22:00-02:00）</p>
<h2 id="数据结构关系图"><a href="#数据结构关系图" class="headerlink" title="数据结构关系图"></a>数据结构关系图</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">cachedStore</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; storage: object.ObjectStorage</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; bcache: CacheManager</span><br><span class="line">    │       │</span><br><span class="line">    │       └─&gt; cacheStore (多个)</span><br><span class="line">    │               │</span><br><span class="line">    │               ├─&gt; pages: map[string]*Page</span><br><span class="line">    │               └─&gt; keys: KeyIndex</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; fetcher: *prefetcher</span><br><span class="line">    │       │</span><br><span class="line">    │       └─&gt; prefetch queue</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; group: *Controller</span><br><span class="line">    │       │</span><br><span class="line">    │       └─&gt; singleflight map</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; currentUpload: chan bool (限流)</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; pendingCh: chan *pendingItem</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; pendingKeys: map[string]*pendingItem</span><br><span class="line">    │</span><br><span class="line">    ├─&gt; upLimit: *ratelimit.Bucket</span><br><span class="line">    │</span><br><span class="line">    └─&gt; downLimit: *ratelimit.Bucket</span><br></pre></td></tr></table></figure>

<h2 id="关键设计决策"><a href="#关键设计决策" class="headerlink" title="关键设计决策"></a>关键设计决策</h2><h3 id="1-为什么使用多级缓存？"><a href="#1-为什么使用多级缓存？" class="headerlink" title="1. 为什么使用多级缓存？"></a>1. 为什么使用多级缓存？</h3><p><strong>原因</strong>:</p>
<ul>
<li>内存缓存：最快，但容量有限</li>
<li>磁盘缓存：较快，容量较大</li>
<li>对象存储：最慢，容量无限</li>
</ul>
<p><strong>优势</strong>:</p>
<ul>
<li>平衡性能和成本</li>
<li>提高缓存命中率</li>
</ul>
<h3 id="2-为什么使用写回机制？"><a href="#2-为什么使用写回机制？" class="headerlink" title="2. 为什么使用写回机制？"></a>2. 为什么使用写回机制？</h3><p><strong>原因</strong>:</p>
<ul>
<li>提高写入性能</li>
<li>减少网络请求</li>
<li>支持批量上传</li>
</ul>
<p><strong>实现</strong>:</p>
<ul>
<li>小数据块先写本地</li>
<li>延迟上传到对象存储</li>
<li>支持时间窗口控制</li>
</ul>
<h3 id="3-为什么使用单飞去重？"><a href="#3-为什么使用单飞去重？" class="headerlink" title="3. 为什么使用单飞去重？"></a>3. 为什么使用单飞去重？</h3><p><strong>原因</strong>:</p>
<ul>
<li>避免重复请求相同数据</li>
<li>减少网络请求</li>
<li>提高效率</li>
</ul>
<p><strong>实现</strong>:</p>
<ul>
<li><code>group.Execute</code> 确保同一 key 只执行一次</li>
<li>其他请求等待结果</li>
</ul>
<h3 id="4-为什么使用搭便车优化？"><a href="#4-为什么使用搭便车优化？" class="headerlink" title="4. 为什么使用搭便车优化？"></a>4. 为什么使用搭便车优化？</h3><p><strong>原因</strong>:</p>
<ul>
<li>从正在进行的读取中获取数据</li>
<li>减少网络请求</li>
<li>提高效率</li>
</ul>
<p><strong>实现</strong>:</p>
<ul>
<li><code>group.TryPiggyback</code> 尝试获取部分数据</li>
<li>如果成功，直接返回</li>
</ul>
<h3 id="5-为什么使用部分读取优化？"><a href="#5-为什么使用部分读取优化？" class="headerlink" title="5. 为什么使用部分读取优化？"></a>5. 为什么使用部分读取优化？</h3><p><strong>原因</strong>:</p>
<ul>
<li>减少数据传输</li>
<li>提高效率</li>
<li>支持随机访问</li>
</ul>
<p><strong>实现</strong>:</p>
<ul>
<li>如果支持随机访问且读取范围小，使用 Range 请求</li>
<li>否则读取完整块</li>
</ul>
<h2 id="潜在问题和改进"><a href="#潜在问题和改进" class="headerlink" title="潜在问题和改进"></a>潜在问题和改进</h2><h3 id="1-缓存一致性"><a href="#1-缓存一致性" class="headerlink" title="1. 缓存一致性"></a>1. 缓存一致性</h3><p><strong>问题</strong>: 多个客户端可能缓存不同版本的数据</p>
<p><strong>改进</strong>: 使用版本号或校验和</p>
<h3 id="2-缓存淘汰"><a href="#2-缓存淘汰" class="headerlink" title="2. 缓存淘汰"></a>2. 缓存淘汰</h3><p><strong>问题</strong>: 缓存淘汰策略可能不够优化</p>
<p><strong>改进</strong>: 使用更智能的淘汰策略（如 LRU）</p>
<h3 id="3-错误恢复"><a href="#3-错误恢复" class="headerlink" title="3. 错误恢复"></a>3. 错误恢复</h3><p><strong>问题</strong>: 某些错误（如网络错误）可能导致数据不一致</p>
<p><strong>改进</strong>: 实现更完善的错误恢复机制</p>
<h3 id="4-性能优化"><a href="#4-性能优化" class="headerlink" title="4. 性能优化"></a>4. 性能优化</h3><p><strong>问题</strong>: </p>
<ul>
<li>部分读取可能不够优化</li>
<li>预取策略可能不够智能</li>
</ul>
<p><strong>改进</strong>: </p>
<ul>
<li>优化部分读取逻辑</li>
<li>实现更智能的预取策略</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>cached_store.go</code> 文件实现了 JuiceFS 的带缓存的块存储功能，具有以下特点：</p>
<ol>
<li><strong>多级缓存</strong>: 内存、磁盘、对象存储三级缓存</li>
<li><strong>写回机制</strong>: 小数据块先写本地，延迟上传</li>
<li><strong>性能优化</strong>: 单飞去重、搭便车、部分读取、预取</li>
<li><strong>限流控制</strong>: 上传和下载限流</li>
<li><strong>压缩支持</strong>: 支持数据压缩和解压</li>
<li><strong>并发安全</strong>: 使用锁和通道保护并发访问</li>
<li><strong>错误处理</strong>: 重试机制、超时控制、错误指标</li>
<li><strong>内存管理</strong>: Page 池、引用计数、缓存淘汰</li>
</ol>
<p>它是 JuiceFS 存储性能的关键组件，实现了高效的缓存管理和数据访问优化。</p>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cached-store"><span class="toc-number">1.</span> <span class="toc-text">cached_store</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">文件结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.</span> <span class="toc-text">常量定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chunkSize"><span class="toc-number">1.2.1.</span> <span class="toc-text">chunkSize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pageSize"><span class="toc-number">1.2.2.</span> <span class="toc-text">pageSize</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SlowRequest"><span class="toc-number">1.2.3.</span> <span class="toc-text">SlowRequest</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.3.</span> <span class="toc-text">核心结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-pendingItem-%E5%BE%85%E4%B8%8A%E4%BC%A0%E9%A1%B9"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. pendingItem - 待上传项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-rSlice-%E8%AF%BB%E5%8F%96%E5%88%87%E7%89%87"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. rSlice - 读取切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-wSlice-%E5%86%99%E5%85%A5%E5%88%87%E7%89%87"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. wSlice - 写入切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Config-%E9%85%8D%E7%BD%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.4.</span> <span class="toc-text">4. Config - 配置结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-cachedStore-%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">5. cachedStore - 带缓存的存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">1.4.</span> <span class="toc-text">核心方法分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rSlice-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">rSlice 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-key-%E7%94%9F%E6%88%90%E5%AF%B9%E8%B1%A1%E5%AD%98%E5%82%A8%E9%94%AE"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">1. key - 生成对象存储键</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ReadAt-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">2. ReadAt - 读取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Remove-%E5%88%A0%E9%99%A4%E5%88%87%E7%89%87"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">3. Remove - 删除切片</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wSlice-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">wSlice 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-WriteAt-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">1. WriteAt - 写入数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-upload-%E4%B8%8A%E4%BC%A0%E5%9D%97"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">2. upload - 上传块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-FlushTo-%E5%88%B7%E6%96%B0%E5%88%B0%E6%8C%87%E5%AE%9A%E5%81%8F%E7%A7%BB"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">3. FlushTo - 刷新到指定偏移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Finish-%E5%AE%8C%E6%88%90%E5%86%99%E5%85%A5"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">4. Finish - 完成写入</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cachedStore-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">cachedStore 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-NewCachedStore-%E5%88%9B%E5%BB%BA%E5%B8%A6%E7%BC%93%E5%AD%98%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">1. NewCachedStore - 创建带缓存的存储</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-load-%E5%8A%A0%E8%BD%BD%E5%9D%97"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">2. load - 加载块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-upload-%E4%B8%8A%E4%BC%A0%E5%9D%97"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">3. upload - 上传块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-put-%E4%B8%8A%E4%BC%A0%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">4. put - 上传数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-uploader-%E4%B8%8A%E4%BC%A0%E5%99%A8"><span class="toc-number">1.4.3.5.</span> <span class="toc-text">5. uploader - 上传器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-uploadStagingFile-%E4%B8%8A%E4%BC%A0%E6%9A%82%E5%AD%98%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.3.6.</span> <span class="toc-text">6. uploadStagingFile - 上传暂存文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%88%86%E6%9E%90"><span class="toc-number">1.5.</span> <span class="toc-text">数据流分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">读取流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">写入流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%9B%9E%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">写回流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">1.6.</span> <span class="toc-text">设计模式和特点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.1.</span> <span class="toc-text">1. 缓存策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%86%99%E5%9B%9E%EF%BC%88Writeback%EF%BC%89%E6%9C%BA%E5%88%B6"><span class="toc-number">1.6.2.</span> <span class="toc-text">2. 写回（Writeback）机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E9%A3%9E%EF%BC%88Singleflight%EF%BC%89%E5%8E%BB%E9%87%8D"><span class="toc-number">1.6.3.</span> <span class="toc-text">3. 单飞（Singleflight）去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%90%AD%E4%BE%BF%E8%BD%A6%EF%BC%88Piggyback%EF%BC%89%E4%BC%98%E5%8C%96"><span class="toc-number">1.6.4.</span> <span class="toc-text">4. 搭便车（Piggyback）优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E9%99%90%E6%B5%81%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.5.</span> <span class="toc-text">5. 限流控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8E%8B%E7%BC%A9%E6%94%AF%E6%8C%81"><span class="toc-number">1.6.6.</span> <span class="toc-text">6. 压缩支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%A2%84%E5%8F%96%EF%BC%88Prefetch%EF%BC%89"><span class="toc-number">1.6.7.</span> <span class="toc-text">7. 预取（Prefetch）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.</span> <span class="toc-text">性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E4%BC%98%E5%85%88"><span class="toc-number">1.7.1.</span> <span class="toc-text">1. 缓存优先</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%83%A8%E5%88%86%E8%AF%BB%E5%8F%96%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.2.</span> <span class="toc-text">2. 部分读取优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E9%A3%9E%E5%8E%BB%E9%87%8D"><span class="toc-number">1.7.3.</span> <span class="toc-text">3. 单飞去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%90%AD%E4%BE%BF%E8%BD%A6%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.4.</span> <span class="toc-text">4. 搭便车优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%86%99%E5%9B%9E%E4%BC%98%E5%8C%96"><span class="toc-number">1.7.5.</span> <span class="toc-text">5. 写回优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%89%B9%E9%87%8F%E4%B8%8A%E4%BC%A0"><span class="toc-number">1.7.6.</span> <span class="toc-text">6. 批量上传</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E9%A2%84%E5%8F%96"><span class="toc-number">1.7.7.</span> <span class="toc-text">7. 预取</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.8.</span> <span class="toc-text">并发控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%81%E4%BF%9D%E6%8A%A4"><span class="toc-number">1.8.1.</span> <span class="toc-text">1. 锁保护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%80%9A%E9%81%93%E9%99%90%E6%B5%81"><span class="toc-number">1.8.2.</span> <span class="toc-text">2. 通道限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8D%95%E9%A3%9E%E5%8E%BB%E9%87%8D-1"><span class="toc-number">1.8.3.</span> <span class="toc-text">3. 单飞去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">1.9.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6"><span class="toc-number">1.9.1.</span> <span class="toc-text">1. 重试机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">1.9.2.</span> <span class="toc-text">2. 超时控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%99%E8%AF%AF%E6%8C%87%E6%A0%87"><span class="toc-number">1.9.3.</span> <span class="toc-text">3. 错误指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D"><span class="toc-number">1.9.4.</span> <span class="toc-text">4. 错误恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.10.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Page-%E6%B1%A0"><span class="toc-number">1.10.1.</span> <span class="toc-text">1. Page 池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">2. 引用计数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%86%85%E5%AD%98%E9%99%90%E5%88%B6"><span class="toc-number">1.10.3.</span> <span class="toc-text">3. 内存限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.</span> <span class="toc-text">关键算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%94%AE%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95"><span class="toc-number">1.11.1.</span> <span class="toc-text">1. 键生成算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9D%97%E5%A4%A7%E5%B0%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.11.2.</span> <span class="toc-text">2. 块大小计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8A%E4%BC%A0%E6%97%B6%E9%97%B4%E7%AA%97%E5%8F%A3"><span class="toc-number">1.11.3.</span> <span class="toc-text">3. 上传时间窗口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%B3%E7%B3%BB%E5%9B%BE"><span class="toc-number">1.12.</span> <span class="toc-text">数据结构关系图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96"><span class="toc-number">1.13.</span> <span class="toc-text">关键设计决策</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%EF%BC%9F"><span class="toc-number">1.13.1.</span> <span class="toc-text">1. 为什么使用多级缓存？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%86%99%E5%9B%9E%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">1.13.2.</span> <span class="toc-text">2. 为什么使用写回机制？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8D%95%E9%A3%9E%E5%8E%BB%E9%87%8D%EF%BC%9F"><span class="toc-number">1.13.3.</span> <span class="toc-text">3. 为什么使用单飞去重？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E6%90%AD%E4%BE%BF%E8%BD%A6%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.13.4.</span> <span class="toc-text">4. 为什么使用搭便车优化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E9%83%A8%E5%88%86%E8%AF%BB%E5%8F%96%E4%BC%98%E5%8C%96%EF%BC%9F"><span class="toc-number">1.13.5.</span> <span class="toc-text">5. 为什么使用部分读取优化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BD%9C%E5%9C%A8%E9%97%AE%E9%A2%98%E5%92%8C%E6%94%B9%E8%BF%9B"><span class="toc-number">1.14.</span> <span class="toc-text">潜在问题和改进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.14.1.</span> <span class="toc-text">1. 缓存一致性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0"><span class="toc-number">1.14.2.</span> <span class="toc-text">2. 缓存淘汰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D"><span class="toc-number">1.14.3.</span> <span class="toc-text">3. 错误恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.14.4.</span> <span class="toc-text">4. 性能优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.15.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2025/06/15/Juicefs/cached_store/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&text=Juicefs cached_store 分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&title=Juicefs cached_store 分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&is_video=false&description=Juicefs cached_store 分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Juicefs cached_store 分析&body=Check out this article: https://szza.github.io/2025/06/15/Juicefs/cached_store/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&title=Juicefs cached_store 分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&title=Juicefs cached_store 分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&title=Juicefs cached_store 分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&title=Juicefs cached_store 分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2025/06/15/Juicefs/cached_store/&name=Juicefs cached_store 分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2025/06/15/Juicefs/cached_store/&t=Juicefs cached_store 分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2026
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
