<!DOCTYPE html>
<html lang=en>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="MVCCmvcc 的核心组件 12345678910111213141516171819┌─────────────────────────────────────────────────────────────┐│                    etcd MVCC 系统                          │├────────────────────────────────">
<meta property="og:type" content="article">
<meta property="og:title" content="剖析 ETCD.mvcc">
<meta property="og:url" content="https://szza.github.io/2024/09/03/ETCD/3_mvcc/index.html">
<meta property="og:site_name" content="szza">
<meta property="og:description" content="MVCCmvcc 的核心组件 12345678910111213141516171819┌─────────────────────────────────────────────────────────────┐│                    etcd MVCC 系统                          │├────────────────────────────────">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-09-03T11:38:49.000Z">
<meta property="article:modified_time" content="2025-10-23T12:59:49.298Z">
<meta property="article:author" content="fibonaccii">
<meta property="article:tag" content="ETCD">
<meta name="twitter:card" content="summary">
    
    
      
        
          <link rel="shortcut icon" href="/images/id.jpg">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/id.jpg" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/id.jpg">
        
      
    
    <!-- title -->
    <title>剖析 ETCD.mvcc</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="szza" type="application/atom+xml">
</head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/2024/09/29/ETCD/4_lessor/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/2024/08/19/ETCD/2_kv/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">Previous post</span>
      <span id="i-next" class="info" style="display:none;">Next post</span>
      <span id="i-top" class="info" style="display:none;">Back to top</span>
      <span id="i-share" class="info" style="display:none;">Share post</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2024/09/03/ETCD/3_mvcc/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&text=剖析 ETCD.mvcc"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&title=剖析 ETCD.mvcc"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&is_video=false&description=剖析 ETCD.mvcc"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析 ETCD.mvcc&body=Check out this article: https://szza.github.io/2024/09/03/ETCD/3_mvcc/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&title=剖析 ETCD.mvcc"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&title=剖析 ETCD.mvcc"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&title=剖析 ETCD.mvcc"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&title=剖析 ETCD.mvcc"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&name=剖析 ETCD.mvcc&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&t=剖析 ETCD.mvcc"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MVCC"><span class="toc-number">1.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Compact"><span class="toc-number">1.0.1.</span> <span class="toc-text">Compact</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#updateCompactRev"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">updateCompactRev</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scheduleCompaction"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">scheduleCompaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#checkPrevCompactionCompleted"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">checkPrevCompactionCompleted</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Restore"><span class="toc-number">1.0.2.</span> <span class="toc-text">Restore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#restoreIntoIndex"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">restoreIntoIndex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#restoreChunk"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">restoreChunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">版本一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lease"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">lease</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compactLockfree"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">compactLockfree</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EtcdServer-applySnapshot"><span class="toc-number">1.0.2.5.1.</span> <span class="toc-text">EtcdServer.applySnapshot</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConsistentIndex"><span class="toc-number">1.1.</span> <span class="toc-text">ConsistentIndex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-apply-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">在 apply 中的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applyEntryNormal-%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">applyEntryNormal() 方法中的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%92%A9%E5%AD%90%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">事务钩子机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TxPostLockInsideApplyHook-%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">TxPostLockInsideApplyHook 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applySnapshot-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">applySnapshot 中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%80%E8%87%B4%E6%80%A7%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">在启动时一致性验证中的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OnPreCommitUnsafe"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">OnPreCommitUnsafe</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        剖析 ETCD.mvcc
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">fibonaccii</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2024-09-03T11:38:49.000Z" itemprop="datePublished">2024-09-03</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/ETCD/" rel="tag">ETCD</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>mvcc 的核心组件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────────────────────────────────────────────────────┐</span><br><span class="line">│                    etcd MVCC 系统                          │</span><br><span class="line">├─────────────────────────────────────────────────────────────┤</span><br><span class="line">│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │</span><br><span class="line">│  │   KV Store  │  │   Index     │  │      Backend        │ │</span><br><span class="line">│  │             │  │             │  │                     │ │</span><br><span class="line">│  │ • 事务管理   │  │ • B+树索引   │   │ • BoltDB存储引擎    │ │</span><br><span class="line">│  │ • 版本控制   │  │ • 版本管理    │  │ • 事务缓冲           │ │</span><br><span class="line">│  │ • 并发控制   │  │ • 压缩管理    │  │ • 快照管理           │ │</span><br><span class="line">│  └─────────────┘  └─────────────┘  └─────────────────────┘ │</span><br><span class="line">├─────────────────────────────────────────────────────────────┤</span><br><span class="line">│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐ │</span><br><span class="line">│  │   Watcher   │  │  Compaction │  │      Hash           │ │</span><br><span class="line">│  │             │  │             │  │                     │ │</span><br><span class="line">│  │ • 事件监听   │  │ • 版本清理   │  │ • 数据完整性校验       │ │</span><br><span class="line">│  │ • 事件分发   │  │ • 空间回收   │  │ • 快照验证            │ │</span><br><span class="line">│  │ • 同步机制   │  │ • 压缩调度   │  │                      │ │</span><br><span class="line">│  └─────────────┘  └─────────────┘  └─────────────────────┘ │</span><br><span class="line">└─────────────────────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>mvcc 的数据流转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">┌─────────────┐    ┌─────────────┐    ┌─────────────┐</span><br><span class="line">│   Client    │    │   KV Store  │    │   Backend   │</span><br><span class="line">│   Request   │───▶│             │───▶│  (BoltDB)   │</span><br><span class="line">└─────────────┘    └─────────────┘    └─────────────┘</span><br><span class="line">                          │                   │</span><br><span class="line">                          ▼                   ▼</span><br><span class="line">                   ┌─────────────┐    ┌─────────────┐</span><br><span class="line">                   │   Index     │    │   Buffer    │</span><br><span class="line">                   │  (B+Tree)   │    │ (txBuffer)  │</span><br><span class="line">                   └─────────────┘    └─────────────┘</span><br><span class="line">                          │                   │</span><br><span class="line">                          ▼                   ▼</span><br><span class="line">                   ┌─────────────┐    ┌─────────────┐</span><br><span class="line">                   │  Watcher    │    │ Compaction  │</span><br><span class="line">                   │   Events    │    │   Cleanup   │</span><br><span class="line">                   └─────────────┘    └─────────────┘</span><br></pre></td></tr></table></figure>
<h3 id="Compact"><a href="#Compact" class="headerlink" title="Compact"></a>Compact</h3><p><code>Compact</code> 也是一种<code>两阶段</code>设计思想</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">调用 Compact(rev)</span><br><span class="line">    ↓</span><br><span class="line">第一阶段: updateCompactRev(rev) - 更新压缩版本号</span><br><span class="line">    ↓  </span><br><span class="line">第二阶段: compact() - 异步调度压缩任务</span><br></pre></td></tr></table></figure>
<h4 id="updateCompactRev"><a href="#updateCompactRev" class="headerlink" title="updateCompactRev"></a>updateCompactRev</h4><p><code>Cpmpact</code> 任务的第一阶段。 </p>
<p>在 ETCD 中，存在一些单独的 Bukcet 用于存储一些元数据，比如 <code>Buckets.Meta</code> 存储当前需要调度的 compaction 任务的 revision 。</p>
<p>因此写入后，需要 <code>ForceCommit</code> 来保证元数据不会丢。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> updateCompactRev(rev <span class="type">int64</span>) (&lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, <span class="type">int64</span>, <span class="type">error</span>) &#123;</span><br><span class="line">    s.revMu.Lock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 版本号有效性检查</span></span><br><span class="line">    <span class="keyword">if</span> rev &lt;= s.compactMainRev &#123;</span><br><span class="line">        <span class="comment">// 已经压缩过，返回错误</span></span><br><span class="line">        <span class="keyword">return</span> ch, <span class="number">0</span>, ErrCompacted</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> rev &gt; s.currentRev &#123;</span><br><span class="line">        <span class="comment">// 版本号过大，返回错误</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, ErrFutureRev</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 更新压缩版本号</span></span><br><span class="line">    compactMainRev := s.compactMainRev</span><br><span class="line">    s.compactMainRev = rev</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 持久化压缩计划到数据库</span></span><br><span class="line">    rbytes := newRevBytes()</span><br><span class="line">    revToBytes(revision&#123;main: rev&#125;, rbytes)</span><br><span class="line">    </span><br><span class="line">    tx := s.b.BatchTx()</span><br><span class="line">    tx.LockInsideApply()</span><br><span class="line">    tx.UnsafePut(buckets.Meta, scheduledCompactKeyName, rbytes)</span><br><span class="line">    tx.Unlock()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 强制提交，确保压缩计划被持久化</span></span><br><span class="line">    s.b.ForceCommit()</span><br><span class="line">    </span><br><span class="line">    s.revMu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, compactMainRev, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="scheduleCompaction"><a href="#scheduleCompaction" class="headerlink" title="scheduleCompaction"></a>scheduleCompaction</h4><p><code>scheduleCompaction</code> 两阶段压缩：先压缩内存索引，再压缩数据库:</p>
<ul>
<li><p>批量处理：分批处理数据，避免长时间锁定</p>
<p>每次在最多处理的kv数由 <code>s.cfg.CompactionBatchLimit</code> 确定</p>
</li>
<li><p>保留策略：根据内存索引的压缩结果决定保留哪些数据</p>
<p>由 treeIndex Compact 完后的结果 <code>keep</code> 来决定DB中哪些数据是否保留</p>
</li>
<li><p>进度控制：每批处理后休眠，避免阻塞其他操作</p>
</li>
<li><p>完成标记：设置压缩完成标记，用于状态检查</p>
<p>更新 <code>buckets.Meta</code> 中的 key <code>finishedCompactKeyName</code> 的值，用于后续状态查询</p>
</li>
</ul>
<p>整体如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> scheduleCompaction(compactMainRev, prevCompactRev <span class="type">int64</span>) (KeyValueHash, <span class="type">error</span>) &#123;</span><br><span class="line">    totalStart := time.Now()</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一步：压缩内存索引</span></span><br><span class="line">    keep := s.kvindex.Compact(compactMainRev)</span><br><span class="line">    indexCompactionPauseMs.Observe(<span class="type">float64</span>(time.Since(totalStart) / time.Millisecond))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 准备压缩范围</span></span><br><span class="line">    end := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>)</span><br><span class="line">    binary.BigEndian.PutUint64(end, <span class="type">uint64</span>(compactMainRev+<span class="number">1</span>))</span><br><span class="line">    </span><br><span class="line">    batchNum := s.cfg.CompactionBatchLimit</span><br><span class="line">    h := newKVHasher(prevCompactRev, compactMainRev, keep)</span><br><span class="line">    last := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>+<span class="number">1</span>+<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 批量处理压缩</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> rev revision</span><br><span class="line">        </span><br><span class="line">        start := time.Now()</span><br><span class="line">        </span><br><span class="line">        tx := s.b.BatchTx()</span><br><span class="line">        tx.LockOutsideApply()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取一批需要处理的数据</span></span><br><span class="line">        keys, values := tx.UnsafeRange(buckets.Key, last, end, <span class="type">int64</span>(batchNum))</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> keys &#123;</span><br><span class="line">            rev = bytesToRev(keys[i])</span><br><span class="line">            <span class="keyword">if</span> _, ok := keep[rev]; !ok &#123;</span><br><span class="line">                <span class="comment">// 删除不需要保留的数据</span></span><br><span class="line">                tx.UnsafeDelete(buckets.Key, keys[i])</span><br><span class="line">                keyCompactions++</span><br><span class="line">            &#125;</span><br><span class="line">            h.WriteKeyValue(keys[i], values[i])</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查是否处理完成</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(keys) &lt; batchNum &#123;</span><br><span class="line">            <span class="comment">// 设置压缩完成标记</span></span><br><span class="line">            rbytes := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">8</span>+<span class="number">1</span>+<span class="number">8</span>)</span><br><span class="line">            revToBytes(revision&#123;main: compactMainRev&#125;, rbytes)</span><br><span class="line">            tx.UnsafePut(buckets.Meta, finishedCompactKeyName, rbytes)</span><br><span class="line">            tx.Unlock()</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录压缩完成信息</span></span><br><span class="line">            hash := h.Hash()</span><br><span class="line">            size, sizeInUse := s.b.Size(), s.b.SizeInUse()</span><br><span class="line">            s.lg.Info(<span class="string">&quot;finished scheduled compaction&quot;</span>, ...)</span><br><span class="line">            <span class="keyword">return</span> hash, <span class="literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新处理位置</span></span><br><span class="line">        revToBytes(revision&#123;main: rev.main, sub: rev.sub + <span class="number">1</span>&#125;, last)</span><br><span class="line">        tx.Unlock()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 立即提交压缩删除操作</span></span><br><span class="line">        s.b.ForceCommit()</span><br><span class="line">        dbCompactionPauseMs.Observe(<span class="type">float64</span>(time.Since(start) / time.Millisecond))</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 一个 batch 结束, 休眠一段时间，避免阻塞其他操作</span></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> &lt;-time.After(s.cfg.CompactionSleepInterval):</span><br><span class="line">        <span class="keyword">case</span> &lt;-s.stopc:</span><br><span class="line">            <span class="keyword">return</span> KeyValueHash&#123;&#125;, fmt.Errorf(<span class="string">&quot;interrupted due to stop signal&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="checkPrevCompactionCompleted"><a href="#checkPrevCompactionCompleted" class="headerlink" title="checkPrevCompactionCompleted"></a>checkPrevCompactionCompleted</h4><p>根据 <code>Buckets.Meta</code> 中 <code>key:finishedCompactKeyName</code> 和 <code>key:scheduledCompactKeyName</code> 的最新值，来判断上次 Compaction 是否完成。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> checkPrevCompactionCompleted() <span class="type">bool</span> &#123;</span><br><span class="line">    tx := s.b.ReadTx()</span><br><span class="line">    tx.Lock()</span><br><span class="line">    <span class="keyword">defer</span> tx.Unlock()</span><br><span class="line">    </span><br><span class="line">    scheduledCompact, scheduledCompactFound := UnsafeReadScheduledCompact(tx)</span><br><span class="line">    finishedCompact, finishedCompactFound := UnsafeReadFinishedCompact(tx)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查上一次压缩是否完成</span></span><br><span class="line">    <span class="keyword">return</span> scheduledCompact == finishedCompact &amp;&amp; scheduledCompactFound == finishedCompactFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Restore"><a href="#Restore" class="headerlink" title="Restore"></a>Restore</h3><p><code>Restore</code> 为 <code>NewStore</code> 和 <code>store.restore</code> 提供统一实现，即是创建一个新的 KV 实例和从已有的数据恢复成一个 KV 实例，提供了一个统一实现:</p>
<ul>
<li><p>恢复 compactMainRev 和 currentRev 版本号</p>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 如果先恢复 currentRev, 再恢复 compactMainRev:</span><br><span class="line">// 1. currentRev 可能小于 compactMainRev</span><br><span class="line">// 2. 导致数据不一致</span><br><span class="line">// 3. 可能触发错误的压缩操作</span><br><span class="line"></span><br><span class="line">// 正确的顺序确保：</span><br><span class="line">// 1. 压缩版本号先确定</span><br><span class="line">// 2. 键值对按版本顺序恢复</span><br><span class="line">// 3. 当前版本号最后确定，确保一致性</span><br></pre></td></tr></table></figure></li>
<li><p>并发恢复 treeIndex 中的索引数据</p>
</li>
<li><p>恢复 lease 租约信息</p>
</li>
<li><p>处理未完成的 compaction 任务</p>
</li>
</ul>
<p>完整实现如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> restore() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 设置监控报告器</span></span><br><span class="line">    s.setupMetricsReporter()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 准备恢复范围</span></span><br><span class="line">    min, max := newRevBytes(), newRevBytes()</span><br><span class="line">    revToBytes(revision&#123;main: <span class="number">1</span>&#125;, min)                                  <span class="comment">// 从版本 1 开始</span></span><br><span class="line">    revToBytes(revision&#123;main: math.MaxInt64, sub: math.MaxInt64&#125;, max)  <span class="comment">// 到最大版本</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 初始化租约映射</span></span><br><span class="line">    keyToLease := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]lease.LeaseID)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 恢复压缩版本号</span></span><br><span class="line">    tx := s.b.ReadTx()</span><br><span class="line">    tx.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 恢复已完成的压缩版本号: finishedCompact</span></span><br><span class="line">    finishedCompact, found := UnsafeReadFinishedCompact(tx)</span><br><span class="line">    <span class="keyword">if</span> found &#123;</span><br><span class="line">        s.revMu.Lock()</span><br><span class="line">        s.compactMainRev = finishedCompact</span><br><span class="line">        s.lg.Info(<span class="string">&quot;restored last compact revision&quot;</span>, </span><br><span class="line">            zap.Int64(<span class="string">&quot;restored-compact-revision&quot;</span>, s.compactMainRev))</span><br><span class="line">        s.revMu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取计划的压缩版本号</span></span><br><span class="line">    scheduledCompact, _ := UnsafeReadScheduledCompact(tx)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 并发恢复 treeIndex 索引数据</span></span><br><span class="line">    keysGauge.Set(<span class="number">0</span>)</span><br><span class="line">    rkvc, revc := restoreIntoIndex(s.lg, s.kvindex)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 6. 分块读取和恢复数据</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        keys, vals := tx.UnsafeRange(buckets.Key, min, max, <span class="type">int64</span>(restoreChunkKeys))</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理当前块的数据</span></span><br><span class="line">        restoreChunk(s.lg, rkvc, keys, vals, keyToLease)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(keys) &lt; restoreChunkKeys &#123;</span><br><span class="line">            <span class="comment">// 部分集合意味着最终集合</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新下一个块的起始位置</span></span><br><span class="line">        newMin := bytesToRev(keys[<span class="built_in">len</span>(keys)<span class="number">-1</span>][:revBytesLen])</span><br><span class="line">        newMin.sub++</span><br><span class="line">        revToBytes(newMin, min)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(rkvc)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 恢复当前版本号</span></span><br><span class="line">    &#123;</span><br><span class="line">        s.revMu.Lock()</span><br><span class="line">        s.currentRev = &lt;-revc</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理压缩后的版本号调整</span></span><br><span class="line">        <span class="keyword">if</span> s.currentRev &lt; s.compactMainRev &#123;</span><br><span class="line">            s.currentRev = s.compactMainRev</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理未完成压缩的情况</span></span><br><span class="line">        <span class="keyword">if</span> s.currentRev &lt; scheduledCompact &#123;</span><br><span class="line">            s.currentRev = scheduledCompact</span><br><span class="line">        &#125;</span><br><span class="line">        s.revMu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 8. 处理未完成的压缩</span></span><br><span class="line">    <span class="keyword">if</span> scheduledCompact &lt;= s.compactMainRev &#123;</span><br><span class="line">        scheduledCompact = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 9. 恢复租约信息</span></span><br><span class="line">    <span class="keyword">for</span> key, lid := <span class="keyword">range</span> keyToLease &#123;</span><br><span class="line">        <span class="keyword">if</span> s.le == <span class="literal">nil</span> &#123;</span><br><span class="line">            tx.Unlock()</span><br><span class="line">            <span class="built_in">panic</span>(<span class="string">&quot;no lessor to attach lease&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        err := s.le.Attach(lid, []lease.LeaseItem&#123;&#123;Key: key&#125;&#125;)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.lg.Error(<span class="string">&quot;failed to attach a lease&quot;</span>, zap.Error(err))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tx.Unlock()</span><br><span class="line"></span><br><span class="line">    s.lg.Info(<span class="string">&quot;kvstore restored&quot;</span>, zap.Int64(<span class="string">&quot;current-rev&quot;</span>, s.currentRev))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 10. 处理未完成的压缩任务</span></span><br><span class="line">    <span class="keyword">if</span> scheduledCompact != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := s.compactLockfree(scheduledCompact); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.lg.Warn(<span class="string">&quot;compaction encountered error&quot;</span>, zap.Error(err))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="restoreIntoIndex"><a href="#restoreIntoIndex" class="headerlink" title="restoreIntoIndex"></a>restoreIntoIndex</h4><p><code>restoreIntoIndex</code> 是创建一个新的消费者 goroutine，来 restore treeIndex 与主线程 <code>restoreChunk</code> 一起并发 restore. </p>
<ul>
<li>生产者-消费者模式：使用通道进行数据传输</li>
<li>缓存优化：使用 LRU 风格的缓存策略</li>
<li>并发安全：在单独的 goroutine 中处理索引更新</li>
<li>内存控制：通过缓存大小限制内存使用</li>
</ul>
<p>完整实现如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> revKeyValue <span class="keyword">struct</span> &#123;</span><br><span class="line">	key  []<span class="type">byte</span>          <span class="comment">// 版本化的键（包含 revision 信息）</span></span><br><span class="line">	kv   mvccpb.KeyValue <span class="comment">// 键值对数据 (User&#x27;s Key Value)</span></span><br><span class="line">	kstr <span class="type">string</span>          <span class="comment">// kv.Key 的字符串形式（用于缓存查找）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreIntoIndex</span><span class="params">(lg *zap.Logger, idx index)</span></span> (<span class="keyword">chan</span>&lt;- revKeyValue, &lt;-<span class="keyword">chan</span> <span class="type">int64</span>) &#123;</span><br><span class="line">    rkvc, revc := <span class="built_in">make</span>(<span class="keyword">chan</span> revKeyValue, restoreChunkKeys), <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int64</span>, <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        currentRev := <span class="type">int64</span>(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; revc &lt;- currentRev &#125;()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建键索引缓存</span></span><br><span class="line">        kiCache := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]*keyIndex, restoreChunkKeys)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> rkv := <span class="keyword">range</span> rkvc &#123;</span><br><span class="line">            ki, ok := kiCache[rkv.kstr]</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 缓存清理策略：当缓存满且未命中时，清理部分缓存</span></span><br><span class="line">            <span class="keyword">if</span> !ok &amp;&amp; <span class="built_in">len</span>(kiCache) &gt;= restoreChunkKeys &#123;</span><br><span class="line">                i := <span class="number">10</span></span><br><span class="line">                <span class="comment">// kiCache 是 unordered, range 是随机访问</span></span><br><span class="line">                <span class="comment">// 因此 delete 是随机删除</span></span><br><span class="line">                <span class="keyword">for</span> k := <span class="keyword">range</span> kiCache &#123;</span><br><span class="line">                    <span class="built_in">delete</span>(kiCache, k)</span><br><span class="line">                    <span class="keyword">if</span> i--; i == <span class="number">0</span> &#123;</span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 缓存未命中，从树索引中获取</span></span><br><span class="line">            <span class="keyword">if</span> !ok &#123;</span><br><span class="line">                ki = &amp;keyIndex&#123;key: rkv.kv.Key&#125;</span><br><span class="line">                <span class="keyword">if</span> idxKey := idx.KeyIndex(ki); idxKey != <span class="literal">nil</span> &#123;</span><br><span class="line">                    kiCache[rkv.kstr], ki = idxKey, idxKey</span><br><span class="line">                    ok = <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            rev := bytesToRev(rkv.key) <span class="comment">// revision_byte to rev</span></span><br><span class="line">            currentRev = rev.main</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                <span class="comment">/// rkv.kv.Key 在 treeIndex 中已存在索引</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> isTombstone(rkv.key) &#123;</span><br><span class="line">                    <span class="comment">// 处理墓碑标记</span></span><br><span class="line">                    <span class="keyword">if</span> err := ki.tombstone(lg, rev.main, rev.sub); err != <span class="literal">nil</span> &#123;</span><br><span class="line">                        lg.Warn(<span class="string">&quot;tombstone encountered error&quot;</span>, zap.Error(err))</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 插入</span></span><br><span class="line">                ki.put(lg, rev.main, rev.sub)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 键索引不存在，创建新的</span></span><br><span class="line">                <span class="keyword">if</span> isTombstone(rkv.key) &#123;</span><br><span class="line">                    ki.restoreTombstone(lg, rev.main, rev.sub)</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ki.restore(lg, revision&#123;rkv.kv.CreateRevision, <span class="number">0</span>&#125;, rev, rkv.kv.Version)</span><br><span class="line">                &#125;</span><br><span class="line">                idx.Insert(ki)</span><br><span class="line">                kiCache[rkv.kstr] = ki <span class="comment">// update cache</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rkvc, revc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="restoreChunk"><a href="#restoreChunk" class="headerlink" title="restoreChunk"></a>restoreChunk</h4><p><code>restoreChunk</code> 在 restore 主线程中处理，将从 backend 中获取到的数据进行租约 lease 信息处理，处理完将这个 batch 的数据集 <code>rkv</code> 通过 channel 传递给消费者 goroutine: restoreIntoIndex 去恢复 treeIndex。</p>
<p>restoreChunk:</p>
<ul>
<li>一次最多处理 <code>restoreChunkKeys</code> 个 {key value}</li>
<li>etcdServer.Restore 需要先恢复 leasor 信息</li>
</ul>
<p>store.restore 这部分关系如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// func restore</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		keys, vals := tx.UnsafeRange(buckets.Key, min, max, <span class="type">int64</span>(restoreChunkKeys))</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(keys) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// rkvc blocks if the total pending keys exceeds the restore</span></span><br><span class="line">		<span class="comment">// chunk size to keep keys from consuming too much memory.</span></span><br><span class="line">		restoreChunk(s.lg, rkvc, keys, vals, keyToLease)</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(keys) &lt; restoreChunkKeys &#123;</span><br><span class="line">			<span class="comment">// partial set implies final set</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// next set begins after where this one ended</span></span><br><span class="line">		newMin := bytesToRev(keys[<span class="built_in">len</span>(keys)<span class="number">-1</span>][:revBytesLen])</span><br><span class="line">		newMin.sub++</span><br><span class="line">		revToBytes(newMin, min)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">restoreChunk</span><span class="params">(lg *zap.Logger, kvc <span class="keyword">chan</span>&lt;- revKeyValue, keys, vals [][]<span class="type">byte</span>, keyToLease <span class="keyword">map</span>[<span class="type">string</span>]lease.LeaseID)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i, key := <span class="keyword">range</span> keys &#123;</span><br><span class="line">        rkv := revKeyValue&#123;key: key&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 反序列化键值对</span></span><br><span class="line">        <span class="keyword">if</span> err := rkv.kv.Unmarshal(vals[i]); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            lg.Fatal(<span class="string">&quot;failed to unmarshal mvccpb.KeyValue&quot;</span>, zap.Error(err))</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rkv.kstr = <span class="type">string</span>(rkv.kv.Key)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理租约信息</span></span><br><span class="line">        <span class="keyword">if</span> isTombstone(key) &#123;</span><br><span class="line">            <span class="comment">// 墓碑标记，删除租约关联</span></span><br><span class="line">            <span class="built_in">delete</span>(keyToLease, rkv.kstr)</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> lid := lease.LeaseID(rkv.kv.Lease); lid != lease.NoLease &#123;</span><br><span class="line">            <span class="comment">// 有租约，记录租约关联</span></span><br><span class="line">            keyToLease[rkv.kstr] = lid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 无租约，删除租约关联</span></span><br><span class="line">            <span class="built_in">delete</span>(keyToLease, rkv.kstr)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 发送到索引恢复通道</span></span><br><span class="line">        kvc &lt;- rkv</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="版本一致性"><a href="#版本一致性" class="headerlink" title="版本一致性"></a>版本一致性</h4><p>在完成上述操作后，即可获得最大 revision，但是仍需要调整下版本号:</p>
<ul>
<li>压缩后调整：确保 currentRev &gt;&#x3D; compactMainRev</li>
<li>未完成压缩：使用 scheduledCompact 调整版本号</li>
<li>墓碑版本处理：正确处理删除操作的版本号</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本号恢复逻辑</span></span><br><span class="line"></span><br><span class="line">finishedCompact, found := UnsafeReadFinishedCompact(tx)</span><br><span class="line"><span class="keyword">if</span> found &#123;</span><br><span class="line">    s.compactMainRev = finishedCompact</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//..</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    s.revMu.Lock()</span><br><span class="line">    s.currentRev = &lt;-revc  <span class="comment">// 从 treeIndex 索引恢复过程中获取最大版本号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况1：处理压缩后的版本号调整</span></span><br><span class="line">    <span class="comment">// 在压缩过程中，某些版本可能被删除，需要确保当前版本号不小于压缩版本号</span></span><br><span class="line">    <span class="keyword">if</span> s.currentRev &lt; s.compactMainRev &#123;</span><br><span class="line">        s.currentRev = s.compactMainRev</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 情况2：处理未完成压缩的情况</span></span><br><span class="line">    <span class="comment">// 如果 etcd 在压缩过程中崩溃，可能导致版本号不一致</span></span><br><span class="line">    <span class="comment">// 使用计划的压缩版本号来调整当前版本号</span></span><br><span class="line">    <span class="keyword">if</span> s.currentRev &lt; scheduledCompact &#123;</span><br><span class="line">        s.currentRev = scheduledCompact</span><br><span class="line">    &#125;</span><br><span class="line">    s.revMu.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="lease"><a href="#lease" class="headerlink" title="lease"></a>lease</h4><p>调整完版本，再恢复租约：</p>
<ul>
<li>状态重建：重新建立键与租约的关联关系</li>
<li>错误容忍：租约恢复失败时记录错误但不终止恢复过程</li>
<li>完整性检查：确保租约管理器存在</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> key, lid := <span class="keyword">range</span> keyToLease &#123;</span><br><span class="line">    <span class="comment">// 需要 etcdServer 先恢复 leasor</span></span><br><span class="line">    <span class="keyword">if</span> s.le == <span class="literal">nil</span> &#123;</span><br><span class="line">        tx.Unlock()</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;no lessor to attach lease&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重新关联键和租约</span></span><br><span class="line">    err := s.le.Attach(lid, []lease.LeaseItem&#123;&#123;Key: key&#125;&#125;)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        s.lg.Error(<span class="string">&quot;failed to attach a lease&quot;</span>, </span><br><span class="line">            zap.String(<span class="string">&quot;lease-id&quot;</span>, fmt.Sprintf(<span class="string">&quot;%016x&quot;</span>, lid)),</span><br><span class="line">            zap.Error(err))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="compactLockfree"><a href="#compactLockfree" class="headerlink" title="compactLockfree"></a>compactLockfree</h4><p>compaction 需要作为 restore 的最后一步，设计原因如下:</p>
<ol>
<li>数据完整性保证</li>
</ol>
<ul>
<li>所有数据都已恢复</li>
<li>索引结构已建立</li>
<li>租约关联已建立</li>
</ul>
<p>   如果 restore 提前 compaction，可能会导致 compactMainRev 变大，导致数据不一致，删除了部分数据。</p>
<ol start="2">
<li>系统可用性</li>
</ol>
<ul>
<li>即使压缩失败，系统仍可运行</li>
<li>不会因为压缩问题导致启动失败</li>
</ul>
<ol start="3">
<li>错误隔离<ul>
<li>压缩错误不会影响数据恢复（这点很重要）</li>
<li>可以独立处理压缩问题</li>
</ul>
</li>
</ol>
<p>从性能角度考虑: 先恢复核心功能, compaction 作为后台异步任务执行可以减少启动时间</p>
<p>完整实现如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 restore 过程中检测未完成的压缩</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *store)</span></span> restore() <span class="type">error</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 首先读取已完成的压缩版本号</span></span><br><span class="line">    finishedCompact, found := UnsafeReadFinishedCompact(tx)</span><br><span class="line">    <span class="keyword">if</span> found &#123;</span><br><span class="line">        s.compactMainRev = finishedCompact</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 读取计划的压缩版本号</span></span><br><span class="line">    scheduledCompact, _ := UnsafeReadScheduledCompact(tx)</span><br><span class="line">    <span class="comment">// 3. 恢复上述所有数据...</span></span><br><span class="line">   </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 最后处理未完成的压缩</span></span><br><span class="line">    <span class="keyword">if</span> scheduledCompact != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> _, err := s.compactLockfree(scheduledCompact); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            s.lg.Warn(<span class="string">&quot;compaction encountered error&quot;</span>, zap.Error(err))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            s.lg.Info(<span class="string">&quot;resume scheduled compaction&quot;</span>, </span><br><span class="line">                zap.Int64(<span class="string">&quot;scheduled-compact-revision&quot;</span>, scheduledCompact))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h5 id="EtcdServer-applySnapshot"><a href="#EtcdServer-applySnapshot" class="headerlink" title="EtcdServer.applySnapshot"></a>EtcdServer.applySnapshot</h5><p><code>EtcdServer.applySnapshot</code> 具有重要意义，分别应用于进程重启后的状态恢复，以及 follower 加入已有集群后的状态初始化等。实际应用价值如下:</p>
<ul>
<li>集群同步：确保 Follower 节点能够快速同步到 Leader 状态</li>
<li>故障恢复：系统重启后能够从快照快速恢复</li>
<li>性能优化：避免长时间的重放日志操作</li>
<li>数据一致性：保证分布式系统中的强一致性</li>
</ul>
<p>核心设计原则</p>
<ul>
<li>顺序重要性：ConsistentIndex → Lessor → MVCC → 其他组件的恢复顺序</li>
<li>原子性：后端切换和进度更新使用原子操作</li>
<li>资源管理：异步关闭旧资源，避免阻塞主流程</li>
<li>错误处理：关键错误使用 Panic，确保系统一致性</li>
</ul>
<p>执行程图如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">    O[等待 Raft 节点持久化] --&gt;A[ConsistentIndex]</span><br><span class="line">    A[ConsistentIndex] --&gt; B[Lessor]</span><br><span class="line">    B --&gt; C[MVCC Store]</span><br><span class="line">    C --&gt; D[事务钩子]</span><br><span class="line">    D --&gt; E[后端切换]</span><br><span class="line">    E --&gt; F[Alarm Store]</span><br><span class="line">    F --&gt; G[Auth Store]</span><br><span class="line">    G --&gt; H[V2 Store]</span><br><span class="line">    H --&gt; I[集群配置]</span><br><span class="line">    I --&gt; J[网络配置]</span><br><span class="line">    </span><br><span class="line">    style A fill:#0f3460,stroke:#16213e,stroke-width:2px,color:#ffffff</span><br><span class="line">    style B fill:#0d7377,stroke:#14a085,stroke-width:2px,color:#ffffff</span><br><span class="line">    style C fill:#0d7377,stroke:#14a085,stroke-width:2px,color:#ffffff</span><br><span class="line">    style D fill:#0d7377,stroke:#14a085,stroke-width:2px,color:#ffffff</span><br><span class="line">    style E fill:#6a0572,stroke:#8b008b,stroke-width:2px,color:#ffffff</span><br><span class="line">    style J fill:#2d5016,stroke:#4a7c59,stroke-width:2px,color:#ffffff</span><br></pre></td></tr></table></figure>

<p>这里核心的 MVCC Restore 之前已经分析过，Lesssor 后续分析，另一个核心的设计就是 <code>ConsistentIndex</code>。</p>
<h2 id="ConsistentIndex"><a href="#ConsistentIndex" class="headerlink" title="ConsistentIndex"></a>ConsistentIndex</h2><p><code>consistIndex</code> 存在的必要性是 etcd 确保数据一致性的核心机制：</p>
<ul>
<li>核心就是防止重复 apply entry: 通过比较 log index, 确保每个 log entry 只 applied 一次</li>
<li>持久化保证: 只有真正持久化的数据才被标记为已应用</li>
<li>重启一致性: 重启后能够正确恢复到一致状态</li>
<li>异常处理: 在各种异常情况（重启、leader changed、网络分区等）下都能保证数据完整性</li>
</ul>
<p>这种设计使得 etcd 能够在复杂的分布式环境中提供强一致性保证，是 etcd 作为可靠分布式键值存储的重要基础。没有 consistIndex，etcd 就无法正确处理重启、快照恢复、网络分区等场景下的日志重放问题，会导致数据不一致或重复应用的问题。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// position：server/etcdserver/cindex/cindex.go:58-78</span></span><br><span class="line"><span class="keyword">type</span> consistentIndex <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="comment">// consistentIndex 表示一致副本日志中条目的偏移量</span></span><br><span class="line">    <span class="comment">// 它缓存了 &quot;consistent_index&quot; 键的值</span></span><br><span class="line">    <span class="comment">// 通过原子操作访问，必须 64 位对齐</span></span><br><span class="line">    consistentIndex <span class="type">uint64</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// term 表示一致副本日志中已提交条目的 RAFT term</span></span><br><span class="line">    <span class="comment">// 通过原子操作访问，必须 64 位对齐</span></span><br><span class="line">    <span class="comment">// 从 v3.5 开始持久化到后端</span></span><br><span class="line">    term <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// applyingIndex 和 applyingTerm 是 raftpb.Entry.Index 和 raftpb.Entry.Term 的临时缓存</span></span><br><span class="line">    <span class="comment">// 它们还没有准备好被持久化，将在 txPostLockInsideApplyHook 中保存到上面的 consistentIndex 和 term</span></span><br><span class="line">    applyingIndex <span class="type">uint64</span></span><br><span class="line">    applyingTerm  <span class="type">uint64</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// be 用于初始读取 consistentIndex</span></span><br><span class="line">    be Backend</span><br><span class="line">    <span class="comment">// mutex 保护 be</span></span><br><span class="line">    mutex sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在-apply-中的使用"><a href="#在-apply-中的使用" class="headerlink" title="在 apply 中的使用"></a>在 apply 中的使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShouldApplyV3 <span class="type">bool</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	ApplyBoth        = ShouldApplyV3(<span class="literal">true</span>)</span><br><span class="line">	ApplyV2storeOnly = ShouldApplyV3(<span class="literal">false</span>)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span></span> apply(es []raftpb.Entry, confState *raftpb.ConfState) (appliedt <span class="type">uint64</span>, appliedi <span class="type">uint64</span>, shouldStop <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> es &#123;</span><br><span class="line">        e := es[i]</span><br><span class="line">        <span class="keyword">switch</span> e.Type &#123;</span><br><span class="line">        <span class="keyword">case</span> raftpb.EntryNormal:</span><br><span class="line">            s.applyEntryNormal(&amp;e)</span><br><span class="line">            s.setAppliedIndex(e.Index)</span><br><span class="line">            s.setTerm(e.Term)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> raftpb.EntryConfChange:</span><br><span class="line">            <span class="comment">// 我们需要在 v2store 上应用所有 WAL 条目</span></span><br><span class="line">            <span class="comment">// 并且只在后端上应用 &#x27;unapplied&#x27; (e.Index&gt;backend.ConsistentIndex)</span></span><br><span class="line">            shouldApplyV3 := membership.ApplyV2storeOnly</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置当前执行条目的一致性索引</span></span><br><span class="line">            <span class="keyword">if</span> e.Index &gt; s.consistIndex.ConsistentIndex() &#123;</span><br><span class="line">                s.consistIndex.SetConsistentApplyingIndex(e.Index, e.Term)</span><br><span class="line">                shouldApplyV3 = membership.ApplyBoth</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ... 处理配置变更</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>关键逻辑</strong>：</p>
<ul>
<li>对于 <code>raftpb.EntryConfChange</code>，只有当 <code>e.Index &gt; s.consistIndex.ConsistentIndex()</code> 时才应用到 v3Store（即 BlotDB）</li>
<li>这确保了只有新的配置变更才会被处理</li>
</ul>
<h3 id="applyEntryNormal-方法中的使用"><a href="#applyEntryNormal-方法中的使用" class="headerlink" title="applyEntryNormal() 方法中的使用"></a>applyEntryNormal() 方法中的使用</h3><p><strong>关键逻辑</strong>：</p>
<ul>
<li>同样也只有当 <code>e.Index &gt; s.consistIndex.ConsistentIndex</code> 时才应用到 v3 存储</li>
<li>设置 <code>applyingIndex</code> 作为临时缓存</li>
<li>使用 <code>defer</code> 确保在异常情况下也能更新索引 (比如接收到空包等)</li>
</ul>
<p>只有当 index 更大，shouldApplyV3 的值是 <code>membership.ApplyBoth</code>，即为 true，才真正 apply 到 backend。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span></span> applyEntryNormal(e *raftpb.Entry) &#123;</span><br><span class="line">    shouldApplyV3 := membership.ApplyV2storeOnly</span><br><span class="line">    <span class="keyword">var</span> ar *applyResult</span><br><span class="line">    index := s.consistIndex.ConsistentIndex()</span><br><span class="line">    <span class="keyword">if</span> e.Index &gt; index &#123;</span><br><span class="line">        <span class="comment">// 设置当前执行条目的一致性索引</span></span><br><span class="line">        s.consistIndex.SetConsistentApplyingIndex(e.Index, e.Term)</span><br><span class="line">        shouldApplyV3 = membership.ApplyBoth</span><br><span class="line">        <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="comment">// 在某些情况下 txPostLockInsideApplyHook 不会被调用</span></span><br><span class="line">            <span class="comment">// 在这种情况下我们应该直接推进一致性索引</span></span><br><span class="line">            newIndex := s.consistIndex.ConsistentIndex()</span><br><span class="line">            <span class="keyword">if</span> newIndex &lt; e.Index &#123;</span><br><span class="line">                s.consistIndex.SetConsistentIndex(e.Index, e.Term)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 应用条目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务钩子机制"><a href="#事务钩子机制" class="headerlink" title="事务钩子机制"></a>事务钩子机制</h4><h3 id="TxPostLockInsideApplyHook-方法"><a href="#TxPostLockInsideApplyHook-方法" class="headerlink" title="TxPostLockInsideApplyHook 方法"></a>TxPostLockInsideApplyHook 方法</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">newbe.SetTxPostLockInsideApplyHook(s.getTxPostLockInsideApplyHook())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *EtcdServer)</span></span> getTxPostLockInsideApplyHook() <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        applyingIdx, applyingTerm := s.consistIndex.ConsistentApplyingIndex()</span><br><span class="line">        <span class="keyword">if</span> applyingIdx &gt; s.consistIndex.UnsafeConsistentIndex() &#123;</span><br><span class="line">            s.consistIndex.SetConsistentIndex(applyingIdx, applyingTerm)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分析</strong>：</p>
<ul>
<li>TxnApplyHook 在事务锁定时调用，因此内部调用的是 <code>Unsafe</code></li>
<li>将 <code>applyingIndex</code> 提升为 <code>consistentIndex</code></li>
<li>确保只有真正持久化的数据才被标记为已应用</li>
<li>在服务启动或者恢复存储后端时设置钩子</li>
<li>确保后续的事务操作都会在 <code>Unlock</code> 前调用这个钩子<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *backend)</span></span> SetTxPostLockInsideApplyHook(hook <span class="function"><span class="keyword">func</span><span class="params">()</span></span>) &#123;</span><br><span class="line">	b.batchTx.lock()</span><br><span class="line">	<span class="keyword">defer</span> b.batchTx.Unlock() <span class="comment">// 智能 Commit</span></span><br><span class="line">	b.txPostLockInsideApplyHook = hook</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *batchTx)</span></span> LockInsideApply() &#123;</span><br><span class="line">	t.lock()</span><br><span class="line">	<span class="keyword">if</span> t.backend.txPostLockInsideApplyHook != <span class="literal">nil</span> &#123;</span><br><span class="line">		ValidateCalledInsideApply(t.backend.lg)</span><br><span class="line">		t.backend.txPostLockInsideApplyHook()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="applySnapshot-中的应用"><a href="#applySnapshot-中的应用" class="headerlink" title="applySnapshot 中的应用"></a>applySnapshot 中的应用</h3><p><strong>关键时机</strong>：</p>
<ul>
<li>必须在恢复 lessor 之前设置后端</li>
<li>避免旧的索引值覆盖新的快照值<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置：server/etcdserver/server.go:1340-1345</span></span><br><span class="line"><span class="comment">// We need to set the backend to consistIndex before recovering the lessor,</span></span><br><span class="line"><span class="comment">// because lessor.Recover will commit the boltDB transaction, accordingly it</span></span><br><span class="line"><span class="comment">// will get the old consistent_index persisted into the db in OnPreCommitUnsafe.</span></span><br><span class="line"><span class="comment">// Eventually the new consistent_index value coming from snapshot is overwritten</span></span><br><span class="line"><span class="comment">// by the old value.</span></span><br><span class="line">s.consistIndex.SetBackend(newbe)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="在启动时一致性验证中的使用"><a href="#在启动时一致性验证中的使用" class="headerlink" title="在启动时一致性验证中的使用"></a>在启动时一致性验证中的使用</h3><p><strong>验证规则</strong>：</p>
<ul>
<li><code>consistIndex &lt;= hardstate.Commit</code></li>
<li><code>consistIndex &gt;= snapshot.Index</code></li>
<li>确保启动时状态的一致性</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 位置：server/verify/verify.go:110-131</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateConsistentIndex</span><span class="params">(cfg Config, hardstate *raftpb.HardState, snapshot *walpb.Snapshot, be backend.Backend)</span></span> <span class="type">error</span> &#123;</span><br><span class="line">    index, term := cindex.ReadConsistentIndex(be.ReadTx())</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cfg.ExactIndex &amp;&amp; index != hardstate.Commit &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;backend.ConsistentIndex (%v) expected == WAL.HardState.commit (%v)&quot;</span>, index, hardstate.Commit)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> index &gt; hardstate.Commit &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;backend.ConsistentIndex (%v) must be &lt;= WAL.HardState.commit (%v)&quot;</span>, index, hardstate.Commit)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> index &lt; snapshot.Index &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;backend.ConsistentIndex (%v) must be &gt;= last snapshot index (%v)&quot;</span>, index, snapshot.Index)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>consistIndex 也是批量更新到 blotdb，和事物提交同步</p>
<h4 id="OnPreCommitUnsafe"><a href="#OnPreCommitUnsafe" class="headerlink" title="OnPreCommitUnsafe"></a>OnPreCommitUnsafe</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(bh *backendHooks)</span></span> OnPreCommitUnsafe(tx backend.BatchTx) &#123;</span><br><span class="line">	bh.indexer.UnsafeSave(tx)</span><br><span class="line">	bh.confStateLock.Lock()</span><br><span class="line">	<span class="keyword">defer</span> bh.confStateLock.Unlock()</span><br><span class="line">	<span class="keyword">if</span> bh.confStateDirty &#123;</span><br><span class="line">		membership.MustUnsafeSaveConfStateToBackend(bh.lg, tx, &amp;bh.confState)</span><br><span class="line">		<span class="comment">// save bh.confState</span></span><br><span class="line">		bh.confStateDirty = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#MVCC"><span class="toc-number">1.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Compact"><span class="toc-number">1.0.1.</span> <span class="toc-text">Compact</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#updateCompactRev"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">updateCompactRev</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#scheduleCompaction"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">scheduleCompaction</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#checkPrevCompactionCompleted"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">checkPrevCompactionCompleted</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Restore"><span class="toc-number">1.0.2.</span> <span class="toc-text">Restore</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#restoreIntoIndex"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">restoreIntoIndex</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#restoreChunk"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">restoreChunk</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">1.0.2.3.</span> <span class="toc-text">版本一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lease"><span class="toc-number">1.0.2.4.</span> <span class="toc-text">lease</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#compactLockfree"><span class="toc-number">1.0.2.5.</span> <span class="toc-text">compactLockfree</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#EtcdServer-applySnapshot"><span class="toc-number">1.0.2.5.1.</span> <span class="toc-text">EtcdServer.applySnapshot</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConsistentIndex"><span class="toc-number">1.1.</span> <span class="toc-text">ConsistentIndex</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-apply-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">在 apply 中的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applyEntryNormal-%E6%96%B9%E6%B3%95%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">applyEntryNormal() 方法中的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E9%92%A9%E5%AD%90%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">事务钩子机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TxPostLockInsideApplyHook-%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">TxPostLockInsideApplyHook 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#applySnapshot-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">applySnapshot 中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E4%B8%80%E8%87%B4%E6%80%A7%E9%AA%8C%E8%AF%81%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.5.</span> <span class="toc-text">在启动时一致性验证中的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#OnPreCommitUnsafe"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">OnPreCommitUnsafe</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://szza.github.io/2024/09/03/ETCD/3_mvcc/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&text=剖析 ETCD.mvcc"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&title=剖析 ETCD.mvcc"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&is_video=false&description=剖析 ETCD.mvcc"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=剖析 ETCD.mvcc&body=Check out this article: https://szza.github.io/2024/09/03/ETCD/3_mvcc/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&title=剖析 ETCD.mvcc"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&title=剖析 ETCD.mvcc"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&title=剖析 ETCD.mvcc"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&title=剖析 ETCD.mvcc"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&name=剖析 ETCD.mvcc&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://szza.github.io/2024/09/03/ETCD/3_mvcc/&t=剖析 ETCD.mvcc"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> Menu</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> TOC</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> Share</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2026
    fibonaccii
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/">Home</a></li>
         
          <li><a href="/archives">archives</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script async src="https://www.googletagmanager.com/gtag/js?id=szza"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'szza');
    </script>

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Umami Analytics -->

<!-- Disqus Comments -->


</body>
</html>
